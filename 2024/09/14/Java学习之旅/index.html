<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.0.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" integrity="sha256-CTSx/A06dm1B063156EVh15m6Y67pAjZZaQc89LLSrU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"6pc1.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.18.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/./search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="学学Java吧！">
<meta property="og:type" content="article">
<meta property="og:title" content="Java学习之旅">
<meta property="og:url" content="http://6pc1.github.io/2024/09/14/Java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/index.html">
<meta property="og:site_name" content="6pc1&#39;s blog">
<meta property="og:description" content="学学Java吧！">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-16/c9ac44a4a04ebd2fd63b7df7de2f2d66--9e4a--image-20240916195454929.png">
<meta property="og:image" content="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-16/1f7caad12229ce68470a87760100bb70--07f4--image-20210414143735613.png">
<meta property="og:image" content="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-16/6cadde5fb4d27323c285b0d428245dc7--4b48--image-20240916214245870.png">
<meta property="og:image" content="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-16/5c5632e65292b3883e07b66cefa2c846--395e--1622105878156.png">
<meta property="og:image" content="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-16/ef136c0b0a60d13a465c9eabf4a507c3--9a6b--1622108608331.png">
<meta property="og:image" content="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-16/f536e2a3282130e263ee9de36e64baaa--4d2b--1622349200598.png">
<meta property="og:image" content="http://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-16/0305cc69a3803b657b001f20616fefc2--0f4e--image-20240916221855128.png">
<meta property="og:image" content="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/9dad4dc296387a3aa745bda588e541a0--66fb--1622843400375.png">
<meta property="og:image" content="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/0a394f1331265ead6eba52441a0770fa--928b--image-20240917095443916.png">
<meta property="og:image" content="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/77ec534b38864564efad53e68734991d--162a--image-20240917100058991.png">
<meta property="og:image" content="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/d405c3f637ebd987f0af0044618984ed--8070--image-20240917103243395.png">
<meta property="og:image" content="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/f88f172d93e3c916b346a9b232fdd7e4--c081--f-011.png">
<meta property="og:image" content="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/5f40e28ca82ae81c89448191221f92f0--83c8--f-06.png">
<meta property="og:image" content="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/b49ce55a60f475317da97e9ee4b24e12--7a09--f-07.png">
<meta property="og:image" content="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/8435cd3f8e1c81d70aea2e42ef381fbe--922d--f-08.png">
<meta property="og:image" content="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/659ed8f50e7ce55076c5c296c3d69baf--6882--f-09.png">
<meta property="og:image" content="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/4244078ff7a3b6a04d0d154bf6acc9f9--06e2--f-10.png">
<meta property="og:image" content="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/40b729502feb4a579d2b142d353e93e8--4004--f-11.png">
<meta property="og:image" content="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/a204f787a807f87378f7985085222d20--1859--f-12.png">
<meta property="og:image" content="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/1b6c0ffa297bcdaceb4608573e08b701--5284--f-13.png">
<meta property="og:image" content="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/23223b4d4c88ab5e9b5dff87bd1ea81d--4171--f-15.png">
<meta property="og:image" content="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/bec0d1357c803bbce86c88c385b006c1--9cc2--f-16.png">
<meta property="og:image" content="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/d8b42e2a9e4c2fab065e9a7160656ca5--acd9--f-17.png">
<meta property="og:image" content="http://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/21debf6ef21a57f7c1120fe58649ef71--3936--f-18.png">
<meta property="og:image" content="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/dd405cec8a709e7320fbee9bd1727cda--f922--image-20240917134808187.png">
<meta property="og:image" content="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/a51b3ad3b6fc096f0abfbedb5a5db10a--7906--image-20240917135507627.png">
<meta property="og:image" content="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/036c79ac6d7da45dda9da1226bf8facd--eb96--01.png">
<meta property="og:image" content="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/4a960f7e7bfc8b68f5cb42eaebbc0064--95a7--02.png">
<meta property="og:image" content="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/512c704c1691e6d466a59c9e120b99ba--9137--03.png">
<meta property="og:image" content="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/73bb56682e583202b5dce7dadb23a2d0--3b71--06.png">
<meta property="og:image" content="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/42ffa72f12011be3b40c0802081b0816--02c2--07.png">
<meta property="og:image" content="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-26/689411ff1ee20d9f4676a6f37a92f14e--e1a9--image-20240926103359953.png">
<meta property="og:image" content="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-26/e5c5d1664e576887561e0b5d345399a0--f2ed--image-20240926103900334.png">
<meta property="og:image" content="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-26/49f74611c39b83069b6b4b3b4fc70fe0--4580--image-20240926103921057.png">
<meta property="og:image" content="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-26/2e1a01fbd76a3b98b8060678b8c652da--578a--image-20240926113011579.png">
<meta property="og:image" content="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-26/d310da4fde968e21e9c4cd5fb731e3e1--e5c3--image-20240926114757184.png">
<meta property="og:image" content="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-26/4c965e78676367af02bdc233fcd4e21a--3bb8--image-20240926154223158.png">
<meta property="og:image" content="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-26/4cc23d898e14d8003b0ae66094b41ed2--e610--image-20240926154251866.png">
<meta property="og:image" content="http://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-26/72532b7ff7aafd3013078e556dcd5789--c2f7--image-20240926155705628.png">
<meta property="og:image" content="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-26/016b16f866b8814053813f34ef5ecd04--3ebe--image-20240926160356106.png">
<meta property="og:image" content="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-26/5c6b47f892f9a5a48d33dfd7eac19e22--580b--image-20240926160454945.png">
<meta property="og:image" content="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-26/ec2168962e0afd8308af7a84307e36c3--d616--image-20240926161011409.png">
<meta property="og:image" content="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-26/f366179f78492670947d2f3c225434b1--5796--image-20240926161016501.png">
<meta property="og:image" content="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-26/5def8a853d13145aec0fac58b21ec825--dc6e--image-20240926161107656.png">
<meta property="og:image" content="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-26/a74194cb166be60b7c14d33841288421--a599--image-20240926161127564.png">
<meta property="og:image" content="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-02/0332c07d4172fd418c663af3cf0e62c9--dd7c--image-20241002172628012.png">
<meta property="og:image" content="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-02/4fcecdfdeb30135c60b9f69d33e65dc4--7e07--image-20241002173511265.png">
<meta property="og:image" content="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-02/548e94ddbf27a53c4ea5dc103380530a--eba7--image-20241002173536636.png">
<meta property="og:image" content="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-02/e15a777941671c4cb10540b0dbdd135a--083a--image-20241002183552837.png">
<meta property="og:image" content="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-02/b3b7754d04c3b7f5e3aac395d953838d--d9d6--image-20241002183634220.png">
<meta property="og:image" content="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-02/1d2348b58ca17120964e61d189a8d294--c67c--image-20241002184541945.png">
<meta property="og:image" content="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-02/44407cfc98725875886f4b92a502a464--d8e6--image-20241002185539502.png">
<meta property="og:image" content="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-02/d23001b07313a32006b232017fccbda7--c8d3--image-20241002185546613.png">
<meta property="og:image" content="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-02/a82dd7550a4c16ef3ea37fc6aa8609a6--7334--image-20241002190644089.png">
<meta property="og:image" content="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-02/8254c3f67ca2c7111a66692567b84c67--2a50--image-20241002191211308.png">
<meta property="og:image" content="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-02/ba3be1ca719cecb6fcccee7568a403d6--ec6a--image-20241002191223484.png">
<meta property="og:image" content="https://picx.zhimg.com/80/v2-db587ee075af848892e64f137ea9fd5e_1440w.webp?source=1def8aca">
<meta property="og:image" content="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-02/cf09b1139d0685d05e0de851fd49a94d--4166--image-20241002192704353.png">
<meta property="og:image" content="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-02/1248aa7b160d777171d9816f1f8e182c--de8e--image-20241002192722608.png">
<meta property="og:image" content="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-02/f1c84981f8b01587eff9be2fc64dd7a6--6362--image-20241002193643594.png">
<meta property="og:image" content="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-02/51f7dcfcdb8f0cd022e3ccd81021033a--b1f8--image-20241002194149715.png">
<meta property="og:image" content="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-02/5470eb5dfe09d3ef6743df8efc80e6d6--759e--image-20241002195004190.png">
<meta property="og:image" content="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-02/a93581cde7b6ff6b5e0f388d3dc9bcbb--48bf--image-20241002200418140.png">
<meta property="og:image" content="http://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-06/0f21687c7dae4f514872b6eca338b761--d6f5--image-20241006132520284.png">
<meta property="og:image" content="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-06/bfe245ecd11b4f7efae76acd496e5dfb--4306--image-20241006134641276.png">
<meta property="og:image" content="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-06/6aa70bdff9b7d0ccaab0fcbf9e43512a--8967--image-20241006142241243.png">
<meta property="og:image" content="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-06/93e398a6d304d22f3e9508b65e5d7db1--1d19--image-20241006142255177.png">
<meta property="og:image" content="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-06/d789e0d2559d4467d10b7795d4a0f0b5--118e--image-20241006142311833.png">
<meta property="og:image" content="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-06/9b372cb18be71db388e8ce1c20f00bb7--45cf--image-20241006142329579.png">
<meta property="og:image" content="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-06/3c5e2afce39776a9856aa0325ae2015b--8dfd--image-20241006142802266.png">
<meta property="og:image" content="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-06/a22edb7010caa4d6da813af49a570d10--683b--image-20241006142815613.png">
<meta property="og:image" content="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-06/4558c3a3bcf24243d562cb6f6bc4fb81--e402--image-20241006142842061.png">
<meta property="og:image" content="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-06/6f685bd89884419530aaba4167ddb2a0--365d--image-20241006142859222.png">
<meta property="og:image" content="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-06/d0acde08a8674b45418842b7d10eae38--d0c8--image-20241006143301494.png">
<meta property="og:image" content="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-06/97851aa1659b6455ef2896b6e007843a--7088--image-20241006145802193.png">
<meta property="og:image" content="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-06/2408cff000b434b3d05db3cbd12bdd9b--312f--image-20241006145827201.png">
<meta property="og:image" content="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-06/76a92767801a37f6cc81d492e28bb998--6b68--image-20241006152941896.png">
<meta property="og:image" content="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-06/35703c4b7c062b664191ec914bbb765c--ee70--image-20241006201713560.png">
<meta property="og:image" content="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-06/be9b8c63ed6e11166c584df0ec7d46bd--d62e--image-20241006203510092.png">
<meta property="og:image" content="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-06/9738ef9679770afe7f810b8b1ec303a3--f08b--image-20241006203545571.png">
<meta property="og:image" content="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-06/248f7b6bdbcc58f556d8a006ec4fd36b--6c52--image-20241006203555990.png">
<meta property="og:image" content="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-06/9281b634c599b8c2edfac30cb2009a79--e49a--image-20241006203627642.png">
<meta property="og:image" content="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-06/69b06ba5feeee963329165f6c7e8fae8--1373--image-20241006203652024.png">
<meta property="og:image" content="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-07/7034533d6df0a76a9e47b90fe40965ff--d64e--image-20241007131846399.png">
<meta property="og:image" content="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-07/50328b5e689195ee970a7c76472b1ada--b0a1--image-20241007134552563.png">
<meta property="og:image" content="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-07/fd06ebf085a98d84cd36f4775d52280d--5015--Java%20SE.png">
<meta property="article:published_time" content="2024-09-14T10:31:37.000Z">
<meta property="article:modified_time" content="2024-10-20T02:44:13.964Z">
<meta property="article:author" content="6pc1">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-16/c9ac44a4a04ebd2fd63b7df7de2f2d66--9e4a--image-20240916195454929.png">


<link rel="canonical" href="http://6pc1.github.io/2024/09/14/Java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://6pc1.github.io/2024/09/14/Java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/","path":"2024/09/14/Java学习之旅/","title":"Java学习之旅"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Java学习之旅 | 6pc1's blog</title>
  







<link rel="dns-prefetch" href="waline-server-pi-one.vercel.app">
  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">6pc1's blog</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">世界如画，心中有梦!</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E3%80%81Java-SE%E5%9F%BA%E7%A1%80"><span class="nav-number">1.</span> <span class="nav-text">一、Java SE基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%A2%84%E7%A7%91"><span class="nav-number">1.1.</span> <span class="nav-text">计算机预科</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E5%9F%BA%E7%A1%80"><span class="nav-number">1.2.</span> <span class="nav-text">Java基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81Java%E7%AE%80%E4%BB%8B"><span class="nav-number">1.2.1.</span> <span class="nav-text">1、Java简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81Hello-World"><span class="nav-number">1.2.2.</span> <span class="nav-text">2、Hello World</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E6%A0%87%E8%AF%86%E7%AC%A6%E5%92%8C%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">1.2.3.</span> <span class="nav-text">3、标识符和关键字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.2.4.</span> <span class="nav-text">4、数据类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5%E3%80%81%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">1.2.5.</span> <span class="nav-text">5、类型转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6%E3%80%81%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B8%B8%E9%87%8F"><span class="nav-number">1.2.6.</span> <span class="nav-text">6、变量与常量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7%E3%80%81%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">1.2.7.</span> <span class="nav-text">7、基本运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8%E3%80%81%E8%87%AA%E5%A2%9E%E8%87%AA%E5%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6%E3%80%81%E5%88%9D%E5%A7%8BMath%E7%B1%BB"><span class="nav-number">1.2.8.</span> <span class="nav-text">8、自增自减运算符、初始Math类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9%E3%80%81%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6%E3%80%81%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">1.2.9.</span> <span class="nav-text">9、逻辑运算符、位运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10%E3%80%81%E4%B8%89%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">1.2.10.</span> <span class="nav-text">10、三元运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11%E3%80%81%E5%8C%85%E6%9C%BA%E5%88%B6"><span class="nav-number">1.2.11.</span> <span class="nav-text">11、包机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12%E3%80%81JavaDoc"><span class="nav-number">1.2.12.</span> <span class="nav-text">12、JavaDoc</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="nav-number">1.3.</span> <span class="nav-text">流程控制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E7%94%A8%E6%88%B7%E4%BA%A4%E4%BA%92Scanner"><span class="nav-number">1.3.1.</span> <span class="nav-text">1、用户交互Scanner</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84"><span class="nav-number">1.3.2.</span> <span class="nav-text">2、顺序结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84"><span class="nav-number">1.3.3.</span> <span class="nav-text">3、选择结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84"><span class="nav-number">1.3.4.</span> <span class="nav-text">4、循环结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5%E3%80%81break-continue"><span class="nav-number">1.3.5.</span> <span class="nav-text">5、break &amp; continue</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%95"><span class="nav-number">1.4.</span> <span class="nav-text">方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E4%BD%95%E8%B0%93%E6%96%B9%E6%B3%95"><span class="nav-number">1.4.1.</span> <span class="nav-text">1、何谓方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9A%E4%B9%89%E5%8F%8A%E8%B0%83%E7%94%A8"><span class="nav-number">1.4.2.</span> <span class="nav-text">2、方法的定义及调用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD"><span class="nav-number">1.4.3.</span> <span class="nav-text">3、方法重载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BC%A0%E5%8F%82"><span class="nav-number">1.4.4.</span> <span class="nav-text">4、命令行传参</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5%E3%80%81%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0"><span class="nav-number">1.4.5.</span> <span class="nav-text">5、可变参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6%E3%80%81%E9%80%92%E5%BD%92"><span class="nav-number">1.4.6.</span> <span class="nav-text">6、递归</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E7%BB%84"><span class="nav-number">1.5.</span> <span class="nav-text">数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E6%95%B0%E7%BB%84%E6%A6%82%E8%BF%B0"><span class="nav-number">1.5.1.</span> <span class="nav-text">1、数组概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E6%95%B0%E7%BB%84%E5%A3%B0%E6%98%8E%E5%88%9B%E5%BB%BA"><span class="nav-number">1.5.2.</span> <span class="nav-text">2、数组声明创建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E6%95%B0%E7%BB%84%E4%BD%BF%E7%94%A8"><span class="nav-number">1.5.3.</span> <span class="nav-text">3、数组使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="nav-number">1.5.4.</span> <span class="nav-text">4、多维数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5%E3%80%81Arrays%E7%B1%BB"><span class="nav-number">1.5.5.</span> <span class="nav-text">5、Arrays类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6%E3%80%81%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84"><span class="nav-number">1.5.6.</span> <span class="nav-text">6、稀疏数组</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88OOP%EF%BC%89"><span class="nav-number">1.6.</span> <span class="nav-text">面向对象（OOP）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E5%88%9D%E5%A7%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.6.1.</span> <span class="nav-text">1、初始面向对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E6%96%B9%E6%B3%95%E7%9A%84%E5%9B%9E%E9%A1%BE%E5%92%8C%E5%8A%A0%E6%B7%B1"><span class="nav-number">1.6.2.</span> <span class="nav-text">2、方法的回顾和加深</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E5%88%86%E6%9E%90"><span class="nav-number">1.6.3.</span> <span class="nav-text">3、对象的创建分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="nav-number">1.6.4.</span> <span class="nav-text">4、面向对象三大特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5%E3%80%81%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.6.5.</span> <span class="nav-text">5、抽象类和接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6%E3%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E5%8F%8AOOP%E5%AE%9E%E6%88%98"><span class="nav-number">1.6.6.</span> <span class="nav-text">6、内部类及OOP实战</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8"><span class="nav-number">1.7.</span> <span class="nav-text">异常</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%BC%82%E5%B8%B8"><span class="nav-number">1.7.1.</span> <span class="nav-text">1、什么是异常</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="nav-number">1.7.2.</span> <span class="nav-text">2、异常体系结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8"><span class="nav-number">1.7.3.</span> <span class="nav-text">3、Java异常处理机制与处理异常</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8"><span class="nav-number">1.7.4.</span> <span class="nav-text">4、自定义异常</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5%E3%80%81%E6%80%BB%E7%BB%93"><span class="nav-number">1.7.5.</span> <span class="nav-text">5、总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E7%B1%BB"><span class="nav-number">1.8.</span> <span class="nav-text">常用类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%85%B3%E7%9A%84%E7%B1%BB"><span class="nav-number">1.8.1.</span> <span class="nav-text">1、字符串相关的类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81String%E7%B1%BB%E7%9A%84%E6%A6%82%E8%BF%B0"><span class="nav-number">1.8.1.1.</span> <span class="nav-text">1、String类的概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E7%90%86%E8%A7%A3String%E7%B1%BB%E7%9A%84%E4%B8%8D%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="nav-number">1.8.1.2.</span> <span class="nav-text">2、理解String类的不可见性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81String%E4%B8%8D%E5%90%8C%E5%AE%9E%E4%BE%8B%E5%8C%96%E6%96%B9%E6%B3%95%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="nav-number">1.8.1.3.</span> <span class="nav-text">3、String不同实例化方法的对比</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81String%E4%B8%8D%E5%90%8C%E6%8B%BC%E6%8E%A5%E6%93%8D%E4%BD%9C%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="nav-number">1.8.1.4.</span> <span class="nav-text">4、String不同拼接操作的对比</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#String%E4%BD%BF%E7%94%A8%E9%99%B7%E9%98%B1"><span class="nav-number">1.8.1.4.1.</span> <span class="nav-text">String使用陷阱</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%E3%80%81%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="nav-number">1.8.1.5.</span> <span class="nav-text">5、一道面试题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6%E3%80%81JVM%E4%B8%AD%E6%B6%89%E5%8F%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="nav-number">1.8.1.6.</span> <span class="nav-text">6、JVM中涉及字符串的内存结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7%E3%80%81String%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">1.8.1.7.</span> <span class="nav-text">7、String常用的方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-String%E4%B8%8E%E5%85%B6%E4%BB%96%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="nav-number">1.8.1.8.</span> <span class="nav-text">8.String与其他数据类型之间的转换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9%E3%80%81StringBuffer%E5%92%8CStringBuilder%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.8.1.9.</span> <span class="nav-text">9、StringBuffer和StringBuilder的介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10%E3%80%81StringBuffer%E7%9A%84%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">1.8.1.10.</span> <span class="nav-text">10、StringBuffer的源码分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11%E3%80%81StringBuffer%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-number">1.8.1.11.</span> <span class="nav-text">11、StringBuffer中的常用方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81JDK-8%E4%B9%8B%E5%89%8D%E7%9A%84%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4API"><span class="nav-number">1.8.2.</span> <span class="nav-text">2、JDK 8之前的日期时间API</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81System%E7%B1%BB%E4%B8%AD%E8%8E%B7%E5%8F%96%E6%97%B6%E9%97%B4%E6%88%B3%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">1.8.2.1.</span> <span class="nav-text">1、System类中获取时间戳的方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81Java%E4%B8%AD%E4%B8%A4%E4%B8%AADate%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">1.8.2.2.</span> <span class="nav-text">2、Java中两个Date类的使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81SimpleDateFormate%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">1.8.2.3.</span> <span class="nav-text">3、SimpleDateFormate的使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81Calendar%E6%97%A5%E5%8E%86%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">1.8.2.4.</span> <span class="nav-text">4、Calendar日历类的使用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81JDK8%E4%B8%AD%E6%97%A5%E6%9C%9FAPI%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.8.3.</span> <span class="nav-text">3、JDK8中日期API的介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-LocalDate%E3%80%81LocalTime%E3%80%81LocalDateTime%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">1.8.3.1.</span> <span class="nav-text">1.LocalDate、LocalTime、LocalDateTime的使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81Instant%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">1.8.3.2.</span> <span class="nav-text">2、Instant类的使用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81Java%E6%AF%94%E8%BE%83%E5%99%A8"><span class="nav-number">1.8.4.</span> <span class="nav-text">4、Java比较器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E6%A6%82%E8%BF%B0"><span class="nav-number">1.8.4.1.</span> <span class="nav-text">1.概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%AE%9E%E7%8E%B0Comparable%E8%87%AA%E7%84%B6%E6%8E%92%E5%BA%8F"><span class="nav-number">1.8.4.2.</span> <span class="nav-text">2、自定义类实现Comparable自然排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E4%BD%BF%E7%94%A8Comparator%E5%AE%9E%E7%8E%B0%E5%AE%9A%E5%88%B6%E6%8E%92%E5%BA%8F"><span class="nav-number">1.8.4.3.</span> <span class="nav-text">3、使用Comparator实现定制排序</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5%E3%80%81System%E7%B1%BB%E3%80%81Math%E7%B1%BB%E3%80%81BigInteger%E4%B8%8EBigDecimal"><span class="nav-number">1.8.5.</span> <span class="nav-text">5、System类、Math类、BigInteger与BigDecimal</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81System%E7%B1%BB"><span class="nav-number">1.8.5.1.</span> <span class="nav-text">1、System类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81Math%E7%B1%BB"><span class="nav-number">1.8.5.2.</span> <span class="nav-text">2、Math类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81BigInteger%E4%B8%8EBigDecimal"><span class="nav-number">1.8.5.3.</span> <span class="nav-text">3、BigInteger与BigDecimal</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9B%86%E5%90%88"><span class="nav-number">1.9.</span> <span class="nav-text">集合</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%A6%82%E8%BF%B0"><span class="nav-number">1.9.1.</span> <span class="nav-text">1、Java集合框架概述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%92%8C%E6%95%B0%E7%BB%84%E7%9A%84%E5%AF%B9%E6%AF%94%E5%8F%8A%E6%A6%82%E8%BF%B0"><span class="nav-number">1.9.1.1.</span> <span class="nav-text">1、集合框架和数组的对比及概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%B6%89%E5%8F%8A%E5%88%B0%E7%9A%84API"><span class="nav-number">1.9.1.2.</span> <span class="nav-text">2、集合框架涉及到的API</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81Collection%E6%8E%A5%E5%8F%A3%E6%96%B9%E6%B3%95"><span class="nav-number">1.9.2.</span> <span class="nav-text">2、Collection接口方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Collection%E6%8E%A5%E5%8F%A3%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-number">1.9.2.1.</span> <span class="nav-text">Collection接口中的常用方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-Iterator%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.9.3.</span> <span class="nav-text">3.Iterator迭代器接口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8Iterator%E7%9A%84%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86"><span class="nav-number">1.9.3.1.</span> <span class="nav-text">迭代器Iterator的执行原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Iterator%E8%BF%AD%E4%BB%A3%E5%99%A8remove-%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">1.9.3.2.</span> <span class="nav-text">Iterator迭代器remove()的使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B0%E7%89%B9%E6%80%A7foreach%E5%BE%AA%E7%8E%AF%E9%81%8D%E5%8E%86%E9%9B%86%E5%90%88%E6%88%96%E6%95%B0%E7%BB%84"><span class="nav-number">1.9.3.3.</span> <span class="nav-text">新特性foreach循环遍历集合或数组</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81Collection%E5%AD%90%E6%8E%A5%E5%8F%A3%E4%B9%8B%E4%B8%80%EF%BC%9AList%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.9.4.</span> <span class="nav-text">4、Collection子接口之一：List接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-Collection%E5%AD%90%E6%8E%A5%E5%8F%A3%E4%B9%8B%E4%B8%80%EF%BC%9AList%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.9.5.</span> <span class="nav-text">4.Collection子接口之一：List接口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#List%E6%8E%A5%E5%8F%A3%E5%B8%B8%E7%94%A8%E5%AE%9E%E7%8E%B0%E7%B1%BB%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="nav-number">1.9.5.1.</span> <span class="nav-text">List接口常用实现类的对比</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ArrayList%E7%9A%84%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">1.9.5.2.</span> <span class="nav-text">ArrayList的源码分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LinkedList%E7%9A%84%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">1.9.5.3.</span> <span class="nav-text">LinkedList的源码分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Vector%E7%9A%84%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">1.9.5.4.</span> <span class="nav-text">Vector的源码分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#List%E6%8E%A5%E5%8F%A3%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%B5%8B%E8%AF%95"><span class="nav-number">1.9.5.5.</span> <span class="nav-text">List接口中的常用方法测试</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#List%E7%9A%84%E4%B8%80%E4%B8%AA%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="nav-number">1.9.5.6.</span> <span class="nav-text">List的一个面试题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5%E3%80%81Collection%E5%AD%90%E6%8E%A5%E5%8F%A3%E4%B9%8B%E4%BA%8C%EF%BC%9ASet%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.9.6.</span> <span class="nav-text">5、Collection子接口之二：Set接口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Set%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E7%B1%BB%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="nav-number">1.9.6.1.</span> <span class="nav-text">Set接口实现类的对比</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HashSet%E4%B8%AD%E5%85%83%E7%B4%A0%E7%9A%84%E6%B7%BB%E5%8A%A0%E8%BF%87%E7%A8%8B"><span class="nav-number">1.9.6.2.</span> <span class="nav-text">HashSet中元素的添加过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B3%E4%BA%8EhashCode-%E5%92%8Cequals-%E7%9A%84%E9%87%8D%E5%86%99"><span class="nav-number">1.9.6.3.</span> <span class="nav-text">关于hashCode()和equals()的重写</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%87%8D%E5%86%99hashCode-%E6%96%B9%E6%B3%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99"><span class="nav-number">1.9.6.3.1.</span> <span class="nav-text">重写hashCode() 方法的基本原则</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%87%8D%E5%86%99equals-%E6%96%B9%E6%B3%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99"><span class="nav-number">1.9.6.3.2.</span> <span class="nav-text">重写equals() 方法的基本原则</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Eclipse-IDEA%E5%B7%A5%E5%85%B7%E9%87%8ChashCode-%E7%9A%84%E9%87%8D%E5%86%99"><span class="nav-number">1.9.6.3.3.</span> <span class="nav-text">Eclipse&#x2F;IDEA工具里hashCode()的重写</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LinkedHashSet%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">1.9.6.4.</span> <span class="nav-text">LinkedHashSet的使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TreeSet%E7%9A%84%E8%87%AA%E7%84%B6%E6%8E%92%E5%BA%8F"><span class="nav-number">1.9.6.5.</span> <span class="nav-text">TreeSet的自然排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TreeSet%E7%9A%84%E5%AE%9A%E5%88%B6%E6%8E%92%E5%BA%8F"><span class="nav-number">1.9.6.6.</span> <span class="nav-text">TreeSet的定制排序</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6%E3%80%81Map%E6%8E%A5%E5%8F%A3"><span class="nav-number">1.9.7.</span> <span class="nav-text">6、Map接口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Map%E4%B8%AD%E5%AD%98%E5%82%A8%E7%9A%84key-value%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-number">1.9.7.1.</span> <span class="nav-text">Map中存储的key-value的特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Map%E5%AE%9E%E7%8E%B0%E7%B1%BB%E4%B9%8B%E4%B8%80%EF%BC%9AHashMap"><span class="nav-number">1.9.7.2.</span> <span class="nav-text">Map实现类之一：HashMap</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HashMap%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">1.9.7.3.</span> <span class="nav-text">HashMap的底层实现原理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#HashMap%E5%9C%A8JDK7%E4%B8%AD%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">1.9.7.3.1.</span> <span class="nav-text">HashMap在JDK7中的底层实现原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#HashMap%E5%9C%A8JDK8%E4%B8%AD%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">1.9.7.3.2.</span> <span class="nav-text">HashMap在JDK8中的底层实现原理</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LinkedHashMap%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%81%EF%BC%81%EF%BC%81%EF%BC%89"><span class="nav-number">1.9.7.4.</span> <span class="nav-text">LinkedHashMap的底层实现原理（了解！！！）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Map%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-number">1.9.7.5.</span> <span class="nav-text">Map中的常用方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TreeMap%E4%B8%A4%E7%A7%8D%E6%B7%BB%E5%8A%A0%E6%96%B9%E5%BC%8F%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">1.9.7.6.</span> <span class="nav-text">TreeMap两种添加方式的使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Hashtable"><span class="nav-number">1.9.7.7.</span> <span class="nav-text">Hashtable</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Properties%E5%A4%84%E7%90%86%E5%B1%9E%E6%80%A7%E6%96%87%E4%BB%B6"><span class="nav-number">1.9.7.8.</span> <span class="nav-text">Properties处理属性文件</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7%E3%80%81Collections%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="nav-number">1.9.8.</span> <span class="nav-text">7、Collections工具类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IO"><span class="nav-number">1.10.</span> <span class="nav-text">IO</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81File%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">1.10.1.</span> <span class="nav-text">1、File类的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#File%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="nav-number">1.10.1.1.</span> <span class="nav-text">File类的实例化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#File%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-number">1.10.1.2.</span> <span class="nav-text">File类的常用方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-IO%E6%B5%81%E5%8E%9F%E7%90%86%E5%8F%8A%E6%B5%81%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-number">1.10.2.</span> <span class="nav-text">2.IO流原理及流的分类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#IO%E6%B5%81%E5%8E%9F%E7%90%86"><span class="nav-number">1.10.2.1.</span> <span class="nav-text">IO流原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%81%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-number">1.10.2.2.</span> <span class="nav-text">流的分类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IO-%E6%B5%81%E4%BD%93%E7%B3%BB"><span class="nav-number">1.10.2.3.</span> <span class="nav-text">IO 流体系</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E8%8A%82%E7%82%B9%E6%B5%81-%E6%88%96%E6%96%87%E4%BB%B6%E6%B5%81"><span class="nav-number">1.10.3.</span> <span class="nav-text">3.节点流(或文件流)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#FileReader%E8%AF%BB%E5%85%A5%E6%95%B0%E6%8D%AE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="nav-number">1.10.3.1.</span> <span class="nav-text">FileReader读入数据的基本操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#FileWriter%E5%86%99%E5%87%BA%E6%95%B0%E6%8D%AE%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="nav-number">1.10.3.2.</span> <span class="nav-text">FileWriter写出数据的操作</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E7%BC%93%E5%86%B2%E6%B5%81"><span class="nav-number">1.10.4.</span> <span class="nav-text">4.缓冲流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E8%BD%AC%E6%8D%A2%E6%B5%81"><span class="nav-number">1.10.5.</span> <span class="nav-text">5.转换流</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BD%AC%E6%8D%A2%E6%B5%81%E6%A6%82%E8%BF%B0%E4%B8%8EInputStreamReader%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">1.10.5.1.</span> <span class="nav-text">转换流概述与InputStreamReader的使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E7%A7%8D%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E9%9B%86%E7%9A%84%E8%AF%B4%E6%98%8E"><span class="nav-number">1.10.5.2.</span> <span class="nav-text">多种字符编码集的说明</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E3%80%81%E8%BE%93%E5%87%BA%E6%B5%81"><span class="nav-number">1.10.6.</span> <span class="nav-text">6.标准输入、输出流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-%E6%89%93%E5%8D%B0%E6%B5%81"><span class="nav-number">1.10.7.</span> <span class="nav-text">7.打印流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-%E6%95%B0%E6%8D%AE%E6%B5%81"><span class="nav-number">1.10.8.</span> <span class="nav-text">8.数据流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-%E5%AF%B9%E8%B1%A1%E6%B5%81"><span class="nav-number">1.10.9.</span> <span class="nav-text">9.对象流</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96%E6%9C%BA%E5%88%B6%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">1.10.9.1.</span> <span class="nav-text">对象序列化机制的理解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%AE%9E%E7%8E%B0%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%93%8D%E4%BD%9C"><span class="nav-number">1.10.9.2.</span> <span class="nav-text">自定义类实现序列化与反序列化操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#serialVersionUID%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">1.10.9.3.</span> <span class="nav-text">serialVersionUID的理解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-%E9%9A%8F%E6%9C%BA%E5%AD%98%E5%8F%96%E6%96%87%E4%BB%B6%E6%B5%81"><span class="nav-number">1.10.10.</span> <span class="nav-text">10.随机存取文件流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-NIO-2%E4%B8%ADPath%E3%80%81Paths%E3%80%81Files%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">1.10.11.</span> <span class="nav-text">11.NIO.2中Path、Paths、Files类的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5%E8%A7%A3%E9%87%8A%EF%BC%9A"><span class="nav-number">1.10.11.0.1.</span> <span class="nav-text">概念解释：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#NIO%E5%92%8C%E4%BC%A0%E7%BB%9F%E7%9A%84IO%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E5%91%A2"><span class="nav-number">1.10.11.0.2.</span> <span class="nav-text">NIO和传统的IO有什么区别呢?</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%80%E5%90%8E%EF%BC%8C%E5%AF%B9%E4%BA%8ENIO%E5%92%8C%E4%BC%A0%E7%BB%9FIO%EF%BC%8C%E6%9C%89%E4%B8%80%E4%B8%AA%E7%BD%91%E5%8F%8B%E8%AE%B2%E7%9A%84%E7%94%9F%E5%8A%A8%E7%9A%84%E4%BE%8B%E5%AD%90%EF%BC%9A"><span class="nav-number">1.10.11.0.3.</span> <span class="nav-text">最后，对于NIO和传统IO，有一个网友讲的生动的例子：</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="nav-number">1.11.</span> <span class="nav-text">网络编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%A6%82%E8%BF%B0-1"><span class="nav-number">1.11.1.</span> <span class="nav-text">1.概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E8%A6%81%E7%B4%A0"><span class="nav-number">1.11.2.</span> <span class="nav-text">2.网络通信要素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-IP"><span class="nav-number">1.11.3.</span> <span class="nav-text">3.IP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E7%AB%AF%E5%8F%A3"><span class="nav-number">1.11.4.</span> <span class="nav-text">4.端口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE"><span class="nav-number">1.11.5.</span> <span class="nav-text">5.通信协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-TCP"><span class="nav-number">1.11.6.</span> <span class="nav-text">6.TCP</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%88%9D%E8%AF%86Tomcat"><span class="nav-number">1.11.6.1.</span> <span class="nav-text">2.初识Tomcat</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-UDP"><span class="nav-number">1.11.7.</span> <span class="nav-text">7.UDP</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF"><span class="nav-number">1.11.7.1.</span> <span class="nav-text">1.发送消息</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-URL"><span class="nav-number">1.11.8.</span> <span class="nav-text">8.URL</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.12.</span> <span class="nav-text">多线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.12.1.</span> <span class="nav-text">1、线程实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA-%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="nav-number">1.12.1.1.</span> <span class="nav-text">1.线程的创建(三种方式)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86"><span class="nav-number">1.12.1.2.</span> <span class="nav-text">2.静态代理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">1.12.1.3.</span> <span class="nav-text">3.Lambda表达式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="nav-number">1.12.2.</span> <span class="nav-text">2、线程状态</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BA%94%E5%A4%A7%E7%8A%B6%E6%80%81"><span class="nav-number">1.12.2.1.</span> <span class="nav-text">1 、线程的五大状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E7%BA%BF%E7%A8%8B%E6%96%B9%E6%B3%95"><span class="nav-number">1.12.2.2.</span> <span class="nav-text">2、线程方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%A7%82%E6%B5%8B"><span class="nav-number">1.12.2.3.</span> <span class="nav-text">3.线程状态观测</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4%E3%80%81%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7"><span class="nav-number">1.12.2.4.</span> <span class="nav-text">4、线程优先级</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%E3%80%81%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.12.2.5.</span> <span class="nav-text">5、守护线程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="nav-number">1.12.3.</span> <span class="nav-text">3、线程同步</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.12.3.1.</span> <span class="nav-text">1.介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95"><span class="nav-number">1.12.3.2.</span> <span class="nav-text">2、同步方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E5%90%8C%E6%AD%A5%E5%9D%97"><span class="nav-number">1.12.3.3.</span> <span class="nav-text">3.同步块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E6%AD%BB%E9%94%81"><span class="nav-number">1.12.3.4.</span> <span class="nav-text">4.死锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5%E3%80%81Lock%EF%BC%88%E9%94%81%EF%BC%89"><span class="nav-number">1.12.3.5.</span> <span class="nav-text">5、Lock（锁）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-synchroized%E4%B8%8ELock%E5%AF%B9%E6%AF%94"><span class="nav-number">1.12.3.6.</span> <span class="nav-text">6.synchroized与Lock对比</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E9%97%AE%E9%A2%98"><span class="nav-number">1.12.4.</span> <span class="nav-text">4.线程通信问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%96%B9%E6%B3%95"><span class="nav-number">1.12.4.1.</span> <span class="nav-text">1.线程通信方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F"><span class="nav-number">1.12.4.2.</span> <span class="nav-text">2.线程通信问题解决方式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">1.12.5.</span> <span class="nav-text">5.线程池</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%A8%E8%A7%A3%E4%B8%8E%E5%8F%8D%E5%B0%84"><span class="nav-number">1.13.</span> <span class="nav-text">注解与反射</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E6%B3%A8%E8%A7%A3"><span class="nav-number">1.13.1.</span> <span class="nav-text">1、注解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E6%B3%A8%E8%A7%A3%E5%85%A5%E9%97%A8"><span class="nav-number">1.13.1.1.</span> <span class="nav-text">1、注解入门</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%86%85%E7%BD%AE%E6%B3%A8%E8%A7%A3"><span class="nav-number">1.13.1.2.</span> <span class="nav-text">2.内置注解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3"><span class="nav-number">1.13.1.3.</span> <span class="nav-text">3、自定义注解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6"><span class="nav-number">1.13.2.</span> <span class="nav-text">2、反射机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E6%A6%82%E5%BF%B5"><span class="nav-number">1.13.2.1.</span> <span class="nav-text">1.Java反射机制概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E7%90%86%E8%A7%A3Class%E7%B1%BB%E5%B9%B6%E8%8E%B7%E5%8F%96Class%E5%AE%9E%E4%BE%8B"><span class="nav-number">1.13.2.2.</span> <span class="nav-text">2.理解Class类并获取Class实例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E4%B8%8EClassLoader"><span class="nav-number">1.13.2.3.</span> <span class="nav-text">3.类的加载与ClassLoader</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E8%8E%B7%E5%8F%96%E8%BF%90%E8%A1%8C%E7%B1%BB%E7%9A%84%E5%AE%8C%E6%95%B4%E7%BB%93%E6%9E%84"><span class="nav-number">1.13.2.4.</span> <span class="nav-text">4.获取运行类的完整结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-%E8%B0%83%E7%94%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E7%9A%84%E6%8C%87%E5%AE%9A%E7%BB%93%E6%9E%84"><span class="nav-number">1.13.2.5.</span> <span class="nav-text">5.调用运行时类的指定结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-%E5%8F%8D%E5%B0%84%E6%93%8D%E4%BD%9C%E6%B3%9B%E5%9E%8B"><span class="nav-number">1.13.2.6.</span> <span class="nav-text">6.反射操作泛型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-%E5%8F%8D%E5%B0%84%E6%93%8D%E4%BD%9C%E6%B3%A8%E8%A7%A3"><span class="nav-number">1.13.2.7.</span> <span class="nav-text">7.反射操作注解</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JAVA-SE%E6%80%BB%E7%BB%93"><span class="nav-number">1.14.</span> <span class="nav-text">JAVA SE总结</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="6pc1"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">6pc1</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">18</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/6pc1" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;6pc1" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:2961816476@qq.com" title="E-Mail → mailto:2961816476@qq.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://qm.qq.com/q/uZSUzwBesa" title="QQ → https:&#x2F;&#x2F;qm.qq.com&#x2F;q&#x2F;uZSUzwBesa" rel="noopener me" target="_blank"><i class="fab fa-qq fa-fw"></i>QQ</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
    <div class="sidebar-inner sidebar-blogroll">
      <div class="links-of-blogroll animated">
        <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
          链接
        </div>
        <ul class="links-of-blogroll-list">
            <li class="links-of-blogroll-item">
              <a href="https://hacbit.tech/" title="https:&#x2F;&#x2F;hacbit.tech&#x2F;" rel="noopener" target="_blank">hacbit</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="https://yixinbc.tech/" title="https:&#x2F;&#x2F;yixinbc.tech&#x2F;" rel="noopener" target="_blank">yixinBC</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="http://clearwine.online/" title="http:&#x2F;&#x2F;clearwine.online" rel="noopener" target="_blank">qinjiu</a>
            </li>
        </ul>
      </div>
    </div>
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://6pc1.github.io/2024/09/14/Java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="6pc1">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="6pc1's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Java学习之旅 | 6pc1's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java学习之旅
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-09-14 18:31:37" itemprop="dateCreated datePublished" datetime="2024-09-14T18:31:37+08:00">2024-09-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-10-20 10:44:13" itemprop="dateModified" datetime="2024-10-20T10:44:13+08:00">2024-10-20</time>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2024/09/14/Java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2024/09/14/Java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>87k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1:19</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>学学Java吧！</p>
<span id="more"></span>

<h1 id="一、Java-SE基础"><a href="#一、Java-SE基础" class="headerlink" title="一、Java SE基础"></a>一、Java SE基础</h1><p>​	这里就是Java学习的开始，从这开始我的Java复习，以及笔记整理之路。</p>
<h2 id="计算机预科"><a href="#计算机预科" class="headerlink" title="计算机预科"></a>计算机预科</h2><p>​	这都是最基础的，大概就提一下。</p>
<p>1、打开CMD</p>
<p>2、管理员身份运行CMD</p>
<p>3、常见的Dos命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cd  切换路径</span><br><span class="line">dir 查看目录</span><br><span class="line">exit  退出终端</span><br><span class="line">ipconfig  查看电脑ip信息</span><br><span class="line">calc  打开计算器</span><br><span class="line">mspaint  打开画图</span><br><span class="line">notepad  打开记事本</span><br><span class="line">ping  对网站发起ping操作</span><br><span class="line">md或mkdir  创建文件夹</span><br><span class="line">rmdir或rd  删除空目录</span><br><span class="line">del 删除目录或文件</span><br></pre></td></tr></table></figure>

<h2 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h2><h3 id="1、Java简介"><a href="#1、Java简介" class="headerlink" title="1、Java简介"></a>1、Java简介</h3><ul>
<li><p>Java的特性和优势</p>
<ul>
<li>简单性</li>
<li>面向对象</li>
<li>可移植性</li>
<li>高性能</li>
<li>分布式</li>
<li>动态性</li>
<li>多线程</li>
<li>安全性</li>
<li>健壮性</li>
</ul>
</li>
<li><p>Java的三大版本</p>
<ul>
<li>JavaSE： 标准版（桌面程序、控制台开发……）</li>
<li>JavaME：嵌入式开发（手机、加点…..）</li>
<li>JavaEE：企业级开发（Web端、服务器开发……）</li>
</ul>
</li>
<li><p>Java的安装与卸载开发环境（这个网上都有的，搜下很多）</p>
</li>
</ul>
<h3 id="2、Hello-World"><a href="#2、Hello-World" class="headerlink" title="2、Hello World"></a>2、Hello World</h3><ul>
<li>代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World!Java!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以直接通过java先编译为字节码class文件再执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javac Hello.java           ---&gt;得到Hello.class</span><br><span class="line">java Hello.class           ---&gt;Hello World!Java!</span><br></pre></td></tr></table></figure>

<ul>
<li><p>注释</p>
<p>java中的注释有三种</p>
<ul>
<li>单行注释：只能注释一行文字   Ctrl  + &#x2F;</li>
<li>多行注释：可以注释一段文字  Ctrl  +  Shift +  &#x2F;</li>
<li>文档注释：一般用于表名文档创建者、创建日期、说明等</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//   单行注释</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	多行注释</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 文档注释</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h3 id="3、标识符和关键字"><a href="#3、标识符和关键字" class="headerlink" title="3、标识符和关键字"></a>3、标识符和关键字</h3><ul>
<li><p>标识符</p>
<ul>
<li>所有的标识符都应该以字母，$符号或者下划线开始</li>
<li>不能使用关键字作为变量名或者方法名</li>
<li>不建议使用中文或者拼音</li>
</ul>
</li>
<li><p>关键字</p>
<table>
<thead>
<tr>
<th>abstract</th>
<th>boolean</th>
<th>break</th>
<th>byte</th>
<th>case</th>
</tr>
</thead>
<tbody><tr>
<td>catch</td>
<td>char</td>
<td>const</td>
<td>class</td>
<td>continue</td>
</tr>
<tr>
<td>default</td>
<td>do</td>
<td>double</td>
<td>else</td>
<td>extends</td>
</tr>
<tr>
<td>final</td>
<td>finally</td>
<td>float</td>
<td>for</td>
<td>goto</td>
</tr>
<tr>
<td>if</td>
<td>implements</td>
<td>import</td>
<td>instanceof</td>
<td>int</td>
</tr>
<tr>
<td>interface</td>
<td>long</td>
<td>native</td>
<td>new</td>
<td>package</td>
</tr>
<tr>
<td>private</td>
<td>protected</td>
<td>public</td>
<td>return</td>
<td>short</td>
</tr>
<tr>
<td>static</td>
<td>strictfp</td>
<td>super</td>
<td>switch</td>
<td>this</td>
</tr>
<tr>
<td>throw</td>
<td>throws</td>
<td>transient</td>
<td>try</td>
<td>void</td>
</tr>
<tr>
<td>volatile</td>
<td>while</td>
<td>synchronized</td>
<td></td>
<td></td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="4、数据类型"><a href="#4、数据类型" class="headerlink" title="4、数据类型"></a>4、数据类型</h3><ul>
<li><p>静态类型语言</p>
<ul>
<li>变量定义时有类型声明的语言</li>
</ul>
</li>
<li><p>强类型语言</p>
<ul>
<li>强制数据类型定义的语言。也就是说，一旦一个变量被指定了某个数据类型，如果不经过强制转换，那么它就永远是这个数据类型了。</li>
</ul>
</li>
<li><p>数据类型基本分类</p>
<ul>
<li>基本类型<ul>
<li>数值类型<ul>
<li>整数<ul>
<li>byte   1字节   -128~127   （一字节八位）</li>
<li>short  2字节   -2^15~2^15-1</li>
<li>int       4字节   -2^31~2^31-1</li>
<li>long    8字节   -2^63~2^63-1</li>
</ul>
</li>
<li>浮点数<ul>
<li>float   4字节</li>
<li>double   8字节</li>
</ul>
</li>
<li>字符<ul>
<li>char  2字节</li>
</ul>
</li>
<li>布尔<ul>
<li>boolean  1位 只有true和false两值</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>引用类型<ul>
<li>类</li>
<li>接口</li>
<li>数组</li>
</ul>
</li>
</ul>
</li>
<li><p>什么是字节</p>
<ul>
<li>位（bit） 计算机内部数据存储的最小单位， 1011 1101是一个八位的二进制数</li>
<li>字节（byte）  是计算机中数据处理的基本单位，习惯用大写B表示，1B（byte字节） &#x3D;  8bit（位）</li>
<li>字符：是指计算机中使用的字母、数字、字和符号。<ul>
<li>1bit表示1位</li>
<li>1Byte表示一个字节1B&#x3D;8b</li>
<li>1024B&#x3D;1KB</li>
<li>1024KB&#x3D;1M</li>
<li>1024M&#x3D;1G</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>数据类型拓展</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不同进制的表示</span></span><br><span class="line"><span class="type">int</span> i=<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="number">010</span>;   <span class="comment">// 八进制0</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i3</span> <span class="operator">=</span> <span class="number">0x10</span>;  <span class="comment">// 十六进制0x</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 转义字符</span></span><br><span class="line"><span class="comment">// \t   制表符</span></span><br><span class="line"><span class="comment">// \n   换行</span></span><br></pre></td></tr></table></figure>

<h3 id="5、类型转换"><a href="#5、类型转换" class="headerlink" title="5、类型转换"></a>5、类型转换</h3><ul>
<li><p>由于Java是强类型语言，所以在进行某些运算的时候，需要进行对应的类型转换</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">低 ------------------------------------------------&gt; 高</span><br><span class="line"><span class="type">byte</span> -&gt; <span class="type">short</span> -&gt; <span class="type">char</span> -&gt; <span class="type">int</span> -&gt; <span class="type">long</span> -&gt; <span class="type">float</span> -&gt; <span class="type">double</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>运算中，不同类型的数据先转化为统一类型在进行运算</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//强制类型转换</span></span><br><span class="line">(<span class="type">int</span>)<span class="number">12.3</span> ---&gt; <span class="number">12</span></span><br><span class="line">(<span class="type">double</span>)<span class="number">12</span>  ----&gt;  <span class="number">12.00</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">// 不过要注意数据类型的大小，防止内存溢出的出现</span></span><br><span class="line"><span class="comment">// JDK7新特性，数字之间可以用下划线分割</span></span><br><span class="line"><span class="type">int</span> <span class="variable">money</span> <span class="operator">=</span> <span class="number">10_0000_0000</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="6、变量与常量"><a href="#6、变量与常量" class="headerlink" title="6、变量与常量"></a>6、变量与常量</h3><ul>
<li>变量：可以变化的量 </li>
<li>Java是一种强类型语言，每个变量都要申明其数据类型</li>
<li>Java变量是程序中最基本的存储单元，其要素包括变量名、变量类型和作用域</li>
<li>每个变量都必须要有对应的类型，可以使基本类型也可以是引用类型</li>
<li>变量名必须是合法的标识符</li>
<li>变量声明需要以分号结尾</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类变量 static</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">double</span> <span class="variable">salary</span> <span class="operator">=</span> <span class="number">2500</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例变量:从属于对象：实例变量：从属于对象；如果不自行初始化，这个类型的默认值 0 0.0</span></span><br><span class="line"><span class="comment">// 布尔值：默认是 faLse</span></span><br><span class="line"><span class="comment">// 除了基本类型，其余的都是null</span></span><br></pre></td></tr></table></figure>

<ul>
<li>变量的一些命名规范（使你的代码更加规范化）<ul>
<li>所有变量、方法、类名：见名如意（可以采用英文命名）</li>
<li>类成员变量：首字母小写和驼峰原则：monthSalary</li>
<li>局部变量：首字母小写和驼峰原则</li>
<li>常量：大写字母加下划线：MAX_VALUE</li>
<li>类名：首字母大写加驼峰原则：Man，GoodMan</li>
<li>方法名：首字母小写和驼峰原则：runRun()</li>
</ul>
</li>
</ul>
<h3 id="7、基本运算符"><a href="#7、基本运算符" class="headerlink" title="7、基本运算符"></a>7、基本运算符</h3><blockquote>
<p>Java支持如下运算符</p>
</blockquote>
<ul>
<li><p>算术运算符：+，-，*，&#x2F;，%，++，–</p>
</li>
<li><p>赋值运算符: &#x3D;</p>
</li>
<li><p>关系运算符：&gt;，≤，&gt;&#x3D;，&lt;&#x3D;，&#x3D;&#x3D;，!&#x3D;， instanceof</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">instanceof是Java中的二元运算符，左边是对象，右边是类；当对象是右边类或子类所创建对象时，返回true；否则，返回false。</span><br></pre></td></tr></table></figure>
</li>
<li><p>逻辑运算符：&amp;&amp;，‖，!</p>
</li>
<li><p>位运算符：&amp;，|，~，^，&gt;&gt;，&lt;&lt;，&gt;&gt;&gt;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&amp;：按位与</span><br><span class="line">|：按位或</span><br><span class="line">~：按位非</span><br><span class="line">^：按位异或</span><br><span class="line">&lt;&lt;：左位移运算符</span><br><span class="line">&gt;&gt;：右位移运算符</span><br><span class="line">&lt;&lt;&lt;：无符号左移运算符</span><br></pre></td></tr></table></figure>
</li>
<li><p>条件运算符: ？：</p>
</li>
<li><p>扩展赋值运算符：+&#x3D;，-&#x3D;，*&#x3D;，&#x2F;&#x3D;</p>
</li>
</ul>
<h3 id="8、自增自减运算符、初始Math类"><a href="#8、自增自减运算符、初始Math类" class="headerlink" title="8、自增自减运算符、初始Math类"></a>8、自增自减运算符、初始Math类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a++ 与  ++a的区别</span><br><span class="line"><span class="comment">// ++在前表示先+1再去执行代码  在后则是相反</span></span><br><span class="line"><span class="comment">// --也是同理</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>Math类的一些常见用法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Math.abs(a)：取a的绝对值</span><br><span class="line">Math.sqrt(a)：取a的平方根</span><br><span class="line">Math.cbrt(a)：取a的立方根</span><br><span class="line">Math.max(a,b)：取a、b之间的最大值</span><br><span class="line">Math.min(a,b)：取a、b之间的最小值</span><br><span class="line">Math.pow(a,b)：取a的b平方</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="9、逻辑运算符、位运算符"><a href="#9、逻辑运算符、位运算符" class="headerlink" title="9、逻辑运算符、位运算符"></a>9、逻辑运算符、位运算符</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&amp;&amp;   <span class="comment">// 逻辑与：两个变量都为真，结果才为true</span></span><br><span class="line">||   <span class="comment">// 逻辑或：两个变量有一个为真，则结果才为true</span></span><br><span class="line">!    <span class="comment">// 取反：如果是真，则变为假；如果是假，则变为真</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        A = 0011 1100</span></span><br><span class="line"><span class="comment">        B = 0000 1101</span></span><br><span class="line"><span class="comment">----------------------------------</span></span><br><span class="line"><span class="comment">        A&amp;B = 0000 1100</span></span><br><span class="line"><span class="comment">        A|B = 0011 1101</span></span><br><span class="line"><span class="comment">        A^B = 0011 0001</span></span><br><span class="line"><span class="comment">        ~B = 1111 0010</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        2*8 = 16</span></span><br><span class="line"><span class="comment">        &lt;&lt; *2</span></span><br><span class="line"><span class="comment">        &gt;&gt; /2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         */</span></span><br></pre></td></tr></table></figure>

<h3 id="10、三元运算符"><a href="#10、三元运算符" class="headerlink" title="10、三元运算符"></a>10、三元运算符</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 三元运算符</span></span><br><span class="line"><span class="comment">// x ？ y : z</span></span><br><span class="line"><span class="comment">// 如果x==true,则结果为y，否则结果为z</span></span><br></pre></td></tr></table></figure>

<h3 id="11、包机制"><a href="#11、包机制" class="headerlink" title="11、包机制"></a>11、包机制</h3><ul>
<li><p>为了更好的组织类，Java提供了包机制，用于区别类名的命名空间</p>
</li>
<li><p>包语句的语法格式是</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> pkg1[.pkg2[.pkg3……]];</span><br></pre></td></tr></table></figure>
</li>
<li><p>一般利用公司域名倒置作为包名；<a target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a> —&gt;   com&#x2F;baidu&#x2F;www</p>
</li>
<li><p>为了能够使用某个包的成员，我们需要再Java程序中明确导入该包，使用“import”语句可完成此功能</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> package1[.package2……].(classname | *);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="12、JavaDoc"><a href="#12、JavaDoc" class="headerlink" title="12、JavaDoc"></a>12、JavaDoc</h3><ul>
<li><p>JavaDoc是用来生成自己API文档的。</p>
</li>
<li><p>参数信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- @ author作者名</span><br><span class="line">- @ version版本号</span><br><span class="line">- @ since指明需要最早使用的jdk版本</span><br><span class="line">- @ paran参数名</span><br><span class="line">- @ return返回值情况</span><br><span class="line">- @ throws异常抛出情况</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javadoc -encoding UTF-<span class="number">8</span> -charset UTF-<span class="number">8</span> Doc.java   <span class="comment">// 注意保持编码一致</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><h3 id="1、用户交互Scanner"><a href="#1、用户交互Scanner" class="headerlink" title="1、用户交互Scanner"></a>1、用户交互Scanner</h3><ul>
<li><p>Java给我们提供了一个工具类，去实现程序与人的交互，获取用户的输入，java.util.Scanner是Java5的新特性，我们可以使用Scanner类去获取用户输入。</p>
</li>
<li><p>基本语法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">s</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过 Scanner类的next()与 nextLine()方法获取输入的字符串，在读取前我们一般需要使用 hasNext()与 hasNextLine()判断是否还有输入的数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span>(scanner.hasNext())&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">            System.out.println(<span class="string">&quot;输入的内容为:&quot;</span> + str);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(scanner.hasNextLine())&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">            System.out.println(<span class="string">&quot;输出的内容为:&quot;</span> + str);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>next()：</p>
<ol>
<li>一定要读取到有效字符才可以结束输入。</li>
<li>对输入有效字符之前遇到的空白，会自动去除</li>
<li>只有输入有效字符才将其后输入的空白作为分隔符或者结束符</li>
<li>next不能获取带空格的字符串</li>
</ol>
</li>
<li><p>nextLine():</p>
<ol>
<li>以Enter为结束符，也就是说返回的是Enter前所有字符</li>
<li>可以获取空白</li>
</ol>
</li>
</ul>
<h3 id="2、顺序结构"><a href="#2、顺序结构" class="headerlink" title="2、顺序结构"></a>2、顺序结构</h3><ul>
<li>Java的基本结构就是顺序结构，除非特别指明，负责就是按照顺序一句一句执行。</li>
<li>顺序结构是最简单的算法结构</li>
<li>语句与语句之间，框与框之间是按从上到下的顺序进行的，它是由若干个依次执行的处理步骤组成的，<strong>它是任何一个算法都离不开的一种基本算法结构</strong> 。</li>
</ul>
<h3 id="3、选择结构"><a href="#3、选择结构" class="headerlink" title="3、选择结构"></a>3、选择结构</h3><ul>
<li><p>if简单选择结构</p>
<ul>
<li><p>我们很多时候去判断一个东西是否可行，可行才能够去执行，这就用到if结构</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>（布尔表达式）&#123;</span><br><span class="line">	<span class="comment">// 如果布尔表达式为true才执行这个代码块中的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>if双选择结构（也就是if else）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(布尔表达式)&#123;</span><br><span class="line">    <span class="comment">// 如果布尔表达式为true</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">// 如果布尔表达式值为false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>if多选择结构</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(布尔表达式<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="comment">// 如果布尔表达式1为true执行代码</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(布尔表达式<span class="number">2</span>)&#123;</span><br><span class="line">    <span class="comment">// 如果布尔表达式2为true执行代码</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(布尔表达式<span class="number">3</span>)&#123;</span><br><span class="line">    <span class="comment">// 如果布尔表达式3为true执行代码</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">// 如果以上布尔表达式值都不为true执行代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>嵌套的if结构</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(布尔表达式<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="comment">// 如果布尔表达式1为true执行代码</span></span><br><span class="line">	<span class="keyword">if</span>(布尔表达式<span class="number">2</span>)&#123;</span><br><span class="line">    	<span class="comment">// 如果布尔表达式2为true执行代码</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>switch多选择结构</p>
<ul>
<li>多选择结构还有一个实现方式就是 switch case语句。</li>
<li>switch case语句判断一个变量与一系列值中某个值是否相等，每个值称为一个分支。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>（参数）&#123;</span><br><span class="line">	<span class="keyword">case</span> A:</span><br><span class="line">	<span class="keyword">case</span> B:</span><br><span class="line">	<span class="keyword">case</span> C:</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4、循环结构"><a href="#4、循环结构" class="headerlink" title="4、循环结构"></a>4、循环结构</h3><ul>
<li>while循环</li>
<li>do……while循环</li>
<li>for循环</li>
</ul>
<h3 id="5、break-continue"><a href="#5、break-continue" class="headerlink" title="5、break &amp; continue"></a>5、break &amp; continue</h3><ul>
<li><p>break在任何循环语句的主体部分，均可用 break控制循环的流程。 <strong>break用于强行退出循环</strong>，不执行循环中剩余的语句。（ break语句也在 switch语句中使用）。</p>
</li>
<li><p>continue语句用在循环语句体中，<strong>用于终止某次循环过程</strong>，即跳过循环体中尚未执行的语句，接着进行下一次是否执行循环的判定。</p>
</li>
<li><p>关于goto标签</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">label:</span><br><span class="line">while（或其他循环语句）</span><br></pre></td></tr></table></figure>

<ul>
<li>goto关键字很早就在程序设计语言中出现。尽管goto仍是Java的一个保留字，但并未在语言中得到正式使用；Java没有goto。然而，在 breaki和 continue这两个关键字的身上，我们仍然能看出一些goto的影子—带标签的 break和continue。</li>
<li>“标签”是指后面跟一个冒号的标识符，例如：label；</li>
<li>对Java来说唯一用到标签的地方是在循环语句之前。而在循环之前设置标签的唯一理由是：我们希望在其中嵌套另一个循环，由于 break和 continue关键字通常只中断当前循环，但若随同标签使用，它们就会中断到存在标签的地方。</li>
<li>goto标签由于有一些不好的方面，一般基本不使用</li>
</ul>
</li>
</ul>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="1、何谓方法"><a href="#1、何谓方法" class="headerlink" title="1、何谓方法"></a>1、何谓方法</h3><ul>
<li><p>Java方法是语句得到集合，它们在一起执行一个功能。</p>
<ul>
<li>方法是解决一类问题的步骤的有序组合</li>
<li>发包含于类或对象中</li>
<li>方法在程序中被创建，在其他地方被引用</li>
</ul>
</li>
<li><p>设计方法的原则：方法的本意是功能块，就是实现某个功能的语句块的集合。我们设计方法的时候，最好保持方法的原子性，<strong>就是一个方法只完成1个功能，这样利于我们后期的扩展</strong>。并且对于方法的命名，也尽可能去对应其功能，使其更浅显易懂。</p>
</li>
</ul>
<h3 id="2、方法的定义及调用"><a href="#2、方法的定义及调用" class="headerlink" title="2、方法的定义及调用"></a>2、方法的定义及调用</h3><ul>
<li><p>Java的方法类似于其它语言的函数，是一段<strong>用来完成特定功能的代码片段</strong>，一般情况下，定义一个方法包含以下语法：</p>
</li>
<li><p><strong>方法包含一个方法头和一个方法体</strong>。下面是一个方法的所有部分：</p>
<ul>
<li><strong>修饰符</strong>：修饰符，这是可选的，告诉编译器如何调用该方法。定义了该方法的访问类型。</li>
<li><strong>返回值类型</strong>：方法可能会返回值。 returnValueType是方法返回值的数据类型。有些方法执行所需的操作，但没有返回值。在这种情况下， returnValueType是关键字void。</li>
<li><strong>方法名</strong>：是方法的实际名称。方法名和参数表共同构成方法签名。</li>
<li><strong>参数类型</strong>：参数像是一个占位符。当方法被调用时，传递值给参数。这个值被称为实参或变量。参数列表是指方法的参数类型、顺序和参数的个数。参数是可选的，方法可以不包含任何参数。<ul>
<li>形式参数：在方法被调用时用于接收外界输入的数据。</li>
<li>实参：调用方法时实际传给方法的数据。</li>
</ul>
</li>
<li><strong>方法体</strong>：方法体包含具体的语句，定义该方法的功能。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数类型 参数名)&#123;</span><br><span class="line">    ...</span><br><span class="line">    方法体</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> 返回值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用方法：对象名.方法名（实参列表）</p>
</li>
<li><p>Java支持两种调用方法的方式，根据方法是否返回值来选择，当方法返回一个值的时候，方法调用通常被当做一个值。</p>
</li>
<li><p>如果返回值为空的话，方法调用一定是一条语句</p>
</li>
</ul>
<blockquote>
<p>注意！！！！！</p>
</blockquote>
<ul>
<li>方法可以修改<strong>传递引用所对应的</strong>变量值，而<strong>不能修改传递值调用</strong>所对应的变量值，这句话相当重要，这是按值调用与引用调用的根本区别，以下为分析：</li>
<li>按值调用(call by value)表示方法接受的时调用者<strong>提供的值</strong>。</li>
</ul>
<p>函数传递值流程图</p>
<p><img src="http://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-16/c9ac44a4a04ebd2fd63b7df7de2f2d66--9e4a--image-20240916195454929.png" alt="image-20240916195454929"></p>
<p><strong>分析</strong>：</p>
<ul>
<li>1）value被初始化为x值的一个拷贝（也就是10）</li>
<li>2）value被乘以3后等于30，但注意此时x的值仍为10！</li>
<li>3）这个方法结束后，参数变量value不再使用，被回收。</li>
</ul>
<blockquote>
<p><strong>结论：</strong>当传递方法参数类型为基本数据类型（数字以及布尔值）时，一个方法是不可能修改一个基本数据类型的参数。</p>
</blockquote>
<ul>
<li><p>按引用调用(call by reference)</p>
</li>
<li><p>按引用调用则表示方法接收的是<strong>调用者提供的变量地址</strong>(如果是C语言的话来说就是指针啦，当然java并没有指针的概念)</p>
</li>
<li><p>当然java中除了基本数据类型还有<strong>引用数据类型</strong>，也就是<strong>对象引用</strong>，那么对于这种数据类型又是怎么样的情况呢？我们还是一样先来看一个例子：<br>先声明一个User对象类型： </p>
</li>
<li><p>分析一下这个过程： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HomeWork02</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">updateUser</span><span class="params">(User student)</span>&#123;</span><br><span class="line">        student.setName(<span class="string">&quot;subeiLY&quot;</span>);</span><br><span class="line">        student.setAge(<span class="number">22</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;SUBEI&quot;</span>,<span class="number">20</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;调用user前的值:&quot;</span> + user.getName() + <span class="string">&quot;,&quot;</span> + user.getAge());</span><br><span class="line">        updateUser(user);</span><br><span class="line">        System.out.println(<span class="string">&quot;调用user后的值:&quot;</span> + user.getName() + <span class="string">&quot;,&quot;</span> + user.getAge());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-16/1f7caad12229ce68470a87760100bb70--07f4--image-20210414143735613.png" alt="img"></p>
<p><strong>分析</strong>：</p>
<ul>
<li>1）student变量被初始化为user值的拷贝，这里是一个对象的引用。</li>
<li>2）调用student变量的set方法作用在这个引用对象上，<strong>user和student同时引用的User对象内部值</strong>被修改。</li>
<li>3）方法结束后，student变量不再使用，被释放，而user还是没有变，依然指向User对象。</li>
</ul>
<blockquote>
<p><strong>结论：</strong>显然，User的值被改变了，但是这是将最开始所对应得值改变了，把User的本身属性改变了，才会进行值得变化，虽然看似是按引用传递值，但是实际上是将值改变了。 </p>
</blockquote>
<ul>
<li>这个过程也充分说明了java程序设计语言对对象采用的不是引用调用，实际上是<strong>对象引用进行的是值传递</strong>，当然在这里我们可以简单理解为这就是按值调用和引用调用的区别，而且必须明白即使java函数在传递引用数据类型时，也只是拷贝了引用的值罢了，之所以能修改引用数据是因为它们同时指向了一个对象，<strong>但这仍然是按值调用而不是引用调用。</strong></li>
<li><strong>总结</strong><ul>
<li>一个方法不能修改一个基本数据类型的参数（数值型和布尔型）。</li>
<li>一个方法可以修改一个引用所指向的对象状态，但这仍然是按值调用而非引用调用。</li>
<li>上面两种传递都进行了值拷贝的过程。</li>
</ul>
</li>
</ul>
<h3 id="3、方法重载"><a href="#3、方法重载" class="headerlink" title="3、方法重载"></a>3、方法重载</h3><ul>
<li>重载就是在一个类中，有相同的函数名称，但形参不同的函数。</li>
<li>方法的重载的规则<ul>
<li>方法名称必须相同。</li>
<li>参数列表必须不同（个数不同、或类型不同、参数排列顺序不同等）<br>方法的返回类型可以相同也可以不相同。</li>
<li>仅仅返回类型不同不足以成为方法的重载。</li>
</ul>
</li>
<li>实现理论：<ul>
<li>方法名称相同时，编译器会根据调用方法的参数个数、参数类型等去逐个匹配，以选择对应的方法，如果匹配失败，则编译器报错。</li>
</ul>
</li>
</ul>
<h3 id="4、命令行传参"><a href="#4、命令行传参" class="headerlink" title="4、命令行传参"></a>4、命令行传参</h3><ul>
<li>通过main函数中的args去传递参数</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.github;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (String arg : args) &#123;</span><br><span class="line">            System.out.println(arg);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<h3 id="5、可变参数"><a href="#5、可变参数" class="headerlink" title="5、可变参数"></a>5、可变参数</h3><ul>
<li>JDK1.5开始，Java支持传递同类型的可变参数给一个方法。</li>
<li>在方法声明中，在指定参数类型后加一个省略号（）。</li>
<li>一个方法中只能指定一个可变参数，它必须是方法的最后一个参数。任何普通的参数必须在它之前声明。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package com.github;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        test(1,2,3,4,5,6);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void test(int... i)&#123;</span><br><span class="line">        for (int k : i) &#123;</span><br><span class="line">            System.out.println(k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6、递归"><a href="#6、递归" class="headerlink" title="6、递归"></a>6、递归</h3><ul>
<li>A方法调用B方法，我们很容易理解！</li>
<li>递归就是：A方法调用A方法！就是自己调用自己。</li>
<li>利用递归可以用简单的程序来解决一些复杂的问题。它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解，递归策略只需少量的程序就可描述岀解题过程所需要的多次重复计算，大大地减少了程序的代码量。递归的能力在于用有限的语句来定义对象的无限集合。</li>
<li>递归结构包括两个部分：<ul>
<li>递归头：什么时候不调用自身方法。如果没有头，将陷入死循环；</li>
<li>递归体：什么时候需要调用自身方法。</li>
</ul>
</li>
</ul>
<p>示例：使用递归求阶乘</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.github;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(test(<span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> n*test(n-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="1、数组概述"><a href="#1、数组概述" class="headerlink" title="1、数组概述"></a>1、数组概述</h3><ul>
<li>数组是相同类型数据的有序集合。</li>
<li>数组描述的是相同类型的若干个数据按照一定的先后次序排列组合而成。</li>
<li>其中每一个数据称作一个数组元素每个数组元素可以通过一个下标来访问它们。</li>
</ul>
<h3 id="2、数组声明创建"><a href="#2、数组声明创建" class="headerlink" title="2、数组声明创建"></a>2、数组声明创建</h3><ul>
<li>首先必须声明数组变量，才能在程序中使用数组。下面是声明数组变量的语法：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dataType[] arrayRefVar;	<span class="comment">// 首选的方法</span></span><br><span class="line">或</span><br><span class="line">dataType arrayRefVar[];	<span class="comment">// 效果相同，但不是首选方法</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Java语言使用new操作符来创建数组，语法如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataType[] arrayRefVar = <span class="keyword">new</span> <span class="title class_">dataType</span>[arraySize];</span><br></pre></td></tr></table></figure>

<ul>
<li>数组的元素是通过索引访问的，数组索引从0开始。</li>
<li>获取数组长度：<code>arrays. length</code></li>
</ul>
<blockquote>
<p>内存分析</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-16/6cadde5fb4d27323c285b0d428245dc7--4b48--image-20240916214245870.png" alt="image-20240916214245870"></p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-16/5c5632e65292b3883e07b66cefa2c846--395e--1622105878156.png" alt="1622105878156"></p>
<blockquote>
<p>数组的四个基本特点：</p>
</blockquote>
<ul>
<li>其长度是确定的。数组一旦被创建，它的大小就是不可以改变的；</li>
<li>其元素必须是相同类型不允许出现混合类型。</li>
<li>数组中的元素可以是任何数据类型，包括基本类型和引用类型。</li>
<li>数组变量属引用类型，数组也可以看成是对象，数组中的每个元素相当于该对象的成员变量数组本身就是对象，Java中对象是在堆中的，因此数组无论保存原始类型还是其他对象类型，&#x3D;&#x3D;数组对象本身是在堆中的&#x3D;&#x3D;。</li>
</ul>
<blockquote>
<p>下标越界及小结：</p>
</blockquote>
<ul>
<li>下标的合法区间：[0, length-1]，如果越界就会报错：</li>
</ul>
<p>数组的下标异常：</p>
<ul>
<li><p>ArraylndexOutofBounds Exception：数组下标越界异常！</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-16/ef136c0b0a60d13a465c9eabf4a507c3--9a6b--1622108608331.png" alt="1622108608331"></p>
</li>
<li><p>数组是相同数据类型（数据类型可以为任意类型）的有序集合数组也是对象。</p>
</li>
<li><p>数组元素相当于对象的成员变量。</p>
</li>
<li><p>数组长度的确定的，不可变的。如果越界，则报：ArrayIndexOutofBounds。</p>
</li>
</ul>
<h3 id="3、数组使用"><a href="#3、数组使用" class="headerlink" title="3、数组使用"></a>3、数组使用</h3><ul>
<li><p>普通的for循环</p>
</li>
<li><p>For-Each循环</p>
</li>
<li><p>数组作方法入参</p>
</li>
<li><p>数组作返回值</p>
</li>
</ul>
<h3 id="4、多维数组"><a href="#4、多维数组" class="headerlink" title="4、多维数组"></a>4、多维数组</h3><ul>
<li>多维数组可以看成是数组的数组，比如二维数组就是一个特殊的一维数组，其每一个元素都是一个一维数组。</li>
<li>二维数组</li>
</ul>
<h3 id="5、Arrays类"><a href="#5、Arrays类" class="headerlink" title="5、Arrays类"></a>5、Arrays类</h3><ul>
<li>数组的工具类 javautil. Arrays</li>
<li>由于数组对象本身并没有什么方法可以供我们调用但AP中提供了一个工具类 Arrays供我们使用从而可以对数据对象进行一些基本的操作。</li>
<li>&#x3D;&#x3D;查看JDK帮助文档&#x3D;&#x3D;。</li>
<li>Arrays类中的方法都是 static 修饰的静态方法在使用的时候可以直接使用类名进行调用，而”不用”使用对象来调用（注意：是“不用”而不是“不能”）。</li>
<li>具有以下常用功能：<ul>
<li>给数组赋值：通过fill方法。</li>
<li>对数组排序：通过sort方法按升序。</li>
<li>比较数组：通过 equals方法比较数组中元素值是否相等。</li>
<li>查找数组元素：通过 binarySearch方法能对排序好的数组进行二分查找法操作。</li>
</ul>
</li>
</ul>
<p>一些常用的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">方法名	简要描述</span><br><span class="line">asList()	返回由指定数组支持的固定大小的列表。</span><br><span class="line">sort()	将数组排序（升序）</span><br><span class="line">parallelSort()	将指定的数组按升序排序</span><br><span class="line">binarySearch()	使用二分搜索法快速查找指定的值（前提是数组必须是有序的）</span><br><span class="line">compare()	按字典顺序比较两个数组</span><br><span class="line">compareUnsigned()	按字典顺序比较两个数组，将数字元素处理为无符号</span><br><span class="line">copyOf()	填充复制数组</span><br><span class="line">copyOfRange()	将数组的指定范围复制到新数组</span><br><span class="line">equals()	比较两个数组</span><br><span class="line">deepEquals()	比较两个数组深度</span><br><span class="line">toString()	将数组转换为字符串</span><br><span class="line">deepToString()	将一个多维数组转换为字符串</span><br><span class="line">fill()	将指定元素填充给数组每一个元素</span><br><span class="line">mismatch()	查找并返回两个数组之间第一个不匹配的索引，如果未找到则返回-<span class="number">1</span></span><br><span class="line">parallelPrefix()	使用提供的函数对数组元素进行操作</span><br><span class="line">parallelSetAll()	使用提供的生成器函数并行设置指定数组的所有元素以计算每个元素</span><br><span class="line">setAll()	使用提供的生成器函数设置指定数组的所有元素以计算每个元素</span><br></pre></td></tr></table></figure>

<h3 id="6、稀疏数组"><a href="#6、稀疏数组" class="headerlink" title="6、稀疏数组"></a>6、稀疏数组</h3><ul>
<li>当一个数组中大部分元素为0，或者为同一值的数组时，可以使用稀疏数组来保存该数组。</li>
<li>稀疏数组的处理方式是：<ul>
<li>记录数组一共有几行几列，有多少个不同值。</li>
<li>把具有不同值的元素和行列及值记录在一个小规模的数组中，从而缩小程序的规模。</li>
</ul>
</li>
<li>如下图：左边是原始数组，右边是稀疏数组。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-16/f536e2a3282130e263ee9de36e64baaa--4d2b--1622349200598.png" alt="1622349200598"></p>
<h2 id="面向对象（OOP）"><a href="#面向对象（OOP）" class="headerlink" title="面向对象（OOP）"></a>面向对象（OOP）</h2><h3 id="1、初始面向对象"><a href="#1、初始面向对象" class="headerlink" title="1、初始面向对象"></a>1、初始面向对象</h3><ul>
<li>面向过程思想<ul>
<li>步骤清晰简单，第一步做什么，第二步做什么…</li>
<li>面对过程适合处理一些较为简单的问题。</li>
</ul>
</li>
<li>面向对象思想<ul>
<li>物以类聚，分类的思维模式，思考问题首先会解决问题需要哪些分类，然后对这些分类进行单独思考。最后，才对某个分类下的细节进行面向过程的思索。</li>
<li>面向对象适合处理复杂的问题，适合处理需要多人协作的问题！</li>
</ul>
</li>
<li>对于描述复杂的事物，为了从宏观上把握、从整体上合理分析，我们需要使用面向对象的思路来分析整个系统。但是，具体到微观操作，仍然需要面向过程的思路去处理。</li>
<li>面向对象编程（ Object- Oriented Programming,OOP）</li>
<li>面向对象编程的本质就是：&#x3D;&#x3D;以类的方式组织代码，以对象的组织（封装）数据&#x3D;&#x3D;。</li>
<li>三大特征：<ul>
<li><strong>继承</strong></li>
<li><strong>封装</strong></li>
<li><strong>多态</strong></li>
</ul>
</li>
<li>从认识论角度考虑是先有对象后有类。对象，是具体的事物。类，是抽象的，是对对象的抽象。</li>
<li>从代码运行角度考虑是先有类后有对象。类是对象的模板。</li>
</ul>
<h3 id="2、方法的回顾和加深"><a href="#2、方法的回顾和加深" class="headerlink" title="2、方法的回顾和加深"></a>2、方法的回顾和加深</h3><ul>
<li><p>方法的定义</p>
<ul>
<li>修饰符</li>
<li>返回类型</li>
<li>break：跳出 switch，结束循环和 return的区别。</li>
<li>方法名：注意规范就OK，见名知意</li>
<li>参数列表：(参数类型，参数名) …</li>
<li>异常抛出：疑问，参考下文！</li>
</ul>
</li>
<li><p>方法的调用</p>
<ul>
<li>静态方法（可以直接调用）</li>
<li>非静态方法（需要new对象才能调用）</li>
<li>形参和实参</li>
<li>值传递和引用传递</li>
<li>this关键字（表示当前所在类）</li>
</ul>
</li>
</ul>
<h3 id="3、对象的创建分析"><a href="#3、对象的创建分析" class="headerlink" title="3、对象的创建分析"></a>3、对象的创建分析</h3><ul>
<li>类是一种抽象的数据类型它是对某一类事物整体描述&#x2F;定义但是并不能代表某一个具体的事物。</li>
<li>使用new关键字创建对象。</li>
<li>使用new关键字创建的时候，除了分配内存空间之外，还会给刨建好的对象进行默认的初始化以及对类中构造器的调用。</li>
<li>类中的构造器也称为构造方法，是在进行创建对象的时候必须要调用的。并且构造器有以下俩个特点：<ul>
<li>1.必须和类的名字相同；</li>
<li>2.必须没有返回类型也不能写void。</li>
</ul>
</li>
<li>构造器：<ul>
<li>1.和类名初问</li>
<li>2.没有返回值</li>
</ul>
</li>
<li>作用：<ul>
<li>1.new本质在调用构造方法；</li>
<li>2.初始化对象的值。</li>
</ul>
</li>
<li>注意：定义有参构造之后，如果想使用无参构造，显示的定义一个无参构造。</li>
</ul>
<h3 id="4、面向对象三大特性"><a href="#4、面向对象三大特性" class="headerlink" title="4、面向对象三大特性"></a>4、面向对象三大特性</h3><blockquote>
<p>封装：<strong>属性私有，get&#x2F;set</strong></p>
</blockquote>
<p>封装的作用：</p>
<ul>
<li>提高了代码的安全性，保护数据；</li>
<li>隐藏代码的实现细则；</li>
<li>统一接口；</li>
<li>系统可维护增加了。</li>
</ul>
<blockquote>
<p>继承：<strong>object类、super、方法重写</strong></p>
</blockquote>
<ul>
<li>继承的本质是对某一批类的抽象，从而实现对现实世界更好的建模。</li>
<li>extands的意思是“扩展”。子类是父类的扩展。</li>
<li><strong>JAVA中类只有单继承，没有多继承！</strong></li>
<li>继承是类和类之间的一种关系。除此之外，类和类之间的关系还有依赖、组合、聚合等。</li>
<li>继承关系的俩个类，一个为子类（派生类），一个为父类（基类）。子类继承父类使用关键字 extends来表示。</li>
<li>子类和父类之间从意义上讲应该具有”is a”的关系。</li>
<li>私有的东西无法被继承！！！</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">super注意点：</span><br><span class="line"></span><br><span class="line">1. super调用父类的构造方法，必须在构造方法的第一个</span><br><span class="line">2. super必须只能出现在子类的方法或者构造方法中！</span><br><span class="line">3. super和this不能同时调用构造方法！</span><br><span class="line"></span><br><span class="line">super VS this</span><br><span class="line">- 代表的对象不同：</span><br><span class="line">  - this：本身调用者这个对象；</span><br><span class="line">  - super：代表父类对象的应用；</span><br><span class="line">- 前提</span><br><span class="line">  - this：没有继承也可以使用；</span><br><span class="line">  - super：只能在继承条件才可以使用；</span><br><span class="line">- 构造方法</span><br><span class="line">  - this（）：本类的构造；</span><br><span class="line">  - super（）：父类的构造。</span><br></pre></td></tr></table></figure>

<ul>
<li><p>方法的重写</p>
</li>
<li><p>重写：需要有继承关系，子类重写父类的方法！</p>
</li>
</ul>
<ol>
<li>方法名必须相同;</li>
<li>参数列表列表必须相同;</li>
<li>修饰符：范围可以扩大但不能缩小: public&gt;Protected&gt;Default&gt;private</li>
<li>抛出的异常：范围，可以被缩小，但不能扩大；ClassNotFoundException–&gt; Exception(大)</li>
</ol>
<ul>
<li>重写，子类的方法和父类必要一致；方法体不同！</li>
<li>为什么需要重写：父类的功能，子类不一定需要，或者不一定满足！</li>
</ul>
<blockquote>
<p>多态</p>
</blockquote>
<ul>
<li>即同一方法可以根据发送对象的不同而采用多种不同的行为方式。</li>
<li>一个对象的实际类型是确定的，但可以指向对象的引用的类型有很多。</li>
<li>多态存在的条件：<ul>
<li>有继承关系；</li>
<li>子类重写父类方法；</li>
<li>父类引用指向子类对象。</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- 多态注意事项：</span><br><span class="line">  1. 多态是方法的多态，属性没有多态；</span><br><span class="line">  2. 父类和子类，有联系，类型转换异常！ClassCastException!</span><br><span class="line">  3. 存在条件：继承条件，方法需要重写！父类引用指向子类对象！</span><br><span class="line">     1. static 方法，属于类，它不属于实例</span><br><span class="line">     2. final 常量；</span><br><span class="line">     3. private 方法；</span><br><span class="line"></span><br><span class="line">instanceof：判断一个对象是什么类型。</span><br></pre></td></tr></table></figure>

<ul>
<li>匿名代码块<ul>
<li>在类创建对象时执行</li>
<li>在构造方法前执行，在静态代码块后执行</li>
</ul>
</li>
<li>静态代码块<ul>
<li>只会在类初次创建对象时执行</li>
<li>在构造方法、静态代码块前执行</li>
</ul>
</li>
</ul>
<h3 id="5、抽象类和接口"><a href="#5、抽象类和接口" class="headerlink" title="5、抽象类和接口"></a>5、抽象类和接口</h3><blockquote>
<p>抽象类</p>
</blockquote>
<ul>
<li>abstract修饰符可以用来修饰方法也可以修饰类如果修饰方法那么该方法就是抽象方法如果修饰类那么该类就是抽象类。</li>
<li>抽象类中可以没有抽象方法但是有抽象方法的类一定要声明为抽象类。</li>
<li>抽象类，不能使用new关键字来创建对象它是用来让子类继承的。</li>
<li>抽象方法只有方法的声明没有方法的实现它是用来让子类实现的。</li>
<li>子类继承抽象类那么就必须要实现抽象类没有实现的抽象方法否则该子类也要声明为抽象类。</li>
</ul>
<blockquote>
<p>接口</p>
</blockquote>
<ul>
<li>普通类：只有具体实现；</li>
<li>抽象类：具体实现和规范（抽象方法）都有！</li>
<li>接口：只有规范！</li>
<li>接口就是规范，定义的是一组规则，体现了现实世界中“如果你是…则必须能…”的思想。如果你是天使，则必须能飞。如果你是汽车，则必须能跑。如果你好人，则必须干掉坏人；如果你是坏人，则必须欺负好人。</li>
<li>接口的本质是契约，就像我们人间的法律一样。制定好后大家都遵守。</li>
<li>OO的精髓，是对对象的抽象，最能体现这一点的就是接口。为什么我们讨论设计模式都只针对具备了抽象能力的语言（比如c++、java、c#等），就是因为设计模式所硏究的，实际上就是如何合理的去抽象。</li>
<li><strong>声明类的关键字是 class，声明接口的关键字是 interface。</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">抽象类和接口的区别：</span><br><span class="line">- 抽象类：具体实现和规范（抽象方法）都有！</span><br><span class="line">- 接口：只有规范！</span><br></pre></td></tr></table></figure>

<h3 id="6、内部类及OOP实战"><a href="#6、内部类及OOP实战" class="headerlink" title="6、内部类及OOP实战"></a>6、内部类及OOP实战</h3><p>内部类就是在一个类的内部在定义一个类，比如，A类中定义一个B类，那么B类相对A类来说就称为内部类，而A类相对B类来说就是外部类了。</p>
<ol>
<li>成员内部类</li>
<li>静态内部类</li>
<li>局部内部类</li>
<li>匿名内部类</li>
</ol>
<p><img src="http://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-16/0305cc69a3803b657b001f20616fefc2--0f4e--image-20240916221855128.png" alt="image-20240916221855128"></p>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><h3 id="1、什么是异常"><a href="#1、什么是异常" class="headerlink" title="1、什么是异常"></a>1、什么是异常</h3><pre><code> 实际工作中，遇到的情况不可能是非常完美的。比如：你写的某个模块，用户输入不一定符合你的要求、你的程序要打开某个文件，这个文件可能不存在或者文件格式不对，你要读取数据库的数据，数据可能是空的等。我们的程序再跑着，内存或硬盘可能满了。等等。
</code></pre>
<p> &nbsp;  &nbsp; 软件程序在运行过程中，非常可能遇到刚刚提到的这些异常问题，我们叫异常，英文是：Exception，意思是例外。这些，例外情况，或者叫异常，怎么让我们写的程序做出合理的处理。而不至于程序崩溃。</p>
<p> &nbsp;  &nbsp; 异常指程序运行中出现的不期而至的各种状况如：文件找不到、网络连接失败、非法参数等。异常发生在程序运行期间它影响了正常的程序执行流程。</p>
<blockquote>
<p>要理解Java异常处理是如何工作的，需要掌握以下三种类型的异常</p>
</blockquote>
<ul>
<li>检查性异常：最具代表的检查性异常时用户错误或问题引起的异常，</li>
<li>这是程序员无法预见的例如要打开一个不存在文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略。</li>
<li>运行时异常：运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略。</li>
<li>错误<strong>ERROR</strong>：错误不是异常，而是脱离程序员控制的冋题。错误在代码中通常被忽略。例如，当栈溢出时，一个错误就发生了，它们在编译也检查不到的。</li>
</ul>
<h3 id="2、异常体系结构"><a href="#2、异常体系结构" class="headerlink" title="2、异常体系结构"></a>2、异常体系结构</h3><ul>
<li>Java把异常当为对象来处理，并定义一个基类 java. lang.Throwable作为所有异常的超类。</li>
<li>在 Java API中已经定义了许多异常类，这些异常类分为两大类，错误Error和异常 Exception。<img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/9dad4dc296387a3aa745bda588e541a0--66fb--1622843400375.png" alt="1622843400375"></li>
</ul>
<blockquote>
<p>Error</p>
</blockquote>
<ul>
<li>Error类对象由Java虚拟机生成并抛出，大多数错误与代码编写者所执行的操作无关。</li>
<li>Java虚拟机运行错误（ Virtual Machine Error），当JVM不再有继续执行操作所需的内存资源时，将出现 <strong>OutofMemory Error（OOM内存溢出）</strong>。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止。</li>
<li>还有发生在虛拟机试图执行应用时，如类定义错误（ NoClass Deffound error）、链接错误（ Linkage Error）。这些错误是不可查的，因为它们在应用程序的控制和处理能力之外，而且绝大多数是程序运行时不允许出现的状况。</li>
</ul>
<blockquote>
<p>Exception</p>
</blockquote>
<ul>
<li>在 Exception分支中有一个重要的子类 Runtime Exception（运行时异常）<ul>
<li>ArraylndexOutOfBoundsException（数组下标越界）</li>
<li>NullPointerException（空指针异常）</li>
<li>ArithmeticException（算术异常）</li>
<li>Missing Resource Exception（丢失资源）</li>
<li>ClassNotFound Exception（找不到类）等异常，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。</li>
</ul>
</li>
<li>这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生； </li>
<li>Error和 Exception的区别：Error通常是灾难性的致命的错误，是程序无法控制和处理的，当出现这些异常时，Java虛拟机（JVM）一般会选择终止线程；Exception通常情况下是可以被程序处理的，并且在程序中应该尽可能的去处理这些异常。</li>
</ul>
<h3 id="3、Java异常处理机制与处理异常"><a href="#3、Java异常处理机制与处理异常" class="headerlink" title="3、Java异常处理机制与处理异常"></a>3、Java异常处理机制与处理异常</h3><ul>
<li>抛出异常</li>
<li>捕获异常</li>
<li>异常处理五个关键字：<ul>
<li>try、catch、 finally、throw、throws</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/0a394f1331265ead6eba52441a0770fa--928b--image-20240917095443916.png" alt="image-20240917095443916"></p>
<h3 id="4、自定义异常"><a href="#4、自定义异常" class="headerlink" title="4、自定义异常"></a>4、自定义异常</h3><ul>
<li>使用Java内置的异常类可以描述在编程时岀现的大部分异常情况。除此之外，用户还可以自定义异常。用户自定义异常类，只需继承 Exception类即可。</li>
<li>在程序中使用自定义异常类，大体可分为以下几个步骤：<ol>
<li>创建自定义异常类。</li>
<li>在方法中通过 throw关键字抛出异常对象。</li>
<li>如果在当前抛出异常的方法中处理异常，可以使用try- catch语句捕获并处理；否则在方法的声明处通过 throws关键字指明要抛岀给方法调用者的异常，继续进行下一步操作。</li>
<li>在出现异常方法的调用者中捕获并处理异常。</li>
</ol>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/77ec534b38864564efad53e68734991d--162a--image-20240917100058991.png" alt="image-20240917100058991"></p>
<h3 id="5、总结"><a href="#5、总结" class="headerlink" title="5、总结"></a>5、总结</h3><ul>
<li>处理运行时异常时，采用逻辑去合理规避同时辅助 try-catch ；</li>
<li>处理在多重 catch块后面，可以加一个 catch（ Exception）来处理可能会被遗漏的异常；</li>
<li>对于不确定的代码，也可以加上try- catch，处理潜在的异常；</li>
<li>尽量去处理异常，切忌只是简单地调用 printStackTrace0去打印输出；</li>
<li>具体如何处理异常，要根据不同的业务需求和异常类型去决定；</li>
<li>尽量添加 finally！语句块去释放占用的资源。</li>
</ul>
<h2 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h2><h3 id="1、字符串相关的类"><a href="#1、字符串相关的类" class="headerlink" title="1、字符串相关的类"></a>1、字符串相关的类</h3><h4 id="1、String类的概述"><a href="#1、String类的概述" class="headerlink" title="1、String类的概述"></a>1、String类的概述</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * String:字符串，使用一对“”引起来表示。</span></span><br><span class="line"><span class="comment">     * 1.String声明为final的，不可被继承</span></span><br><span class="line"><span class="comment">     * 2.String实现了Serializable接口：表示字符串是支持序列化的。</span></span><br><span class="line"><span class="comment">     *         实现了Comparable接口：表示String可以比较大小</span></span><br><span class="line"><span class="comment">     * 3.String内部定义了final char[] value用于存储字符串数据</span></span><br><span class="line"><span class="comment">     * 4.String:代表不可变的字符序列。简称：不可变性。</span></span><br><span class="line"><span class="comment">     *      体现：1.当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值。</span></span><br><span class="line"><span class="comment">     *           2.当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。</span></span><br><span class="line"><span class="comment">     *           3.当调用String的replace()方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。</span></span><br><span class="line"><span class="comment">     * 5.通过字面量的方式（区别于new）给一个字符串赋值，此时的字符串值声明在字符串常量池中。</span></span><br><span class="line"><span class="comment">     * 6.字符串常量池中是不会存储相同内容的字符串的。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure>

<h4 id="2、理解String类的不可见性"><a href="#2、理解String类的不可见性" class="headerlink" title="2、理解String类的不可见性"></a>2、理解String类的不可见性</h4><p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/d405c3f637ebd987f0af0044618984ed--8070--image-20240917103243395.png" alt="image-20240917103243395"></p>
<h4 id="3、String不同实例化方法的对比"><a href="#3、String不同实例化方法的对比" class="headerlink" title="3、String不同实例化方法的对比"></a>3、String不同实例化方法的对比</h4><ul>
<li>String对象的创建</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//本质上this.value = new char[0];</span></span><br><span class="line"><span class="type">String</span>  <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(); </span><br><span class="line"></span><br><span class="line"><span class="comment">//this.value = original.value;</span></span><br><span class="line"><span class="type">String</span>  <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(String original); </span><br><span class="line"></span><br><span class="line"><span class="comment">//this.value = Arrays.copyOf(value, value.length);</span></span><br><span class="line"><span class="type">String</span>  <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="type">char</span>[] a);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span>  <span class="variable">s4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="type">char</span>[] a,<span class="type">int</span> startIndex,<span class="type">int</span> count);</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/f88f172d93e3c916b346a9b232fdd7e4--c081--f-011.png" alt="f-011"></p>
<p>String str1  &#x3D; “abc”;与String str2 &#x3D; new String(“abc”);的区别？</p>
<ul>
<li>字符串常量存储在字符串常量池，目的是共享</li>
<li>字符串非常量对象存储在堆中。</li>
</ul>
<h4 id="4、String不同拼接操作的对比"><a href="#4、String不同拼接操作的对比" class="headerlink" title="4、String不同拼接操作的对比"></a>4、String不同拼接操作的对比</h4><h5 id="String使用陷阱"><a href="#String使用陷阱" class="headerlink" title="String使用陷阱"></a>String使用陷阱</h5><ul>
<li><p>String s1 &#x3D; “a”; </p>
<blockquote>
<p>说明：在字符串常量池中创建了一个字面量为”a”的字符串。</p>
</blockquote>
</li>
<li><p>s1 &#x3D; s1 + “b”; </p>
<blockquote>
<p>说明：实际上原来的“a”字符串对象已经丢弃了，现在在堆空间中产生了一个字符串s1+”b”（也就是”ab”)。如果多次执行这些改变串内容的操作，会导致大量副本字符串对象存留在内存中，降低效率。如果这样的操作放到循环中，会极大影响程序的性能。</p>
</blockquote>
</li>
<li><p>String s2 &#x3D; “ab”;</p>
<blockquote>
<p>说明：直接在字符串常量池中创建一个字面量为”ab”的字符串。</p>
</blockquote>
</li>
<li><p>String s3 &#x3D; “a” + “b”;</p>
<blockquote>
<p>说明：s3指向字符串常量池中已经创建的”ab”的字符串。</p>
</blockquote>
</li>
<li><p>String s4 &#x3D; s1.intern();</p>
<blockquote>
<p>说明：堆空间的s1对象在调用intern()之后，会将常量池中已经存在的”ab”字符串赋值给s4。</p>
</blockquote>
</li>
</ul>
<h4 id="5、一道面试题"><a href="#5、一道面试题" class="headerlink" title="5、一道面试题"></a>5、一道面试题</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTest</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;good&quot;</span>);</span><br><span class="line">    <span class="type">char</span>[] ch = &#123; <span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;t&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(String str, <span class="type">char</span> ch[])</span> &#123;</span><br><span class="line">        str = <span class="string">&quot;test ok&quot;</span>;</span><br><span class="line">        ch[<span class="number">0</span>] = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">StringTest</span> <span class="variable">ex</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringTest</span>();</span><br><span class="line">        ex.change(ex.str, ex.ch);</span><br><span class="line">        System.out.println(ex.str);<span class="comment">//good</span></span><br><span class="line">        System.out.println(ex.ch);<span class="comment">//best</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6、JVM中涉及字符串的内存结构"><a href="#6、JVM中涉及字符串的内存结构" class="headerlink" title="6、JVM中涉及字符串的内存结构"></a>6、JVM中涉及字符串的内存结构</h4><p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/5f40e28ca82ae81c89448191221f92f0--83c8--f-06.png" alt="f-06"></p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/b49ce55a60f475317da97e9ee4b24e12--7a09--f-07.png" alt="f-07"></p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/8435cd3f8e1c81d70aea2e42ef381fbe--922d--f-08.png" alt="f-08"></p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/659ed8f50e7ce55076c5c296c3d69baf--6882--f-09.png" alt="f-09"></p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/4244078ff7a3b6a04d0d154bf6acc9f9--06e2--f-10.png" alt="f-10"></p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/40b729502feb4a579d2b142d353e93e8--4004--f-11.png" alt="f-11"></p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/a204f787a807f87378f7985085222d20--1859--f-12.png" alt="f-12"></p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/1b6c0ffa297bcdaceb4608573e08b701--5284--f-13.png" alt="f-13"></p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/23223b4d4c88ab5e9b5dff87bd1ea81d--4171--f-15.png" alt="f-15"></p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/bec0d1357c803bbce86c88c385b006c1--9cc2--f-16.png" alt="f-16"></p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/d8b42e2a9e4c2fab065e9a7160656ca5--acd9--f-17.png" alt="f-17"></p>
<h4 id="7、String常用的方法"><a href="#7、String常用的方法" class="headerlink" title="7、String常用的方法"></a>7、String常用的方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * int length()：返回字符串的长度：return value.length</span></span><br><span class="line"><span class="comment"> * char charAt(int index)：返回某索引处的字符return value[index]</span></span><br><span class="line"><span class="comment"> * boolean isEmpty()：判断是否是空字符串：return value.length==0</span></span><br><span class="line"><span class="comment"> * String toLowerCase()：使用默认语言环境，将String中的所有字符转换为小写</span></span><br><span class="line"><span class="comment"> * String toUpperCase()：使用默认语言环境，将String中的所有字符转换为大写</span></span><br><span class="line"><span class="comment"> * String trim()：返回字符串的副本，忽略前导空白和尾部空白</span></span><br><span class="line"><span class="comment"> * boolean equals(Object obj)：比较字符串的内容是否相同</span></span><br><span class="line"><span class="comment"> * boolean equals IgnoreCase(String anotherString)：与equals方法类似，忽略大小写</span></span><br><span class="line"><span class="comment"> * String concat(String str)：将指定字符串连接到此字符串的结尾。等价于用“+”</span></span><br><span class="line"><span class="comment"> * int compareTo(String anotherString)：比较两个字符串的大小</span></span><br><span class="line"><span class="comment"> * String substring(int beginIndex)：返回一个新的字符串，它是此字符串的从beginIndex开始截取到最后的一个子字符串。</span></span><br><span class="line"><span class="comment"> * String substring(int beginIndex,int endIndex)：返回一个新字符串，它是此字符串从beginIndex开始截取到endIndex(不包含)的一个子字符串。</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * boolean endsWith(String suffix)：测试此字符串是否以指定的后缀结束</span></span><br><span class="line"><span class="comment"> * boolean startsWith(String prefix)：测试此字符串是否以指定的前缀开始</span></span><br><span class="line"><span class="comment"> * boolean startsWith(String prefix, int toffset)：测试此字符串从指定索引开始的子字符串是否以指定前缀开始</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * boolean contains(CharSequence s)：当且仅当此字符串包含指定的 char 值序列时，返回 true</span></span><br><span class="line"><span class="comment"> * int indexOf(String str)：返回指定子字符串在此字符串中第一次出现处的索引</span></span><br><span class="line"><span class="comment"> * int indexOf(String str, int fromIndex)：返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始</span></span><br><span class="line"><span class="comment"> * int lastIndexOf(String str)：返回指定子字符串在此字符串中最右边出现处的索引</span></span><br><span class="line"><span class="comment"> * int lastIndexOf(String str, int fromIndex)：返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 注：indexOf和lastIndexOf方法如果未找到都是返回-1</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 替换：</span></span><br><span class="line"><span class="comment">    * String replace(char oldChar, char newChar)：返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的。</span></span><br><span class="line"><span class="comment">    * String replace(CharSequence target, CharSequence replacement)：使用指定的字面值替换序列替换此字符串所有匹配字面值目标序列的子字符串。</span></span><br><span class="line"><span class="comment">    * String replaceAll(String regex, String replacement)：使用给定的 replacement 替换此字符串所有匹配给定的正则表达式的子字符串。</span></span><br><span class="line"><span class="comment">    * String replaceFirst(String regex, String replacement)：使用给定的 replacement 替换此字符串匹配给定的正则表达式的第一个子字符串。</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * 匹配:</span></span><br><span class="line"><span class="comment">    * boolean matches(String regex)：告知此字符串是否匹配给定的正则表达式。</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * 切片：</span></span><br><span class="line"><span class="comment">    * String[] split(String regex)：根据给定正则表达式的匹配拆分此字符串。</span></span><br><span class="line"><span class="comment">    * String[] split(String regex, int limit)：根据匹配给定的正则表达式来拆分此字符串，最多不超过limit个，如果超过了，剩下的全部都放到最后一个元素中。</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    */</span></span><br></pre></td></tr></table></figure>

<h4 id="8-String与其他数据类型之间的转换"><a href="#8-String与其他数据类型之间的转换" class="headerlink" title="8.String与其他数据类型之间的转换"></a>8.String与其他数据类型之间的转换</h4><ul>
<li><p>String–&gt; int  使用 Integer.parseInt(str1);将字符串转换为数字</p>
</li>
<li><p>String –&gt; char[]:调用String的toCharArray()</p>
</li>
<li><p>char[] –&gt; String:调用String的构造器</p>
</li>
<li><p>String &lt;—&gt;  byte   </p>
<ul>
<li>编码：String –&gt; byte[]:调用String的getBytes()</li>
<li>解码：byte[] –&gt; String:调用String的构造器</li>
</ul>
</li>
</ul>
<h4 id="9、StringBuffer和StringBuilder的介绍"><a href="#9、StringBuffer和StringBuilder的介绍" class="headerlink" title="9、StringBuffer和StringBuilder的介绍"></a>9、StringBuffer和StringBuilder的介绍</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * String、StringBuffer、StringBuilder三者的异同？</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * String:不可变的字符序列；底层使用char[]存储</span></span><br><span class="line"><span class="comment"> * StringBuffer:可变的字符序列；线程安全的，效率低；底层使用char[]存储</span></span><br><span class="line"><span class="comment"> * StringBuilder:可变的字符序列；jdk5.0新增的，线程不安全的，效率高；底层使用char[]存储</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h4 id="10、StringBuffer的源码分析"><a href="#10、StringBuffer的源码分析" class="headerlink" title="10、StringBuffer的源码分析"></a>10、StringBuffer的源码分析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 源码分析：</span></span><br><span class="line"><span class="comment"> * String str = new String();//char[] value = new char[0];</span></span><br><span class="line"><span class="comment"> * String str1 = new String(&quot;abc&quot;);//char[] value = new char[]&#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;&#125;;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * StringBuffer sb1 = new StringBuffer();//char[] value = new char[16];底层创建了一个长度是16的数组。</span></span><br><span class="line"><span class="comment"> * System.out.println(sb1.length());//</span></span><br><span class="line"><span class="comment"> * sb1.append(&#x27;a&#x27;);//value[0] = &#x27;a&#x27;;</span></span><br><span class="line"><span class="comment"> * sb1.append(&#x27;b&#x27;);//value[1] = &#x27;b&#x27;;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * StringBuffer sb2 = new StringBuffer(&quot;abc&quot;);//char[] value = new char[&quot;abc&quot;.length() + 16];</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * //问题1.System.out.println(sb2.length());//3</span></span><br><span class="line"><span class="comment"> * //问题2.扩容问题:如果要添加的数据底层数组盛不下了，那就需要扩容底层的数组。</span></span><br><span class="line"><span class="comment"> *        默认情况下，扩容为原来容量的2倍 + 2，同时将原有数组中的元素复制到新的数组中。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 意义：开发中建议大家使用：StringBuffer(int capacity) 或 StringBuilder(int capacity)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h4 id="11、StringBuffer中的常用方法"><a href="#11、StringBuffer中的常用方法" class="headerlink" title="11、StringBuffer中的常用方法"></a>11、StringBuffer中的常用方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * StringBuffer的常用方法：</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * StringBuffer append(xxx)：提供了很多的append()方法，用于进行字符串拼接</span></span><br><span class="line"><span class="comment">     * StringBuffer delete(int start,int end)：删除指定位置的内容</span></span><br><span class="line"><span class="comment">     * StringBuffer replace(int start, int end, String str)：把[start,end)位置替换为str</span></span><br><span class="line"><span class="comment">     * StringBuffer insert(int offset, xxx)：在指定位置插入xxx</span></span><br><span class="line"><span class="comment">     * StringBuffer reverse() ：把当前字符序列逆转</span></span><br><span class="line"><span class="comment">     * public int indexOf(String str)</span></span><br><span class="line"><span class="comment">     * public String substring(int start,int end):返回一个从start开始到end索引结束的左闭右开区间的子字符串</span></span><br><span class="line"><span class="comment">     * public int length()</span></span><br><span class="line"><span class="comment">     * public char charAt(int n )</span></span><br><span class="line"><span class="comment">     * public void setCharAt(int n ,char ch)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 总结：</span></span><br><span class="line"><span class="comment">     *     增：append(xxx)</span></span><br><span class="line"><span class="comment">     *     删：delete(int start,int end)</span></span><br><span class="line"><span class="comment">     *     改：setCharAt(int n ,char ch) / replace(int start, int end, String str)</span></span><br><span class="line"><span class="comment">     *     查：charAt(int n )</span></span><br><span class="line"><span class="comment">     *     插：insert(int offset, xxx)</span></span><br><span class="line"><span class="comment">     *     长度：length();</span></span><br><span class="line"><span class="comment">     *     遍历：for() + charAt() / toString()</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure>

<p>12、String、StringBuffer、StringBuilder效率对比   —–相比String，其他两个</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对比String、StringBuffer、StringBuilder三者的效率：</span></span><br><span class="line"><span class="comment">     * 从高到低排列：StringBuilder &gt; StringBuffer &gt; String</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure>

<h3 id="2、JDK-8之前的日期时间API"><a href="#2、JDK-8之前的日期时间API" class="headerlink" title="2、JDK 8之前的日期时间API"></a>2、JDK 8之前的日期时间API</h3><p><img src="http://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/21debf6ef21a57f7c1120fe58649ef71--3936--f-18.png" alt="f-18"></p>
<h4 id="1、System类中获取时间戳的方法"><a href="#1、System类中获取时间戳的方法" class="headerlink" title="1、System类中获取时间戳的方法"></a>1、System类中获取时间戳的方法</h4><blockquote>
<p>System类提供的public static long currentTimeMillis()用来返回当前时间与1970年1月1日0时0分0秒之间以毫秒为单位的时间差。</p>
</blockquote>
<ul>
<li>此方法适于计算时间差。</li>
<li>计算世界时间的主要标准有：<ul>
<li>UTC(Coordinated Universal Time)</li>
<li>GMT(Greenwich Mean Time)</li>
<li>CST(Central Standard Time)</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//返回当前时间与1970年1月1日0时0分0秒之间以毫秒为单位的时间差。</span></span><br><span class="line">        <span class="comment">//称为时间戳</span></span><br></pre></td></tr></table></figure>

<h4 id="2、Java中两个Date类的使用"><a href="#2、Java中两个Date类的使用" class="headerlink" title="2、Java中两个Date类的使用"></a>2、Java中两个Date类的使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DateDemo</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * java.util.Date类 ---&gt; 表示特定的瞬间，精确到毫秒</span></span><br><span class="line"><span class="comment">     *            |---java.sql.Date类</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 1.两个构造器的使用</span></span><br><span class="line"><span class="comment">     *     &gt;构造器一：Date()：创建一个对应当前时间的Date对象</span></span><br><span class="line"><span class="comment">     *     &gt;构造器二：创建指定毫秒数的Date对象</span></span><br><span class="line"><span class="comment">     * 2.两个方法的使用</span></span><br><span class="line"><span class="comment">     *     &gt;toString():显示当前的年、月、日、时、分、秒</span></span><br><span class="line"><span class="comment">     *     &gt;getTime():获取当前Date对象对应的毫秒数。（时间戳）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 3. java.sql.Date对应着数据库中的日期类型的变量</span></span><br><span class="line"><span class="comment">     *     &gt;如何实例化</span></span><br><span class="line"><span class="comment">     *     &gt;如何将java.util.Date对象转换为java.sql.Date对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//构造器一：Date()：创建一个对应当前时间的Date对象</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">date1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        System.out.println(date1.toString());   <span class="comment">//Tue Sep 17 13:39:46 CST 2024</span></span><br><span class="line"></span><br><span class="line">        System.out.println(date1.getTime());    <span class="comment">//1726551586623</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//构造器二：创建指定毫秒数的Date对象</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">date2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">1726551586623L</span>);</span><br><span class="line">        System.out.println(date2.toString());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建java.sql.Date对象</span></span><br><span class="line">        java.sql.<span class="type">Date</span> <span class="variable">date3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">java</span>.sql.Date(<span class="number">35635325345L</span>);</span><br><span class="line">        System.out.println(date3);  <span class="comment">//1971-02-17</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//如何将java.util.Date对象转换为java.sql.Date对象</span></span><br><span class="line">        <span class="comment">//情况一：</span></span><br><span class="line"><span class="comment">//        Date date4 = new java.sql.Date(2343243242323L);</span></span><br><span class="line"><span class="comment">//        java.sql.Date date5 = (java.sql.Date) date4;</span></span><br><span class="line">        <span class="comment">//情况二：</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">date6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        java.sql.<span class="type">Date</span> <span class="variable">date7</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">java</span>.sql.Date(date6.getTime());</span><br><span class="line">        System.out.println(date7);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/dd405cec8a709e7320fbee9bd1727cda--f922--image-20240917134808187.png" alt="image-20240917134808187"></p>
<h4 id="3、SimpleDateFormate的使用"><a href="#3、SimpleDateFormate的使用" class="headerlink" title="3、SimpleDateFormate的使用"></a>3、SimpleDateFormate的使用</h4><ul>
<li>Date类的API不易于国际化，大部分被废弃了，java.text.SimpleDateFormat类是一个不与语言环境有关的方式来格式化和解析日期的具体类。</li>
<li>它允许进行<ul>
<li>格式化：日期—&gt;文本</li>
<li>解析：文本—&gt;日期</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/a51b3ad3b6fc096f0abfbedb5a5db10a--7906--image-20240917135507627.png" alt="image-20240917135507627"></p>
<ul>
<li>主要用于对格式日期的读取，或者对日期进行自定义格式化</li>
</ul>
<h4 id="4、Calendar日历类的使用"><a href="#4、Calendar日历类的使用" class="headerlink" title="4、Calendar日历类的使用"></a>4、Calendar日历类的使用</h4><ul>
<li>Calendar是一个抽象基类，主用用于完成日期字段之间相互操作的功能。</li>
<li>获取Calendar实例的方法<ul>
<li>使用Calendar.getInstance()方法</li>
<li>调用它的子类GregorianCalendar的构造器。</li>
</ul>
</li>
<li>一个Calendar的实例是系统时间的抽象表示，通过get(intfield)方法来取得想要的时间信息。比如YEAR、MONTH、DAY_OF_WEEK、HOUR_OF_DAY 、MINUTE、SECOND<ul>
<li>public void set(intfield,intvalue)</li>
<li>public void add(intfield,intamount)</li>
<li>public final Date getTime()</li>
<li>public final void setTime(Date date)</li>
</ul>
</li>
<li>注意:<ul>
<li>获取月份时：一月是0，二月是1，以此类推，12月是11</li>
<li>获取星期时：周日是1，周二是2，。。。。周六是7</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DateFormateDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Calendar</span> <span class="variable">calendar</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得是该月第几天</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">days</span> <span class="operator">=</span> calendar.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">        System.out.println(days); <span class="comment">// 17</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 可变性</span></span><br><span class="line">        calendar.set(Calendar.DAY_OF_MONTH, days + <span class="number">1</span>);</span><br><span class="line">        days = calendar.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">        System.out.println(days);  <span class="comment">// 18</span></span><br><span class="line"></span><br><span class="line">        calendar.add(Calendar.DAY_OF_MONTH, <span class="number">6</span>);</span><br><span class="line">        days = calendar.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">        System.out.println(days); <span class="comment">//24</span></span><br><span class="line"></span><br><span class="line">        System.out.println(calendar.getTime()); <span class="comment">//Tue Sep 24 14:29:29 CST 2024</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        calendar.setTime(date);</span><br><span class="line">        System.out.println(calendar.getTime());<span class="comment">// Tue Sep 17 14:29:29 CST 2024</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、JDK8中日期API的介绍"><a href="#3、JDK8中日期API的介绍" class="headerlink" title="3、JDK8中日期API的介绍"></a>3、JDK8中日期API的介绍</h3><ul>
<li>新日期时间API出现的背景</li>
</ul>
<blockquote>
<p>如果我们可以跟别人说：“我们在1502643933071见面，别晚了！”那么就再简单不过了。但是我们希望时间与昼夜和四季有关，于是事情就变复杂了。JDK 1.0中包含了一个java.util.Date类，但是它的大多数方法已经在JDK 1.1引入Calendar类之后被弃用了。而Calendar并不比Date好多少。它们面临的问题是：</p>
<blockquote>
<p>可变性：像日期和时间这样的类应该是不可变的。</p>
</blockquote>
<blockquote>
<p>偏移性：Date中的年份是从1900开始的，而月份都从0开始。</p>
</blockquote>
<blockquote>
<p>格式化：格式化只对Date有用，Calendar则不行。</p>
</blockquote>
<blockquote>
<p>此外，它们也不是线程安全的；不能处理闰秒等。</p>
</blockquote>
<p>总结：对日期和时间的操作一直是Java程序员最痛苦的地方之一。</p>
</blockquote>
<ul>
<li>Java 8 吸收了Joda-Time 的精华，以一个新的开始为Java 创建优秀的API。新的java.time 中包含了所有关于<strong>本地日期（LocalDate）、本地时间（LocalTime）、本地日期时间（LocalDateTime）、时区（ZonedDateTime）和持续时间（Duration）的类</strong>。历史悠久的Date 类新增了toInstant() 方法，用于把Date 转换成新的表示形式。这些新增的本地化时间日期API 大大简化了日期时间和本地化的管理。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java.time–包含值对象的基础包</span><br><span class="line">java.time.chrono–提供对不同的日历系统的访问java.time.format–格式化和解析时间和日期java.time.temporal–包括底层框架和扩展特性java.time.zone–包含时区支持的类</span><br><span class="line"></span><br><span class="line">说明：大多数开发者只会用到基础包和format包，也可能会用到temporal包。因此，尽管有68个新的公开类型，大多数开发者，大概将只会用到其中的三分之一。</span><br></pre></td></tr></table></figure>

<h4 id="1-LocalDate、LocalTime、LocalDateTime的使用"><a href="#1-LocalDate、LocalTime、LocalDateTime的使用" class="headerlink" title="1.LocalDate、LocalTime、LocalDateTime的使用"></a>1.LocalDate、LocalTime、LocalDateTime的使用</h4><ul>
<li><p>LocalDate、LocalTime、LocalDateTime 类是其中较重要的几个类，它们的实例是<strong>不可变的对象</strong>，分别表示使用ISO-8601日历系统的日期、时间、日期和时间。它们提供了简单的本地日期或时间，并不包含当前的时间信息，也不包含与时区相关的信息。</p>
<ul>
<li>LocalDate代表IOS格式（yyyy-MM-dd）的日期,可以存储生日、纪念日等日期。</li>
<li>LocalTime表示一个时间，而不是日期。</li>
<li>LocalDateTime是用来表示日期和时间的，<strong>这是一个最常用的类之一</strong>。</li>
</ul>
</li>
<li><p>注：ISO-8601日历系统是国际标准化组织制定的现代公民的日期和时间的表示法，也就是公历。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.LocalDate;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalTime;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DateFormate8</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//now():获取当前的日期、时间、日期+时间</span></span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">localDate</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line">        <span class="type">LocalTime</span> <span class="variable">localTime</span> <span class="operator">=</span> LocalTime.now();</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line"></span><br><span class="line">        System.out.println(localDate); <span class="comment">//2024-09-17</span></span><br><span class="line">        System.out.println(localTime);<span class="comment">//14:59:25.963644900</span></span><br><span class="line">        System.out.println(localDateTime);<span class="comment">//2024-09-17T14:59:25.963644900</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//of():设置指定的年、月、日、时、分、秒。没有偏移量</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">localDateTime1</span> <span class="operator">=</span> LocalDateTime.of(<span class="number">2024</span>, <span class="number">12</span>, <span class="number">6</span>, <span class="number">13</span>, <span class="number">25</span>, <span class="number">52</span>);</span><br><span class="line">        System.out.println(localDateTime1); <span class="comment">//2024-12-06T13:25:52</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//getXxx()：获取相关的属性</span></span><br><span class="line">        System.out.println(localDateTime.getDayOfMonth()); <span class="comment">//17</span></span><br><span class="line">        System.out.println(localDateTime.getDayOfWeek());<span class="comment">//TUESDAY</span></span><br><span class="line">        System.out.println(localDateTime.getMonth());<span class="comment">//SEPTEMBER</span></span><br><span class="line">        System.out.println(localDateTime.getMonthValue());<span class="comment">//9</span></span><br><span class="line">        System.out.println(localDateTime.getMinute());<span class="comment">//1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 体现不可变性</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">localDateTime2</span> <span class="operator">=</span> localDateTime.withDayOfMonth(<span class="number">23</span>);</span><br><span class="line">        System.out.println(localDateTime); <span class="comment">//2024-09-17T15:03:22.654453100</span></span><br><span class="line">        System.out.println(localDateTime2);<span class="comment">//2024-09-23T15:03:22.654453100</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/036c79ac6d7da45dda9da1226bf8facd--eb96--01.png" alt="01"></p>
<h4 id="2、Instant类的使用"><a href="#2、Instant类的使用" class="headerlink" title="2、Instant类的使用"></a>2、Instant类的使用</h4><ul>
<li>Instant：时间线上的一个瞬时点。这可能被用来记录应用程序中的事件时间戳。</li>
<li>在处理时间和日期的时候，我们通常会想到年,月,日,时,分,秒。然而，这只是时间的一个模型，是面向人类的。第二种通用模型是面向机器的，或者说是连续的。在此模型中，时间线中的一个点表示为一个很大的数，这有利于计算机处理。在UNIX中，这个数从1970年开始，以秒为的单位；同样的，在Java中，也是从1970年开始，但以毫秒为单位。</li>
<li>java.time包通过值类型Instant提供机器视图，不提供处理人类意义上的时间单位。Instant表示时间线上的一点，而不需要任何上下文信息，例如，时区。概念上讲，它只是简单的表示自1970年1月1日0时0分0秒（UTC）开始的秒数。因为java.time包是基于纳秒计算的，所以Instant的精度可以达到纳秒级。</li>
<li>(1 ns &#x3D; 10-9s)   1秒&#x3D; 1000毫秒&#x3D;10^6微秒&#x3D;10^9纳秒</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/4a960f7e7bfc8b68f5cb42eaebbc0064--95a7--02.png" alt="02"></p>
<ul>
<li>时间戳是指格林威治时间1970年01月01日00时00分00秒(北京时间1970年01月01日08时00分00秒)起至现在的总秒数。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/512c704c1691e6d466a59c9e120b99ba--9137--03.png" alt="03"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.Instant;</span><br><span class="line"><span class="keyword">import</span> java.time.OffsetDateTime;</span><br><span class="line"><span class="keyword">import</span> java.time.ZoneOffset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InstantDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//now():获取本初子午线对应的标准时间</span></span><br><span class="line">        <span class="type">Instant</span> <span class="variable">instant</span> <span class="operator">=</span> Instant.now();</span><br><span class="line">        System.out.println(instant);<span class="comment">//2024-09-17T07:10:05.668448200Z</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加时间的偏移量</span></span><br><span class="line">        <span class="type">OffsetDateTime</span> <span class="variable">offsetDateTime</span> <span class="operator">=</span> instant.atOffset(ZoneOffset.ofHours(<span class="number">8</span>));<span class="comment">//东八区</span></span><br><span class="line">        System.out.println(offsetDateTime); <span class="comment">//2024-09-17T15:10:05.668448200+08:00</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//toEpochMilli():获取自1970年1月1日0时0分0秒（UTC）开始的毫秒数  ---&gt; Date类的getTime()</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">milli</span> <span class="operator">=</span> instant.toEpochMilli();</span><br><span class="line">        System.out.println(milli);  <span class="comment">//1726557005668</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//ofEpochMilli():通过给定的毫秒数，获取Instant实例  --&gt;Date(long millis)</span></span><br><span class="line">        <span class="type">Instant</span> <span class="variable">instant1</span> <span class="operator">=</span> Instant.ofEpochMilli(<span class="number">1550475314878L</span>);</span><br><span class="line">        System.out.println(instant1);   <span class="comment">//2019-02-18T07:35:14.878Z</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、Java比较器"><a href="#4、Java比较器" class="headerlink" title="4、Java比较器"></a>4、Java比较器</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h4><blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 一、说明：Java中的对象，正常情况下，只能进行比较：==  或  != 。不能使用 &gt; 或 &lt; 的</span></span><br><span class="line"><span class="comment">*          但是在开发场景中，我们需要对多个对象进行排序，言外之意，就需要比较对象的大小。</span></span><br><span class="line"><span class="comment">*          如何实现？使用两个接口中的任何一个：Comparable 或 Comparator</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><p>Java实现对象排序的方式有两种：</p>
<ul>
<li>自然排序：java.lang.Comparable</li>
<li>定制排序：java.util.Comparator</li>
</ul>
</li>
<li><p>Comparable自然排序举例</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompareTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">          Comparable接口的使用举例：  自然排序</span></span><br><span class="line"><span class="comment">          1.像String、包装类等实现了Comparable接口，重写了compareTo(obj)方法，给出了比较两个对象大小的方式。</span></span><br><span class="line"><span class="comment">          2.像String、包装类重写compareTo()方法以后，进行了从小到大的排列</span></span><br><span class="line"><span class="comment">          3. 重写compareTo(obj)的规则：</span></span><br><span class="line"><span class="comment">             如果当前对象this大于形参对象obj，则返回正整数，</span></span><br><span class="line"><span class="comment">             如果当前对象this小于形参对象obj，则返回负整数，</span></span><br><span class="line"><span class="comment">             如果当前对象this等于形参对象obj，则返回零。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        String[] arr = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;AA&quot;</span>,<span class="string">&quot;CC&quot;</span>,<span class="string">&quot;KK&quot;</span>,<span class="string">&quot;MM&quot;</span>,<span class="string">&quot;GG&quot;</span>,<span class="string">&quot;JJ&quot;</span>,<span class="string">&quot;DD&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr)); <span class="comment">//[AA, CC, DD, GG, JJ, KK, MM]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、自定义类实现Comparable自然排序"><a href="#2、自定义类实现Comparable自然排序" class="headerlink" title="2、自定义类实现Comparable自然排序"></a>2、自定义类实现Comparable自然排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompareTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 4.对于自定义类来说，如果需要排序，我们可以让自定义类实现Comparable接口，重写compareTo(obj)方法。</span></span><br><span class="line"><span class="comment">     *   在compareTo(obj)方法中指明如何排序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        test2(); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">        Goods[] arr = <span class="keyword">new</span> <span class="title class_">Goods</span>[<span class="number">5</span>];</span><br><span class="line">        arr[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;lenovoMouse&quot;</span>,<span class="number">34</span>);</span><br><span class="line">        arr[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;dellMouse&quot;</span>,<span class="number">43</span>);</span><br><span class="line">        arr[<span class="number">2</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;xiaomiMouse&quot;</span>,<span class="number">12</span>);</span><br><span class="line">        arr[<span class="number">3</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;huaweiMouse&quot;</span>,<span class="number">65</span>);</span><br><span class="line">        arr[<span class="number">4</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;microsoftMouse&quot;</span>,<span class="number">43</span>);</span><br><span class="line"></span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line"></span><br><span class="line">        System.out.println(Arrays.toString(arr));  <span class="comment">//[Goods&#123;name=&#x27;xiaomiMouse&#x27;, price=12.0&#125;, Goods&#123;name=&#x27;lenovoMouse&#x27;, price=34.0&#125;, Goods&#123;name=&#x27;microsoftMouse&#x27;, price=43.0&#125;, Goods&#123;name=&#x27;dellMouse&#x27;, price=43.0&#125;, Goods&#123;name=&#x27;huaweiMouse&#x27;, price=65.0&#125;]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Goods类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Goods</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> price;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Goods</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Goods</span><span class="params">(String name, <span class="type">double</span> price)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getPrice</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPrice</span><span class="params">(<span class="type">double</span> price)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Goods&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, price=&quot;</span> + price +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指明商品比较大小的方式:按照价格从低到高排序,再按照产品名称从高到低排序</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object o)</span> &#123;</span><br><span class="line"><span class="comment">//        System.out.println(&quot;**************&quot;);</span></span><br><span class="line">        <span class="keyword">if</span>(o <span class="keyword">instanceof</span> Goods goods)&#123;</span><br><span class="line">            <span class="comment">//方式一：</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">this</span>.price &gt; goods.price)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">this</span>.price &lt; goods.price)&#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//                return 0;</span></span><br><span class="line">                <span class="keyword">return</span> -<span class="built_in">this</span>.name.compareTo(goods.name);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//方式二：</span></span><br><span class="line"><span class="comment">//           return Double.compare(this.price,goods.price);</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        return 0;</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;传入的数据类型不一致！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="3、使用Comparator实现定制排序"><a href="#3、使用Comparator实现定制排序" class="headerlink" title="3、使用Comparator实现定制排序"></a>3、使用Comparator实现定制排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompareTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Comparator接口的使用：定制排序</span></span><br><span class="line"><span class="comment">     *     1.背景：</span></span><br><span class="line"><span class="comment">     *     当元素的类型没有实现java.lang.Comparable接口而又不方便修改代码，</span></span><br><span class="line"><span class="comment">     *     或者实现了java.lang.Comparable接口的排序规则不适合当前的操作，</span></span><br><span class="line"><span class="comment">     *     那么可以考虑使用 Comparator 的对象来排序</span></span><br><span class="line"><span class="comment">     *     2.重写compare(Object o1,Object o2)方法，比较o1和o2的大小：</span></span><br><span class="line"><span class="comment">     *     如果方法返回正整数，则表示o1大于o2；</span></span><br><span class="line"><span class="comment">     *     如果返回0，表示相等；</span></span><br><span class="line"><span class="comment">     *     返回负整数，表示o1小于o2。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">        String[] arr = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;AA&quot;</span>,<span class="string">&quot;CC&quot;</span>,<span class="string">&quot;KK&quot;</span>,<span class="string">&quot;MM&quot;</span>,<span class="string">&quot;GG&quot;</span>,<span class="string">&quot;JJ&quot;</span>,<span class="string">&quot;DD&quot;</span>&#125;;</span><br><span class="line">        Arrays.sort(arr,<span class="keyword">new</span> <span class="title class_">Comparator</span>()&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//按照字符串从大到小的顺序排列</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(o1 <span class="keyword">instanceof</span> String &amp;&amp; o2 <span class="keyword">instanceof</span>  String)&#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> (String) o1;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> (String) o2;</span><br><span class="line">                    <span class="keyword">return</span> -s1.compareTo(s2);</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">//                return 0;</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;输入的数据类型不一致&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span>&#123;</span><br><span class="line">        Goods[] arr = <span class="keyword">new</span> <span class="title class_">Goods</span>[<span class="number">6</span>];</span><br><span class="line">        arr[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;lenovoMouse&quot;</span>,<span class="number">34</span>);</span><br><span class="line">        arr[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;dellMouse&quot;</span>,<span class="number">43</span>);</span><br><span class="line">        arr[<span class="number">2</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;xiaomiMouse&quot;</span>,<span class="number">12</span>);</span><br><span class="line">        arr[<span class="number">3</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;huaweiMouse&quot;</span>,<span class="number">65</span>);</span><br><span class="line">        arr[<span class="number">4</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;huaweiMouse&quot;</span>,<span class="number">224</span>);</span><br><span class="line">        arr[<span class="number">5</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;microsoftMouse&quot;</span>,<span class="number">43</span>);</span><br><span class="line"></span><br><span class="line">        Arrays.sort(arr, <span class="keyword">new</span> <span class="title class_">Comparator</span>() &#123;</span><br><span class="line">            <span class="comment">//指明商品比较大小的方式:按照产品名称从低到高排序,再按照价格从高到低排序</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(o1 <span class="keyword">instanceof</span> Goods &amp;&amp; o2 <span class="keyword">instanceof</span> Goods)&#123;</span><br><span class="line">                    <span class="type">Goods</span> <span class="variable">g1</span> <span class="operator">=</span> (Goods)o1;</span><br><span class="line">                    <span class="type">Goods</span> <span class="variable">g2</span> <span class="operator">=</span> (Goods)o2;</span><br><span class="line">                    <span class="keyword">if</span>(g1.getName().equals(g2.getName()))&#123;</span><br><span class="line">                        <span class="keyword">return</span> -Double.compare(g1.getPrice(),g2.getPrice());</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> g1.getName().compareTo(g2.getName());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;输入的数据类型不一致&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>Comparable接口与Comparator的使用的对比</strong>：<ul>
<li>Comparable接口的方式一旦一定，保证Comparable接口实现类的对象在任何位置都可以比较大小。</li>
<li>Comparator接口属于临时性的比较。</li>
</ul>
</li>
</ul>
<h3 id="5、System类、Math类、BigInteger与BigDecimal"><a href="#5、System类、Math类、BigInteger与BigDecimal" class="headerlink" title="5、System类、Math类、BigInteger与BigDecimal"></a>5、System类、Math类、BigInteger与BigDecimal</h3><h4 id="1、System类"><a href="#1、System类" class="headerlink" title="1、System类"></a>1、System类</h4><ul>
<li><p>System类代表系统，系统级的很多属性和控制方法都放置在该类的内部。该类位于java.lang包。</p>
</li>
<li><p>由于该类的构造器是private的，所以无法创建该类的对象，也就是无法实例化该类。其内部的成员变量和成员方法都是static的，所以也可以很方便的进行调用。</p>
</li>
<li><p>成员变量</p>
<ul>
<li>System类内部包含in、out和err三个成员变量，分别代表标准输入流(键盘输入)，标准输出流(显示器)和标准错误输出流(显示器)。</li>
</ul>
</li>
<li><p>成员方法</p>
<ul>
<li><p>native long currentTimeMillis()：</p>
<blockquote>
<p>该方法的作用是返回当前的计算机时间，时间的表达格式为当前计算机时间和GMT时间(格林威治时间)1970年1月1号0时0分0秒所差的毫秒数。</p>
</blockquote>
</li>
<li><p>void exit(int status)：</p>
<blockquote>
<p>该方法的作用是退出程序。其中status的值为0代表正常退出，非零代表异常退出。使用该方法可以在图形界面编程中实现程序的退出功能等。</p>
</blockquote>
</li>
<li><p>void gc()：</p>
<blockquote>
<p>该方法的作用是请求系统进行垃圾回收。至于系统是否立刻回收，则取决于系统中垃圾回收算法的实现以及系统执行时的情况。String </p>
</blockquote>
</li>
<li><p>getProperty(String key)：</p>
<blockquote>
<p>该方法的作用是获得系统中属性名为key的属性对应的值。系统中常见的属性名以及属性的作用如下表所示：</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/73bb56682e583202b5dce7dadb23a2d0--3b71--06.png" alt="06"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SystemDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">javaVersion</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;java.version&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;java的version:&quot;</span> + javaVersion);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">javaHome</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;java.home&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;java的home:&quot;</span> + javaHome);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">osName</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;os.name&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;os的name:&quot;</span> + osName);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">osVersion</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;os.version&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;os的version:&quot;</span> + osVersion);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">userName</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;user.name&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;user的name:&quot;</span> + userName);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">userHome</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;user.home&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;user的home:&quot;</span> + userHome);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">userDir</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;user.dir&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;user的dir:&quot;</span> + userDir);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*        java的version:22.0.2</span></span><br><span class="line"><span class="comment">        java的home:C:\Users\ASUS\.jdks\openjdk-22.0.2</span></span><br><span class="line"><span class="comment">        os的name:Windows 11</span></span><br><span class="line"><span class="comment">        os的version:10.0</span></span><br><span class="line"><span class="comment">        user的name:ASUS</span></span><br><span class="line"><span class="comment">        user的home:C:\Users\ASUS</span></span><br><span class="line"><span class="comment">        user的dir:E:\JavaWeb\Demo</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、Math类"><a href="#2、Math类" class="headerlink" title="2、Math类"></a>2、Math类</h4><ul>
<li>这个在之前也简单使用过的</li>
</ul>
<blockquote>
<p>java.lang.Math提供了一系列静态方法用于科学计算。其方法的参数和返回值类型一般为double型。</p>
</blockquote>
<blockquote>
<p>abs     绝对值</p>
<p>acos,asin,atan,cos,sin,tan  三角函数</p>
<p>sqrt     平方根</p>
<p>pow(double a,doble b)     a的b次幂</p>
<p>log    自然对数</p>
<p>exp    e为底指数</p>
<p>max(double a,double b)</p>
<p>min(double a,double b)</p>
<p>random()      返回0.0到1.0的随机数</p>
<p>long round(double a)     double型数据a转换为long型（四舍五入）</p>
<p>toDegrees(double angrad)     弧度—&gt;角度</p>
<p>toRadians(double angdeg)     角度—&gt;弧度</p>
</blockquote>
<h4 id="3、BigInteger与BigDecimal"><a href="#3、BigInteger与BigDecimal" class="headerlink" title="3、BigInteger与BigDecimal"></a>3、BigInteger与BigDecimal</h4><ul>
<li><p>Integer类作为int的包装类，能存储的最大整型值为2^31 -1，Long类也是有限的，最大为2^63 -1。如果要表示再大的整数，不管是基本数据类型还是他们的包装类都无能为力，更不用说进行运算了。</p>
</li>
<li><p>java.math包的BigInteger可以表示不可变的任意精度的整数。BigInteger 提供所有Java 的基本整数操作符的对应物，并提供java.lang.Math 的所有相关方法。另外，BigInteger 还提供以下运算：模算术、GCD 计算、质数测试、素数生成、位操作以及一些其他操作。</p>
</li>
<li><p>构造器</p>
<ul>
<li>BigInteger(String val)：根据字符串构建BigInteger对象</li>
</ul>
</li>
<li><p>常用方法</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/42ffa72f12011be3b40c0802081b0816--02c2--07.png" alt="07"></p>
<ul>
<li>一般的Float类和Double类可以用来做科学计算或工程计算，但<strong>在商业计算中，要求数字精度比较高，故用到java.math.BigDecimal类</strong>。</li>
<li>BigDecimal类支持不可变的、任意精度的有符号十进制定点数。</li>
<li>构造器<ul>
<li>public BigDecimal(double val)</li>
<li>public BigDecimal(String val)</li>
</ul>
</li>
<li>常用方法<ul>
<li>public BigDecimal add(BigDecimal augend)</li>
<li>public BigDecimal subtract(BigDecimal subtrahend)</li>
<li>public BigDecimal multiply(BigDecimal multiplicand)</li>
<li>public BigDecimal divide(BigDecimal divisor, int scale, int roundingMode)</li>
</ul>
</li>
</ul>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="1、Java集合框架概述"><a href="#1、Java集合框架概述" class="headerlink" title="1、Java集合框架概述"></a>1、Java集合框架概述</h3><h4 id="1、集合框架和数组的对比及概述"><a href="#1、集合框架和数组的对比及概述" class="headerlink" title="1、集合框架和数组的对比及概述"></a>1、集合框架和数组的对比及概述</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一、集合的框架</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1.集合、数组都是对多个数据进行存储操作的结构，简称Java容器。</span></span><br><span class="line"><span class="comment"> *   说明；此时的存储，主要是指能存层面的存储，不涉及到持久化的存储（.txt,.jpg,.avi,数据库中）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 2.1数组在存储多个数据封面的特点：</span></span><br><span class="line"><span class="comment"> *      》一旦初始化以后，它的长度就确定了。</span></span><br><span class="line"><span class="comment"> *      》数组一旦定义好，它的数据类型也就确定了。我们就只能操作指定类型的数据了。</span></span><br><span class="line"><span class="comment"> *      比如：String[] arr;int[] str;</span></span><br><span class="line"><span class="comment"> * 2.2数组在存储多个数据方面的特点：</span></span><br><span class="line"><span class="comment"> *      》一旦初始化以后，其长度就不可修改。</span></span><br><span class="line"><span class="comment"> *      》数组中提供的方法非常有限，对于添加、删除、插入数据等操作，非常不便，同时效率不高。</span></span><br><span class="line"><span class="comment"> *      》获取数组中实际元素的个数的需求，数组没有现成的属性或方法可用</span></span><br><span class="line"><span class="comment"> *      》数组存储数据的特点：有序、可重复。对于无序、不可重复的需求，不能满足。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>集合的使用场景</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-26/689411ff1ee20d9f4676a6f37a92f14e--e1a9--image-20240926103359953.png" alt="image-20240926103359953"></p>
</li>
</ul>
<h4 id="2、集合框架涉及到的API"><a href="#2、集合框架涉及到的API" class="headerlink" title="2、集合框架涉及到的API"></a>2、集合框架涉及到的API</h4><ul>
<li><p>Java 集合可分为Collection 和Map 两种体系</p>
<ul>
<li>Collection接口：单列数据，定义了存取一组对象的方法的集合<ul>
<li>List：元素有序、可重复的集合</li>
<li>Set：元素无序、不可重复的集合</li>
</ul>
</li>
<li>Map接口：双列数据，保存具有映射关系“key-value对”的集合</li>
</ul>
</li>
<li><p><strong>Collection接口继承树</strong></p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-26/e5c5d1664e576887561e0b5d345399a0--f2ed--image-20240926103900334.png" alt="image-20240926103900334"></p>
<ul>
<li><strong>Map接口继承树</strong></li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-26/49f74611c39b83069b6b4b3b4fc70fe0--4580--image-20240926103921057.png" alt="image-20240926103921057"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 二、集合框架</span></span><br><span class="line"><span class="comment"> *      &amp;---Collection接口：单列集合，用来存储一个一个的对象</span></span><br><span class="line"><span class="comment"> *          &amp;---List接口：存储有序的、可重复的数据。  --&gt;“动态”数组</span></span><br><span class="line"><span class="comment"> *              &amp;---ArrayList、LinkedList、Vector</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *          &amp;---Set接口：存储无序的、不可重复的数据   --&gt;高中讲的“集合”</span></span><br><span class="line"><span class="comment"> *              &amp;---HashSet、LinkedHashSet、TreeSet</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      &amp;---Map接口：双列集合，用来存储一对(key - value)一对的数据   --&gt;高中函数：y = f(x)</span></span><br><span class="line"><span class="comment"> *          &amp;---HashMap、LinkedHashMap、TreeMap、Hashtable、Properties</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h3 id="2、Collection接口方法"><a href="#2、Collection接口方法" class="headerlink" title="2、Collection接口方法"></a>2、Collection接口方法</h3><ul>
<li>Collection 接口是List、Set 和Queue 接口的父接口，该接口里定义的方法既可用于操作Set 集合，也可用于操作List 和Queue 集合。</li>
<li>JDK不提供此接口的任何直接实现，而是提供更具体的子接口(如：Set和List)实现。</li>
<li>在Java5 之前，Java 集合会丢失容器中所有对象的数据类型，把所有对象都当成Object 类型处理；从JDK 5.0 增加了<strong>泛型</strong>以后，Java 集合可以记住容器中对象的数据类型。</li>
</ul>
<h4 id="Collection接口中的常用方法"><a href="#Collection接口中的常用方法" class="headerlink" title="Collection接口中的常用方法"></a>Collection接口中的常用方法</h4><ol>
<li>添加<ul>
<li>add(Objectobj)</li>
<li>addAll(Collectioncoll)</li>
</ul>
</li>
<li>获取有效元素的个数<ul>
<li>intsize()</li>
</ul>
</li>
<li>清空集合<ul>
<li>voidclear()</li>
</ul>
</li>
<li>是否是空集合<ul>
<li>boolean isEmpty()</li>
</ul>
</li>
<li>是否包含某个元素<ul>
<li>booleancontains(Objectobj)：是通过元素的equals方法来判断是否是同一个对象</li>
<li>booleancontainsAll(Collectionc)：也是调用元素的equals方法来比较的。拿两个集合的元素挨个比较。</li>
</ul>
</li>
<li>删除<ul>
<li>boolean remove(Object obj) ：通过元素的equals方法判断是否是要删除的那个元素。只会删除找到的第一个元素</li>
<li>boolean removeAll(Collection coll)：取当前集合的差集</li>
</ul>
</li>
<li>取两个集合的交集<ul>
<li>boolean retainAll(Collection c)：把交集的结果存在当前集合中，不影响c</li>
</ul>
</li>
<li>集合是否相等<ul>
<li>boolean equals(Object obj)</li>
</ul>
</li>
<li>转成对象数组<ul>
<li>Object[] toArray()</li>
</ul>
</li>
<li>获取集合对象的哈希值<ul>
<li>hashCode()</li>
</ul>
</li>
<li>遍历<ul>
<li>iterator()：返回迭代器对象，用于集合遍历</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Collection</span> <span class="variable">collection</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        collection.add(<span class="number">1</span>);</span><br><span class="line">        collection.add(<span class="number">2</span>);</span><br><span class="line">        collection.add(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(collection); <span class="comment">//[1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-Iterator迭代器接口"><a href="#3-Iterator迭代器接口" class="headerlink" title="3.Iterator迭代器接口"></a>3.Iterator迭代器接口</h3><ul>
<li>Iterator对象称为迭代器(设计模式的一种)，主要用于遍历Collection 集合中的元素。</li>
<li>GOF给迭代器模式的定义为：提供一种方法访问一个容器(container)对象中各个元素，而又不需暴露该对象的内部细节。<strong>迭代器模式，就是为容器而生</strong>。类似于“公交车上的售票员”、“火车上的乘务员”、“空姐”。</li>
<li>Collection接口继承了java.lang.Iterable接口，该接口有一个iterator()方法，那么所有实现了Collection接口的集合类都有一个iterator()方法，用以返回一个实现了Iterator接口的对象。</li>
<li><strong>Iterator 仅用于遍历集合</strong>，Iterator本身并不提供承装对象的能力。如果需要创建Iterator 对象，则必须有一个被迭代的集合。</li>
<li><strong>集合对象每次调用iterator()方法都得到一个全新的迭代器对象</strong>，默认游标都在集合的第一个元素之前。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IteratorTest</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Collection</span> <span class="variable">coll</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        coll.add(<span class="number">123</span>);</span><br><span class="line">        coll.add(<span class="number">456</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;Jerry&quot;</span>);</span><br><span class="line">        coll.add(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Tom&quot;</span>));</span><br><span class="line">        coll.add(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> coll.iterator();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//方式一：</span></span><br><span class="line"><span class="comment">//        System.out.println(iterator.next());</span></span><br><span class="line"><span class="comment">//        System.out.println(iterator.next());</span></span><br><span class="line"><span class="comment">//        System.out.println(iterator.next());</span></span><br><span class="line"><span class="comment">//        System.out.println(iterator.next());</span></span><br><span class="line"><span class="comment">//        System.out.println(iterator.next());</span></span><br><span class="line"><span class="comment">//        //报异常：NoSuchElementException</span></span><br><span class="line"><span class="comment">//        //因为：在调用it.next()方法之前必须要调用it.hasNext()进行检测。若不调用，且下一条记录无效，直接调用it.next()会抛出NoSuchElementException异常。</span></span><br><span class="line"><span class="comment">//        System.out.println(iterator.next());</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//方式二：不推荐</span></span><br><span class="line"><span class="comment">//        for(int i = 0;i &lt; coll.size();i++)&#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(iterator.next());</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//方式三：推荐</span></span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="迭代器Iterator的执行原理"><a href="#迭代器Iterator的执行原理" class="headerlink" title="迭代器Iterator的执行原理"></a>迭代器Iterator的执行原理</h4><p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-26/2e1a01fbd76a3b98b8060678b8c652da--578a--image-20240926113011579.png" alt="image-20240926113011579"></p>
<h4 id="Iterator迭代器remove-的使用"><a href="#Iterator迭代器remove-的使用" class="headerlink" title="Iterator迭代器remove()的使用"></a>Iterator迭代器remove()的使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 集合元素的遍历操作，使用迭代器Iterator接口</span></span><br><span class="line"><span class="comment"> * 1.内部的方法：hasNext()和 next()</span></span><br><span class="line"><span class="comment"> * 2.集合对象每次调用iterator()方法都得到一个全新的迭代器对象，默认游标都在集合的第一个元素之前。</span></span><br><span class="line"><span class="comment"> * 3.内部定义了remove(),可以在遍历的时候，删除集合中的元素。此方法不同于集合直接调用remove()</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> subei</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-05-12 12:22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IteratorTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//测试Iterator中的remove()方法</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Collection</span> <span class="variable">coll</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        coll.add(<span class="number">123</span>);</span><br><span class="line">        coll.add(<span class="number">456</span>);</span><br><span class="line">        coll.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Jerry&quot;</span>,<span class="number">20</span>));</span><br><span class="line">        coll.add(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Tom&quot;</span>));</span><br><span class="line">        coll.add(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//删除集合中”Tom”</span></span><br><span class="line">        <span class="comment">//如果还未调用next()或在上一次调用 next 方法之后已经调用了 remove 方法，</span></span><br><span class="line">        <span class="comment">// 再调用remove都会报IllegalStateException。</span></span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> coll.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line"><span class="comment">//            iterator.remove();</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;Tom&quot;</span>.equals(obj))&#123;</span><br><span class="line">                iterator.remove();</span><br><span class="line"><span class="comment">//                iterator.remove();                </span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历集合</span></span><br><span class="line">        iterator = coll.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>注意：<ul>
<li>Iterator可以删除集合的元素，但是是遍历过程中通过迭代器对象的remove方法，不是集合对象的remove方法。</li>
<li><strong>如果还未调用next()或在上一次调用next方法之后已经调用了remove方法，再调用remove都会报IllegalStateException</strong>。</li>
</ul>
</li>
</ul>
<h4 id="新特性foreach循环遍历集合或数组"><a href="#新特性foreach循环遍历集合或数组" class="headerlink" title="新特性foreach循环遍历集合或数组"></a>新特性foreach循环遍历集合或数组</h4><ul>
<li>Java 5.0 提供了foreach循环迭代访问Collection和数组。</li>
<li>遍历操作不需获取Collection或数组的长度，无需使用索引访问元素。</li>
<li><strong>遍历集合的底层调用Iterator完成操作。</strong></li>
<li>foreach还可以用来遍历数组。</li>
</ul>
<h3 id="4、Collection子接口之一：List接口"><a href="#4、Collection子接口之一：List接口" class="headerlink" title="4、Collection子接口之一：List接口"></a>4、Collection子接口之一：List接口</h3><h3 id="4-Collection子接口之一：List接口"><a href="#4-Collection子接口之一：List接口" class="headerlink" title="4.Collection子接口之一：List接口"></a>4.Collection子接口之一：List接口</h3><ul>
<li>鉴于Java中数组用来存储数据的局限性，我们通常使用List替代数组</li>
<li>List集合类中元素有序、且可重复，集合中的每个元素都有其对应的顺序索引。</li>
<li>List容器中的元素都对应一个整数型的序号记载其在容器中的位置，可以根据序号存取容器中的元素。</li>
<li>JDK API中List接口的实现类常用的有：ArrayList、LinkedList和Vector。</li>
</ul>
<h4 id="List接口常用实现类的对比"><a href="#List接口常用实现类的对比" class="headerlink" title="List接口常用实现类的对比"></a>List接口常用实现类的对比</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1. List接口框架</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    |----Collection接口：单列集合，用来存储一个一个的对象</span></span><br><span class="line"><span class="comment"> *          |----List接口：存储有序的、可重复的数据。  --&gt;“动态”数组,替换原有的数组</span></span><br><span class="line"><span class="comment"> *              |----ArrayList：作为List接口的主要实现类；线程不安全的，效率高；底层使用Object[] elementData存储</span></span><br><span class="line"><span class="comment"> *              |----LinkedList：对于频繁的插入、删除操作，使用此类效率比ArrayList高；底层使用双向链表存储</span></span><br><span class="line"><span class="comment"> *              |----Vector：作为List接口的古老实现类；线程安全的，效率低；底层使用Object[] elementData存储</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 面试题：比较ArrayList、LinkedList、Vector三者的异同？</span></span><br><span class="line"><span class="comment"> *        同：三个类都是实现了List接口，存储数据的特点相同：存储有序的、可重复的数据</span></span><br><span class="line"><span class="comment"> *        不同：见上</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h4 id="ArrayList的源码分析"><a href="#ArrayList的源码分析" class="headerlink" title="ArrayList的源码分析"></a>ArrayList的源码分析</h4><ul>
<li>ArrayList是List 接口的典型实现类、主要实现类</li>
<li>本质上，ArrayList是对象引用的一个”变长”数组</li>
</ul>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 2.ArrayList的源码分析：</span></span><br><span class="line"><span class="comment"> *   2.1 jdk 7情况下</span></span><br><span class="line"><span class="comment"> *      ArrayList list = new ArrayList();//底层创建了长度是10的Object[]数组elementData</span></span><br><span class="line"><span class="comment"> *      list.add(123);//elementData[0] = new Integer(123);</span></span><br><span class="line"><span class="comment"> *      ...</span></span><br><span class="line"><span class="comment"> *      list.add(11);//如果此次的添加导致底层elementData数组容量不够，则扩容。</span></span><br><span class="line"><span class="comment"> *      默认情况下，扩容为原来的容量的1.5倍，同时需要将原有数组中的数据复制到新的数组中。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      结论：建议开发中使用带参的构造器：ArrayList list = new ArrayList(int capacity)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   2.2 jdk 8中ArrayList的变化：</span></span><br><span class="line"><span class="comment"> *      ArrayList list = new ArrayList();//底层Object[] elementData初始化为&#123;&#125;.并没有创建长度为10的数组</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      list.add(123);//第一次调用add()时，底层才创建了长度10的数组，并将数据123添加到elementData[0]</span></span><br><span class="line"><span class="comment"> *      ...</span></span><br><span class="line"><span class="comment"> *      后续的添加和扩容操作与jdk 7 无异。</span></span><br><span class="line"><span class="comment"> *   2.3 小结：jdk7中的ArrayList的对象的创建类似于单例的饿汉式，而jdk8中的ArrayList的对象</span></span><br><span class="line"><span class="comment"> *            的创建类似于单例的懒汉式，延迟了数组的创建，节省内存。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="LinkedList的源码分析"><a href="#LinkedList的源码分析" class="headerlink" title="LinkedList的源码分析"></a>LinkedList的源码分析</h4><ul>
<li><p>对于频繁的插入或删除元素的操作，建议使用LinkedList类，效率较高</p>
</li>
<li><p>LinkedList：双向链表，内部没有声明数组，而是定义了Node类型的first和last，用于记录首末元素。同时，定义内部类Node，作为LinkedList中保存数据的基本结构。</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-26/d310da4fde968e21e9c4cd5fb731e3e1--e5c3--image-20240926114757184.png" alt="image-20240926114757184"></p>
</li>
</ul>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 3.LinkedList的源码分析：</span></span><br><span class="line"><span class="comment">  *       LinkedList list = new LinkedList(); 内部声明了Node类型的first和last属性，默认值为null</span></span><br><span class="line"><span class="comment">  *       list.add(123);//将123封装到Node中，创建了Node对象。</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  *       其中，Node定义为：体现了LinkedList的双向链表的说法</span></span><br><span class="line"><span class="comment">  *       private static class Node&lt;E&gt; &#123;</span></span><br><span class="line"><span class="comment">  *            E item;</span></span><br><span class="line"><span class="comment">  *            Node&lt;E&gt; next;</span></span><br><span class="line"><span class="comment">  *            Node&lt;E&gt; prev;</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  *            Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span></span><br><span class="line"><span class="comment">  *            this.item = element;</span></span><br><span class="line"><span class="comment">  *            this.next = next;     //next变量记录下一个元素的位置</span></span><br><span class="line"><span class="comment">  *            this.prev = prev;     //prev变量记录前一个元素的位置</span></span><br><span class="line"><span class="comment">  *            &#125;</span></span><br><span class="line"><span class="comment">  *        &#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="Vector的源码分析"><a href="#Vector的源码分析" class="headerlink" title="Vector的源码分析"></a>Vector的源码分析</h4><ul>
<li>Vector 是一个古老的集合，JDK1.0就有了。大多数操作与ArrayList相同，区别之处在于Vector是线程安全的。</li>
<li>在各种list中，最好把ArrayList作为缺省选择。当插入、删除频繁时，使用LinkedList；Vector总是比ArrayList慢，所以尽量避免使用。</li>
</ul>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">  * 4.Vector的源码分析：jdk7和jdk8中通过Vector()构造器创建对象时，底层都创建了长度为10的数组。</span></span><br><span class="line"><span class="comment">  *      在扩容方面，默认扩容为原来的数组长度的2倍。</span></span><br><span class="line"><span class="comment">  */</span>    </span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="List接口中的常用方法测试"><a href="#List接口中的常用方法测试" class="headerlink" title="List接口中的常用方法测试"></a>List接口中的常用方法测试</h4><ul>
<li>List除了从Collection集合继承的方法外，List 集合里添加了一些根据索引来操作集合元素的方法。<ul>
<li>void add(intindex, Object ele):在index位置插入ele元素</li>
<li>boolean addAll(int index, Collection eles):从index位置开始将eles中的所有元素添加进来</li>
<li>Object get(int index):获取指定index位置的元素</li>
<li>int indexOf(Object obj):返回obj在集合中首次出现的位置</li>
<li>int lastIndexOf(Object obj):返回obj在当前集合中末次出现的位置</li>
<li>Object remove(int index):移除指定index位置的元素，并返回此元素</li>
<li>Object set(int index, Object ele):设置指定index位置的元素为ele</li>
<li>List subList(int fromIndex, int toIndex):返回从fromIndex到toIndex位置的子集合</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 5.List接口的常用方法</span></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * void add(int index, Object ele):在index位置插入ele元素</span></span><br><span class="line"><span class="comment">     * boolean addAll(int index, Collection eles):从index位置开始将eles中的所有元素添加进来</span></span><br><span class="line"><span class="comment">     * Object get(int index):获取指定index位置的元素</span></span><br><span class="line"><span class="comment">     * int indexOf(Object obj):返回obj在集合中首次出现的位置</span></span><br><span class="line"><span class="comment">     * int lastIndexOf(Object obj):返回obj在当前集合中末次出现的位置</span></span><br><span class="line"><span class="comment">     * Object remove(int index):移除指定index位置的元素，并返回此元素</span></span><br><span class="line"><span class="comment">     * Object set(int index, Object ele):设置指定index位置的元素为ele</span></span><br><span class="line"><span class="comment">     * List subList(int fromIndex, int toIndex):返回从fromIndex到toIndex位置的子集合</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 总结：常用方法</span></span><br><span class="line"><span class="comment">     * 增：add(Object obj)</span></span><br><span class="line"><span class="comment">     * 删：remove(int index) / remove(Object obj)</span></span><br><span class="line"><span class="comment">     * 改：set(int index, Object ele)</span></span><br><span class="line"><span class="comment">     * 查：get(int index)</span></span><br><span class="line"><span class="comment">     * 插：add(int index, Object ele)</span></span><br><span class="line"><span class="comment">     * 长度：size()</span></span><br><span class="line"><span class="comment">     * 遍历：① Iterator迭代器方式</span></span><br><span class="line"><span class="comment">     *      ② 增强for循环</span></span><br><span class="line"><span class="comment">     *      ③ 普通的循环</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure>

<h4 id="List的一个面试题"><a href="#List的一个面试题" class="headerlink" title="List的一个面试题"></a>List的一个面试题</h4><ul>
<li>面试题1</li>
</ul>
<blockquote>
<p>请问ArrayList&#x2F;LinkedList&#x2F;Vector的异同？谈谈你的理解？ArrayList底层是什么？扩容机制？Vector和ArrayList的最大区别?</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 请问ArrayList/LinkedList/Vector的异同？谈谈你的理解？</span></span><br><span class="line"><span class="comment">  * ArrayList底层是什么？扩容机制？Vector和ArrayList的最大区别?</span></span><br><span class="line"><span class="comment">  * </span></span><br><span class="line"><span class="comment">  * ArrayList和LinkedList的异同二者都线程不安全，相对线程安全的Vector，执行效率高。</span></span><br><span class="line"><span class="comment">  * 此外，ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。</span></span><br><span class="line"><span class="comment">  * 对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。</span></span><br><span class="line"><span class="comment">  * 对于新增和删除操作add(特指插入)和remove，LinkedList比较占优势，因为ArrayList要移动数据。</span></span><br><span class="line"><span class="comment">  * </span></span><br><span class="line"><span class="comment">  * ArrayList和Vector的区别Vector和ArrayList几乎是完全相同的,</span></span><br><span class="line"><span class="comment">  * 唯一的区别在于Vector是同步类(synchronized)，属于强同步类。</span></span><br><span class="line"><span class="comment">  * 因此开销就比ArrayList要大，访问要慢。正常情况下,</span></span><br><span class="line"><span class="comment">  * 大多数的Java程序员使用ArrayList而不是Vector,</span></span><br><span class="line"><span class="comment">  * 因为同步完全可以由程序员自己来控制。Vector每次扩容请求其大小的2倍空间，</span></span><br><span class="line"><span class="comment">  * 而ArrayList是1.5倍。Vector还有一个子类Stack。</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></table></figure>

<h3 id="5、Collection子接口之二：Set接口"><a href="#5、Collection子接口之二：Set接口" class="headerlink" title="5、Collection子接口之二：Set接口"></a>5、Collection子接口之二：Set接口</h3><ul>
<li>Set接口是Collection的子接口，set接口没有提供额外的方法</li>
<li>Set 集合不允许包含相同的元素，如果试把两个相同的元素加入同一个Set 集合中，则添加操作失败。</li>
<li>Set 判断两个对象是否相同不是使用&#x3D;&#x3D; 运算符，而是根据equals() 方法</li>
</ul>
<h4 id="Set接口实现类的对比"><a href="#Set接口实现类的对比" class="headerlink" title="Set接口实现类的对比"></a>Set接口实现类的对比</h4><blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1.Set接口的框架：</span></span><br><span class="line"><span class="comment"> * |----Collection接口：单列集合，用来存储一个一个的对象</span></span><br><span class="line"><span class="comment"> *          |----Set接口：存储无序的、不可重复的数据   --&gt;高中讲的“集合”</span></span><br><span class="line"><span class="comment"> *             |----HashSet：作为Set接口的主要实现类；线程不安全的；可以存储null值</span></span><br><span class="line"><span class="comment"> *                 |----LinkedHashSet：作为HashSet的子类；遍历其内部数据时，可以按照添加的顺序遍历</span></span><br><span class="line"><span class="comment"> *                                    对于频繁的遍历操作，LinkedHashSet效率高于HashSet.</span></span><br><span class="line"><span class="comment"> *             |----TreeSet：可以按照添加对象的指定属性，进行排序。</span></span><br><span class="line"><span class="comment"> *</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="HashSet中元素的添加过程"><a href="#HashSet中元素的添加过程" class="headerlink" title="HashSet中元素的添加过程"></a>HashSet中元素的添加过程</h4><ul>
<li><p>HashSet是Set 接口的典型实现，大多数时候使用Set 集合时都使用这个实现类。</p>
</li>
<li><p>HashSet按Hash 算法来存储集合中的元素，因此具有很好的存取、查找、删除性能。</p>
</li>
<li><p>HashSet具有以下特点：不能保证元素的排列顺序</p>
<ul>
<li>HashSet不是线程安全的</li>
<li>集合元素可以是null</li>
</ul>
</li>
<li><p>HashSet 集合判断两个元素相等的标准：两个对象通过hashCode() 方法比较相等，并且两个对象的equals() 方法返回值也相等。</p>
</li>
<li><p>对于存放在Set容器中的对象，对应的类一定要重写equals()和hashCode(Object obj)方法，以实现对象相等规则。即：“<strong>相等的对象必须具有相等的散列码</strong>”。</p>
</li>
<li></li>
</ul>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 一、Set:存储无序的、不可重复的数据</span></span><br><span class="line"><span class="comment">     *      1.无序性：不等于随机性。存储的数据在底层数组中并非按照数组索引的顺序添加，而是根据数据的哈希值决定的。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *      2.不可重复性：保证添加的元素按照equals()判断时，不能返回true.即：相同的元素只能添加一个。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 二、添加元素的过程：以HashSet为例：</span></span><br><span class="line"><span class="comment">     *      我们向HashSet中添加元素a,首先调用元素a所在类的hashCode()方法，计算元素a的哈希值，</span></span><br><span class="line"><span class="comment">     *      此哈希值接着通过某种算法计算出在HashSet底层数组中的存放位置（即为：索引位置），判断</span></span><br><span class="line"><span class="comment">     *      数组此位置上是否已经有元素：</span></span><br><span class="line"><span class="comment">     *          如果此位置上没有其他元素，则元素a添加成功。 ---&gt;情况1</span></span><br><span class="line"><span class="comment">     *          如果此位置上有其他元素b(或以链表形式存在的多个元素），则比较元素a与元素b的hash值：</span></span><br><span class="line"><span class="comment">     *              如果hash值不相同，则元素a添加成功。---&gt;情况2</span></span><br><span class="line"><span class="comment">     *              如果hash值相同，进而需要调用元素a所在类的equals()方法：</span></span><br><span class="line"><span class="comment">     *                    equals()返回true,元素a添加失败</span></span><br><span class="line"><span class="comment">     *                    equals()返回false,则元素a添加成功。---&gt;情况2</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *      对于添加成功的情况2和情况3而言：元素a 与已经存在指定索引位置上数据以链表的方式存储。</span></span><br><span class="line"><span class="comment">     *      jdk 7 :元素a放到数组中，指向原来的元素。</span></span><br><span class="line"><span class="comment">     *      jdk 8 :原来的元素在数组中，指向元素a</span></span><br><span class="line"><span class="comment">     *      总结：七上八下</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * HashSet底层：数组+链表的结构。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-26/4c965e78676367af02bdc233fcd4e21a--3bb8--image-20240926154223158.png" alt="image-20240926154223158"></p>
<p>底层也是数组，初始容量为16，当如果使用率超过0.75，（16*0.75&#x3D;12）就会扩大容量为原来的2倍。（16扩容为32，依次为64,128….等）</p>
<h4 id="关于hashCode-和equals-的重写"><a href="#关于hashCode-和equals-的重写" class="headerlink" title="关于hashCode()和equals()的重写"></a>关于hashCode()和equals()的重写</h4><h5 id="重写hashCode-方法的基本原则"><a href="#重写hashCode-方法的基本原则" class="headerlink" title="重写hashCode() 方法的基本原则"></a>重写hashCode() 方法的基本原则</h5><ul>
<li>在程序运行时，同一个对象多次调用hashCode() 方法应该返回相同的值。</li>
<li>当两个对象的equals() 方法比较返回true 时，这两个对象的hashCode() 方法的返回值也应相等。</li>
<li>对象中用作equals() 方法比较的Field，都应该用来计算hashCode 值。</li>
</ul>
<h5 id="重写equals-方法的基本原则"><a href="#重写equals-方法的基本原则" class="headerlink" title="重写equals() 方法的基本原则"></a>重写equals() 方法的基本原则</h5><blockquote>
<p>以自定义的Customer类为例，何时需要重写equals()？</p>
</blockquote>
<ul>
<li>当一个类有自己特有的“逻辑相等”概念,当改写equals()的时候，总是要改写hashCode()，根据一个类的equals方法（改写后），两个截然不同的实例有可能在逻辑上是相等的，但是，根据Object.hashCode()方法，它们仅仅是两个对象。</li>
<li>因此，违反了“<strong>相等的对象必须具有相等的散列码</strong>”。</li>
<li>结论：复写equals方法的时候一般都需要同时复写hashCode方法。通常参与计算hashCode的对象的属性也应该参与到equals()中进行计算。</li>
</ul>
<h5 id="Eclipse-IDEA工具里hashCode-的重写"><a href="#Eclipse-IDEA工具里hashCode-的重写" class="headerlink" title="Eclipse&#x2F;IDEA工具里hashCode()的重写"></a>Eclipse&#x2F;IDEA工具里hashCode()的重写</h5><blockquote>
<p>以Eclipse&#x2F;IDEA为例，在自定义类中可以调用工具自动重写equals和hashCode。问题：为什么用Eclipse&#x2F;IDEA复写hashCode方法，有31这个数字？</p>
</blockquote>
<ul>
<li>选择系数的时候要选择尽量大的系数。因为如果计算出来的hash地址越大，所谓的“冲突”就越少，查找起来效率也会提高。（减少冲突）</li>
<li>并且31只占用5bits,相乘造成数据溢出的概率较小。</li>
<li>31可以由i*31&#x3D;&#x3D; (i&lt;&lt;5)-1来表示,现在很多虚拟机里面都有做相关优化。（提高算法效率）</li>
<li>31是一个素数，素数作用就是如果我用一个数字来乘以这个素数，那么最终出来的结果只能被素数本身和被乘数还有1来整除！(减少冲突)</li>
</ul>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 2.要求：向Set(主要指：HashSet、LinkedHashSet)中添加的数据，其所在的类一定要重写hashCode()和equals()</span></span><br><span class="line"><span class="comment">  *   要求：重写的hashCode()和equals()尽可能保持一致性：相等的对象必须具有相等的散列码</span></span><br><span class="line"><span class="comment">  *        重写两个方法的小技巧：对象中用作 equals() 方法比较的 Field，都应该用来计算 hashCode 值。</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="LinkedHashSet的使用"><a href="#LinkedHashSet的使用" class="headerlink" title="LinkedHashSet的使用"></a>LinkedHashSet的使用</h4><ul>
<li>LinkedHashSet是HashSet的子类</li>
<li>LinkedHashSet根据元素的hashCode值来决定元素的存储位置，但它同时使用双向链表维护元素的次序，这使得元素看起来是以<strong>插入顺序保存</strong>的。</li>
<li><strong>LinkedHashSet插入性能略低于HashSet</strong>，但在迭代访问Set 里的全部元素时有很好的性能。</li>
<li>LinkedHashSet不允许集合元素重复。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-26/4cc23d898e14d8003b0ae66094b41ed2--e610--image-20240926154251866.png" alt="image-20240926154251866"></p>
<h4 id="TreeSet的自然排序"><a href="#TreeSet的自然排序" class="headerlink" title="TreeSet的自然排序"></a>TreeSet的自然排序</h4><ul>
<li><p>TreeSet是SortedSet接口的实现类，TreeSet可以确保集合元素处于排序状态。</p>
</li>
<li><p>TreeSet底层使用<strong>红黑树</strong>结构存储数据</p>
</li>
<li><p>新增的方法如下：(了解)</p>
<ul>
<li>Comparator comparator()</li>
<li>Object first()</li>
<li>Object last()</li>
<li>Object lower(Object e)</li>
<li>Object higher(Object e)</li>
<li>SortedSet subSet(fromElement, toElement)</li>
<li>SortedSet headSet(toElement)</li>
<li>SortedSet tailSet(fromElement)</li>
</ul>
</li>
<li><p>TreeSet两种排序方法：<strong>自然排序和定制排序</strong>。默认情况下，TreeSet采用自然排序。</p>
</li>
<li><p>TreeSet和后面要讲的TreeMap采用红黑树的存储结构</p>
</li>
<li><p>特点：有序，查询速度比List快</p>
</li>
</ul>
<p><img src="http://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-26/72532b7ff7aafd3013078e556dcd5789--c2f7--image-20240926155705628.png" alt="image-20240926155705628"></p>
<ul>
<li><p>自然排序：TreeSet会调用集合元素的compareTo(Object obj) 方法来比较元素之间的大小关系，然后将集合元素按升序(默认情况)排列。</p>
</li>
<li><p><strong>如果试图把一个对象添加到TreeSet时，则该对象的类必须实现Comparable 接口</strong>。</p>
<ul>
<li>实现Comparable 的类必须实现compareTo(Object obj) 方法，两个对象即通过compareTo(Object obj) 方法的返回值来比较大小。</li>
</ul>
</li>
<li><p>Comparable 的典型实现：</p>
<ul>
<li>BigDecimal、BigInteger 以及所有的数值型对应的包装类：按它们对应的数值大小进行比较</li>
<li>Character：按字符的unicode值来进行比较</li>
<li>Boolean：true 对应的包装类实例大于false 对应的包装类实例</li>
<li>String：按字符串中字符的unicode 值进行比较</li>
<li>Date、Time：后边的时间、日期比前面的时间、日期大</li>
</ul>
</li>
<li><p>向TreeSet中添加元素时，只有第一个元素无须比较compareTo()方法，后面添加的所有元素都会调用compareTo()方法进行比较。</p>
</li>
<li><p><strong>因为只有相同类的两个实例才会比较大小，所以向TreeSet中添加的应该是同一个类的对象</strong>。</p>
</li>
<li><p>对于TreeSet集合而言，它<strong>判断两个对象是否相等的唯一标准</strong>是：两个对象通过compareTo(Object obj) 方法比较返回值。</p>
</li>
<li><p>当需要把一个对象放入TreeSet中，重写该对象对应的equals() 方法时，应保证该方法与compareTo(Object obj) 方法有一致的结果：如果两个对象通过equals() 方法比较返回true，则通过compareTo(Object obj) 方法比较应返回0。否则，让人难以理解。</p>
</li>
</ul>
<h4 id="TreeSet的定制排序"><a href="#TreeSet的定制排序" class="headerlink" title="TreeSet的定制排序"></a>TreeSet的定制排序</h4><ul>
<li>TreeSet的自然排序要求元素所属的类实现Comparable接口，如果元素所属的类没有实现Comparable接口，或不希望按照升序(默认情况)的方式排列元素或希望按照其它属性大小进行排序，则考虑使用定制排序。定制排序，通过Comparator接口来实现。需要重写compare(T o1,T o2)方法。</li>
<li>利用int compare(T o1,T o2)方法，比较o1和o2的大小：如果方法返回正整数，则表示o1大于o2；如果返回0，表示相等；返回负整数，表示o1小于o2。</li>
<li>要实现定制排序，需要将实现Comparator接口的实例作为形参传递给TreeSet的构造器。</li>
<li>此时，仍然只能向TreeSet中添加类型相同的对象。否则发生ClassCastException异常。</li>
<li>使用定制排序判断两个元素相等的标准是：通过Comparator比较两个元素返回了0。</li>
</ul>
<h3 id="6、Map接口"><a href="#6、Map接口" class="headerlink" title="6、Map接口"></a>6、Map接口</h3><p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-26/016b16f866b8814053813f34ef5ecd04--3ebe--image-20240926160356106.png" alt="image-20240926160356106"></p>
<h4 id="Map中存储的key-value的特点"><a href="#Map中存储的key-value的特点" class="headerlink" title="Map中存储的key-value的特点"></a>Map中存储的key-value的特点</h4><ul>
<li>Map与Collection并列存在。用于保存具有映射关系的数据:key-value</li>
<li>Map 中的key 和value 都可以是任何引用类型的数据</li>
<li>Map 中的key 用Set来存放，不允许重复，即同一个Map 对象所对应的类，须重写hashCode()和equals()方法</li>
<li>常用String类作为Map的“键”</li>
<li>key 和value 之间存在单向一对一关系，即通过指定的key 总能找到唯一的、确定的value</li>
<li>Map接口的常用实现类：HashMap、TreeMap、LinkedHashMap和Properties。其中，HashMap是Map 接口使用频率最高的实现类</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-26/5c6b47f892f9a5a48d33dfd7eac19e22--580b--image-20240926160454945.png" alt="image-20240926160454945"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  *  二、Map结构的理解：</span></span><br><span class="line"><span class="comment">  *    Map中的key:无序的、不可重复的，使用Set存储所有的key  ---&gt; key所在的类要重写equals()和hashCode() （以HashMap为例）</span></span><br><span class="line"><span class="comment">  *    Map中的value:无序的、可重复的，使用Collection存储所有的value ---&gt;value所在的类要重写equals()</span></span><br><span class="line"><span class="comment">  *    一个键值对：key-value构成了一个Entry对象。</span></span><br><span class="line"><span class="comment">  *    Map中的entry:无序的、不可重复的，使用Set存储所有的entry</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  */</span>   </span><br></pre></td></tr></table></figure>

<h4 id="Map实现类之一：HashMap"><a href="#Map实现类之一：HashMap" class="headerlink" title="Map实现类之一：HashMap"></a>Map实现类之一：HashMap</h4><ul>
<li><strong>HashMap是Map 接口使用频率最高的实现类</strong>。</li>
<li>允许使用null键和null值，与HashSet一样，不保证映射的顺序。</li>
<li>所有的key构成的集合是Set:无序的、不可重复的。所以，key所在的类要重写：equals()和hashCode()</li>
<li>所有的value构成的集合是Collection:无序的、可以重复的。所以，value所在的类要重写：equals()</li>
<li>一个key-value构成一个entry</li>
<li>所有的entry构成的集合是Set:无序的、不可重复的</li>
<li>HashMap 判断两个key 相等的标准是：两个key 通过equals() 方法返回true，hashCode值也相等。</li>
<li>HashMap判断两个value相等的标准是：两个value 通过equals() 方法返回true。</li>
</ul>
<h4 id="HashMap的底层实现原理"><a href="#HashMap的底层实现原理" class="headerlink" title="HashMap的底层实现原理"></a>HashMap的底层实现原理</h4><blockquote>
<p>JDK 7及以前版本：HashMap是数组+链表结构(即为链地址法)</p>
<p>JDK 8版本发布以后：HashMap是数组+链表+红黑树实现。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-26/ec2168962e0afd8308af7a84307e36c3--d616--image-20240926161011409.png" alt="image-20240926161011409"></p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-26/f366179f78492670947d2f3c225434b1--5796--image-20240926161016501.png" alt="image-20240926161016501"></p>
<ul>
<li>HashMap源码中的重要常量</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *      DEFAULT_INITIAL_CAPACITY : HashMap的默认容量，16</span></span><br><span class="line"><span class="comment"> *      DEFAULT_LOAD_FACTOR：HashMap的默认加载因子：0.75</span></span><br><span class="line"><span class="comment"> *      threshold：扩容的临界值，=容量*填充因子：16 * 0.75 =&gt; 12</span></span><br><span class="line"><span class="comment"> *      TREEIFY_THRESHOLD：Bucket中链表长度大于该默认值，转化为红黑树:8</span></span><br><span class="line"><span class="comment"> *      MIN_TREEIFY_CAPACITY：桶中的Node被树化时最小的hash表容量:64</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h5 id="HashMap在JDK7中的底层实现原理"><a href="#HashMap在JDK7中的底层实现原理" class="headerlink" title="HashMap在JDK7中的底层实现原理"></a>HashMap在JDK7中的底层实现原理</h5><ul>
<li>HashMap的内部存储结构其实是<strong>数组和链表的结合</strong>。当实例化一个HashMap时，系统会创建一个长度为Capacity的Entry数组，这个长度在哈希表中被称为容量(Capacity)，在这个数组中可以存放元素的位置我们称之为“桶”(bucket)，每个bucket都有自己的索引，系统可以根据索引快速的查找bucket中的元素。</li>
<li>每个bucket中存储一个元素，即一个Entry对象，但每一个Entry对象可以带一个引用变量，用于指向下一个元素，因此，在一个桶中，就有可能生成一个Entry链。而且新添加的元素作为链表的head。</li>
<li>添加元素的过程：<ul>
<li>向HashMap中添加entry1(key，value)，需要首先计算entry1中key的哈希值(根据key所在类的hashCode()计算得到)，此哈希值经过处理以后，得到在底层Entry[]数组中要存储的位置i。如果位置i上没有元素，则entry1直接添加成功。如果位置i上已经存在entry2(或还有链表存在的entry3，entry4)，则需要通过循环的方法，依次比较entry1中key和其他的entry。如果彼此hash值不同，则直接添加成功。如果hash值不同，继续比较二者是否equals。如果返回值为true，则使用entry1的value去替换equals为true的entry的value。如果遍历一遍以后，发现所有的equals返回都为false,则entry1仍可添加成功。entry1指向原有的entry元素。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 三、HashMap的底层实现原理？以jdk7为例说明：</span></span><br><span class="line"><span class="comment"> *    HashMap map = new HashMap():</span></span><br><span class="line"><span class="comment"> *    在实例化以后，底层创建了长度是16的一维数组Entry[] table。</span></span><br><span class="line"><span class="comment"> *    ...可能已经执行过多次put...</span></span><br><span class="line"><span class="comment"> *    map.put(key1,value1):</span></span><br><span class="line"><span class="comment"> *    首先，调用key1所在类的hashCode()计算key1哈希值，此哈希值经过某种算法计算以后，得到在Entry数组中的存放位置。</span></span><br><span class="line"><span class="comment"> *    如果此位置上的数据为空，此时的key1-value1添加成功。 ----情况1</span></span><br><span class="line"><span class="comment"> *    如果此位置上的数据不为空，(意味着此位置上存在一个或多个数据(以链表形式存在)),比较key1和已经存在的一个或多个数据</span></span><br><span class="line"><span class="comment"> *    的哈希值：</span></span><br><span class="line"><span class="comment"> *           如果key1的哈希值与已经存在的数据的哈希值都不相同，此时key1-value1添加成功。----情况2</span></span><br><span class="line"><span class="comment"> *           如果key1的哈希值和已经存在的某一个数据(key2-value2)的哈希值相同，继续比较：调用key1所在类的equals(key2)方法，比较：</span></span><br><span class="line"><span class="comment"> *                如果equals()返回false:此时key1-value1添加成功。----情况3</span></span><br><span class="line"><span class="comment"> *                如果equals()返回true:使用value1替换value2。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   补充：关于情况2和情况3：此时key1-value1和原来的数据以链表的方式存储。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   在不断的添加过程中，会涉及到扩容问题，当超出临界值(且要存放的位置非空)时，扩容。默认的扩容方式：扩容为原来容量的2倍，并将原有的数据复制过来。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * HashMap的扩容</span></span><br><span class="line"><span class="comment">  *     当HashMap中的元素越来越多的时候，hash冲突的几率也就越来越高，</span></span><br><span class="line"><span class="comment">  *     因为数组的长度是固定的。所以为了提高查询的效率，</span></span><br><span class="line"><span class="comment">  *     就要对HashMap的数组进行扩容，而在HashMap数组扩容之后，</span></span><br><span class="line"><span class="comment">  *     最消耗性能的点就出现了：原数组中的数据必须重新计算其在新数组中的位置，</span></span><br><span class="line"><span class="comment">  *     并放进去，这就是resize。</span></span><br><span class="line"><span class="comment">  *     </span></span><br><span class="line"><span class="comment">  * 那么HashMap什么时候进行扩容呢？</span></span><br><span class="line"><span class="comment">  *      当HashMap中的元素个数超过数组大小(数组总大小length,</span></span><br><span class="line"><span class="comment">  *      不是数组中个数size)*loadFactor时，就 会 进 行 数 组 扩 容，</span></span><br><span class="line"><span class="comment">  *      loadFactor的默认值(DEFAULT_LOAD_FACTOR)为0.75，这是一个折中的取值。</span></span><br><span class="line"><span class="comment">  *      也就是说，默认情况下，数组大小(DEFAULT_INITIAL_CAPACITY)为16，</span></span><br><span class="line"><span class="comment">  *      那么当HashMap中元素个数超过16*0.75=12（这个值就是代码中的threshold值，</span></span><br><span class="line"><span class="comment">  *      也叫做临界值）的时候，就把数组的大小扩展为2*16=32，即扩大一倍，</span></span><br><span class="line"><span class="comment">  *      然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作，</span></span><br><span class="line"><span class="comment">  *      所以如果我们已经预知HashMap中元素的个数，</span></span><br><span class="line"><span class="comment">  *      那么预设元素的个数能够有效的提高HashMap的性能。</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></table></figure>

<h5 id="HashMap在JDK8中的底层实现原理"><a href="#HashMap在JDK8中的底层实现原理" class="headerlink" title="HashMap在JDK8中的底层实现原理"></a>HashMap在JDK8中的底层实现原理</h5><ul>
<li><p>HashMap的内部存储结构其实是数组+链表+树的结合。当实例化一个HashMap时，会初始化initialCapacity和loadFactor，在put第一对映射关系时，系统会创建一个长度为initialCapacity的Node数组，这个长度在哈希表中被称为容量(Capacity)，在这个数组中可以存放元素的位置我们称之为“桶”(bucket)，每个bucket都有自己的索引，系统可以根据索引快速的查找bucket中的元素。</p>
</li>
<li><p>每个bucket中存储一个元素，即一个Node对象，但每一个Node对象可以带一个引用变量next，用于指向下一个元素，因此，在一个桶中，就有可能生成一个Node链。也可能是一个一个TreeNode对象，每一个TreeNode对象可以有两个叶子结点left和right，因此，在一个桶中，就有可能生成一个TreeNode树。而新添加的元素作为链表的last，或树的叶子结点。</p>
</li>
<li><p><strong>那么HashMap什么时候进行扩容和树形化呢？</strong></p>
<blockquote>
<p>当HashMap中的元素个数超过数组大小(数组总大小length,不是数组中个数size)<em>loadFactor时，就会进行数组扩容，loadFactor的默认值(DEFAULT_LOAD_FACTOR)为0.75，这是一个折中的取值。也就是说，默认情况下，数组大小(DEFAULT_INITIAL_CAPACITY)为16，那么当HashMap中元素个数超过16</em>0.75&#x3D;12（这个值就是代码中的threshold值，也叫做临界值）的时候，就把数组的大小扩展为2*16&#x3D;32，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作，所以如果我们已经预知HashMap中元素的个数，那么预设元素的个数能够有效的提高HashMap的性能。</p>
</blockquote>
</li>
<li><p>当HashMap中的其中一个链的对象个数如果达到了8个，此时如果capacity没有达到64，那么HashMap会先扩容解决，如果已经达到了64，那么这个链会变成树，结点类型由Node变成TreeNode类型。当然，如果当映射关系被移除后，下次resize方法时判断树的结点个数低于6个，也会把树再转为链表。</p>
</li>
<li><p><strong>关于映射关系的key是否可以修改？answer：不要修改</strong></p>
<blockquote>
<p>映射关系存储到HashMap中会存储key的hash值，这样就不用在每次查找时重新计算每一个Entry或Node（TreeNode）的hash值了，因此如果已经put到Map中的映射关系，再修改key的属性，而这个属性又参与hashcode值的计算，那么会导致匹配不上。</p>
</blockquote>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 总结：</span></span><br><span class="line"><span class="comment"> *   jdk8 相较于jdk7在底层实现方面的不同：</span></span><br><span class="line"><span class="comment"> *      1.new HashMap():底层没有创建一个长度为16的数组</span></span><br><span class="line"><span class="comment"> *      2.jdk 8底层的数组是：Node[],而非Entry[]</span></span><br><span class="line"><span class="comment"> *      3.首次调用put()方法时，底层创建长度为16的数组</span></span><br><span class="line"><span class="comment"> *      4.jdk7底层结构只有：数组+链表。jdk8中底层结构：数组+链表+红黑树。</span></span><br><span class="line"><span class="comment"> *         4.1形成链表时，七上八下（jdk7:新的元素指向旧的元素。jdk8：旧的元素指向新的元素）</span></span><br><span class="line"><span class="comment"> *         4.2当数组的某一个索引位置上的元素以链表形式存在的数据个数 &gt; 8 且当前数组的长度 &gt; 64时，此时此索引位置上的所数据改为使用红黑树存储。</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h4 id="LinkedHashMap的底层实现原理（了解！！！）"><a href="#LinkedHashMap的底层实现原理（了解！！！）" class="headerlink" title="LinkedHashMap的底层实现原理（了解！！！）"></a>LinkedHashMap的底层实现原理（了解！！！）</h4><ul>
<li><p>LinkedHashMap是HashMap的子类</p>
</li>
<li><p>在HashMap存储结构的基础上，使用了一对双向链表来记录添加元素的顺序</p>
</li>
<li><p>与LinkedHashSet类似，LinkedHashMap可以维护Map 的迭代顺序：迭代顺序与Key-Value 对的插入顺序一致</p>
</li>
<li><p>HashMap中的内部类：Node</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-26/5def8a853d13145aec0fac58b21ec825--dc6e--image-20240926161107656.png" alt="image-20240926161107656"></p>
<ul>
<li>LinkedHashMap中的内部类：Entry</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-26/a74194cb166be60b7c14d33841288421--a599--image-20240926161127564.png" alt="image-20240926161127564"></p>
<h4 id="Map中的常用方法"><a href="#Map中的常用方法" class="headerlink" title="Map中的常用方法"></a>Map中的常用方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  五、Map中定义的方法：</span></span><br><span class="line"><span class="comment"> *      添加、删除、修改操作：</span></span><br><span class="line"><span class="comment"> *      Object put(Object key,Object value)：将指定key-value添加到(或修改)当前map对象中</span></span><br><span class="line"><span class="comment"> *      void putAll(Map m):将m中的所有key-value对存放到当前map中</span></span><br><span class="line"><span class="comment"> *      Object remove(Object key)：移除指定key的key-value对，并返回value</span></span><br><span class="line"><span class="comment"> *      void clear()：清空当前map中的所有数据</span></span><br><span class="line"><span class="comment"> *      元素查询的操作：</span></span><br><span class="line"><span class="comment"> *      Object get(Object key)：获取指定key对应的value</span></span><br><span class="line"><span class="comment"> *      boolean containsKey(Object key)：是否包含指定的key</span></span><br><span class="line"><span class="comment"> *      boolean containsValue(Object value)：是否包含指定的value</span></span><br><span class="line"><span class="comment"> *      int size()：返回map中key-value对的个数</span></span><br><span class="line"><span class="comment"> *      boolean isEmpty()：判断当前map是否为空</span></span><br><span class="line"><span class="comment"> *      boolean equals(Object obj)：判断当前map和参数对象obj是否相等</span></span><br><span class="line"><span class="comment"> *      元视图操作的方法：</span></span><br><span class="line"><span class="comment"> *      Set keySet()：返回所有key构成的Set集合</span></span><br><span class="line"><span class="comment"> *      Collection values()：返回所有value构成的Collection集合</span></span><br><span class="line"><span class="comment"> *      Set entrySet()：返回所有key-value对构成的Set集合</span></span><br><span class="line"><span class="comment"> *总结：常用方法：</span></span><br><span class="line"><span class="comment"> *    添加：put(Object key,Object value)</span></span><br><span class="line"><span class="comment"> *    删除：remove(Object key)</span></span><br><span class="line"><span class="comment"> *    修改：put(Object key,Object value)</span></span><br><span class="line"><span class="comment"> *    查询：get(Object key)</span></span><br><span class="line"><span class="comment"> *    长度：size()</span></span><br><span class="line"><span class="comment"> *    遍历：keySet() / values() / entrySet()</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  面试题：</span></span><br><span class="line"><span class="comment"> *  1. HashMap的底层实现原理？</span></span><br><span class="line"><span class="comment"> *  2. HashMap 和 Hashtable的异同？</span></span><br><span class="line"><span class="comment"> *      1.HashMap与Hashtable都实现了Map接口。由于HashMap的非线程安全性，效率上可能高于Hashtable。Hashtable的方法是Synchronize的，而HashMap不是，在多个线程访问Hashtable时，不需要自己为它的方法实现同步，而HashMap 就必须为之提供外同步。</span></span><br><span class="line"><span class="comment"> *      2.HashMap允许将null作为一个entry的key或者value，而Hashtable不允许。</span></span><br><span class="line"><span class="comment"> *      3.HashMap把Hashtable的contains方法去掉了，改成containsvalue和containsKey。因为contains方法容易让人引起误解。</span></span><br><span class="line"><span class="comment"> *      4.Hashtable继承自Dictionary类，而HashMap是Java1.2引进的Map interface的一个实现。</span></span><br><span class="line"><span class="comment"> *      5.Hashtable和HashMap采用的hash/rehash算法都大概一样，所以性能不会有很大的差异。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  3. CurrentHashMap 与 Hashtable的异同？（暂时不讲）</span></span><br><span class="line"><span class="comment"> *</span></span><br></pre></td></tr></table></figure>

<h4 id="TreeMap两种添加方式的使用"><a href="#TreeMap两种添加方式的使用" class="headerlink" title="TreeMap两种添加方式的使用"></a>TreeMap两种添加方式的使用</h4><ul>
<li>TreeMap存储Key-Value 对时，需要根据key-value 对进行排序。TreeMap可以保证所有的Key-Value 对处于<strong>有序</strong>状态。</li>
<li>TreeSet底层使用<strong>红黑树</strong>结构存储数据</li>
<li>TreeMap的Key 的排序：<ul>
<li><strong>自然排序</strong>：TreeMap的所有的Key 必须实现Comparable 接口，而且所有的Key 应该是同一个类的对象，否则将会抛出ClasssCastException</li>
<li><strong>定制排序</strong>：创建TreeMap时，传入一个Comparator 对象，该对象负责对TreeMap中的所有key 进行排序。此时不需要Map 的Key 实现Comparable 接口</li>
</ul>
</li>
<li>TreeMap判断<strong>两个key相等</strong>的标准：两个key通过compareTo()方法或者compare()方法返回0。</li>
</ul>
<h4 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h4><ul>
<li>Hashtable是个古老的Map 实现类，JDK1.0就提供了。不同于HashMap，Hashtable是线程安全的。</li>
<li>Hashtable实现原理和HashMap相同，功能相同。底层都使用哈希表结构，查询速度快，很多情况下可以互用。</li>
<li>与HashMap不同，Hashtable不允许使用null 作为key 和value</li>
<li>与HashMap一样，Hashtable也不能保证其中Key-Value 对的顺序</li>
<li>Hashtable判断两个key相等、两个value相等的标准，与HashMap一致。</li>
</ul>
<h4 id="Properties处理属性文件"><a href="#Properties处理属性文件" class="headerlink" title="Properties处理属性文件"></a>Properties处理属性文件</h4><ul>
<li>Properties 类是Hashtable的子类，该对象用于处理属性文件</li>
<li>由于属性文件里的key、value 都是字符串类型，所以<strong>Properties 里的key 和value 都是字符串类型</strong></li>
<li>存取数据时，建议使用setProperty(String key,Stringvalue)方法和getProperty(String key)方法</li>
</ul>
<h3 id="7、Collections工具类"><a href="#7、Collections工具类" class="headerlink" title="7、Collections工具类"></a>7、Collections工具类</h3><ul>
<li><p>操作数组的工具类：Arrays</p>
</li>
<li><p>Collections 是一个操作Set、List和Map 等集合的工具类</p>
</li>
<li><p>Collections 中提供了一系列静态的方法对集合元素进行排序、查询和修改等操作，还提供了对集合对象设置不可变、对集合对象实现同步控制等方法</p>
</li>
<li><p>排序操作：（均为static方法）</p>
<ul>
<li>reverse(List)：反转List 中元素的顺序</li>
<li>shuffle(List)：对List集合元素进行随机排序</li>
<li>sort(List)：根据元素的自然顺序对指定List 集合元素按升序排序</li>
<li>sort(List，Comparator)：根据指定的Comparator 产生的顺序对List 集合元素进行排序</li>
<li>swap(List，int，int)：将指定list 集合中的i处元素和j 处元素进行交换</li>
</ul>
</li>
</ul>
<h2 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h2><h3 id="1、File类的使用"><a href="#1、File类的使用" class="headerlink" title="1、File类的使用"></a>1、File类的使用</h3><h4 id="File类的实例化"><a href="#File类的实例化" class="headerlink" title="File类的实例化"></a>File类的实例化</h4><ul>
<li>java.io.File类：文件和文件目录路径的抽象表示形式，与平台无关</li>
<li>File 能新建、删除、重命名文件和目录，但File 不能访问文件内容本身。如果需要访问文件内容本身，则需要使用输入&#x2F;输出流。</li>
<li>想要在Java程序中表示一个真实存在的文件或目录，那么必须有一个File对象，但是Java程序中的一个File对象，可能没有一个真实存在的文件或目录。</li>
<li>File对象可以作为参数传递给流的构造器</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1.如何创建file类的实例</span></span><br><span class="line"><span class="comment">     *      File(String filePath):以filePath为路径创建File对象，可以是绝对路径或者相对路径</span></span><br><span class="line"><span class="comment">     *      File(String parentPath,String childPath):以parentPath为父路径，childPath为子路径创建File对象。</span></span><br><span class="line"><span class="comment">     *      File(File parentFile,String childPath):根据一个父File对象和子文件路径创建File对象</span></span><br><span class="line"><span class="comment">     * 2.</span></span><br><span class="line"><span class="comment">     *   相对路径：相较于某个路径下，指明的路径。</span></span><br><span class="line"><span class="comment">     *   绝对路径：包含盘符在内的文件或文件目录的路径</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 3.路径分隔符</span></span><br><span class="line"><span class="comment">     *      windows:\\</span></span><br><span class="line"><span class="comment">     *      unix:/</span></span><br><span class="line"><span class="comment">     * 4.Java程序支持跨平台运行，因此路径分隔符要慎用。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 5.为了解决这个隐患，File类提供了一个常量：</span></span><br><span class="line"><span class="comment">     *   public  static final String separator。</span></span><br><span class="line"><span class="comment">     *   根据操作系统，动态的提供分隔符。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * File file1= new File(&quot;d:\\Work\\info.txt&quot;);</span></span><br><span class="line"><span class="comment">     * File file2= new File(&quot;d:&quot;+ File.separator+ &quot;Work&quot;+ File.separator+ &quot;info.txt&quot;);</span></span><br><span class="line"><span class="comment">     * File file3= new File(&quot;d:/Work&quot;);</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure>

<h4 id="File类的常用方法"><a href="#File类的常用方法" class="headerlink" title="File类的常用方法"></a>File类的常用方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * public String getAbsolutePath()：获取绝对路径</span></span><br><span class="line"><span class="comment">     * public String getPath() ：获取路径</span></span><br><span class="line"><span class="comment">     * public String getName() ：获取名称</span></span><br><span class="line"><span class="comment">     * public String getParent()：获取上层文件目录路径。若无，返回null</span></span><br><span class="line"><span class="comment">     * public long length() ：获取文件长度（即：字节数）。不能获取目录的长度。</span></span><br><span class="line"><span class="comment">     * public long lastModified() ：获取最后一次的修改时间，毫秒值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 如下的两个方法适用于文件目录：</span></span><br><span class="line"><span class="comment">     * public String[] list() ：获取指定目录下的所有文件或者文件目录的名称数组</span></span><br><span class="line"><span class="comment">     * public File[] listFiles() ：获取指定目录下的所有文件或者文件目录的File数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * File类的重命名功能</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *  public boolean renameTo(File dest):把文件重命名为指定的文件路径</span></span><br><span class="line"><span class="comment">     *    比如：file1.renameTo(file2)为例：</span></span><br><span class="line"><span class="comment">     *         要想保证返回true,需要file1在硬盘中是存在的，且file2不能在硬盘中存在。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * public boolean isDirectory()：判断是否是文件目录</span></span><br><span class="line"><span class="comment">     * public boolean isFile() ：判断是否是文件</span></span><br><span class="line"><span class="comment">     * public boolean exists() ：判断是否存在</span></span><br><span class="line"><span class="comment">     * public boolean canRead() ：判断是否可读</span></span><br><span class="line"><span class="comment">     * public boolean canWrite() ：判断是否可写</span></span><br><span class="line"><span class="comment">     * public boolean isHidden() ：判断是否隐藏</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建硬盘中对应的文件或文件目录</span></span><br><span class="line"><span class="comment">     * public boolean createNewFile() ：创建文件。若文件存在，则不创建，返回false</span></span><br><span class="line"><span class="comment">     * public boolean mkdir() ：创建文件目录。如果此文件目录存在，就不创建了。如果此文件目录的上层目录不存在，也不创建。</span></span><br><span class="line"><span class="comment">     * public boolean mkdirs() ：创建文件目录。如果此文件目录存在，就不创建了。如果上层文件目录不存在，一并创建</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *     删除磁盘中的文件或文件目录</span></span><br><span class="line"><span class="comment">     * public boolean delete()：删除文件或者文件夹</span></span><br><span class="line"><span class="comment">     *     删除注意事项：Java中的删除不走回收站。</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure>

<h3 id="2-IO流原理及流的分类"><a href="#2-IO流原理及流的分类" class="headerlink" title="2.IO流原理及流的分类"></a>2.IO流原理及流的分类</h3><h4 id="IO流原理"><a href="#IO流原理" class="headerlink" title="IO流原理"></a>IO流原理</h4><ul>
<li>I&#x2F;O是Input&#x2F;Output的缩写，I&#x2F;O技术是非常实用的技术，用于处理设备之间的数据传输。如读&#x2F;写文件，网络通讯等。</li>
<li>Java程序中，对于数据的输入&#x2F;输出操作以“流(stream)”的方式进行。</li>
<li>java.io包下提供了各种“流”类和接口，用以获取不同种类的数据，并通过标准的方法输入或输出数据。</li>
<li>输入input：读取外部数据（磁盘、光盘等存储设备的数据）到程序（内存）中。</li>
<li>输出output：将程序（内存）数据输出到磁盘、光盘等存储设备中。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-02/0332c07d4172fd418c663af3cf0e62c9--dd7c--image-20241002172628012.png" alt="image-20241002172628012"></p>
<h4 id="流的分类"><a href="#流的分类" class="headerlink" title="流的分类"></a>流的分类</h4><ul>
<li>按操作<strong>数据单位</strong>不同分为：字节流(8 bit)，字符流(16 bit)</li>
<li>按数据流的<strong>流向</strong>不同分为：输入流，输出流</li>
<li>按流的<strong>角色</strong>的不同分为：节点流，处理流</li>
</ul>
<table>
<thead>
<tr>
<th align="center">抽象基类</th>
<th align="center">字节流</th>
<th align="center">字符流</th>
</tr>
</thead>
<tbody><tr>
<td align="center">输入流</td>
<td align="center">InputStream</td>
<td align="center">Reader</td>
</tr>
<tr>
<td align="center">输出流</td>
<td align="center">OutputStream</td>
<td align="center">Writer</td>
</tr>
</tbody></table>
<ol>
<li><p>Java的IO流共涉及40多个类，实际上非常规则，都是从如下4个抽象基类派生的。</p>
</li>
<li><p>由这四个类派生出来的子类名称都是以其父类名作为子类名后缀。</p>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-02/4fcecdfdeb30135c60b9f69d33e65dc4--7e07--image-20241002173511265.png" alt="image-20241002173511265"></p>
<h4 id="IO-流体系"><a href="#IO-流体系" class="headerlink" title="IO 流体系"></a>IO 流体系</h4><p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-02/548e94ddbf27a53c4ea5dc103380530a--eba7--image-20241002173536636.png" alt="image-20241002173536636"></p>
<h3 id="3-节点流-或文件流"><a href="#3-节点流-或文件流" class="headerlink" title="3.节点流(或文件流)"></a>3.节点流(或文件流)</h3><h4 id="FileReader读入数据的基本操作"><a href="#FileReader读入数据的基本操作" class="headerlink" title="FileReader读入数据的基本操作"></a>FileReader读入数据的基本操作</h4><ul>
<li>读取文件</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>建立一个流对象，将已存在的一个文件加载进流。		</span><br><span class="line">	FileReaderfr= <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="keyword">new</span> <span class="title class_">File</span>(“Test.txt”));</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>创建一个临时存放数据的数组。</span><br><span class="line">	<span class="type">char</span>[] ch= <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>调用流对象的读取方法将流中的数据读入到数组中。		</span><br><span class="line">	fr.read(ch);</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> 关闭资源。</span><br><span class="line">	fr.close();</span><br></pre></td></tr></table></figure>

<h4 id="FileWriter写出数据的操作"><a href="#FileWriter写出数据的操作" class="headerlink" title="FileWriter写出数据的操作"></a>FileWriter写出数据的操作</h4><ul>
<li>写入文件</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>创建流对象，建立数据存放文件</span><br><span class="line">    FileWriterfw= <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="keyword">new</span> <span class="title class_">File</span>(“Test.txt”));</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>调用流对象的写入方法，将数据写入流</span><br><span class="line">    fw.write(“atguigu-songhongkang”);</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>关闭流资源，并将流中的数据清空到文件中。</span><br><span class="line">    fw.close();</span><br></pre></td></tr></table></figure>

<h3 id="4-缓冲流"><a href="#4-缓冲流" class="headerlink" title="4.缓冲流"></a>4.缓冲流</h3><ul>
<li>为了提高数据读写的速度，Java API提供了带缓冲功能的流类，在使用这些流类时，会创建一个内部缓冲区数组，缺省使用8192个字节(8Kb)的缓冲区。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-02/e15a777941671c4cb10540b0dbdd135a--083a--image-20241002183552837.png" alt="image-20241002183552837"></p>
<ul>
<li><p>缓冲流要“套接”在相应的节点流之上，根据数据操作单位可以把缓冲流分为：</p>
<ul>
<li>BufferedInputStream和BufferedOutputStream</li>
<li>BufferedReader和BufferedWriter</li>
</ul>
</li>
<li><p>当读取数据时，数据按块读入缓冲区，其后的读操作则直接访问缓冲区</p>
</li>
<li><p>当使用BufferedInputStream读取字节文件时，BufferedInputStream会一次性从文件中读取8192个(8Kb)，存在缓冲区中，直到缓冲区装满了，才重新从文件中读取下一个8192个字节数组。</p>
</li>
<li><p>向流中写入字节时，不会直接写到文件，先写到缓冲区中直到缓冲区写满，BufferedOutputStream才会把缓冲区中的数据一次性写到文件里。使用方法flush()可以强制将缓冲区的内容全部写入输出流</p>
</li>
<li><p>关闭流的顺序和打开流的顺序相反。只要关闭最外层流即可，关闭最外层流也会相应关闭内层节点流</p>
</li>
<li><p>flush()方法的使用：手动将buffer中内容写入文件</p>
</li>
<li><p>如果是带缓冲区的流对象的close()方法，不但会关闭流，还会在关闭流之前刷新缓冲区，关闭后不能再写出。</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-02/b3b7754d04c3b7f5e3aac395d953838d--d9d6--image-20241002183634220.png" alt="image-20241002183634220"></p>
<h3 id="5-转换流"><a href="#5-转换流" class="headerlink" title="5.转换流"></a>5.转换流</h3><h4 id="转换流概述与InputStreamReader的使用"><a href="#转换流概述与InputStreamReader的使用" class="headerlink" title="转换流概述与InputStreamReader的使用"></a>转换流概述与InputStreamReader的使用</h4><ul>
<li><p>转换流提供了在字节流和字符流之间的转换</p>
</li>
<li><p>Java API提供了两个转换流：</p>
<ul>
<li>InputStreamReader：将InputStream转换为Reader<ul>
<li>实现将字节的输入流按指定字符集转换为字符的输入流。</li>
<li>需要和InputStream“套接”。</li>
<li>构造器<ul>
<li>public InputStreamReader(InputStreamin)</li>
<li>public InputSreamReader(InputStreamin,StringcharsetName)</li>
<li>如：Reader isr&#x3D; new InputStreamReader(System.in,”gbk”);</li>
</ul>
</li>
</ul>
</li>
<li>OutputStreamWriter：将Writer转换为OutputStream<ul>
<li>实现将字符的输出流按指定字符集转换为字节的输出流。</li>
<li>需要和OutputStream“套接”。</li>
<li>构造器<ul>
<li>public OutputStreamWriter(OutputStreamout)</li>
<li>public OutputSreamWriter(OutputStreamout,StringcharsetName)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>字节流中的数据都是字符时，转成字符流操作更高效。</p>
</li>
<li><p>很多时候我们使用转换流来处理文件乱码问题。实现编码和解码的功能。</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-02/1d2348b58ca17120964e61d189a8d294--c67c--image-20241002184541945.png" alt="image-20241002184541945"></p>
<h4 id="多种字符编码集的说明"><a href="#多种字符编码集的说明" class="headerlink" title="多种字符编码集的说明"></a>多种字符编码集的说明</h4><ul>
<li><p>编码表的由来</p>
<blockquote>
<p>计算机只能识别二进制数据，早期由来是电信号。为了方便应用计算机，让它可以识别各个国家的文字。就将各个国家的文字用数字来表示，并一一对应，形成一张表。这就是编码表。</p>
</blockquote>
</li>
<li><p>常见的编码表</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 4.字符集</span></span><br><span class="line"><span class="comment">  *  ASCII：美国标准信息交换码。</span></span><br><span class="line"><span class="comment">  *     用一个字节的7位可以表示。</span></span><br><span class="line"><span class="comment">  *  ISO8859-1：拉丁码表。欧洲码表</span></span><br><span class="line"><span class="comment">  *     用一个字节的8位表示。</span></span><br><span class="line"><span class="comment">  *  GB2312：中国的中文编码表。最多两个字节编码所有字符</span></span><br><span class="line"><span class="comment">  *  GBK：中国的中文编码表升级，融合了更多的中文文字符号。最多两个字节编码</span></span><br><span class="line"><span class="comment">  *  Unicode：国际标准码，融合了目前人类使用的所有字符。为每个字符分配唯一的字符码。所有的文字都用两个字节来表示。</span></span><br><span class="line"><span class="comment">  *  UTF-8：变长的编码方式，可用1-4个字节来表示一个字符。</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Unicode不完美，这里就有三个问题，一个是，我们已经知道，英文字母只用一个字节表示就够了，第二个问题是如何才能区别Unicode和ASCII？计算机怎么知道两个字节表示一个符号，而不是分别表示两个符号呢？第三个，如果和GBK等双字节编码方式一样，用最高位是1或0表示两个字节和一个字节，就少了很多值无法用于表示字符，不够表示所有字符。Unicode在很长一段时间内无法推广，直到互联网的出现。</li>
<li>面向传输的众多UTF（UCS Transfer Format）标准出现了，顾名思义，<strong>UTF-8就是每次8个位传输数据，而UTF-16就是每次16个位。</strong>这是为传输而设计的编码，并使编码无国界，这样就可以显示全世界上所有文化的字符了。</li>
<li>Unicode只是定义了一个庞大的、全球通用的字符集，并为每个字符规定了唯一确定的编号，具体存储成什么样的字节流，取决于字符编码方案。推荐的Unicode编码是UTF-8和UTF-16。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-02/44407cfc98725875886f4b92a502a464--d8e6--image-20241002185539502.png" alt="image-20241002185539502"></p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-02/d23001b07313a32006b232017fccbda7--c8d3--image-20241002185546613.png" alt="image-20241002185546613"></p>
<h3 id="6-标准输入、输出流"><a href="#6-标准输入、输出流" class="headerlink" title="6.标准输入、输出流"></a>6.标准输入、输出流</h3><ul>
<li>System.in和System.out分别代表了系统标准的输入和输出设备</li>
<li>默认输入设备是：键盘，输出设备是：显示器</li>
<li>System.in的类型是InputStream</li>
<li>System.out的类型是PrintStream，其是OutputStream的子类FilterOutputStream的子类</li>
<li>重定向：通过System类的setIn，setOut方法对默认设备进行改变。<ul>
<li>public static void setIn(InputStreamin)</li>
<li>public static void setOut(PrintStreamout)</li>
</ul>
</li>
</ul>
<h3 id="7-打印流"><a href="#7-打印流" class="headerlink" title="7.打印流"></a>7.打印流</h3><ul>
<li>实现将基本数据类型的数据格式转化为字符串输出</li>
<li>打印流：PrintStream和PrintWriter<ul>
<li>提供了一系列重载的print()和println()方法，用于多种数据类型的输出</li>
<li>PrintStream和PrintWriter的输出不会抛出IOException异常</li>
<li>PrintStream和PrintWriter有自动flush功能</li>
<li>PrintStream 打印的所有字符都使用平台的默认字符编码转换为字节。在需要写入字符而不是写入字节的情况下，应该使用PrintWriter 类。</li>
<li>System.out返回的是PrintStream的实例</li>
</ul>
</li>
</ul>
<h3 id="8-数据流"><a href="#8-数据流" class="headerlink" title="8.数据流"></a>8.数据流</h3><ul>
<li><p>为了方便地操作Java语言的基本数据类型和String的数据，可以使用数据流。</p>
</li>
<li><p>数据流有两个类：(用于读取和写出基本数据类型、String类的数据）</p>
<ul>
<li>DataInputStream和DataOutputStream</li>
<li>分别“套接”在InputStream和OutputStream子类的流上</li>
</ul>
</li>
<li><p>DataInputStream中的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">readBoolean</span><span class="params">()</span>	<span class="type">byte</span> <span class="title function_">readByte</span><span class="params">()</span></span><br><span class="line"><span class="type">char</span> <span class="title function_">readChar</span><span class="params">()</span>	<span class="type">float</span> <span class="title function_">readFloat</span><span class="params">()</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">readDouble</span><span class="params">()</span>	<span class="type">short</span> <span class="title function_">readShort</span><span class="params">()</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">readLong</span><span class="params">()</span>	<span class="type">int</span> <span class="title function_">readInt</span><span class="params">()</span></span><br><span class="line">String <span class="title function_">readUTF</span><span class="params">()</span>	<span class="keyword">void</span> <span class="title function_">readFully</span><span class="params">(<span class="type">byte</span>[s] b)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>DataOutputStream中的方法</p>
<ul>
<li>将上述的方法的read改为相应的write即可。</li>
</ul>
</li>
</ul>
<h3 id="9-对象流"><a href="#9-对象流" class="headerlink" title="9.对象流"></a>9.对象流</h3><h4 id="对象序列化机制的理解"><a href="#对象序列化机制的理解" class="headerlink" title="对象序列化机制的理解"></a>对象序列化机制的理解</h4><ul>
<li>ObjectInputStream和OjbectOutputSteam</li>
<li>用于存储和读取基本数据类型数据或对象的处理流。它的强大之处就是可以把Java中的对象写入到数据源中，也能把对象从数据源中还原回来。</li>
<li>序列化：用ObjectOutputStream类保存基本类型数据或对象的机制</li>
<li>反序列化：用ObjectInputStream类读取基本类型数据或对象的机制</li>
<li>ObjectOutputStream和ObjectInputStream不能序列化static和transient修饰的成员变量</li>
<li>对象序列化机制允许把内存中的Java对象转换成平台无关的二进制流，从而允许把这种二进制流持久地保存在磁盘上，或通过网络将这种二进制流传输到另一个网络节点。&#x2F;&#x2F;当其它程序获取了这种二进制流，就可以恢复成原来的Java对象</li>
<li>序列化的好处在于可将任何实现了Serializable接口的对象转化为字节数据，使其在保存和传输时可被还原</li>
<li>序列化是RMI（Remote Method Invoke –远程方法调用）过程的参数和返回值都必须实现的机制，而RMI 是JavaEE的基础。因此序列化机制是JavaEE平台的基础</li>
<li>如果需要让某个对象支持序列化机制，则必须让对象所属的类及其属性是可序列化的，为了让某个类是可序列化的，该类必须实现如下两个接口之一。否则，会抛出NotSerializableException异常<ul>
<li>Serializable</li>
<li>Externalizable</li>
</ul>
</li>
</ul>
<h4 id="自定义类实现序列化与反序列化操作"><a href="#自定义类实现序列化与反序列化操作" class="headerlink" title="自定义类实现序列化与反序列化操作"></a>自定义类实现序列化与反序列化操作</h4><ul>
<li><p>若某个类实现了Serializable接口，该类的对象就是可序列化的：</p>
<ul>
<li>创建一个ObjectOutputStream</li>
<li>调用ObjectOutputStream对象的writeObject(对象) 方法输出可序列化对象</li>
<li>注意写出一次，操作flush()一次</li>
</ul>
</li>
<li><p>反序列化</p>
<ul>
<li>创建一个ObjectInputStream调用readObject() 方法读取流中的对象</li>
</ul>
</li>
<li><p>强调：如果某个类的属性不是基本数据类型或String  类型，而是另一个引用类型，那么这个引用类型必须是可序列化的，否则拥有该类型的Field 的类也不能序列化</p>
</li>
<li><p>Person类</p>
</li>
</ul>
<h4 id="serialVersionUID的理解"><a href="#serialVersionUID的理解" class="headerlink" title="serialVersionUID的理解"></a>serialVersionUID的理解</h4><ul>
<li><p>凡是实现Serializable接口的类都有一个表示序列化版本标识符的静态变量：</p>
<ul>
<li>private static final long serialVersionUID;</li>
<li>serialVersionUID用来表明类的不同版本间的兼容性。简言之，其目的是以序列化对象进行版本控制，有关各版本反序列化时是否兼容。</li>
<li>如果类没有显示定义这个静态常量，它的值是Java运行时环境根据类的内部细节自动生成的。若类的实例变量做了修改，serialVersionUID可能发生变化。故建议，显式声明。</li>
</ul>
</li>
<li><p>简单来说，Java的序列化机制是通过在运行时判断类的serialVersionUID来验证版本一致性的。在进行反序列化时，JVM会把传来的字节流中的serialVersionUID与本地相应实体类的serialVersionUID进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常。(InvalidCastException)</p>
</li>
<li><p>Person类</p>
</li>
</ul>
<h3 id="10-随机存取文件流"><a href="#10-随机存取文件流" class="headerlink" title="10.随机存取文件流"></a>10.随机存取文件流</h3><ul>
<li><p>RandomAccessFile 声明在java.io包下，但直接继承于java.lang.Object类。并且它实现了DataInput、DataOutput这两个接口，也就意味着这个类既可以读也可以写。</p>
</li>
<li><p>RandomAccessFile 类支持“随机访问” 的方式，程序可以直接跳到文件的任意地方来读、写文件</p>
<ul>
<li>支持只访问文件的部分内容</li>
<li>可以向已存在的文件后追加内容</li>
</ul>
</li>
<li><p>RandomAccessFile 对象包含一个记录指针，用以标示当前读写处的位置。RandomAccessFile类对象可以自由移动记录指针：</p>
<ul>
<li>long getFilePointer()：获取文件记录指针的当前位置</li>
<li>void seek(long pos)：将文件记录指针定位到pos位置</li>
</ul>
</li>
<li><p>构造器</p>
<ul>
<li>public RandomAccessFile(Filefile, Stringmode) </li>
<li>public RandomAccessFile(Stringname, Stringmode)</li>
</ul>
</li>
<li><p>创建RandomAccessFile类实例需要指定一个mode 参数，该参数指定RandomAccessFile的访问模式：</p>
<ul>
<li>r: 以只读方式打开</li>
<li>rw：打开以便读取和写入</li>
<li>rwd:打开以便读取和写入；同步文件内容的更新</li>
<li>rws:打开以便读取和写入；同步文件内容和元数据的更新</li>
</ul>
</li>
<li><p>如果模式为只读r。则不会创建文件，而是会去读取一个已经存在的文件，如果读取的文件不存在则会出现异常。如果模式为rw读写。如果文件不存在则会去创建文件，如果存在则不会创建。</p>
</li>
</ul>
<h3 id="11-NIO-2中Path、Paths、Files类的使用"><a href="#11-NIO-2中Path、Paths、Files类的使用" class="headerlink" title="11.NIO.2中Path、Paths、Files类的使用"></a>11.NIO.2中Path、Paths、Files类的使用</h3><ul>
<li><p>Java NIO (New IO，Non-Blocking IO)是从Java 1.4版本开始引入的一套新的IO API，可以替代标准的Java IO API。NIO与原来的IO有同样的作用和目的，但是使用的方式完全不同，NIO支持面向缓冲区的(IO是面向流的)、基于通道的IO操作。NIO将以更加高效的方式进行文件的读写操作。</p>
</li>
<li><p>Java API中提供了两套NIO，一套是针对标准输入输出NIO，另一套就是网络编程NIO。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|-----java.nio.channels.Channel</span><br><span class="line">    |-----FileChannel:处理本地文件</span><br><span class="line">    |-----SocketChannel：TCP网络编程的客户端的Channel</span><br><span class="line">    |-----ServerSocketChannel:TCP网络编程的服务器端的Channel</span><br><span class="line">    |-----DatagramChannel：UDP网络编程中发送端和接收端的Channel</span><br></pre></td></tr></table></figure>
</li>
<li><p>随着JDK 7 的发布，Java对NIO进行了极大的扩展，增强了对文件处理和文件系统特性的支持，以至于我们称他们为NIO.2。因为NIO 提供的一些功能，NIO已经成为文件处理中越来越重要的部分。</p>
</li>
<li><p>早期的Java只提供了一个File类来访问文件系统，但File类的功能比较有限，所提供的方法性能也不高。而且，大多数方法在出错时仅返回失败，并不会提供异常信息。</p>
</li>
<li><p>NIO. 2为了弥补这种不足，引入了Path接口，代表一个平台无关的平台路径，描述了目录结构中文件的位置。Path可以看成是File类的升级版本，实际引用的资源也可以不存在。</p>
</li>
<li><p>在以前IO操作都是这样写的:</p>
<ul>
<li>import java.io.File;</li>
<li>File file &#x3D; new File(“index.html”);</li>
</ul>
</li>
<li><p>但在Java7 中，我们可以这样写：</p>
<ul>
<li>import java.nio.file.Path;</li>
<li>import java.nio.file.Paths;</li>
<li>Path path &#x3D; Paths.get(“index.html”);</li>
</ul>
</li>
<li><p>同时，NIO.2在java.nio.file包下还提供了Files、Paths工具类，Files包含了大量静态的工具方法来操作文件；Paths则包含了两个返回Path的静态工厂方法。</p>
</li>
<li><p>Paths 类提供的静态get() 方法用来获取Path 对象：</p>
<ul>
<li>static Pathget(String first, String … more) : 用于将多个字符串串连成路径</li>
<li>static Path get(URI uri): 返回指定uri对应的Path路径</li>
</ul>
</li>
<li><p>Path接口</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-02/a82dd7550a4c16ef3ea37fc6aa8609a6--7334--image-20241002190644089.png" alt="image-20241002190644089"></p>
<ul>
<li>Files 类</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-02/8254c3f67ca2c7111a66692567b84c67--2a50--image-20241002191211308.png" alt="image-20241002191211308"></p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-02/ba3be1ca719cecb6fcccee7568a403d6--ec6a--image-20241002191223484.png" alt="image-20241002191223484"></p>
<blockquote>
<p>一些对于NIO与IO的对比</p>
</blockquote>
<p>作者：终端研发部<br>链接：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/439681246/answer/1753604983">https://www.zhihu.com/question/439681246/answer/1753604983</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<p>NIO是为了弥补IO操作的不足而诞生的，NIO的一些新特性有：非阻塞I&#x2F;O，选择器，缓冲以及管道。管道（Channel），缓冲（Buffer） ，选择器（ Selector）是其主要特征。</p>
<p><img src="https://picx.zhimg.com/80/v2-db587ee075af848892e64f137ea9fd5e_1440w.webp?source=1def8aca" alt="img"></p>
<h5 id="概念解释："><a href="#概念解释：" class="headerlink" title="概念解释："></a>概念解释：</h5><p>Channel——管道实际上就像传统IO中的流，到任何目的地(或来自任何地方)的所有数据都必须通过一个 Channel 对象。一个 Buffer 实质上是一个<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=348917546&content_type=Answer&match_order=1&q=%E5%AE%B9%E5%99%A8%E5%AF%B9%E8%B1%A1&zhida_source=entity">容器对象</a>。</p>
<p>Selector——选择器用于监听多个管道的事件，使用传统的<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=348917546&content_type=Answer&match_order=1&q=%E9%98%BB%E5%A1%9EIO&zhida_source=entity">阻塞IO</a>时我们可以方便的知道什么时候可以进行读写，而使用非阻塞通道，我们需要一些方法来知道什么时候通道准备好了，选择器正是为这个需要而诞生的。</p>
<h5 id="NIO和传统的IO有什么区别呢"><a href="#NIO和传统的IO有什么区别呢" class="headerlink" title="NIO和传统的IO有什么区别呢?"></a>NIO和传统的IO有什么区别呢?</h5><p><strong>1，IO是面向流的，NIO是面向块（缓冲区）的。</strong></p>
<p>IO面向流的操作一次一个字节地处理数据。一个输入流产生一个字节的数据，一个输出流消费一个字节的数据。，导致了数据的读取和写入效率不佳；</p>
<p>NIO面向块的操作在一步中产生或者消费一个数据块。按块处理数据比按(流式的)字节处理数据要快得多，同时数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。通俗来说，NIO采取了“预读”的方式，当你读取某一部分数据时，他就会猜测你下一步可能会读取的数据而预先缓冲下来。</p>
<p><strong>2，IO是阻塞的，NIO是非阻塞的。</strong></p>
<p>对于传统的IO，当一个线程调用read() 或 write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。</p>
<p>而对于NIO，使用一个线程发送读取数据请求，没有得到响应之前，线程是空闲的，此时线程可以去执行别的任务，而不是像IO中那样只能等待响应完成。</p>
<p><strong>3，NIO和IO适用场景</strong></p>
<p>NIO是为弥补传统IO的不足而诞生的，但是<a href="https://link.zhihu.com/?target=https://www.baidu.com/s?wd=%E5%B0%BA%E6%9C%89%E6%89%80%E7%9F%AD&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd">尺有所短</a><a href="https://link.zhihu.com/?target=https://www.baidu.com/s?wd=%E5%AF%B8%E6%9C%89%E6%89%80%E9%95%BF&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd">寸有所长</a>，NIO也有缺点，因为NIO是面向缓冲区的操作，每一次的数据处理都是对缓冲区进行的，那么就会有一个问题，在数据处理之前必须要判断缓冲区的数据是否完整或者已经读取完毕，如果没有，假设数据只读取了一部分，那么对不完整的数据处理没有任何意义。所以每次数据处理之前都要检测缓冲区数据。</p>
<p><strong>那么NIO和IO各适用的场景是什么呢？</strong></p>
<p>如果需要管理同时打开的<a href="https://link.zhihu.com/?target=https://www.baidu.com/s?wd=%E6%88%90%E5%8D%83%E4%B8%8A%E4%B8%87&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd">成千上万</a>个连接，这些连接每次只是发送少量的数据，例如<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=348917546&content_type=Answer&match_order=1&q=%E8%81%8A%E5%A4%A9%E6%9C%8D%E5%8A%A1%E5%99%A8&zhida_source=entity">聊天服务器</a>，这时候用NIO处理数据可能是个很好的选择。</p>
<p>而如果只有少量的连接，而这些连接每次要发送大量的数据，这时候传统的IO更合适。使用哪种处理数据，需要在数据的响应等待时间和检查缓冲区数据的时间上作比较来权衡选择。</p>
<p><strong>4，通俗解释</strong></p>
<h5 id="最后，对于NIO和传统IO，有一个网友讲的生动的例子："><a href="#最后，对于NIO和传统IO，有一个网友讲的生动的例子：" class="headerlink" title="最后，对于NIO和传统IO，有一个网友讲的生动的例子："></a>最后，对于NIO和传统IO，有一个网友讲的生动的例子：</h5><p>以前的流总是堵塞的，一个线程只要对它进行操作，其它操作就会被堵塞，也就相当于水管没有阀门，你伸手接水的时候，不管水到了没有，你就都只能耗在接水（流）上。</p>
<p>nio的Channel的加入，相当于增加了水龙头（有阀门），虽然一个时刻也只能接一个水管的水，但依赖轮换策略，在水量不大的时候，各个水管里流出来的水，都可以得到妥</p>
<p>善接纳，这个关键之处就是增加了一个接水工，也就是Selector，他负责协调，也就是看哪根水管有水了的话，在当前水管的水接到一定程度的时候，就切换一下：临时关上当前水龙头，试着打开另一个水龙头（看看有没有水）。</p>
<p>当其他人需要用水的时候，不是直接去接水，而是事前提了一个水桶给接水工，这个水桶就是Buffer。也就是，其他人虽然也可能要等，但不会在现场等，而是回家等，可以做其它事去，水接满了，接水工会通知他们。</p>
<p>这其实也是非常接近当前社会分工细化的现实，也是统分利用现有资源达到并发效果的一种很经济的手段，而不是动不动就来个并行处理，虽然那样是最简单的，但也是最浪费资源的方式。</p>
<h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><h3 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1.概述"></a>1.概述</h3><p>邮件：</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-02/cf09b1139d0685d05e0de851fd49a94d--4166--image-20241002192704353.png" alt="image-20241002192704353"></p>
<ul>
<li>计算机网络： 计算机网络是指将<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%9C%B0%E7%90%86">地理</a>位置不同的具有独立功能的多台<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA/140338">计算机</a>及其外部设备，通过通信线路连接起来，在<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3997">网络操作系统</a>，<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86%E8%BD%AF%E4%BB%B6/6579078">网络管理软件</a>及<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/4438611">网络通信协议</a>的管理和协调下，实现<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB/233480">资源共享</a>和信息传递的计算机系统。 </li>
<li>网络编程的目的：无线电台…传播交流信息，数据交换，通信。</li>
<li><strong>想要达到这个效果需要什么：</strong><ol>
<li>如何让准确的定位网络上的一台主机 192.168.16.124：端口， 定位上这个计算机上的某个资源。</li>
<li>找到了这个主机，如何传输数据呢？</li>
</ol>
</li>
<li>Javaweb:网页编程 、 B&#x2F;S架构</li>
<li>网络编程：TCP&#x2F;IP 、 C&#x2F;S</li>
</ul>
<h3 id="2-网络通信要素"><a href="#2-网络通信要素" class="headerlink" title="2.网络通信要素"></a>2.网络通信要素</h3><p><strong>如何实现网络的通信？</strong></p>
<ul>
<li>通信双方的地址：<ul>
<li>ip：192.168.16.124</li>
<li>端口：5900</li>
</ul>
</li>
<li><strong>规则：网络通信的协议</strong>：TCP&#x2F;IP</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-02/1248aa7b160d777171d9816f1f8e182c--de8e--image-20241002192722608.png" alt="image-20241002192722608"></p>
<blockquote>
<p>小结：</p>
</blockquote>
<ol>
<li>网络编程中有两个主要的问题：<ul>
<li>如何让准确的定位到网络上的一台或多台主机；</li>
<li>找到主机之后如何通信；</li>
</ul>
</li>
<li>网络编程中的要素：<ul>
<li>IP和端口号：IP</li>
<li>网络通信协议：UDP、TCP</li>
</ul>
</li>
<li>万物皆对象</li>
</ol>
<h3 id="3-IP"><a href="#3-IP" class="headerlink" title="3.IP"></a>3.IP</h3><p>IP 地址：InetAddress</p>
<ul>
<li><p>唯一定位一台网络上的计算机</p>
</li>
<li><p>127.0.0.1： 本机localhost</p>
</li>
<li><p>ip地址的父类</p>
<ul>
<li>&#x3D;&#x3D;IPV4&#x3D;&#x3D;： 127.0.0.1 ,4个字节组成。，0<del>255， 42亿</del>；30亿都在北美，亚洲4亿。2011年就用尽；</li>
<li>&#x3D;&#x3D;IPV6&#x3D;&#x3D;： fe80::f0e0:7383:ad8e:f32f%3 ，128位。8个无符号整数</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2406</span>:da18:ddf:<span class="number">4000</span>:67d5:b226:cad7:125b</span><br></pre></td></tr></table></figure>
</li>
<li><p>公网（互联网）–私网（局域网）</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://www.jb51.net/network/579228.html">ABCD地址</a></p>
</li>
<li><p>192.168.xx.xx,专门给组织内部使用。</p>
</li>
</ul>
</li>
<li><p>域名：记忆IP问题！</p>
<ul>
<li>IP：<a target="_blank" rel="noopener" href="http://www.vip.com/">www.vip.com</a></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.UnknownHostException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestInetAddress</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">InetAddress</span> <span class="variable">byName</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">            System.out.println(byName);</span><br><span class="line">            <span class="type">InetAddress</span> <span class="variable">byName2</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">            System.out.println(byName2);</span><br><span class="line">            <span class="type">InetAddress</span> <span class="variable">localHost</span> <span class="operator">=</span> InetAddress.getLocalHost();</span><br><span class="line">            System.out.println(localHost);</span><br><span class="line"></span><br><span class="line">            <span class="type">InetAddress</span> <span class="variable">byName1</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;www.taobao.com&quot;</span>);</span><br><span class="line">            System.out.println(byName1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">localhost/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">6pc1/<span class="number">192.168</span><span class="number">.56</span><span class="number">.1</span></span><br><span class="line">www.taobao.com/<span class="number">221.228</span><span class="number">.217</span><span class="number">.213</span></span><br></pre></td></tr></table></figure>

<h3 id="4-端口"><a href="#4-端口" class="headerlink" title="4.端口"></a>4.端口</h3><ul>
<li><p>端口表示计算机上一个程序的进程；</p>
</li>
<li><p>不同的进程有不同的端口号！用来区分软件！</p>
</li>
<li><p>被规定0~65535</p>
</li>
<li><p>TCP，UDP：65535*2个端口 tcp：80 udp：80 单个协议下，端口号不能冲突</p>
</li>
<li><p>端口分类</p>
<ul>
<li>共有端口 0~1023 内置的进程使用<ul>
<li>HTTP：80</li>
<li>HTTP：443 如访问https：&#x2F;&#x2F;<a target="_blank" rel="noopener" href="http://www.baidu.com:443/">www.baidu.com:443</a> 访问的还是百度</li>
<li>FTP：21</li>
<li>TELENT：23</li>
</ul>
</li>
<li>程序注册端口：1014-49151，分配给用户和程序<ul>
<li>Tomcat：8080</li>
<li>MySql：3306</li>
<li>Oracle：1521</li>
</ul>
</li>
<li>动态、私有端口：49152~65535</li>
</ul>
</li>
</ul>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">netstat -ano #查看所有的端口</span><br><span class="line">netstat -nao|<span class="built_in">findstr</span> &quot;<span class="number">7808</span>&quot; #查看指定的端口</span><br><span class="line">tasklist|<span class="built_in">findstr</span> &quot;<span class="number">8696</span>&quot;</span><br></pre></td></tr></table></figure>

<h3 id="5-通信协议"><a href="#5-通信协议" class="headerlink" title="5.通信协议"></a>5.通信协议</h3><p>协议：约定，就好比中国人交流说的是普通话</p>
<p><strong>网络通信协议：</strong> 速率，传输码率，代码结构，传输控制…</p>
<p><strong>问题</strong>：非常的复杂</p>
<p>大事化小：分层</p>
<p><strong>TCP&#x2F;IP协议簇：实际上是一组协议</strong></p>
<p>重要：</p>
<ul>
<li>TCP：用户传输协议</li>
<li>UDP：用户数据报协议</li>
</ul>
<p>出名的协议：</p>
<ul>
<li>TCP：</li>
<li>IP：网络互联协议</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-02/f1c84981f8b01587eff9be2fc64dd7a6--6362--image-20241002193643594.png" alt="image-20241002193643594"></p>
<p>CP UDP 对比**</p>
<ul>
<li><p>TCP：打电话</p>
<ul>
<li><p>连接，稳定</p>
</li>
<li><p>三次握手，四次挥手</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">最少需要三次，保证稳定连接！</span><br><span class="line">A：你瞅啥？</span><br><span class="line">B：瞅你咋地？</span><br><span class="line">A：干一场</span><br><span class="line"></span><br><span class="line">A：我要分手了</span><br><span class="line">B：我知道你要分手了</span><br><span class="line">B：你真的要分手吗？</span><br><span class="line">A：我真的要分手了</span><br></pre></td></tr></table></figure>
</li>
<li><p>客户端、服务器</p>
</li>
<li><p>传输完成，释放连接，效率低</p>
</li>
</ul>
</li>
<li><p>UDP;发短信</p>
<ul>
<li>不连接，不稳定</li>
<li>客户端、服务端：没有明确的解现</li>
<li>不管有没有准备好，都可以发给你</li>
<li>DDOS：洪水攻击！ 发垃圾包 堵塞线路 （饱和攻击）</li>
</ul>
</li>
</ul>
<h3 id="6-TCP"><a href="#6-TCP" class="headerlink" title="6.TCP"></a>6.TCP</h3><blockquote>
<p><strong>先启动服务端，再启动客户端！！！！</strong></p>
</blockquote>
<p><strong>客户端</strong></p>
<ul>
<li>连接服务器 Socket</li>
<li>发送消息</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TCPClientDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">accept</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1.要知道服务器的地址</span></span><br><span class="line">            <span class="type">InetAddress</span> <span class="variable">inetAddress</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">9999</span>;</span><br><span class="line">            <span class="comment">// 2.创建一个socket链接</span></span><br><span class="line">            accept = <span class="keyword">new</span> <span class="title class_">Socket</span>(inetAddress,port);</span><br><span class="line">            <span class="comment">// 3.发送信息IO流</span></span><br><span class="line">            os = accept.getOutputStream();</span><br><span class="line">            os.write(<span class="string">&quot;就这吧，什么鬼？咿呀咿呀哟咿呀咿呀哟&quot;</span>.getBytes());</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 关闭资源</span></span><br><span class="line">            <span class="keyword">if</span>(os != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    os.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(accept != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    accept.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>服务器端</strong></p>
<ul>
<li>建立服务的端口 ServerSocket</li>
<li>等待的用户的连接 accept</li>
<li>接收用户的消息</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TCPServerDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// 1.有一个地址</span></span><br><span class="line">            serverSocket = <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">9999</span>);</span><br><span class="line">            <span class="comment">// 2.等待客户端连接过来</span></span><br><span class="line">            socket = serverSocket.accept();</span><br><span class="line">            <span class="comment">// 3.读取客户端的消息</span></span><br><span class="line">            is = socket.getInputStream();</span><br><span class="line"></span><br><span class="line">           <span class="comment">/*</span></span><br><span class="line"><span class="comment">           //弃用 会有中文乱码</span></span><br><span class="line"><span class="comment">           byte[] buffer = new byte[1024];</span></span><br><span class="line"><span class="comment">            int len = 0;</span></span><br><span class="line"><span class="comment">            while ((len = is.read(bytes)) != -1)&#123;</span></span><br><span class="line"><span class="comment">                String s = new String(buffer,0,len);</span></span><br><span class="line"><span class="comment">                System.out.println(s);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 管道流</span></span><br><span class="line">            baos = <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line"></span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((len = is.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                baos.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(baos.toString());</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 关闭资源</span></span><br><span class="line">            <span class="keyword">if</span> (baos != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    baos.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (is != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    is.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (socket != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (serverSocket != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    serverSocket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-02/51f7dcfcdb8f0cd022e3ccd81021033a--b1f8--image-20241002194149715.png" alt="image-20241002194149715"></p>
<h4 id="2-初识Tomcat"><a href="#2-初识Tomcat" class="headerlink" title="2.初识Tomcat"></a>2.初识Tomcat</h4><blockquote>
<p>Tomcat乱码： conf\logging.properties 把UTF-8改为GBK</p>
</blockquote>
<p>服务端</p>
<ul>
<li>自定义 S</li>
<li>Tomcat服务器 S ：Java后台开发</li>
</ul>
<p>客户端</p>
<ul>
<li>自定义 C</li>
<li>浏览器 B</li>
</ul>
<h3 id="7-UDP"><a href="#7-UDP" class="headerlink" title="7.UDP"></a>7.UDP</h3><p> 发短信：不用连接，需要知道对方的地址 </p>
<h4 id="1-发送消息"><a href="#1-发送消息" class="headerlink" title="1.发送消息"></a>1.发送消息</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UDPClientDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 1、建立一个Socket</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">datagramSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();</span><br><span class="line">        <span class="comment">// 2、建个包</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;UDP服务器。你好！&quot;</span>;</span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">byName</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">9090</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 数据、数据的长度起始、要发送给谁</span></span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">datagramPacket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(msg.getBytes(), msg.getBytes().length, byName, port);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3、 发送包</span></span><br><span class="line">        datagramSocket.send(datagramPacket);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4、 关闭流</span></span><br><span class="line">        datagramSocket.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UDPServerDemo011</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//1、 开放端口</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">datagramSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">9090</span>);</span><br><span class="line">        <span class="comment">//2 、接受数据包</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">datagramPacket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(bytes, bytes.length);</span><br><span class="line"></span><br><span class="line">        datagramSocket.receive(datagramPacket);</span><br><span class="line">        System.out.println(datagramPacket.getAddress().getHostAddress());</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(datagramPacket.getData()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3、关闭连接</span></span><br><span class="line">        datagramSocket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-02/5470eb5dfe09d3ef6743df8efc80e6d6--759e--image-20241002195004190.png" alt="image-20241002195004190"></p>
<ul>
<li>长串乱码是接受使用的1024的byte</li>
</ul>
<h3 id="8-URL"><a href="#8-URL" class="headerlink" title="8.URL"></a>8.URL</h3><ul>
<li><p><a target="_blank" rel="noopener" href="https://www.baidu.com/">https://www.baidu.com</a></p>
</li>
<li><p>统一资源定位符：定位互联网上的某一个资源</p>
</li>
<li><p>DNS域名解析 <a target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a> —&gt; xxx.xxx.xxxx.xxx…xxx</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">协议：//ip地址：端口号/项目名/资源</span><br></pre></td></tr></table></figure>

<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="1、线程实现"><a href="#1、线程实现" class="headerlink" title="1、线程实现"></a>1、线程实现</h3><h4 id="1-线程的创建-三种方式"><a href="#1-线程的创建-三种方式" class="headerlink" title="1.线程的创建(三种方式)"></a>1.线程的创建(三种方式)</h4><blockquote>
<p>1.1 继承Thread类<strong>（重要）</strong></p>
<ul>
<li>自定义线程类继承<code>Thread</code>类；</li>
<li>重写<code>run()</code>方法，编写线程执行体；</li>
<li>创建线程对象，调用<code>start()</code>方法启动线程。</li>
</ul>
</blockquote>
<ul>
<li>可以直接使用lambo表达式开启多线程</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName());</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-02/a93581cde7b6ff6b5e0f388d3dc9bcbb--48bf--image-20241002200418140.png" alt="image-20241002200418140"></p>
<blockquote>
<p>1.2 实现Runnable接口</p>
<ul>
<li><strong>推荐使用Runnable对象,因为Java单继承的局限性</strong>；</li>
<li>自定义线程类实现<code>Runnable</code>接口；</li>
<li>实现<code>run()</code>方法,编写线程执行体；</li>
<li>创建线程对象,调用<code>start()</code>方法启动对象。</li>
</ul>
</blockquote>
<blockquote>
<p>1.3 实现Callable接口（了解）</p>
<ul>
<li>实现Callable接口，需要返回值类型；</li>
<li>重写call方法，需要抛出异常；</li>
<li>创建目标对象；</li>
<li>创建执行服务：ExecutorService ser &#x3D; Executors.newFixedThreadPool(1);</li>
<li>提交执行：Future result1 &#x3D; ser.submit(11);</li>
<li>获取结果：boolean r1 &#x3D; result1.get();</li>
<li>关闭服务：ser.shutdownNow();</li>
</ul>
</blockquote>
<h4 id="2-静态代理"><a href="#2-静态代理" class="headerlink" title="2.静态代理"></a>2.静态代理</h4><p><img src="http://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-06/0f21687c7dae4f514872b6eca338b761--d6f5--image-20241006132520284.png" alt="image-20241006132520284"></p>
<ul>
<li>总结<ul>
<li>真实对象和代理对象都要实现一个接口；</li>
<li>代理对象要代理真实角色。</li>
</ul>
</li>
<li>好处<ul>
<li>代理对象可以做很多真实对象做不了的事情；</li>
<li>真实对象专注做自己的事。</li>
</ul>
</li>
</ul>
<h4 id="3-Lambda表达式"><a href="#3-Lambda表达式" class="headerlink" title="3.Lambda表达式"></a>3.Lambda表达式</h4><p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-06/bfe245ecd11b4f7efae76acd496e5dfb--4306--image-20241006134641276.png" alt="image-20241006134641276"></p>
<ul>
<li>λ 希腊字母表中排序第十一位的字母，英语名称为 Lambda；</li>
<li>避免匿名内部类定义过多；</li>
<li>其实质属于函数式编程的概念；</li>
<li>去掉了一堆没有意义的代码,只留下核心逻辑。</li>
</ul>
<blockquote>
<ul>
<li><p>(params)-&gt; expression[表达式]</p>
</li>
<li><p>(params) -&gt; statement[语句]</p>
</li>
<li><p>(params)-&gt; {statements}</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a -&gt; System.out.println(<span class="string">&quot;i like lamda--&gt;&quot;</span>+a)</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>new Thread (()-&gt;System.out.println(“多线程学习。。。。”)).start()；</li>
<li>理解Functional Interface (函数式接口) 是学习Java 8 lambda表达式的关键</li>
</ul>
<blockquote>
<p>函数式接口的定义</p>
</blockquote>
<ul>
<li>任何接口，如果只包含唯一一个抽象方法，那么它就是一个函数式接口。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>对于函数式接口，我们可以通过Lambda表达式来创建该接口的对象。</li>
</ul>
<h3 id="2、线程状态"><a href="#2、线程状态" class="headerlink" title="2、线程状态"></a>2、线程状态</h3><h4 id="1-、线程的五大状态"><a href="#1-、线程的五大状态" class="headerlink" title="1 、线程的五大状态"></a>1 、线程的五大状态</h4><p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-06/6aa70bdff9b7d0ccaab0fcbf9e43512a--8967--image-20241006142241243.png" alt="image-20241006142241243"></p>
<h4 id="2、线程方法"><a href="#2、线程方法" class="headerlink" title="2、线程方法"></a>2、线程方法</h4><p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-06/93e398a6d304d22f3e9508b65e5d7db1--1d19--image-20241006142255177.png" alt="image-20241006142255177"></p>
<blockquote>
<p>停止线程</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-06/d789e0d2559d4467d10b7795d4a0f0b5--118e--image-20241006142311833.png" alt="image-20241006142311833"></p>
<blockquote>
<p>线程休眠</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-06/9b372cb18be71db388e8ce1c20f00bb7--45cf--image-20241006142329579.png" alt="image-20241006142329579"></p>
<blockquote>
<p>线程礼让</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-06/3c5e2afce39776a9856aa0325ae2015b--8dfd--image-20241006142802266.png" alt="image-20241006142802266"></p>
<blockquote>
<p>线程插队</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-06/a22edb7010caa4d6da813af49a570d10--683b--image-20241006142815613.png" alt="image-20241006142815613"></p>
<h4 id="3-线程状态观测"><a href="#3-线程状态观测" class="headerlink" title="3.线程状态观测"></a>3.线程状态观测</h4><p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-06/4558c3a3bcf24243d562cb6f6bc4fb81--e402--image-20241006142842061.png" alt="image-20241006142842061"></p>
<h4 id="4、线程优先级"><a href="#4、线程优先级" class="headerlink" title="4、线程优先级"></a>4、线程优先级</h4><p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-06/6f685bd89884419530aaba4167ddb2a0--365d--image-20241006142859222.png" alt="image-20241006142859222"></p>
<h4 id="5、守护线程"><a href="#5、守护线程" class="headerlink" title="5、守护线程"></a>5、守护线程</h4><ul>
<li>线程分为<strong>用户线程</strong>和<strong>守护线程</strong>；</li>
<li>虚拟机必须确保用户线程执行完毕；</li>
<li>虚拟机不用等待守护线程执行完毕；</li>
<li>如，后台记录操作日志，监控内存垃圾回收等待……</li>
</ul>
<h3 id="3、线程同步"><a href="#3、线程同步" class="headerlink" title="3、线程同步"></a>3、线程同步</h3><h4 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h4><ul>
<li>**多个线程操作同一个资源 **</li>
<li>并发：同一个对象被多个线程同时操作</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-06/d0acde08a8674b45418842b7d10eae38--d0c8--image-20241006143301494.png" alt="image-20241006143301494"></p>
<blockquote>
<p>线程同步：</p>
<ul>
<li>现实生活中我们会遇到“同—个资源，多个人都想使用”的问题，比如食堂排队打饭，每个人都想吃饭，最天然的解決办法就是：排队，一个个来。</li>
<li>处理多线程问题时，多个线程访问同一个对象，并且某些线程还想修改这个对象这时候我们就需要线程同步。线程同步其实就是一种等待机制，多个需要同时访问此对象的线程进入这个&#x3D;&#x3D;对象的等待池形&#x3D;&#x3D;成队列，等待前面线程使用完毕，下一个线程再使用。</li>
</ul>
</blockquote>
<ul>
<li>队列和锁</li>
</ul>
<blockquote>
<p>线程同步：</p>
<ul>
<li>由于同一进程的多个线程共享同一块存储空间，在带来方便的同时，也带来了访问冲突问题，为了保证数据在方法中被访问时的正确性，在访问时加入锁机制synchronized，当一个线程获得对象的排它锁，独占资源，其他线程必须等待使用后释放锁即可。存在以下问题：<ul>
<li>一个线程持有锁会导致其他所有需要此锁的线程挂起；</li>
<li>在多线程竞争下，加锁，释放锁会导致比较多的上下文切换和调度延时，引起性能问题；</li>
<li>如果一个优先级高的线程等待个优先级低的线程释放锁会导致优先级倒置，引起性能问题。</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="2、同步方法"><a href="#2、同步方法" class="headerlink" title="2、同步方法"></a>2、同步方法</h4><ul>
<li>由于我们可以通过 private关键字来保证数据对象只能被方法访问，所以我们只需要针对方法提岀一套机制，这套机制就是syη chronized关键字，它包括两种用法synchronized方法和 synchronized块。<ul>
<li>同步方法：public synchronized void method (int args) {}</li>
</ul>
</li>
<li>synchronized方法控制对“对象”的访问，每个对象对应一把锁，每个synchronized方法都必须获得调用该方法的对象的锁才能执行，否则线程会阻塞，方法一旦执行，就独占该锁，直到该方法返回才释放锁，后面被阻塞的线程才能获得这个锁，继续执行。<ul>
<li>缺陷：若将一个大的方法申明为 synchronized将会影响效率。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">BuyTicket</span> <span class="variable">buyTicket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BuyTicket</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(buyTicket, <span class="string">&quot;张三&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(buyTicket, <span class="string">&quot;李四&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(buyTicket, <span class="string">&quot;王五&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BuyTicket</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="comment">// 票</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">ticketNums</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                buy();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 买票</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">buy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ticketNums &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;拿到&quot;</span> + ticketNums--);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加锁前：</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-06/97851aa1659b6455ef2896b6e007843a--7088--image-20241006145802193.png" alt="image-20241006145802193"></p>
<p>加锁后：</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-06/2408cff000b434b3d05db3cbd12bdd9b--312f--image-20241006145827201.png" alt="image-20241006145827201"></p>
<h4 id="3-同步块"><a href="#3-同步块" class="headerlink" title="3.同步块"></a>3.同步块</h4><ul>
<li>同步块：synchronized (Obj) {}</li>
<li>obj称之为同步监视器<ul>
<li>Obj可以是任何对象，但是推存使用共享资源作为同步监视器。</li>
<li>同步方法中无需指定同步监视器，因为同步方法的同步监视器就是this，就是这个对象本身，或者是class。</li>
</ul>
</li>
<li>同步监视器的执行过程：<ul>
<li>1.第一个线程访问，锁定同步监视器，执行其中代码；</li>
<li>2.第二个线程访问，发现同步监视器被锁定，无法访问；</li>
<li>3.第一个线程访问完毕，解锁同步监视器；</li>
<li>4.第二个线程访问，发现同步监视器没有锁，然后锁定并访问。</li>
</ul>
</li>
</ul>
<p><strong>锁的对象就是变量的量,需要增删改查的对象</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Account</span> <span class="variable">account</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Account</span>(<span class="number">100</span>, <span class="string">&quot;养老基金&quot;</span>);</span><br><span class="line">        <span class="type">Drawing</span> <span class="variable">drawing</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Drawing</span>(account, <span class="number">60</span>, <span class="string">&quot;夸克&quot;</span>);</span><br><span class="line">        <span class="type">Drawing</span> <span class="variable">drawing2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Drawing</span>(account, <span class="number">100</span>, <span class="string">&quot;1111&quot;</span>);</span><br><span class="line">        <span class="type">Drawing</span> <span class="variable">same</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Drawing</span>(account, <span class="number">120</span>, <span class="string">&quot;same&quot;</span>);</span><br><span class="line">        drawing.start();</span><br><span class="line">        drawing2.start();</span><br><span class="line">        same.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span>&#123;</span><br><span class="line">    <span class="type">int</span> money;  <span class="comment">// 余额</span></span><br><span class="line">    String cardName;    <span class="comment">// 卡名</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Account</span><span class="params">(<span class="type">int</span> money, String cardName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.money = money;</span><br><span class="line">        <span class="built_in">this</span>.cardName = cardName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Drawing</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    Account account;    <span class="comment">// 账户</span></span><br><span class="line">    <span class="type">int</span> drawingMoney;   <span class="comment">// 取余额</span></span><br><span class="line">    <span class="type">int</span> nowMoney;   <span class="comment">// 个人手里的钱</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Drawing</span><span class="params">(Account account, <span class="type">int</span> drawingMoney, String name)</span> &#123;</span><br><span class="line">        <span class="comment">// super(name) =  父类构造方法(name)</span></span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        <span class="built_in">this</span>.account = account;</span><br><span class="line">        <span class="built_in">this</span>.drawingMoney = drawingMoney;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取钱</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 锁的对象就是变量的量,需要增删改查的对象</span></span><br><span class="line">        <span class="keyword">synchronized</span> (account) &#123;</span><br><span class="line">            <span class="comment">// 判断是否有钱</span></span><br><span class="line">            <span class="keyword">if</span> (account.money - drawingMoney &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;余额不足,不能进行取钱&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>); <span class="comment">// 放大问题的发生性</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 卡内金额 = 余额 - 个人手里的钱</span></span><br><span class="line">            account.money = account.money - drawingMoney;</span><br><span class="line">            <span class="comment">// 个人手里的钱</span></span><br><span class="line">            nowMoney = nowMoney + drawingMoney;</span><br><span class="line">            System.out.println(account.cardName + <span class="string">&quot;余额为:&quot;</span> + account.money);</span><br><span class="line">            <span class="comment">// this.getName()==Thread.currentThread().getName()</span></span><br><span class="line">            System.out.println(<span class="built_in">this</span>.getName() + <span class="string">&quot;手里的钱:&quot;</span> + nowMoney);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-死锁"><a href="#4-死锁" class="headerlink" title="4.死锁"></a>4.死锁</h4><ul>
<li>多个线程各自占有一些共享资源，并且互相等待其他线程占有的资源才能运行，而导致两个或者多个线程都在等待对方释放资源，都停止执行的情形。某一个同步块同时拥有“两个以上对象的锁”时，就可能会发生“死锁”的问题。</li>
</ul>
<blockquote>
<p>死锁:多个线程互相抱着对方需要的资源,然后形成僵持</p>
<p>解决:一个锁只锁一个对象</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Makeup</span> <span class="variable">makeup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Makeup</span>(<span class="number">0</span>, <span class="string">&quot;黄焖鸡&quot;</span>);</span><br><span class="line">        <span class="type">Makeup</span> <span class="variable">makeup1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Makeup</span>(<span class="number">1</span>, <span class="string">&quot;牛肉土豆粉&quot;</span>);</span><br><span class="line"></span><br><span class="line">        makeup.start();</span><br><span class="line">        makeup1.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 鸭脖</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DuckNeck</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 土豆粉</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PotatoPowder</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Makeup</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="comment">// 需要的资源只有一份,用static保证只有一份</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">DuckNeck</span> <span class="variable">duckneck</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DuckNeck</span>();</span><br><span class="line">    <span class="keyword">static</span> <span class="type">PotatoPowder</span> <span class="variable">potatoPowder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PotatoPowder</span>();</span><br><span class="line">    <span class="type">int</span> choice; <span class="comment">// 选择</span></span><br><span class="line">    String foodName;    <span class="comment">// 食品名称</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Makeup</span><span class="params">(<span class="type">int</span> choice, String foodName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.choice = choice;</span><br><span class="line">        <span class="built_in">this</span>.foodName = foodName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 美食</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            food();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">food</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line">        <span class="keyword">if</span>(choice == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (duckneck) &#123;    <span class="comment">// 获得鸭脖的锁</span></span><br><span class="line">                System.out.println(<span class="built_in">this</span>.foodName + <span class="string">&quot;获得鸭脖的锁&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (potatoPowder)&#123;    <span class="comment">// 一秒后想获得 土豆粉的锁</span></span><br><span class="line">                System.out.println(<span class="built_in">this</span>.foodName + <span class="string">&quot;获得土豆粉的锁&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (duckneck) &#123;    <span class="comment">// 获得鸭脖的锁</span></span><br><span class="line">                System.out.println(<span class="built_in">this</span>.foodName + <span class="string">&quot;获得鸭脖的锁&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (potatoPowder)&#123;    <span class="comment">// 一秒后想获得 土豆粉的锁</span></span><br><span class="line">                System.out.println(<span class="built_in">this</span>.foodName + <span class="string">&quot;获得土豆粉的锁&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>避免死锁的办法</p>
</blockquote>
<ul>
<li>产生死锁的四个必要条件<ul>
<li>1.互斥条件：一个资源毎次只能被一个进程使用。</li>
<li>2.请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li>
<li>3.不剥夺条件∶进程已获得的资源，在末使用完之前，不能强行剥夺。</li>
<li>4.循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。</li>
</ul>
</li>
<li>上面列出了死锁的四个必要条件，我们只要想办法破其中的任意一个或多个条件就可以避免死锁发生。</li>
</ul>
<h4 id="5、Lock（锁）"><a href="#5、Lock（锁）" class="headerlink" title="5、Lock（锁）"></a>5、Lock（锁）</h4><ul>
<li>从JDK 5.0开始, Java提供了更强大的线程同步机制一通过显式定义同步锁对象来实现同步。同步锁使用Lock对象充当。</li>
<li>java.util.concurrent.locks.Lock接口是控制多个线程对共享资源进行访问的工具。锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应先获得Lock对象。</li>
<li>ReentrantLock 类实现了 Lock，它拥有与 synchronized 相同的并发性和内存语义，在实现线程安全的控制中，比较常用的是ReentrantLock, 可以显式加锁、释放锁。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Reentrantlock lock <span class="keyword">new</span> <span class="title class_">Reen</span> TrantLock();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m</span><span class="params">()</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// 保证线程安全的代码</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span>&#123;</span><br><span class="line">            lock.unlock();	<span class="comment">// 如果同步代码有异常，要将unlock()写入finally语句块</span></span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h4 id="6-synchroized与Lock对比"><a href="#6-synchroized与Lock对比" class="headerlink" title="6.synchroized与Lock对比"></a>6.synchroized与Lock对比</h4><ul>
<li>Lock是显式锁 (手动开启和关闭锁，别忘记关闭锁) synchronized是隐式锁, 出了作用域自动释放。</li>
<li>Lock只有代码块锁, synchronized有代码块锁和方法锁。</li>
<li>使用Lock锁，JVM将花费较少的时间来调度线程, 性能更好。并且具有更好的扩展性 (提供更多的子类)。</li>
<li>优先使用顺序:<ul>
<li>Lock &gt; 同步代码块 (已经进入了方法体，分配了相应资源 $)&gt;$ 同步方法 (在方法体之外)</li>
</ul>
</li>
</ul>
<h3 id="4-线程通信问题"><a href="#4-线程通信问题" class="headerlink" title="4.线程通信问题"></a>4.线程通信问题</h3><ul>
<li>应用场景 : 生产者和消费者问题<ul>
<li>假设仓库中只能存放一件产品 , 生产者将生产出来的产品放入仓库，消费者将仓库中产品取走消费。</li>
<li>如果仓库中没有产品 , 则生产者将产品放入仓库，否则停止生产并等待，直到仓库中的产品被消费者取走为止。</li>
<li>如果仓库中放有产品 , 则消费者可以将产品取走消费，否则停止消费并等待，直到仓库中再次放入产品为止。</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-06/76a92767801a37f6cc81d492e28bb998--6b68--image-20241006152941896.png" alt="image-20241006152941896"></p>
<h4 id="1-线程通信方法"><a href="#1-线程通信方法" class="headerlink" title="1.线程通信方法"></a>1.线程通信方法</h4><ul>
<li>Java提供了几个方法解决线程之间的通信问题。</li>
</ul>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">wait()</td>
<td>表示线程一直等待，直到其他线程通知，与sleep不同会释放锁。</td>
</tr>
<tr>
<td align="center">wait(long timeout)</td>
<td>指定等待的毫秒数。</td>
</tr>
<tr>
<td align="center">notify()</td>
<td>唤醒一个处于等待状态的线程。</td>
</tr>
<tr>
<td align="center">notifyAll()</td>
<td>唤醒同一个对象上所有调用wait()方法的线程，优先级别高的线程优先调度。</td>
</tr>
</tbody></table>
<ul>
<li>注意：均是 Object类的方法，都只能在同步方法或者同步代码块中使用，否则会抛出异常IIIegalMonitorStateException。</li>
<li>这是一个线程同步问题，生产者和消费者共享同一个资源，并且生产者和消费者之间相互依赖，互为条件：<ul>
<li>对于生产者，没有生产产品之前，要通知消费者等待。而生产了产品之后，又需要马上通知消费者消费。</li>
<li>对于消费者，在消费之后，要通知生产者已经结束消费，需要生产新的产品以供消费。</li>
<li>在生产者消费者问题中，仅有 synchronized是不够的：<ul>
<li>synchronized可阻止并发更新同一个共享资源，实现了同步；</li>
<li>synchronized不能用来实现不同线程之间的消息传递通信。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-线程通信问题解决方式"><a href="#2-线程通信问题解决方式" class="headerlink" title="2.线程通信问题解决方式"></a>2.线程通信问题解决方式</h4><blockquote>
<p>解决方式一：</p>
<ul>
<li>并发协作模型“生产者&#x2F;消费者模式”–&gt;管程法：<ul>
<li>生产者∶负责生产数据的模块（可能是方法，对象，线程，进程）；</li>
<li>消费者：负责处理数据的模块（可能是方法，对象，线程，进程）；</li>
<li>缓冲区：消费者不能直接使用生产者的数据，他们之间有个“缓冲区”。</li>
</ul>
</li>
<li>生产者将生产好的数据放入缓冲区，消费者从缓冲区拿出数据。</li>
</ul>
</blockquote>
<h3 id="5-线程池"><a href="#5-线程池" class="headerlink" title="5.线程池"></a>5.线程池</h3><ul>
<li>背景：经常创建和销毁、使用量特别大的资源，比如并发情况下的线程，对性能影响很大。</li>
<li>思路：提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁、实现重复利用。类似生活中的公共交通工具。</li>
<li>好处：<ul>
<li>提高响应速度（减少了创建新线程的时间）；</li>
<li>降低资源消耗（重复利用线程池中线程，不需要毎次都创建）；</li>
<li>便于线程管理（…）<ul>
<li>corePoolsize：核心池的大小；</li>
<li>maximumPoolSize：最大线程数；</li>
<li>keepAliveTime：线程没有任务时最多保持多长时间后会终止。</li>
</ul>
</li>
</ul>
</li>
<li>JDK 5.0起提供了线程池相关AP:ExecutorService和 Executors。</li>
<li>ExecutorService：真正的线程池接口。常见子类 ThreadPoolExecutor。<ul>
<li>void execute（ Runnable command）：执行任务命令，没有返回值，一般用来执行 Runnable；</li>
<li><T> Future<T> submit（ Callable<T>妇ask）：执行任务，有返回值，一般又来执行Callable；</li>
<li>void shutdown（）：关闭连接池。</li>
</ul>
</li>
<li>Executors：工具类、线程池的工厂类，用于创建并返回不同类型的线程池。</li>
</ul>
<blockquote>
<p>多线程还得看JUC，后边也还会再记录的</p>
</blockquote>
<h2 id="注解与反射"><a href="#注解与反射" class="headerlink" title="注解与反射"></a>注解与反射</h2><p>注解使用的更多的是在后边的spring、springboot的框架中，会大量使用到各种注解。</p>
<h3 id="1、注解"><a href="#1、注解" class="headerlink" title="1、注解"></a>1、注解</h3><h4 id="1、注解入门"><a href="#1、注解入门" class="headerlink" title="1、注解入门"></a>1、注解入门</h4><ul>
<li><p>Annotation是jdk1.5开始引入的新技术。</p>
</li>
<li><p>Annotation的作用：</p>
<ul>
<li>不是程序本身，可以对程序作出解释；</li>
<li>可以被其他程序（例如编译器）读取。</li>
</ul>
</li>
<li><p>Annotation的格式</p>
<ul>
<li>“@注解名”，也可以带参数，例如：@SuppressWarnings(value&#x3D;“unchcked”)</li>
</ul>
</li>
<li><p>Annotation在哪里使用？</p>
<ul>
<li>可以附加在package、class、method、field上，相当于给它们添加了额外的辅助信息，还可以通过反射机制编程实现对这些元数据的访问。</li>
</ul>
</li>
</ul>
<h4 id="2-内置注解"><a href="#2-内置注解" class="headerlink" title="2.内置注解"></a>2.内置注解</h4><ul>
<li>@ Override：定义在 java. lang Override中，此注释只适用于修辞方法，表示一个方法声明打算重写超类中的另一个方法声明。</li>
<li>@ Deprecated：定义在 Java. lang. Deprecated中，此注释可以用于修辞方法，属性，类，表示不鼓励程序员使用这样的元素，通常是因为它很危险或者存在更好的选择。</li>
<li>@ SuppressWarnings：定义在 Java. lang. SuppressWarnings中，用来抑制编译时的警告信息。</li>
<li>与前两个注释有所不同，你需要添加一个参数才能正确使用，这些参数都是已经定义好了的，我们选择性的使用就好了。<ul>
<li>@SuppressWarnings （ “all”）</li>
<li>@SuppressWarnings （unchecked”）</li>
<li>@ SuppressWarnings（value&#x3D;f”unchecked”， “ deprecation “）</li>
<li>等等……</li>
</ul>
</li>
</ul>
<h4 id="3、自定义注解"><a href="#3、自定义注解" class="headerlink" title="3、自定义注解"></a>3、自定义注解</h4><ul>
<li>元注解的作用就是负责注解其他注解，Java定叉了4个标准的meta- annotation类型，他们被用来提供对其他 annotation类型作说明。</li>
<li>这些类型和它们所支持的类在 java. lang annotation包中可以找到。（@Target，@Retention，@Documented, @Inherited）<ul>
<li>@ Target：用于描述注解的使用范围（即被描述的注解可以用在什么地方）。</li>
<li>@ Retention：表示需要在什么级别保存该注释信息，用于描述注解的生命周期。<ul>
<li>SOURCE &lt; CLASS &lt; RUNTIME</li>
</ul>
</li>
<li>@ Document：说明该注解将被包含在 Javadoc中。</li>
<li>@ Inherited：说明子类可以继承父类中的该注解。</li>
</ul>
</li>
</ul>
<blockquote>
<p>自定义注解</p>
</blockquote>
<ul>
<li>使用@ interface自定义注解时，自动继承了 java. lang annotation. Annotation接口。</li>
<li>分析：<ul>
<li>@ interface用来声明一个注解，格式：public@ interface注解名{定义内容}</li>
<li>其中的每一个方法实际上是声明了一个配置参数；</li>
<li>方法的名称就是参数的名称。</li>
<li>返回值类型就是参数的类型（返回值只能是基本类型， Class, String,enum）</li>
<li>可以通过 defau来声明参数的默认值；</li>
<li>如果只有一个参数成员，一般参数名为vaue；</li>
<li>注解元素必须要有值，我们定义注解元素时，经常使用空字符串，0作为默认值</li>
</ul>
</li>
</ul>
<h3 id="2、反射机制"><a href="#2、反射机制" class="headerlink" title="2、反射机制"></a>2、反射机制</h3><h4 id="1-Java反射机制概念"><a href="#1-Java反射机制概念" class="headerlink" title="1.Java反射机制概念"></a>1.Java反射机制概念</h4><blockquote>
<ol>
<li>静态 &amp; 动态语言</li>
</ol>
</blockquote>
<ul>
<li>动态语言<ul>
<li>是一类在运行时可以改变其结构的语言：例如新的函数、对象、甚至代码可以被引进，已有的函数可以被删除或是其他结构上的变化。通俗点说就是在运行时代码可以根据某些条件改变自身结构。</li>
<li>主要动态语言：Object-C、C#、 JavaScript、PHP、 Python等。</li>
</ul>
</li>
<li>静态语言<ul>
<li>与动态语言相对应的，运行时结构不可变的语言就是静态语言。如Java、C、C++。</li>
<li>Java不是动态语言，但Java可以称之为“准动态语言”。即Java有一定的动态性我们可以利用反射机制获得类似动态语言的特性。Java的动态性让编程的时候更加灵活。</li>
</ul>
</li>
</ul>
<blockquote>
<ol start="2">
<li>反射机制概念</li>
</ol>
</blockquote>
<ul>
<li>Reflection（反射）是Java被视为动态语言的关键，反射机制允许程序在执行期借助于 Reflection AP取得仼何类的内部信息，并能直接操作任意对象的内部属性及方法。<ul>
<li>Class c&#x3D; Class.forName(“java. lang String”);</li>
</ul>
</li>
<li>加载完类之后，在堆內存的方法区中就产生了一个 Class类型的对象（一个类只有一个Cass对象），这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构，所以，我们形象的称之为：反射。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-06/35703c4b7c062b664191ec914bbb765c--ee70--image-20241006201713560.png" alt="image-20241006201713560"></p>
<blockquote>
<ol start="3">
<li>反射机制研究与应用</li>
</ol>
</blockquote>
<ul>
<li>Java反射机制提供的功能<ul>
<li>在运行时判断任意一个对象所属的类；</li>
<li>在运行时构造任意一个类的对象；</li>
<li>在运行时判断任意一个类所具有的成员变量和方法；</li>
<li>在运行时获取泛型信息；</li>
<li>在运行时调用任意一个对象的成员变量和方法；</li>
<li>在运行时处理注解；</li>
<li>生成动态代理；</li>
<li>……</li>
</ul>
</li>
</ul>
<blockquote>
<ol start="4">
<li>反射机制优缺点</li>
</ol>
</blockquote>
<ul>
<li>优点：<ul>
<li>可以实现动态创建对象和编译，体现出很大的灵活性。</li>
</ul>
</li>
<li>缺点<ul>
<li>对性能有影响。使用反射基本上是一种解释操作，我们可以告诉JVM，我们希望做什么并且它满足我们的要求。这类操作总是慢于直接执行相同的操作。</li>
</ul>
</li>
</ul>
<blockquote>
<p>&#x2F;*<br>        一个类在内存中只有一个Class对象<br>        一个类被加载后,类的整个结构都会被封装在Class对象中<br>        public native int hashCode();返回该对象的hash码值<br>        注：哈希值是根据哈希算法算出来的一个值，这个值跟地址值有关，但不是实际地址值。<br>         *&#x2F;</p>
</blockquote>
<h4 id="2-理解Class类并获取Class实例"><a href="#2-理解Class类并获取Class实例" class="headerlink" title="2.理解Class类并获取Class实例"></a>2.理解Class类并获取Class实例</h4><blockquote>
<ol>
<li>class类介绍</li>
</ol>
</blockquote>
<ul>
<li>在 Object类中定义了以下的方法，此方法将被所有子类继承<ul>
<li>public final Class getclass()</li>
</ul>
</li>
<li>以上的方法返回值的类型是一个 Class类，此类是Java反射的源头，实际上所谓反射从程序的运行结果来看也很好理解，即：可以通过对象反射求出类的名称。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-06/be9b8c63ed6e11166c584df0ec7d46bd--d62e--image-20241006203510092.png" alt="image-20241006203510092"></p>
<ul>
<li><p>对象照镜子后可以得到的信息：某个类的属性、方法和构造器、某个类到底实现了哪些接口对于每个类而言，JRE都为其保留一个不变的Cass类型的对象。一个Class对象包含了特定某个结构（ class&#x2F;interface&#x2F;enum&#x2F;annotation&#x2F; primitive type&#x2F;void&#x2F;[]）的有关信息。</p>
<ul>
<li>Class本身也是一个类；</li>
<li>Class对象只能由系统建立对象；</li>
<li>一个加载的类在JVM中只会有一个Class实例；</li>
<li>一个Cass对象对应的是一个加载到JM中的一个class文件；</li>
<li>每个类的实例都会记得自己是由哪个Class实例所生成；</li>
<li>通过class可以完整地得到一个类中的所有被加载的结构；</li>
<li>class类是 Reflection的根源，针对任何你想动态加载、运行的类，唯有先获得相应的Class对象。</li>
</ul>
</li>
<li><p>class类的常用方法</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>方法名</th>
<th>功能说明</th>
</tr>
</thead>
<tbody><tr>
<td>static ClassforName (String name)</td>
<td>返回指定类名name的class对象</td>
</tr>
<tr>
<td>Object newInstance ()</td>
<td>调用缺省构造函数，返回 Class对象的一个实例</td>
</tr>
<tr>
<td>getName ()</td>
<td>返回此Class对象所表示的实体（类，接口，数组类或void）的名称。</td>
</tr>
<tr>
<td>Class getSuperClass ()</td>
<td>返回当前class对象的父类的class对象</td>
</tr>
<tr>
<td>Class[] getinterfaces ()</td>
<td>获取当前 Class对象的接口</td>
</tr>
<tr>
<td>ClassLoader getclassLoader ()</td>
<td>返回该类的类加载器</td>
</tr>
<tr>
<td>Constructor getConstructors ()</td>
<td>返回一个包含某些 Constructor对象的数组</td>
</tr>
<tr>
<td>Method getMothed (String name, Class…T)</td>
<td>返回一个 Method对象，此对象的形参类型为paramType</td>
</tr>
<tr>
<td>Field[] getDeclaredFields ()</td>
<td>返回Field对象的一个数组</td>
</tr>
</tbody></table>
<blockquote>
<ol start="2">
<li>获取Class类的实例</li>
</ol>
</blockquote>
<ul>
<li>若已知具体的类，通过类的class属性获取，该方法最为安全可靠，程序性能最高。<ul>
<li>Class clazz&#x3D;Person.class;</li>
</ul>
</li>
<li>已知某个类的实例，调用该实例的 getclass () 方法获取Class对象。<ul>
<li>Class clazz&#x3D; person. getClass();</li>
</ul>
</li>
<li>已知一个类的全类名，且该类在类路径下，可通过class类的静态方法 forName（获取，可能抛出 ClassNotFound Exception。<ul>
<li>Class clazz Class forName（”demo01 Student”);</li>
</ul>
</li>
<li>内置基本数据类型可以直接用类名.Type。</li>
<li>还可以利用 Classloader。</li>
</ul>
<blockquote>
<ol start="3">
<li>哪些类型可以有Class对象</li>
</ol>
</blockquote>
<ul>
<li>class：外部类，成员（成员内部类，静态内部类），局部内部类，匿名内部类。</li>
<li>interface：接口</li>
<li>[]：数组</li>
<li>enum：枚举</li>
<li>annotation：注解@interface </li>
<li>primitive type：基本数据类型</li>
<li>void</li>
</ul>
<h4 id="3-类的加载与ClassLoader"><a href="#3-类的加载与ClassLoader" class="headerlink" title="3.类的加载与ClassLoader"></a>3.类的加载与ClassLoader</h4><blockquote>
<ol>
<li>Java内存分析</li>
</ol>
</blockquote>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-06/9738ef9679770afe7f810b8b1ec303a3--f08b--image-20241006203545571.png" alt="image-20241006203545571"></p>
<blockquote>
<ol start="2">
<li>类的加载</li>
</ol>
</blockquote>
<ul>
<li>当程序主动使用某个类时，如果该类还未被加载到内存中，则系统会通过如下三个步骤来对该类进行初始化。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-06/248f7b6bdbcc58f556d8a006ec4fd36b--6c52--image-20241006203555990.png" alt="image-20241006203555990"></p>
<ul>
<li>加载：将 class文件字节码內容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后生成一个代表这个类的 java. lang . Class对象。</li>
<li>链接：将Java类的二进制代码合并到JVM的运行状态之中的过程。<ul>
<li>验证：确保加载的类信息符合JVM规范，没有安全方面的问题。</li>
<li>准备：正式为类变量（ static）分配内存并设置类变量默认初始值的阶段，这些内存都将在方法区中进行分配。</li>
<li>解析：虚拟机常量池内的符号引用（常量名）替换为直接引用（地址）的过程。</li>
</ul>
</li>
<li>初始化：<ul>
<li>执行类构造器&lt; clinit&gt;方法的过程。类构造器&lt; clinit&gt;方法是由编译期自动收集类中所有类变量的赋值动作和静态代码块中的语句合并产生的。（类构造器是构造类信息的，不是构造该类对象的构造器）。</li>
<li>当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化。</li>
<li>虛拟机会保证一个类的&lt; clinit &gt;()方法在多线程环境中被正确加锁和同步。</li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_38075425/article/details/81627349">深刻理解类加载</a></li>
</ul>
<blockquote>
<ol start="3">
<li>什么时候会发生类初始化</li>
</ol>
</blockquote>
<ul>
<li>类的主动引用（一定会发生类的初始化）<ul>
<li>当虚拟机启动，先初始化main方法所在的类；</li>
<li>new一个类的对象；</li>
<li>调用类的静态成员（除了fina常量）和静态方法；</li>
<li>使用 java. lang. reflect包的方法对类进行反射调用；</li>
<li>当初始化一个类，如果其父类没有被初始化，则先会初始化它的父类。</li>
</ul>
</li>
<li>类的被动引用（不会发生类的初始化）<ul>
<li>当访问一个静态域时，只有真正声明这个域的类才会被初始化。如：当通过子类引用父类的静态变量，不会导致子类初始化；</li>
<li>通过数组定义类引用，不会触发此类的初始化；</li>
<li>引用常量不会触发此类的初始化（常量在链接阶段就存入调用类的常量池中了）。</li>
</ul>
</li>
</ul>
<blockquote>
<ol start="4">
<li>类加载器的作用</li>
</ol>
</blockquote>
<ul>
<li>类加载的作用：将 class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后在堆中生成一个代表这个类的 java. lang Class对象，作为方法区中类数据的访问入口。</li>
<li>类缓存：标准的 JavaSE类加载器可以按要求查找类，但一旦某个类被加载到类加载器中，它将维持加载（缓存）一段时间。不过JVM垃圾回收机制可以回收这些 Class对象</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-06/9281b634c599b8c2edfac30cb2009a79--e49a--image-20241006203627642.png" alt="image-20241006203627642"></p>
<ul>
<li>类加载器作用是用来把类（αlass）装载进内存的。JVM规范定义了如下类型的类的加载器。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-06/69b06ba5feeee963329165f6c7e8fae8--1373--image-20241006203652024.png" alt="image-20241006203652024"></p>
<ul>
<li>ClassLoader systemClassLoader &#x3D; ClassLoader.getSystemClassLoader();&#x2F;&#x2F;获取系统类的加载器</li>
<li>ClassLoader parent &#x3D; systemClassLoader.getParent();&#x2F;&#x2F;获取系统类加载器的父类加载器–&gt;扩展类加载器 jre1.8.0_91\lib\ext</li>
<li>ClassLoader parent1 &#x3D; parent.getParent();&#x2F;&#x2F;获取扩展类加载器父类加载器–&gt;根加载器(c&#x2F;c++) jre1.8.0_91\lib\rt.jar</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">// 获取系统类的加载器</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">systemClassLoader</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader();</span><br><span class="line">        System.out.println(systemClassLoader);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获得系统类加载器的父类加载器 ---&gt; 扩展类加载器   jre1.8.0_91\lib\ext</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">parent</span> <span class="operator">=</span> systemClassLoader.getParent();</span><br><span class="line">        System.out.println(parent);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取扩展类加载器的父类加载器  --&gt;  根加载器（C/c++）jre1.8.0_91\lib\rt.jar</span></span><br><span class="line">        <span class="comment">// 返回null是正常的，表示为根加载器</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">parent1</span> <span class="operator">=</span> parent.getParent();</span><br><span class="line">        System.out.println(parent1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试当前类是哪个加载器去加载的</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classDemo1</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;ClassDemo1&quot;</span>).getClassLoader();</span><br><span class="line">        System.out.println(classDemo1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试JDK内置的类是什么加载器加载的</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.String&quot;</span>).getClassLoader();</span><br><span class="line">        System.out.println(classLoader);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得系统类加载器可以加载的路径</span></span><br><span class="line">        System.out.println(System.getProperty(<span class="string">&quot;java.class.path&quot;</span>));</span><br><span class="line">        <span class="comment">//C:\Program Files\Java\jdk1.8.0_202\jre\lib\charsets.jar;C:\Program Files\Java\jdk1.8.0_202\jre\lib\deploy.jar;C:\Program Files\Java\jdk1.8.0_202\jre\lib\ext\access-bridge-64.jar;C:\Program Files\Java\jdk1.8.0_202\jre\lib\ext\cldrdata.jar;C:\Program Files\Java\jdk1.8.0_202\jre\lib\ext\dnsns.jar;C:\Program Files\Java\jdk1.8.0_202\jre\lib\ext\jaccess.jar;C:\Program Files\Java\jdk1.8.0_202\jre\lib\ext\jfxrt.jar;C:\Program Files\Java\jdk1.8.0_202\jre\lib\ext\localedata.jar;C:\Program Files\Java\jdk1.8.0_202\jre\lib\ext\nashorn.jar;C:\Program Files\Java\jdk1.8.0_202\jre\lib\ext\sunec.jar;C:\Program Files\Java\jdk1.8.0_202\jre\lib\ext\sunjce_provider.jar;C:\Program Files\Java\jdk1.8.0_202\jre\lib\ext\sunmscapi.jar;C:\Program Files\Java\jdk1.8.0_202\jre\lib\ext\sunpkcs11.jar;C:\Program Files\Java\jdk1.8.0_202\jre\lib\ext\zipfs.jar;C:\Program Files\Java\jdk1.8.0_202\jre\lib\javaws.jar;C:\Program Files\Java\jdk1.8.0_202\jre\lib\jce.jar;C:\Program Files\Java\jdk1.8.0_202\jre\lib\jfr.jar;C:\Program Files\Java\jdk1.8.0_202\jre\lib\jfxswt.jar;C:\Program Files\Java\jdk1.8.0_202\jre\lib\jsse.jar;C:\Program Files\Java\jdk1.8.0_202\jre\lib\management-agent.jar;C:\Program Files\Java\jdk1.8.0_202\jre\lib\plugin.jar;C:\Program Files\Java\jdk1.8.0_202\jre\lib\resources.jar;C:\Program Files\Java\jdk1.8.0_202\jre\lib\rt.jar;E:\JavaWeb\JVMDemo\out\production\JVMDemo;C:\Program Files\JetBrains\IntelliJ IDEA 2024.2.0.2\lib\idea_rt.jar</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="4-获取运行类的完整结构"><a href="#4-获取运行类的完整结构" class="headerlink" title="4.获取运行类的完整结构"></a>4.获取运行类的完整结构</h4><ul>
<li><p>通过反射获取运行时类的完整结构</p>
</li>
<li><p>Field、 Method、 Constructor.、 Superclass、 Interface、 Annotation</p>
</li>
<li><p>实现的全部接口</p>
</li>
<li><p>所继承的父类</p>
</li>
<li><p>全部的构造器</p>
</li>
<li><p>全部的方法</p>
</li>
<li><p>全部的Feld</p>
</li>
<li><p>注解</p>
</li>
<li><p>……</p>
</li>
<li><p>在实际的操作中，取得类的信息的操作代码，并不会经常开发。</p>
</li>
<li><p>一定要熟悉 java. lang .reflect包的作用，反射机制。</p>
</li>
<li><p>如何取得属性、方法、构造器的名称，修饰符等。</p>
</li>
</ul>
<h4 id="5-调用运行时类的指定结构"><a href="#5-调用运行时类的指定结构" class="headerlink" title="5.调用运行时类的指定结构"></a>5.调用运行时类的指定结构</h4><blockquote>
<ol>
<li>有Class对象,能做什么</li>
</ol>
</blockquote>
<ul>
<li>创建类的对象：调用 Class对象的 newInstance()方法<ul>
<li>1）类必须有一个无参数的构造器。</li>
<li>2）类的构造器的访问权限需要足够。</li>
</ul>
</li>
<li>思考？难道没有无参的构造器就不能创建对象了吗？只要在操作的时候明确的调用类中的构造器，并将参数传递进去之后，才可以实例化操作。</li>
<li>步骤如下：<ul>
<li>1）通过class类的 getDeclaredConstructor（ Class…， parameterTypes）取得本类的指定形参类型的构造器；</li>
<li>2）向构造器的形参中传递一个对象数组进去，里面包含了构造器中所需的各个参数。</li>
<li>3）通过 Constructo实例化对象</li>
</ul>
</li>
</ul>
<blockquote>
<p>2、方法及使用</p>
</blockquote>
<p>通过反射，调用类中的方法，通过 Method类完成。</p>
<ul>
<li>①通过Cas类的 getMethod（ String name, Class… parameterTypes）方法取得一个 Method对象，并设置此方法操作时所需要的参数类型。</li>
<li>②之后使用 Object invoke（ Object obj，Object[] args）进行调用，并向方法中传递要设置的ob对象的参数信息。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-07/7034533d6df0a76a9e47b90fe40965ff--d64e--image-20241007131846399.png" alt="image-20241007131846399"></p>
<blockquote>
<p>调用指定的方法：</p>
</blockquote>
<ul>
<li>Object invoke（object obj, Object. args）</li>
<li>Object对应原方法的返回值，若原方法无返回值，此时返回null；</li>
<li>若原方法若为静态方法，此时形参 Object obj可为null；</li>
<li>若原方法形参列表为空，则 Object[] args为null；</li>
<li>若原方法声明为 private，则需要在调用此 invoke（）方法前，显式调用方法对象的setAccessible（true）方法，将可访问 private的方法。</li>
</ul>
<blockquote>
<p>setAccessible </p>
</blockquote>
<ul>
<li>Method和 Field、 Constructor对象都有 setAccessible()方法。</li>
<li>setAccessible作用是启动和禁用访问安全检查的开关。</li>
<li>参数值为true则指示反射的对象在使用时应该取消Java语言访问检査。<ul>
<li>提高反射的效率。如果代码中必须用反射，而该句代码需要频繁的被调用，那么请设置为true；</li>
<li>使得原本无法访问的私有成员也可以访问；</li>
</ul>
</li>
<li>参数值为false则指示反射的对象应该实施Java语言访问检查。</li>
</ul>
<blockquote>
<ol start="3">
<li>性能检测</li>
</ol>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">经过反复测试得出结论：普通方式执行效率 &gt; 反射关闭检测方式执行效率 &gt; 反射方式执行效率</span><br></pre></td></tr></table></figure>

<h4 id="6-反射操作泛型"><a href="#6-反射操作泛型" class="headerlink" title="6.反射操作泛型"></a>6.反射操作泛型</h4><ul>
<li>Java采用泛型擦除的机制来引入泛型，Java中的泛型仅仅是给编译器javac使用的，确保数据的安全性和免去强制类型转换问题，但是，一旦编译完成，所有和泛型有关的类型全部擦除。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">泛型：</span><br><span class="line">Java 中的泛型仅仅是给编译器 javac 使用的，确保数据的 安全性和免去强制类型转换的麻烦，但是一旦编译完成，所 有与泛型有关的类型全部擦除。</span><br><span class="line">使用泛型直接读取泛型，是读取不到的，因为反射是操作 加载以后的类的。</span><br><span class="line">Java 新增的数据类型：</span><br><span class="line">为了通过反射操作这些类型以迎合实际开发的需要</span><br><span class="line">1) ParameterizedType： 表 示 一 种 参 数 化 的 类 型 ,比 如Collection&lt;String&gt;,可以获取 String 信息</span><br><span class="line">2) GenericArrayType：泛型数组类型</span><br><span class="line">3) TypeVariable：各种类型变量的公共父接口</span><br><span class="line">4) WildcardType：代表一种通配符类型表达式， 比如? extends Number,? super Integer (Wildcard 是一个单词，就是通配符)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">那么泛型是什么？？？</span><br><span class="line"></span><br><span class="line">泛型 ，顾名思义就是 广泛的数据类型，也就是说什么数据类型都可以。</span><br><span class="line">一般来说，我们见到的泛型就是这个样子，用 T 表示。</span><br><span class="line">如下所示，在类名后方申明泛型 T，接着就可以在成员变量、方法中使用泛型了。</span><br></pre></td></tr></table></figure>

<h4 id="7-反射操作注解"><a href="#7-反射操作注解" class="headerlink" title="7.反射操作注解"></a>7.反射操作注解</h4><ul>
<li>getAnnotations </li>
<li>getAnntation</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-07/50328b5e689195ee970a7c76472b1ada--b0a1--image-20241007134552563.png"></p>
<h2 id="JAVA-SE总结"><a href="#JAVA-SE总结" class="headerlink" title="JAVA SE总结"></a>JAVA SE总结</h2><p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-07/fd06ebf085a98d84cd36f4775d52280d--5015--Java%20SE.png" alt="Java SE"></p>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2024/06/03/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/" rel="prev" title="应急响应">
                  <i class="fa fa-angle-left"></i> 应急响应
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2024/09/17/redis%E5%AD%A6%E4%B9%A0/" rel="next" title="redis学习">
                  redis学习 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments" id="waline"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2023 – 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">6pc1</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">453k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">6:51</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




<script class="next-config" data-name="waline" type="application/json">{"lang":"zh-cn","enable":true,"serverURL":"waline-server-pi-one.vercel.app","cssUrl":"https://unpkg.com/@waline/client@v2/dist/waline.css","commentCount":true,"pageview":false,"placeholder":"请文明评论呀","avatar":"mm","meta":["nick","mail","link"],"pageSize":10,"visitor":false,"comment_count":true,"requiredFields":[],"libUrl":"//unpkg.com/@waline/client@v2/dist/waline.js","el":"#waline","comment":true,"path":"/2024/09/14/Java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/"}</script>
<link rel="stylesheet" href="https://unpkg.com/@waline/client@v2/dist/waline.css">
<script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script>


  <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas> 
  <script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script> 
  <script type="text/javascript" src="/js/fireworks.js"></script>
</body>
</html>
