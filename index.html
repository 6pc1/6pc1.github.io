<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.0.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" integrity="sha256-CTSx/A06dm1B063156EVh15m6Y67pAjZZaQc89LLSrU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"6pc1.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.18.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/./search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="6pc1&#39;s blog">
<meta property="og:url" content="http://6pc1.github.io/index.html">
<meta property="og:site_name" content="6pc1&#39;s blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="6pc1">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://6pc1.github.io/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>6pc1's blog</title>
  







<link rel="dns-prefetch" href="waline-server-pi-one.vercel.app">
  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">6pc1's blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">世界如画，心中有梦!</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="6pc1"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">6pc1</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">15</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/6pc1" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;6pc1" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:2961816476@qq.com" title="E-Mail → mailto:2961816476@qq.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://qm.qq.com/q/uZSUzwBesa" title="QQ → https:&#x2F;&#x2F;qm.qq.com&#x2F;q&#x2F;uZSUzwBesa" rel="noopener me" target="_blank"><i class="fab fa-qq fa-fw"></i>QQ</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
    <div class="sidebar-inner sidebar-blogroll">
      <div class="links-of-blogroll animated">
        <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
          链接
        </div>
        <ul class="links-of-blogroll-list">
            <li class="links-of-blogroll-item">
              <a href="https://hacbit.tech/" title="https:&#x2F;&#x2F;hacbit.tech&#x2F;" rel="noopener" target="_blank">hacbit</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="https://yixinbc.tech/" title="https:&#x2F;&#x2F;yixinbc.tech&#x2F;" rel="noopener" target="_blank">yixinBC</a>
            </li>
            <li class="links-of-blogroll-item">
              <a href="http://clearwine.online/" title="http:&#x2F;&#x2F;clearwine.online" rel="noopener" target="_blank">qinjiu</a>
            </li>
        </ul>
      </div>
    </div>
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://6pc1.github.io/2024/10/07/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="6pc1">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="6pc1's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 6pc1's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/10/07/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" class="post-title-link" itemprop="url">JUC并发编程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2024-10-07 14:15:39 / 修改时间：20:56:31" itemprop="dateCreated datePublished" datetime="2024-10-07T14:15:39+08:00">2024-10-07</time>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2024/10/07/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2024/10/07/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>6.4k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>6 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="1、JUC介绍"><a href="#1、JUC介绍" class="headerlink" title="1、JUC介绍"></a>1、JUC介绍</h1><p><strong>源码+官方文档</strong></p>
<p>java.util.concurrent</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-07/2ddf094e6a13c1260581e88ddaafb21b--dba2--image-20241007142426475.png" alt="image-20241007142426475"></p>
<p>普通的线程代码Thread</p>
<p>Runnable没有返回值，效率相比Callable相对较低</p>
<h1 id="2、线程与进程"><a href="#2、线程与进程" class="headerlink" title="2、线程与进程"></a>2、线程与进程</h1><blockquote>
<p>进程、线程</p>
</blockquote>
<p>进程：就比如你桌面上的任何一个软件，QQ、微信这些</p>
<p>一个进程可以包含多个线程，至少也有一个线程</p>
<p>Java默认就是有两个线程：①main线程。②GC垃圾回收线程</p>
<p>但是有一个问题就是？</p>
<p><strong>Java真的可以开启线程吗？  —–不可以！</strong></p>
<p>Thread部分源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This method is not invoked for the main method thread or &quot;system&quot;</span></span><br><span class="line"><span class="comment">     * group threads created/set up by the VM. Any new functionality added</span></span><br><span class="line"><span class="comment">     * to this method in the future may have to also be added to the VM.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * A zero status value corresponds to state &quot;NEW&quot;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (threadStatus != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalThreadStateException</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Notify the group that this thread is about to be started</span></span><br><span class="line"><span class="comment">     * so that it can be added to the group&#x27;s list of threads</span></span><br><span class="line"><span class="comment">     * and the group&#x27;s unstarted count can be decremented. */</span></span><br><span class="line">    group.add(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">started</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        start0();</span><br><span class="line">        started = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!started) &#123;</span><br><span class="line">                group.threadStartFailed(<span class="built_in">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">            <span class="comment">/* do nothing. If start0 threw a Throwable then</span></span><br><span class="line"><span class="comment">              it will be passed up the call stack */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//本地方法，底层的C++ java无法直接操作硬件</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">start0</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-07/e4042aa096489027d5a5149a194e444f--1875--image-20241007143609517.png" alt="image-20241007143609517">并发、并行</p>
<p>并发（多线程操作同一个资源）</p>
<ul>
<li>CPU单核，模拟出来多条线程，天下武功，唯快不破，快速交替</li>
</ul>
<p>并行（多个人一次行走）</p>
<ul>
<li>CPU多核，多个线程可以同时执行;线程池</li>
</ul>
<p>查询cpu核数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//查询cpu核数</span></span><br><span class="line">        <span class="comment">//CPU 密集型，IO密集型</span></span><br><span class="line">        System.out.println(Runtime.getRuntime().availableProcessors());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并发编程的本质：<strong>充分利用CPU的资源</strong></p>
<h1 id="3、回顾多线程"><a href="#3、回顾多线程" class="headerlink" title="3、回顾多线程"></a>3、回顾多线程</h1><p>线程有几个状态 – 6种   直接就是能够看源码</p>
<pre><code>public enum State &#123;
    /**
     * 新建
     */
    NEW,

    /**
     * 运行
     */
    RUNNABLE,

    /**
     * 阻塞
     */
    BLOCKED,

    /**
     * 等待，死死的等
     */
    WAITING,

    /**
     * 超时等待
     */
    TIMED_WAITING,

    /**
     * 停止
     */
    TERMINATED;
&#125;
</code></pre>
<blockquote>
<p>wait和sleep的区别</p>
</blockquote>
<ol>
<li><p>来自不同的类</p>
<ul>
<li><p>wait—-&gt;Object</p>
</li>
<li><p>sleep—-&gt;Thread</p>
</li>
</ul>
</li>
<li><p>关于锁的释放</p>
<ul>
<li>wait会释放锁</li>
<li>sleep不会释放锁，抱着锁睡觉</li>
</ul>
</li>
<li><p>使用的范围是不同的</p>
<ul>
<li>wait必须在同步代码块中</li>
<li>sleep可以在任何地方睡</li>
</ul>
</li>
</ol>
<h1 id="4、传统的Synchronized锁"><a href="#4、传统的Synchronized锁" class="headerlink" title="4、传统的Synchronized锁"></a>4、传统的Synchronized锁</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JUCDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Ticket</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ticket</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">50</span>;i++)&#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ticket</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sale</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (number &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;买了第&quot;</span> + (number--) + <span class="string">&quot;张票&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-07/c64f5494484b8e7234a3701e9859968e--6fcc--image-20241007145819476.png" alt="image-20241007145819476"></p>
<h1 id="5、Lock锁"><a href="#5、Lock锁" class="headerlink" title="5、Lock锁"></a>5、Lock锁</h1><p>加锁，释放锁</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-07/31d30e67e91ca403f77b1d79ff83854f--4308--image-20241007150354933.png" alt="image-20241007150354933"></p>
<p>实现类（可重入锁，读锁，写锁）</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-07/31664e900c7c465ea6434932a42d1e4f--c0fd--image-20241007150402819.png" alt="image-20241007150402819"></p>
<p>可重入锁构造方法</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-07/fc7c55397daed14671d863d701b29fd5--b6f6--image-20241007150515820.png" alt="image-20241007150515820"></p>
<p>公平锁：十分公平，可以先来后到</p>
<p>非公平锁：十分不公平，可以插队（默认）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JUCDemo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Ticket2</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ticket2</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1.创建锁 Lock lock = new ReentrantLock();</span></span><br><span class="line"><span class="comment"> * 2.加锁 lock.lock();</span></span><br><span class="line"><span class="comment"> * 3.释放锁 lock.unlock();</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ticket2</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sale</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//加锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (number &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;买了第&quot;</span> + (number--) + <span class="string">&quot;张票&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="6、Synchronized和Lock区别"><a href="#6、Synchronized和Lock区别" class="headerlink" title="6、Synchronized和Lock区别"></a>6、Synchronized和Lock区别</h1><ol>
<li>Synchronized 内置的java关键字，Lock是一个java类</li>
<li>Synchronized 无法判断获取锁的状态，Lock可以判断是否获取到了锁</li>
<li>Synchronized 会自动释放锁，Lock必须手动释放锁，如果不释放锁，会导致死锁！</li>
<li>Synchronized 线程1（获得锁，阻塞）、线程2（等待，傻傻的等）；Lock就不一定会等待下去</li>
<li>Synchronized，可重入锁，不可以中断，非公平；Lock，可重入锁，可以判断锁，非公平（自己可以设置）</li>
<li>Synchronized 使用锁少量的代码同步问题，Lock适合锁大量的同步代码</li>
</ol>
<h1 id="7、传统的生产者消费者问题，防止虚假唤醒"><a href="#7、传统的生产者消费者问题，防止虚假唤醒" class="headerlink" title="7、传统的生产者消费者问题，防止虚假唤醒"></a>7、传统的生产者消费者问题，防止虚假唤醒</h1><blockquote>
<p>生产者和消费者问题 Synchronized 版本</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JUCDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Data</span> <span class="variable">data</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Data</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.increment();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.decrement();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (number != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//等待</span></span><br><span class="line">            <span class="built_in">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        number++;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;==&gt;&quot;</span> + number);</span><br><span class="line">        <span class="comment">//通知其他线程，我+1完毕了</span></span><br><span class="line">        <span class="built_in">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">decrement</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (number == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//等待</span></span><br><span class="line">            <span class="built_in">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        number--;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;==&gt;&quot;</span> + number);</span><br><span class="line">        <span class="comment">//通知其他线程，我-1完毕了</span></span><br><span class="line">        <span class="built_in">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-07/976a1f91671bb25cb52b52043dcb8113--adf1--image-20241007204343421.png" alt="image-20241007204343421"></p>
<p>问题存在，如果是A B C D 四个线程（可能不会出现上面预期的结果，可能是有2,3出现）  -》 虚假唤醒</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-07/7f842efd6b130dc531b89023ae585232--34bd--image-20241007204432193.png" alt="image-20241007204432193"></p>
<p><strong>解决：把if 改成while</strong></p>
<p>用if判断的话，唤醒后线程会从wait之后的代码开始运行，但是不会重新判断if条件，直接继续运行if代码块之后的代码，而如果使用while的话，也会从wait之后的代码运行，但是唤醒后会重新判断循环条件，如果不成立再执行while代码块之后的代码块，成立的话继续wait。</p>
<p>拿两个加法线程A、C来说，比如A先执行，执行时调用了wait方法，那它会等待，此时会释放锁，那么线程C获得锁并且也会执行wait方法，两个加线程一起等待被唤醒。此时减线程中的某一个线程执行完毕并且唤醒了这俩加线程，那么这俩加线程不会一起执行，其中A获取了锁并且加1，执行完毕之后C再执行。如果是if的话，那么A修改完num后，C不会再去判断num的值，直接会给num+1。如果是while的话，A执行完之后，C还会去判断num的值，因此就不会执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Data</span> <span class="variable">data</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Data</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.increment();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.decrement();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.increment();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;C&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.decrement();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;D&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (number != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//等待</span></span><br><span class="line">            <span class="built_in">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        number++;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;==&gt;&quot;</span> + number);</span><br><span class="line">        <span class="comment">//通知其他线程，我+1完毕了</span></span><br><span class="line">        <span class="built_in">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">decrement</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (number == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//等待</span></span><br><span class="line">            <span class="built_in">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        number--;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;==&gt;&quot;</span> + number);</span><br><span class="line">        <span class="comment">//通知其他线程，我-1完毕了</span></span><br><span class="line">        <span class="built_in">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://6pc1.github.io/2024/09/14/Java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="6pc1">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="6pc1's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 6pc1's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/09/14/Java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/" class="post-title-link" itemprop="url">Java学习之旅</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-09-14 18:31:37" itemprop="dateCreated datePublished" datetime="2024-09-14T18:31:37+08:00">2024-09-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-10-07 14:10:02" itemprop="dateModified" datetime="2024-10-07T14:10:02+08:00">2024-10-07</time>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2024/09/14/Java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2024/09/14/Java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>87k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1:19</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="一、Java-SE基础"><a href="#一、Java-SE基础" class="headerlink" title="一、Java SE基础"></a>一、Java SE基础</h1><p>​	这里就是Java学习的开始，从这开始我的Java复习，以及笔记整理之路。</p>
<h2 id="计算机预科"><a href="#计算机预科" class="headerlink" title="计算机预科"></a>计算机预科</h2><p>​	这都是最基础的，大概就提一下。</p>
<p>1、打开CMD</p>
<p>2、管理员身份运行CMD</p>
<p>3、常见的Dos命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cd  切换路径</span><br><span class="line">dir 查看目录</span><br><span class="line">exit  退出终端</span><br><span class="line">ipconfig  查看电脑ip信息</span><br><span class="line">calc  打开计算器</span><br><span class="line">mspaint  打开画图</span><br><span class="line">notepad  打开记事本</span><br><span class="line">ping  对网站发起ping操作</span><br><span class="line">md或mkdir  创建文件夹</span><br><span class="line">rmdir或rd  删除空目录</span><br><span class="line">del 删除目录或文件</span><br></pre></td></tr></table></figure>

<h2 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h2><h3 id="1、Java简介"><a href="#1、Java简介" class="headerlink" title="1、Java简介"></a>1、Java简介</h3><ul>
<li><p>Java的特性和优势</p>
<ul>
<li>简单性</li>
<li>面向对象</li>
<li>可移植性</li>
<li>高性能</li>
<li>分布式</li>
<li>动态性</li>
<li>多线程</li>
<li>安全性</li>
<li>健壮性</li>
</ul>
</li>
<li><p>Java的三大版本</p>
<ul>
<li>JavaSE： 标准版（桌面程序、控制台开发……）</li>
<li>JavaME：嵌入式开发（手机、加点…..）</li>
<li>JavaEE：企业级开发（Web端、服务器开发……）</li>
</ul>
</li>
<li><p>Java的安装与卸载开发环境（这个网上都有的，搜下很多）</p>
</li>
</ul>
<h3 id="2、Hello-World"><a href="#2、Hello-World" class="headerlink" title="2、Hello World"></a>2、Hello World</h3><ul>
<li>代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World!Java!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以直接通过java先编译为字节码class文件再执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javac Hello.java           ---&gt;得到Hello.class</span><br><span class="line">java Hello.class           ---&gt;Hello World!Java!</span><br></pre></td></tr></table></figure>

<ul>
<li><p>注释</p>
<p>java中的注释有三种</p>
<ul>
<li>单行注释：只能注释一行文字   Ctrl  + &#x2F;</li>
<li>多行注释：可以注释一段文字  Ctrl  +  Shift +  &#x2F;</li>
<li>文档注释：一般用于表名文档创建者、创建日期、说明等</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//   单行注释</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	多行注释</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 文档注释</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h3 id="3、标识符和关键字"><a href="#3、标识符和关键字" class="headerlink" title="3、标识符和关键字"></a>3、标识符和关键字</h3><ul>
<li><p>标识符</p>
<ul>
<li>所有的标识符都应该以字母，$符号或者下划线开始</li>
<li>不能使用关键字作为变量名或者方法名</li>
<li>不建议使用中文或者拼音</li>
</ul>
</li>
<li><p>关键字</p>
<table>
<thead>
<tr>
<th>abstract</th>
<th>boolean</th>
<th>break</th>
<th>byte</th>
<th>case</th>
</tr>
</thead>
<tbody><tr>
<td>catch</td>
<td>char</td>
<td>const</td>
<td>class</td>
<td>continue</td>
</tr>
<tr>
<td>default</td>
<td>do</td>
<td>double</td>
<td>else</td>
<td>extends</td>
</tr>
<tr>
<td>final</td>
<td>finally</td>
<td>float</td>
<td>for</td>
<td>goto</td>
</tr>
<tr>
<td>if</td>
<td>implements</td>
<td>import</td>
<td>instanceof</td>
<td>int</td>
</tr>
<tr>
<td>interface</td>
<td>long</td>
<td>native</td>
<td>new</td>
<td>package</td>
</tr>
<tr>
<td>private</td>
<td>protected</td>
<td>public</td>
<td>return</td>
<td>short</td>
</tr>
<tr>
<td>static</td>
<td>strictfp</td>
<td>super</td>
<td>switch</td>
<td>this</td>
</tr>
<tr>
<td>throw</td>
<td>throws</td>
<td>transient</td>
<td>try</td>
<td>void</td>
</tr>
<tr>
<td>volatile</td>
<td>while</td>
<td>synchronized</td>
<td></td>
<td></td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="4、数据类型"><a href="#4、数据类型" class="headerlink" title="4、数据类型"></a>4、数据类型</h3><ul>
<li><p>静态类型语言</p>
<ul>
<li>变量定义时有类型声明的语言</li>
</ul>
</li>
<li><p>强类型语言</p>
<ul>
<li>强制数据类型定义的语言。也就是说，一旦一个变量被指定了某个数据类型，如果不经过强制转换，那么它就永远是这个数据类型了。</li>
</ul>
</li>
<li><p>数据类型基本分类</p>
<ul>
<li>基本类型<ul>
<li>数值类型<ul>
<li>整数<ul>
<li>byte   1字节   -128~127   （一字节八位）</li>
<li>short  2字节   -2^15~2^15-1</li>
<li>int       4字节   -2^31~2^31-1</li>
<li>long    8字节   -2^63~2^63-1</li>
</ul>
</li>
<li>浮点数<ul>
<li>float   4字节</li>
<li>double   8字节</li>
</ul>
</li>
<li>字符<ul>
<li>char  2字节</li>
</ul>
</li>
<li>布尔<ul>
<li>boolean  1位 只有true和false两值</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>引用类型<ul>
<li>类</li>
<li>接口</li>
<li>数组</li>
</ul>
</li>
</ul>
</li>
<li><p>什么是字节</p>
<ul>
<li>位（bit） 计算机内部数据存储的最小单位， 1011 1101是一个八位的二进制数</li>
<li>字节（byte）  是计算机中数据处理的基本单位，习惯用大写B表示，1B（byte字节） &#x3D;  8bit（位）</li>
<li>字符：是指计算机中使用的字母、数字、字和符号。<ul>
<li>1bit表示1位</li>
<li>1Byte表示一个字节1B&#x3D;8b</li>
<li>1024B&#x3D;1KB</li>
<li>1024KB&#x3D;1M</li>
<li>1024M&#x3D;1G</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>数据类型拓展</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不同进制的表示</span></span><br><span class="line"><span class="type">int</span> i=<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="number">010</span>;   <span class="comment">// 八进制0</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i3</span> <span class="operator">=</span> <span class="number">0x10</span>;  <span class="comment">// 十六进制0x</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 转义字符</span></span><br><span class="line"><span class="comment">// \t   制表符</span></span><br><span class="line"><span class="comment">// \n   换行</span></span><br></pre></td></tr></table></figure>

<h3 id="5、类型转换"><a href="#5、类型转换" class="headerlink" title="5、类型转换"></a>5、类型转换</h3><ul>
<li><p>由于Java是强类型语言，所以在进行某些运算的时候，需要进行对应的类型转换</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">低 ------------------------------------------------&gt; 高</span><br><span class="line"><span class="type">byte</span> -&gt; <span class="type">short</span> -&gt; <span class="type">char</span> -&gt; <span class="type">int</span> -&gt; <span class="type">long</span> -&gt; <span class="type">float</span> -&gt; <span class="type">double</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>运算中，不同类型的数据先转化为统一类型在进行运算</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//强制类型转换</span></span><br><span class="line">(<span class="type">int</span>)<span class="number">12.3</span> ---&gt; <span class="number">12</span></span><br><span class="line">(<span class="type">double</span>)<span class="number">12</span>  ----&gt;  <span class="number">12.00</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">// 不过要注意数据类型的大小，防止内存溢出的出现</span></span><br><span class="line"><span class="comment">// JDK7新特性，数字之间可以用下划线分割</span></span><br><span class="line"><span class="type">int</span> <span class="variable">money</span> <span class="operator">=</span> <span class="number">10_0000_0000</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="6、变量与常量"><a href="#6、变量与常量" class="headerlink" title="6、变量与常量"></a>6、变量与常量</h3><ul>
<li>变量：可以变化的量 </li>
<li>Java是一种强类型语言，每个变量都要申明其数据类型</li>
<li>Java变量是程序中最基本的存储单元，其要素包括变量名、变量类型和作用域</li>
<li>每个变量都必须要有对应的类型，可以使基本类型也可以是引用类型</li>
<li>变量名必须是合法的标识符</li>
<li>变量声明需要以分号结尾</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类变量 static</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">double</span> <span class="variable">salary</span> <span class="operator">=</span> <span class="number">2500</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例变量:从属于对象：实例变量：从属于对象；如果不自行初始化，这个类型的默认值 0 0.0</span></span><br><span class="line"><span class="comment">// 布尔值：默认是 faLse</span></span><br><span class="line"><span class="comment">// 除了基本类型，其余的都是null</span></span><br></pre></td></tr></table></figure>

<ul>
<li>变量的一些命名规范（使你的代码更加规范化）<ul>
<li>所有变量、方法、类名：见名如意（可以采用英文命名）</li>
<li>类成员变量：首字母小写和驼峰原则：monthSalary</li>
<li>局部变量：首字母小写和驼峰原则</li>
<li>常量：大写字母加下划线：MAX_VALUE</li>
<li>类名：首字母大写加驼峰原则：Man，GoodMan</li>
<li>方法名：首字母小写和驼峰原则：runRun()</li>
</ul>
</li>
</ul>
<h3 id="7、基本运算符"><a href="#7、基本运算符" class="headerlink" title="7、基本运算符"></a>7、基本运算符</h3><blockquote>
<p>Java支持如下运算符</p>
</blockquote>
<ul>
<li><p>算术运算符：+，-，*，&#x2F;，%，++，–</p>
</li>
<li><p>赋值运算符: &#x3D;</p>
</li>
<li><p>关系运算符：&gt;，≤，&gt;&#x3D;，&lt;&#x3D;，&#x3D;&#x3D;，!&#x3D;， instanceof</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">instanceof是Java中的二元运算符，左边是对象，右边是类；当对象是右边类或子类所创建对象时，返回true；否则，返回false。</span><br></pre></td></tr></table></figure>
</li>
<li><p>逻辑运算符：&amp;&amp;，‖，!</p>
</li>
<li><p>位运算符：&amp;，|，~，^，&gt;&gt;，&lt;&lt;，&gt;&gt;&gt;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&amp;：按位与</span><br><span class="line">|：按位或</span><br><span class="line">~：按位非</span><br><span class="line">^：按位异或</span><br><span class="line">&lt;&lt;：左位移运算符</span><br><span class="line">&gt;&gt;：右位移运算符</span><br><span class="line">&lt;&lt;&lt;：无符号左移运算符</span><br></pre></td></tr></table></figure>
</li>
<li><p>条件运算符: ？：</p>
</li>
<li><p>扩展赋值运算符：+&#x3D;，-&#x3D;，*&#x3D;，&#x2F;&#x3D;</p>
</li>
</ul>
<h3 id="8、自增自减运算符、初始Math类"><a href="#8、自增自减运算符、初始Math类" class="headerlink" title="8、自增自减运算符、初始Math类"></a>8、自增自减运算符、初始Math类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a++ 与  ++a的区别</span><br><span class="line"><span class="comment">// ++在前表示先+1再去执行代码  在后则是相反</span></span><br><span class="line"><span class="comment">// --也是同理</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>Math类的一些常见用法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Math.abs(a)：取a的绝对值</span><br><span class="line">Math.sqrt(a)：取a的平方根</span><br><span class="line">Math.cbrt(a)：取a的立方根</span><br><span class="line">Math.max(a,b)：取a、b之间的最大值</span><br><span class="line">Math.min(a,b)：取a、b之间的最小值</span><br><span class="line">Math.pow(a,b)：取a的b平方</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="9、逻辑运算符、位运算符"><a href="#9、逻辑运算符、位运算符" class="headerlink" title="9、逻辑运算符、位运算符"></a>9、逻辑运算符、位运算符</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&amp;&amp;   <span class="comment">// 逻辑与：两个变量都为真，结果才为true</span></span><br><span class="line">||   <span class="comment">// 逻辑或：两个变量有一个为真，则结果才为true</span></span><br><span class="line">!    <span class="comment">// 取反：如果是真，则变为假；如果是假，则变为真</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        A = 0011 1100</span></span><br><span class="line"><span class="comment">        B = 0000 1101</span></span><br><span class="line"><span class="comment">----------------------------------</span></span><br><span class="line"><span class="comment">        A&amp;B = 0000 1100</span></span><br><span class="line"><span class="comment">        A|B = 0011 1101</span></span><br><span class="line"><span class="comment">        A^B = 0011 0001</span></span><br><span class="line"><span class="comment">        ~B = 1111 0010</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        2*8 = 16</span></span><br><span class="line"><span class="comment">        &lt;&lt; *2</span></span><br><span class="line"><span class="comment">        &gt;&gt; /2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         */</span></span><br></pre></td></tr></table></figure>

<h3 id="10、三元运算符"><a href="#10、三元运算符" class="headerlink" title="10、三元运算符"></a>10、三元运算符</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 三元运算符</span></span><br><span class="line"><span class="comment">// x ？ y : z</span></span><br><span class="line"><span class="comment">// 如果x==true,则结果为y，否则结果为z</span></span><br></pre></td></tr></table></figure>

<h3 id="11、包机制"><a href="#11、包机制" class="headerlink" title="11、包机制"></a>11、包机制</h3><ul>
<li><p>为了更好的组织类，Java提供了包机制，用于区别类名的命名空间</p>
</li>
<li><p>包语句的语法格式是</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> pkg1[.pkg2[.pkg3……]];</span><br></pre></td></tr></table></figure>
</li>
<li><p>一般利用公司域名倒置作为包名；<a target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a> —&gt;   com&#x2F;baidu&#x2F;www</p>
</li>
<li><p>为了能够使用某个包的成员，我们需要再Java程序中明确导入该包，使用“import”语句可完成此功能</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> package1[.package2……].(classname | *);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="12、JavaDoc"><a href="#12、JavaDoc" class="headerlink" title="12、JavaDoc"></a>12、JavaDoc</h3><ul>
<li><p>JavaDoc是用来生成自己API文档的。</p>
</li>
<li><p>参数信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- @ author作者名</span><br><span class="line">- @ version版本号</span><br><span class="line">- @ since指明需要最早使用的jdk版本</span><br><span class="line">- @ paran参数名</span><br><span class="line">- @ return返回值情况</span><br><span class="line">- @ throws异常抛出情况</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javadoc -encoding UTF-<span class="number">8</span> -charset UTF-<span class="number">8</span> Doc.java   <span class="comment">// 注意保持编码一致</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><h3 id="1、用户交互Scanner"><a href="#1、用户交互Scanner" class="headerlink" title="1、用户交互Scanner"></a>1、用户交互Scanner</h3><ul>
<li><p>Java给我们提供了一个工具类，去实现程序与人的交互，获取用户的输入，java.util.Scanner是Java5的新特性，我们可以使用Scanner类去获取用户输入。</p>
</li>
<li><p>基本语法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">s</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过 Scanner类的next()与 nextLine()方法获取输入的字符串，在读取前我们一般需要使用 hasNext()与 hasNextLine()判断是否还有输入的数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span>(scanner.hasNext())&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">            System.out.println(<span class="string">&quot;输入的内容为:&quot;</span> + str);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(scanner.hasNextLine())&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">            System.out.println(<span class="string">&quot;输出的内容为:&quot;</span> + str);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>next()：</p>
<ol>
<li>一定要读取到有效字符才可以结束输入。</li>
<li>对输入有效字符之前遇到的空白，会自动去除</li>
<li>只有输入有效字符才将其后输入的空白作为分隔符或者结束符</li>
<li>next不能获取带空格的字符串</li>
</ol>
</li>
<li><p>nextLine():</p>
<ol>
<li>以Enter为结束符，也就是说返回的是Enter前所有字符</li>
<li>可以获取空白</li>
</ol>
</li>
</ul>
<h3 id="2、顺序结构"><a href="#2、顺序结构" class="headerlink" title="2、顺序结构"></a>2、顺序结构</h3><ul>
<li>Java的基本结构就是顺序结构，除非特别指明，负责就是按照顺序一句一句执行。</li>
<li>顺序结构是最简单的算法结构</li>
<li>语句与语句之间，框与框之间是按从上到下的顺序进行的，它是由若干个依次执行的处理步骤组成的，<strong>它是任何一个算法都离不开的一种基本算法结构</strong> 。</li>
</ul>
<h3 id="3、选择结构"><a href="#3、选择结构" class="headerlink" title="3、选择结构"></a>3、选择结构</h3><ul>
<li><p>if简单选择结构</p>
<ul>
<li><p>我们很多时候去判断一个东西是否可行，可行才能够去执行，这就用到if结构</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>（布尔表达式）&#123;</span><br><span class="line">	<span class="comment">// 如果布尔表达式为true才执行这个代码块中的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>if双选择结构（也就是if else）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(布尔表达式)&#123;</span><br><span class="line">    <span class="comment">// 如果布尔表达式为true</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">// 如果布尔表达式值为false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>if多选择结构</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(布尔表达式<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="comment">// 如果布尔表达式1为true执行代码</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(布尔表达式<span class="number">2</span>)&#123;</span><br><span class="line">    <span class="comment">// 如果布尔表达式2为true执行代码</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(布尔表达式<span class="number">3</span>)&#123;</span><br><span class="line">    <span class="comment">// 如果布尔表达式3为true执行代码</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">// 如果以上布尔表达式值都不为true执行代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>嵌套的if结构</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(布尔表达式<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="comment">// 如果布尔表达式1为true执行代码</span></span><br><span class="line">	<span class="keyword">if</span>(布尔表达式<span class="number">2</span>)&#123;</span><br><span class="line">    	<span class="comment">// 如果布尔表达式2为true执行代码</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>switch多选择结构</p>
<ul>
<li>多选择结构还有一个实现方式就是 switch case语句。</li>
<li>switch case语句判断一个变量与一系列值中某个值是否相等，每个值称为一个分支。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>（参数）&#123;</span><br><span class="line">	<span class="keyword">case</span> A:</span><br><span class="line">	<span class="keyword">case</span> B:</span><br><span class="line">	<span class="keyword">case</span> C:</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4、循环结构"><a href="#4、循环结构" class="headerlink" title="4、循环结构"></a>4、循环结构</h3><ul>
<li>while循环</li>
<li>do……while循环</li>
<li>for循环</li>
</ul>
<h3 id="5、break-continue"><a href="#5、break-continue" class="headerlink" title="5、break &amp; continue"></a>5、break &amp; continue</h3><ul>
<li><p>break在任何循环语句的主体部分，均可用 break控制循环的流程。 <strong>break用于强行退出循环</strong>，不执行循环中剩余的语句。（ break语句也在 switch语句中使用）。</p>
</li>
<li><p>continue语句用在循环语句体中，<strong>用于终止某次循环过程</strong>，即跳过循环体中尚未执行的语句，接着进行下一次是否执行循环的判定。</p>
</li>
<li><p>关于goto标签</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">label:</span><br><span class="line">while（或其他循环语句）</span><br></pre></td></tr></table></figure>

<ul>
<li>goto关键字很早就在程序设计语言中出现。尽管goto仍是Java的一个保留字，但并未在语言中得到正式使用；Java没有goto。然而，在 breaki和 continue这两个关键字的身上，我们仍然能看出一些goto的影子—带标签的 break和continue。</li>
<li>“标签”是指后面跟一个冒号的标识符，例如：label；</li>
<li>对Java来说唯一用到标签的地方是在循环语句之前。而在循环之前设置标签的唯一理由是：我们希望在其中嵌套另一个循环，由于 break和 continue关键字通常只中断当前循环，但若随同标签使用，它们就会中断到存在标签的地方。</li>
<li>goto标签由于有一些不好的方面，一般基本不使用</li>
</ul>
</li>
</ul>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="1、何谓方法"><a href="#1、何谓方法" class="headerlink" title="1、何谓方法"></a>1、何谓方法</h3><ul>
<li><p>Java方法是语句得到集合，它们在一起执行一个功能。</p>
<ul>
<li>方法是解决一类问题的步骤的有序组合</li>
<li>发包含于类或对象中</li>
<li>方法在程序中被创建，在其他地方被引用</li>
</ul>
</li>
<li><p>设计方法的原则：方法的本意是功能块，就是实现某个功能的语句块的集合。我们设计方法的时候，最好保持方法的原子性，<strong>就是一个方法只完成1个功能，这样利于我们后期的扩展</strong>。并且对于方法的命名，也尽可能去对应其功能，使其更浅显易懂。</p>
</li>
</ul>
<h3 id="2、方法的定义及调用"><a href="#2、方法的定义及调用" class="headerlink" title="2、方法的定义及调用"></a>2、方法的定义及调用</h3><ul>
<li><p>Java的方法类似于其它语言的函数，是一段<strong>用来完成特定功能的代码片段</strong>，一般情况下，定义一个方法包含以下语法：</p>
</li>
<li><p><strong>方法包含一个方法头和一个方法体</strong>。下面是一个方法的所有部分：</p>
<ul>
<li><strong>修饰符</strong>：修饰符，这是可选的，告诉编译器如何调用该方法。定义了该方法的访问类型。</li>
<li><strong>返回值类型</strong>：方法可能会返回值。 returnValueType是方法返回值的数据类型。有些方法执行所需的操作，但没有返回值。在这种情况下， returnValueType是关键字void。</li>
<li><strong>方法名</strong>：是方法的实际名称。方法名和参数表共同构成方法签名。</li>
<li><strong>参数类型</strong>：参数像是一个占位符。当方法被调用时，传递值给参数。这个值被称为实参或变量。参数列表是指方法的参数类型、顺序和参数的个数。参数是可选的，方法可以不包含任何参数。<ul>
<li>形式参数：在方法被调用时用于接收外界输入的数据。</li>
<li>实参：调用方法时实际传给方法的数据。</li>
</ul>
</li>
<li><strong>方法体</strong>：方法体包含具体的语句，定义该方法的功能。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数类型 参数名)&#123;</span><br><span class="line">    ...</span><br><span class="line">    方法体</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> 返回值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用方法：对象名.方法名（实参列表）</p>
</li>
<li><p>Java支持两种调用方法的方式，根据方法是否返回值来选择，当方法返回一个值的时候，方法调用通常被当做一个值。</p>
</li>
<li><p>如果返回值为空的话，方法调用一定是一条语句</p>
</li>
</ul>
<blockquote>
<p>注意！！！！！</p>
</blockquote>
<ul>
<li>方法可以修改<strong>传递引用所对应的</strong>变量值，而<strong>不能修改传递值调用</strong>所对应的变量值，这句话相当重要，这是按值调用与引用调用的根本区别，以下为分析：</li>
<li>按值调用(call by value)表示方法接受的时调用者<strong>提供的值</strong>。</li>
</ul>
<p>函数传递值流程图</p>
<p><img src="http://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-16/c9ac44a4a04ebd2fd63b7df7de2f2d66--9e4a--image-20240916195454929.png" alt="image-20240916195454929"></p>
<p><strong>分析</strong>：</p>
<ul>
<li>1）value被初始化为x值的一个拷贝（也就是10）</li>
<li>2）value被乘以3后等于30，但注意此时x的值仍为10！</li>
<li>3）这个方法结束后，参数变量value不再使用，被回收。</li>
</ul>
<blockquote>
<p><strong>结论：</strong>当传递方法参数类型为基本数据类型（数字以及布尔值）时，一个方法是不可能修改一个基本数据类型的参数。</p>
</blockquote>
<ul>
<li><p>按引用调用(call by reference)</p>
</li>
<li><p>按引用调用则表示方法接收的是<strong>调用者提供的变量地址</strong>(如果是C语言的话来说就是指针啦，当然java并没有指针的概念)</p>
</li>
<li><p>当然java中除了基本数据类型还有<strong>引用数据类型</strong>，也就是<strong>对象引用</strong>，那么对于这种数据类型又是怎么样的情况呢？我们还是一样先来看一个例子：<br>先声明一个User对象类型： </p>
</li>
<li><p>分析一下这个过程： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HomeWork02</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">updateUser</span><span class="params">(User student)</span>&#123;</span><br><span class="line">        student.setName(<span class="string">&quot;subeiLY&quot;</span>);</span><br><span class="line">        student.setAge(<span class="number">22</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;SUBEI&quot;</span>,<span class="number">20</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;调用user前的值:&quot;</span> + user.getName() + <span class="string">&quot;,&quot;</span> + user.getAge());</span><br><span class="line">        updateUser(user);</span><br><span class="line">        System.out.println(<span class="string">&quot;调用user后的值:&quot;</span> + user.getName() + <span class="string">&quot;,&quot;</span> + user.getAge());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-16/1f7caad12229ce68470a87760100bb70--07f4--image-20210414143735613.png" alt="img"></p>
<p><strong>分析</strong>：</p>
<ul>
<li>1）student变量被初始化为user值的拷贝，这里是一个对象的引用。</li>
<li>2）调用student变量的set方法作用在这个引用对象上，<strong>user和student同时引用的User对象内部值</strong>被修改。</li>
<li>3）方法结束后，student变量不再使用，被释放，而user还是没有变，依然指向User对象。</li>
</ul>
<blockquote>
<p><strong>结论：</strong>显然，User的值被改变了，但是这是将最开始所对应得值改变了，把User的本身属性改变了，才会进行值得变化，虽然看似是按引用传递值，但是实际上是将值改变了。 </p>
</blockquote>
<ul>
<li>这个过程也充分说明了java程序设计语言对对象采用的不是引用调用，实际上是<strong>对象引用进行的是值传递</strong>，当然在这里我们可以简单理解为这就是按值调用和引用调用的区别，而且必须明白即使java函数在传递引用数据类型时，也只是拷贝了引用的值罢了，之所以能修改引用数据是因为它们同时指向了一个对象，<strong>但这仍然是按值调用而不是引用调用。</strong></li>
<li><strong>总结</strong><ul>
<li>一个方法不能修改一个基本数据类型的参数（数值型和布尔型）。</li>
<li>一个方法可以修改一个引用所指向的对象状态，但这仍然是按值调用而非引用调用。</li>
<li>上面两种传递都进行了值拷贝的过程。</li>
</ul>
</li>
</ul>
<h3 id="3、方法重载"><a href="#3、方法重载" class="headerlink" title="3、方法重载"></a>3、方法重载</h3><ul>
<li>重载就是在一个类中，有相同的函数名称，但形参不同的函数。</li>
<li>方法的重载的规则<ul>
<li>方法名称必须相同。</li>
<li>参数列表必须不同（个数不同、或类型不同、参数排列顺序不同等）<br>方法的返回类型可以相同也可以不相同。</li>
<li>仅仅返回类型不同不足以成为方法的重载。</li>
</ul>
</li>
<li>实现理论：<ul>
<li>方法名称相同时，编译器会根据调用方法的参数个数、参数类型等去逐个匹配，以选择对应的方法，如果匹配失败，则编译器报错。</li>
</ul>
</li>
</ul>
<h3 id="4、命令行传参"><a href="#4、命令行传参" class="headerlink" title="4、命令行传参"></a>4、命令行传参</h3><ul>
<li>通过main函数中的args去传递参数</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.github;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (String arg : args) &#123;</span><br><span class="line">            System.out.println(arg);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<h3 id="5、可变参数"><a href="#5、可变参数" class="headerlink" title="5、可变参数"></a>5、可变参数</h3><ul>
<li>JDK1.5开始，Java支持传递同类型的可变参数给一个方法。</li>
<li>在方法声明中，在指定参数类型后加一个省略号（）。</li>
<li>一个方法中只能指定一个可变参数，它必须是方法的最后一个参数。任何普通的参数必须在它之前声明。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package com.github;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        test(1,2,3,4,5,6);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void test(int... i)&#123;</span><br><span class="line">        for (int k : i) &#123;</span><br><span class="line">            System.out.println(k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6、递归"><a href="#6、递归" class="headerlink" title="6、递归"></a>6、递归</h3><ul>
<li>A方法调用B方法，我们很容易理解！</li>
<li>递归就是：A方法调用A方法！就是自己调用自己。</li>
<li>利用递归可以用简单的程序来解决一些复杂的问题。它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解，递归策略只需少量的程序就可描述岀解题过程所需要的多次重复计算，大大地减少了程序的代码量。递归的能力在于用有限的语句来定义对象的无限集合。</li>
<li>递归结构包括两个部分：<ul>
<li>递归头：什么时候不调用自身方法。如果没有头，将陷入死循环；</li>
<li>递归体：什么时候需要调用自身方法。</li>
</ul>
</li>
</ul>
<p>示例：使用递归求阶乘</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.github;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(test(<span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> n*test(n-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="1、数组概述"><a href="#1、数组概述" class="headerlink" title="1、数组概述"></a>1、数组概述</h3><ul>
<li>数组是相同类型数据的有序集合。</li>
<li>数组描述的是相同类型的若干个数据按照一定的先后次序排列组合而成。</li>
<li>其中每一个数据称作一个数组元素每个数组元素可以通过一个下标来访问它们。</li>
</ul>
<h3 id="2、数组声明创建"><a href="#2、数组声明创建" class="headerlink" title="2、数组声明创建"></a>2、数组声明创建</h3><ul>
<li>首先必须声明数组变量，才能在程序中使用数组。下面是声明数组变量的语法：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dataType[] arrayRefVar;	<span class="comment">// 首选的方法</span></span><br><span class="line">或</span><br><span class="line">dataType arrayRefVar[];	<span class="comment">// 效果相同，但不是首选方法</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Java语言使用new操作符来创建数组，语法如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataType[] arrayRefVar = <span class="keyword">new</span> <span class="title class_">dataType</span>[arraySize];</span><br></pre></td></tr></table></figure>

<ul>
<li>数组的元素是通过索引访问的，数组索引从0开始。</li>
<li>获取数组长度：<code>arrays. length</code></li>
</ul>
<blockquote>
<p>内存分析</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-16/6cadde5fb4d27323c285b0d428245dc7--4b48--image-20240916214245870.png" alt="image-20240916214245870"></p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-16/5c5632e65292b3883e07b66cefa2c846--395e--1622105878156.png" alt="1622105878156"></p>
<blockquote>
<p>数组的四个基本特点：</p>
</blockquote>
<ul>
<li>其长度是确定的。数组一旦被创建，它的大小就是不可以改变的；</li>
<li>其元素必须是相同类型不允许出现混合类型。</li>
<li>数组中的元素可以是任何数据类型，包括基本类型和引用类型。</li>
<li>数组变量属引用类型，数组也可以看成是对象，数组中的每个元素相当于该对象的成员变量数组本身就是对象，Java中对象是在堆中的，因此数组无论保存原始类型还是其他对象类型，&#x3D;&#x3D;数组对象本身是在堆中的&#x3D;&#x3D;。</li>
</ul>
<blockquote>
<p>下标越界及小结：</p>
</blockquote>
<ul>
<li>下标的合法区间：[0, length-1]，如果越界就会报错：</li>
</ul>
<p>数组的下标异常：</p>
<ul>
<li><p>ArraylndexOutofBounds Exception：数组下标越界异常！</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-16/ef136c0b0a60d13a465c9eabf4a507c3--9a6b--1622108608331.png" alt="1622108608331"></p>
</li>
<li><p>数组是相同数据类型（数据类型可以为任意类型）的有序集合数组也是对象。</p>
</li>
<li><p>数组元素相当于对象的成员变量。</p>
</li>
<li><p>数组长度的确定的，不可变的。如果越界，则报：ArrayIndexOutofBounds。</p>
</li>
</ul>
<h3 id="3、数组使用"><a href="#3、数组使用" class="headerlink" title="3、数组使用"></a>3、数组使用</h3><ul>
<li><p>普通的for循环</p>
</li>
<li><p>For-Each循环</p>
</li>
<li><p>数组作方法入参</p>
</li>
<li><p>数组作返回值</p>
</li>
</ul>
<h3 id="4、多维数组"><a href="#4、多维数组" class="headerlink" title="4、多维数组"></a>4、多维数组</h3><ul>
<li>多维数组可以看成是数组的数组，比如二维数组就是一个特殊的一维数组，其每一个元素都是一个一维数组。</li>
<li>二维数组</li>
</ul>
<h3 id="5、Arrays类"><a href="#5、Arrays类" class="headerlink" title="5、Arrays类"></a>5、Arrays类</h3><ul>
<li>数组的工具类 javautil. Arrays</li>
<li>由于数组对象本身并没有什么方法可以供我们调用但AP中提供了一个工具类 Arrays供我们使用从而可以对数据对象进行一些基本的操作。</li>
<li>&#x3D;&#x3D;查看JDK帮助文档&#x3D;&#x3D;。</li>
<li>Arrays类中的方法都是 static 修饰的静态方法在使用的时候可以直接使用类名进行调用，而”不用”使用对象来调用（注意：是“不用”而不是“不能”）。</li>
<li>具有以下常用功能：<ul>
<li>给数组赋值：通过fill方法。</li>
<li>对数组排序：通过sort方法按升序。</li>
<li>比较数组：通过 equals方法比较数组中元素值是否相等。</li>
<li>查找数组元素：通过 binarySearch方法能对排序好的数组进行二分查找法操作。</li>
</ul>
</li>
</ul>
<p>一些常用的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">方法名	简要描述</span><br><span class="line">asList()	返回由指定数组支持的固定大小的列表。</span><br><span class="line">sort()	将数组排序（升序）</span><br><span class="line">parallelSort()	将指定的数组按升序排序</span><br><span class="line">binarySearch()	使用二分搜索法快速查找指定的值（前提是数组必须是有序的）</span><br><span class="line">compare()	按字典顺序比较两个数组</span><br><span class="line">compareUnsigned()	按字典顺序比较两个数组，将数字元素处理为无符号</span><br><span class="line">copyOf()	填充复制数组</span><br><span class="line">copyOfRange()	将数组的指定范围复制到新数组</span><br><span class="line">equals()	比较两个数组</span><br><span class="line">deepEquals()	比较两个数组深度</span><br><span class="line">toString()	将数组转换为字符串</span><br><span class="line">deepToString()	将一个多维数组转换为字符串</span><br><span class="line">fill()	将指定元素填充给数组每一个元素</span><br><span class="line">mismatch()	查找并返回两个数组之间第一个不匹配的索引，如果未找到则返回-<span class="number">1</span></span><br><span class="line">parallelPrefix()	使用提供的函数对数组元素进行操作</span><br><span class="line">parallelSetAll()	使用提供的生成器函数并行设置指定数组的所有元素以计算每个元素</span><br><span class="line">setAll()	使用提供的生成器函数设置指定数组的所有元素以计算每个元素</span><br></pre></td></tr></table></figure>

<h3 id="6、稀疏数组"><a href="#6、稀疏数组" class="headerlink" title="6、稀疏数组"></a>6、稀疏数组</h3><ul>
<li>当一个数组中大部分元素为0，或者为同一值的数组时，可以使用稀疏数组来保存该数组。</li>
<li>稀疏数组的处理方式是：<ul>
<li>记录数组一共有几行几列，有多少个不同值。</li>
<li>把具有不同值的元素和行列及值记录在一个小规模的数组中，从而缩小程序的规模。</li>
</ul>
</li>
<li>如下图：左边是原始数组，右边是稀疏数组。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-16/f536e2a3282130e263ee9de36e64baaa--4d2b--1622349200598.png" alt="1622349200598"></p>
<h2 id="面向对象（OOP）"><a href="#面向对象（OOP）" class="headerlink" title="面向对象（OOP）"></a>面向对象（OOP）</h2><h3 id="1、初始面向对象"><a href="#1、初始面向对象" class="headerlink" title="1、初始面向对象"></a>1、初始面向对象</h3><ul>
<li>面向过程思想<ul>
<li>步骤清晰简单，第一步做什么，第二步做什么…</li>
<li>面对过程适合处理一些较为简单的问题。</li>
</ul>
</li>
<li>面向对象思想<ul>
<li>物以类聚，分类的思维模式，思考问题首先会解决问题需要哪些分类，然后对这些分类进行单独思考。最后，才对某个分类下的细节进行面向过程的思索。</li>
<li>面向对象适合处理复杂的问题，适合处理需要多人协作的问题！</li>
</ul>
</li>
<li>对于描述复杂的事物，为了从宏观上把握、从整体上合理分析，我们需要使用面向对象的思路来分析整个系统。但是，具体到微观操作，仍然需要面向过程的思路去处理。</li>
<li>面向对象编程（ Object- Oriented Programming,OOP）</li>
<li>面向对象编程的本质就是：&#x3D;&#x3D;以类的方式组织代码，以对象的组织（封装）数据&#x3D;&#x3D;。</li>
<li>三大特征：<ul>
<li><strong>继承</strong></li>
<li><strong>封装</strong></li>
<li><strong>多态</strong></li>
</ul>
</li>
<li>从认识论角度考虑是先有对象后有类。对象，是具体的事物。类，是抽象的，是对对象的抽象。</li>
<li>从代码运行角度考虑是先有类后有对象。类是对象的模板。</li>
</ul>
<h3 id="2、方法的回顾和加深"><a href="#2、方法的回顾和加深" class="headerlink" title="2、方法的回顾和加深"></a>2、方法的回顾和加深</h3><ul>
<li><p>方法的定义</p>
<ul>
<li>修饰符</li>
<li>返回类型</li>
<li>break：跳出 switch，结束循环和 return的区别。</li>
<li>方法名：注意规范就OK，见名知意</li>
<li>参数列表：(参数类型，参数名) …</li>
<li>异常抛出：疑问，参考下文！</li>
</ul>
</li>
<li><p>方法的调用</p>
<ul>
<li>静态方法（可以直接调用）</li>
<li>非静态方法（需要new对象才能调用）</li>
<li>形参和实参</li>
<li>值传递和引用传递</li>
<li>this关键字（表示当前所在类）</li>
</ul>
</li>
</ul>
<h3 id="3、对象的创建分析"><a href="#3、对象的创建分析" class="headerlink" title="3、对象的创建分析"></a>3、对象的创建分析</h3><ul>
<li>类是一种抽象的数据类型它是对某一类事物整体描述&#x2F;定义但是并不能代表某一个具体的事物。</li>
<li>使用new关键字创建对象。</li>
<li>使用new关键字创建的时候，除了分配内存空间之外，还会给刨建好的对象进行默认的初始化以及对类中构造器的调用。</li>
<li>类中的构造器也称为构造方法，是在进行创建对象的时候必须要调用的。并且构造器有以下俩个特点：<ul>
<li>1.必须和类的名字相同；</li>
<li>2.必须没有返回类型也不能写void。</li>
</ul>
</li>
<li>构造器：<ul>
<li>1.和类名初问</li>
<li>2.没有返回值</li>
</ul>
</li>
<li>作用：<ul>
<li>1.new本质在调用构造方法；</li>
<li>2.初始化对象的值。</li>
</ul>
</li>
<li>注意：定义有参构造之后，如果想使用无参构造，显示的定义一个无参构造。</li>
</ul>
<h3 id="4、面向对象三大特性"><a href="#4、面向对象三大特性" class="headerlink" title="4、面向对象三大特性"></a>4、面向对象三大特性</h3><blockquote>
<p>封装：<strong>属性私有，get&#x2F;set</strong></p>
</blockquote>
<p>封装的作用：</p>
<ul>
<li>提高了代码的安全性，保护数据；</li>
<li>隐藏代码的实现细则；</li>
<li>统一接口；</li>
<li>系统可维护增加了。</li>
</ul>
<blockquote>
<p>继承：<strong>object类、super、方法重写</strong></p>
</blockquote>
<ul>
<li>继承的本质是对某一批类的抽象，从而实现对现实世界更好的建模。</li>
<li>extands的意思是“扩展”。子类是父类的扩展。</li>
<li><strong>JAVA中类只有单继承，没有多继承！</strong></li>
<li>继承是类和类之间的一种关系。除此之外，类和类之间的关系还有依赖、组合、聚合等。</li>
<li>继承关系的俩个类，一个为子类（派生类），一个为父类（基类）。子类继承父类使用关键字 extends来表示。</li>
<li>子类和父类之间从意义上讲应该具有”is a”的关系。</li>
<li>私有的东西无法被继承！！！</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">super注意点：</span><br><span class="line"></span><br><span class="line">1. super调用父类的构造方法，必须在构造方法的第一个</span><br><span class="line">2. super必须只能出现在子类的方法或者构造方法中！</span><br><span class="line">3. super和this不能同时调用构造方法！</span><br><span class="line"></span><br><span class="line">super VS this</span><br><span class="line">- 代表的对象不同：</span><br><span class="line">  - this：本身调用者这个对象；</span><br><span class="line">  - super：代表父类对象的应用；</span><br><span class="line">- 前提</span><br><span class="line">  - this：没有继承也可以使用；</span><br><span class="line">  - super：只能在继承条件才可以使用；</span><br><span class="line">- 构造方法</span><br><span class="line">  - this（）：本类的构造；</span><br><span class="line">  - super（）：父类的构造。</span><br></pre></td></tr></table></figure>

<ul>
<li><p>方法的重写</p>
</li>
<li><p>重写：需要有继承关系，子类重写父类的方法！</p>
</li>
</ul>
<ol>
<li>方法名必须相同;</li>
<li>参数列表列表必须相同;</li>
<li>修饰符：范围可以扩大但不能缩小: public&gt;Protected&gt;Default&gt;private</li>
<li>抛出的异常：范围，可以被缩小，但不能扩大；ClassNotFoundException–&gt; Exception(大)</li>
</ol>
<ul>
<li>重写，子类的方法和父类必要一致；方法体不同！</li>
<li>为什么需要重写：父类的功能，子类不一定需要，或者不一定满足！</li>
</ul>
<blockquote>
<p>多态</p>
</blockquote>
<ul>
<li>即同一方法可以根据发送对象的不同而采用多种不同的行为方式。</li>
<li>一个对象的实际类型是确定的，但可以指向对象的引用的类型有很多。</li>
<li>多态存在的条件：<ul>
<li>有继承关系；</li>
<li>子类重写父类方法；</li>
<li>父类引用指向子类对象。</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- 多态注意事项：</span><br><span class="line">  1. 多态是方法的多态，属性没有多态；</span><br><span class="line">  2. 父类和子类，有联系，类型转换异常！ClassCastException!</span><br><span class="line">  3. 存在条件：继承条件，方法需要重写！父类引用指向子类对象！</span><br><span class="line">     1. static 方法，属于类，它不属于实例</span><br><span class="line">     2. final 常量；</span><br><span class="line">     3. private 方法；</span><br><span class="line"></span><br><span class="line">instanceof：判断一个对象是什么类型。</span><br></pre></td></tr></table></figure>

<ul>
<li>匿名代码块<ul>
<li>在类创建对象时执行</li>
<li>在构造方法前执行，在静态代码块后执行</li>
</ul>
</li>
<li>静态代码块<ul>
<li>只会在类初次创建对象时执行</li>
<li>在构造方法、静态代码块前执行</li>
</ul>
</li>
</ul>
<h3 id="5、抽象类和接口"><a href="#5、抽象类和接口" class="headerlink" title="5、抽象类和接口"></a>5、抽象类和接口</h3><blockquote>
<p>抽象类</p>
</blockquote>
<ul>
<li>abstract修饰符可以用来修饰方法也可以修饰类如果修饰方法那么该方法就是抽象方法如果修饰类那么该类就是抽象类。</li>
<li>抽象类中可以没有抽象方法但是有抽象方法的类一定要声明为抽象类。</li>
<li>抽象类，不能使用new关键字来创建对象它是用来让子类继承的。</li>
<li>抽象方法只有方法的声明没有方法的实现它是用来让子类实现的。</li>
<li>子类继承抽象类那么就必须要实现抽象类没有实现的抽象方法否则该子类也要声明为抽象类。</li>
</ul>
<blockquote>
<p>接口</p>
</blockquote>
<ul>
<li>普通类：只有具体实现；</li>
<li>抽象类：具体实现和规范（抽象方法）都有！</li>
<li>接口：只有规范！</li>
<li>接口就是规范，定义的是一组规则，体现了现实世界中“如果你是…则必须能…”的思想。如果你是天使，则必须能飞。如果你是汽车，则必须能跑。如果你好人，则必须干掉坏人；如果你是坏人，则必须欺负好人。</li>
<li>接口的本质是契约，就像我们人间的法律一样。制定好后大家都遵守。</li>
<li>OO的精髓，是对对象的抽象，最能体现这一点的就是接口。为什么我们讨论设计模式都只针对具备了抽象能力的语言（比如c++、java、c#等），就是因为设计模式所硏究的，实际上就是如何合理的去抽象。</li>
<li><strong>声明类的关键字是 class，声明接口的关键字是 interface。</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">抽象类和接口的区别：</span><br><span class="line">- 抽象类：具体实现和规范（抽象方法）都有！</span><br><span class="line">- 接口：只有规范！</span><br></pre></td></tr></table></figure>

<h3 id="6、内部类及OOP实战"><a href="#6、内部类及OOP实战" class="headerlink" title="6、内部类及OOP实战"></a>6、内部类及OOP实战</h3><p>内部类就是在一个类的内部在定义一个类，比如，A类中定义一个B类，那么B类相对A类来说就称为内部类，而A类相对B类来说就是外部类了。</p>
<ol>
<li>成员内部类</li>
<li>静态内部类</li>
<li>局部内部类</li>
<li>匿名内部类</li>
</ol>
<p><img src="http://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-16/0305cc69a3803b657b001f20616fefc2--0f4e--image-20240916221855128.png" alt="image-20240916221855128"></p>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><h3 id="1、什么是异常"><a href="#1、什么是异常" class="headerlink" title="1、什么是异常"></a>1、什么是异常</h3><pre><code> 实际工作中，遇到的情况不可能是非常完美的。比如：你写的某个模块，用户输入不一定符合你的要求、你的程序要打开某个文件，这个文件可能不存在或者文件格式不对，你要读取数据库的数据，数据可能是空的等。我们的程序再跑着，内存或硬盘可能满了。等等。
</code></pre>
<p> &nbsp;  &nbsp; 软件程序在运行过程中，非常可能遇到刚刚提到的这些异常问题，我们叫异常，英文是：Exception，意思是例外。这些，例外情况，或者叫异常，怎么让我们写的程序做出合理的处理。而不至于程序崩溃。</p>
<p> &nbsp;  &nbsp; 异常指程序运行中出现的不期而至的各种状况如：文件找不到、网络连接失败、非法参数等。异常发生在程序运行期间它影响了正常的程序执行流程。</p>
<blockquote>
<p>要理解Java异常处理是如何工作的，需要掌握以下三种类型的异常</p>
</blockquote>
<ul>
<li>检查性异常：最具代表的检查性异常时用户错误或问题引起的异常，</li>
<li>这是程序员无法预见的例如要打开一个不存在文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略。</li>
<li>运行时异常：运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略。</li>
<li>错误<strong>ERROR</strong>：错误不是异常，而是脱离程序员控制的冋题。错误在代码中通常被忽略。例如，当栈溢出时，一个错误就发生了，它们在编译也检查不到的。</li>
</ul>
<h3 id="2、异常体系结构"><a href="#2、异常体系结构" class="headerlink" title="2、异常体系结构"></a>2、异常体系结构</h3><ul>
<li>Java把异常当为对象来处理，并定义一个基类 java. lang.Throwable作为所有异常的超类。</li>
<li>在 Java API中已经定义了许多异常类，这些异常类分为两大类，错误Error和异常 Exception。<img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/9dad4dc296387a3aa745bda588e541a0--66fb--1622843400375.png" alt="1622843400375"></li>
</ul>
<blockquote>
<p>Error</p>
</blockquote>
<ul>
<li>Error类对象由Java虚拟机生成并抛出，大多数错误与代码编写者所执行的操作无关。</li>
<li>Java虚拟机运行错误（ Virtual Machine Error），当JVM不再有继续执行操作所需的内存资源时，将出现 <strong>OutofMemory Error（OOM内存溢出）</strong>。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止。</li>
<li>还有发生在虛拟机试图执行应用时，如类定义错误（ NoClass Deffound error）、链接错误（ Linkage Error）。这些错误是不可查的，因为它们在应用程序的控制和处理能力之外，而且绝大多数是程序运行时不允许出现的状况。</li>
</ul>
<blockquote>
<p>Exception</p>
</blockquote>
<ul>
<li>在 Exception分支中有一个重要的子类 Runtime Exception（运行时异常）<ul>
<li>ArraylndexOutOfBoundsException（数组下标越界）</li>
<li>NullPointerException（空指针异常）</li>
<li>ArithmeticException（算术异常）</li>
<li>Missing Resource Exception（丢失资源）</li>
<li>ClassNotFound Exception（找不到类）等异常，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。</li>
</ul>
</li>
<li>这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生； </li>
<li>Error和 Exception的区别：Error通常是灾难性的致命的错误，是程序无法控制和处理的，当出现这些异常时，Java虛拟机（JVM）一般会选择终止线程；Exception通常情况下是可以被程序处理的，并且在程序中应该尽可能的去处理这些异常。</li>
</ul>
<h3 id="3、Java异常处理机制与处理异常"><a href="#3、Java异常处理机制与处理异常" class="headerlink" title="3、Java异常处理机制与处理异常"></a>3、Java异常处理机制与处理异常</h3><ul>
<li>抛出异常</li>
<li>捕获异常</li>
<li>异常处理五个关键字：<ul>
<li>try、catch、 finally、throw、throws</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/0a394f1331265ead6eba52441a0770fa--928b--image-20240917095443916.png" alt="image-20240917095443916"></p>
<h3 id="4、自定义异常"><a href="#4、自定义异常" class="headerlink" title="4、自定义异常"></a>4、自定义异常</h3><ul>
<li>使用Java内置的异常类可以描述在编程时岀现的大部分异常情况。除此之外，用户还可以自定义异常。用户自定义异常类，只需继承 Exception类即可。</li>
<li>在程序中使用自定义异常类，大体可分为以下几个步骤：<ol>
<li>创建自定义异常类。</li>
<li>在方法中通过 throw关键字抛出异常对象。</li>
<li>如果在当前抛出异常的方法中处理异常，可以使用try- catch语句捕获并处理；否则在方法的声明处通过 throws关键字指明要抛岀给方法调用者的异常，继续进行下一步操作。</li>
<li>在出现异常方法的调用者中捕获并处理异常。</li>
</ol>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/77ec534b38864564efad53e68734991d--162a--image-20240917100058991.png" alt="image-20240917100058991"></p>
<h3 id="5、总结"><a href="#5、总结" class="headerlink" title="5、总结"></a>5、总结</h3><ul>
<li>处理运行时异常时，采用逻辑去合理规避同时辅助 try-catch ；</li>
<li>处理在多重 catch块后面，可以加一个 catch（ Exception）来处理可能会被遗漏的异常；</li>
<li>对于不确定的代码，也可以加上try- catch，处理潜在的异常；</li>
<li>尽量去处理异常，切忌只是简单地调用 printStackTrace0去打印输出；</li>
<li>具体如何处理异常，要根据不同的业务需求和异常类型去决定；</li>
<li>尽量添加 finally！语句块去释放占用的资源。</li>
</ul>
<h2 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h2><h3 id="1、字符串相关的类"><a href="#1、字符串相关的类" class="headerlink" title="1、字符串相关的类"></a>1、字符串相关的类</h3><h4 id="1、String类的概述"><a href="#1、String类的概述" class="headerlink" title="1、String类的概述"></a>1、String类的概述</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * String:字符串，使用一对“”引起来表示。</span></span><br><span class="line"><span class="comment">     * 1.String声明为final的，不可被继承</span></span><br><span class="line"><span class="comment">     * 2.String实现了Serializable接口：表示字符串是支持序列化的。</span></span><br><span class="line"><span class="comment">     *         实现了Comparable接口：表示String可以比较大小</span></span><br><span class="line"><span class="comment">     * 3.String内部定义了final char[] value用于存储字符串数据</span></span><br><span class="line"><span class="comment">     * 4.String:代表不可变的字符序列。简称：不可变性。</span></span><br><span class="line"><span class="comment">     *      体现：1.当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值。</span></span><br><span class="line"><span class="comment">     *           2.当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。</span></span><br><span class="line"><span class="comment">     *           3.当调用String的replace()方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。</span></span><br><span class="line"><span class="comment">     * 5.通过字面量的方式（区别于new）给一个字符串赋值，此时的字符串值声明在字符串常量池中。</span></span><br><span class="line"><span class="comment">     * 6.字符串常量池中是不会存储相同内容的字符串的。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure>

<h4 id="2、理解String类的不可见性"><a href="#2、理解String类的不可见性" class="headerlink" title="2、理解String类的不可见性"></a>2、理解String类的不可见性</h4><p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/d405c3f637ebd987f0af0044618984ed--8070--image-20240917103243395.png" alt="image-20240917103243395"></p>
<h4 id="3、String不同实例化方法的对比"><a href="#3、String不同实例化方法的对比" class="headerlink" title="3、String不同实例化方法的对比"></a>3、String不同实例化方法的对比</h4><ul>
<li>String对象的创建</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//本质上this.value = new char[0];</span></span><br><span class="line"><span class="type">String</span>  <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(); </span><br><span class="line"></span><br><span class="line"><span class="comment">//this.value = original.value;</span></span><br><span class="line"><span class="type">String</span>  <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(String original); </span><br><span class="line"></span><br><span class="line"><span class="comment">//this.value = Arrays.copyOf(value, value.length);</span></span><br><span class="line"><span class="type">String</span>  <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="type">char</span>[] a);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span>  <span class="variable">s4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="type">char</span>[] a,<span class="type">int</span> startIndex,<span class="type">int</span> count);</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/f88f172d93e3c916b346a9b232fdd7e4--c081--f-011.png" alt="f-011"></p>
<p>String str1  &#x3D; “abc”;与String str2 &#x3D; new String(“abc”);的区别？</p>
<ul>
<li>字符串常量存储在字符串常量池，目的是共享</li>
<li>字符串非常量对象存储在堆中。</li>
</ul>
<h4 id="4、String不同拼接操作的对比"><a href="#4、String不同拼接操作的对比" class="headerlink" title="4、String不同拼接操作的对比"></a>4、String不同拼接操作的对比</h4><h5 id="String使用陷阱"><a href="#String使用陷阱" class="headerlink" title="String使用陷阱"></a>String使用陷阱</h5><ul>
<li><p>String s1 &#x3D; “a”; </p>
<blockquote>
<p>说明：在字符串常量池中创建了一个字面量为”a”的字符串。</p>
</blockquote>
</li>
<li><p>s1 &#x3D; s1 + “b”; </p>
<blockquote>
<p>说明：实际上原来的“a”字符串对象已经丢弃了，现在在堆空间中产生了一个字符串s1+”b”（也就是”ab”)。如果多次执行这些改变串内容的操作，会导致大量副本字符串对象存留在内存中，降低效率。如果这样的操作放到循环中，会极大影响程序的性能。</p>
</blockquote>
</li>
<li><p>String s2 &#x3D; “ab”;</p>
<blockquote>
<p>说明：直接在字符串常量池中创建一个字面量为”ab”的字符串。</p>
</blockquote>
</li>
<li><p>String s3 &#x3D; “a” + “b”;</p>
<blockquote>
<p>说明：s3指向字符串常量池中已经创建的”ab”的字符串。</p>
</blockquote>
</li>
<li><p>String s4 &#x3D; s1.intern();</p>
<blockquote>
<p>说明：堆空间的s1对象在调用intern()之后，会将常量池中已经存在的”ab”字符串赋值给s4。</p>
</blockquote>
</li>
</ul>
<h4 id="5、一道面试题"><a href="#5、一道面试题" class="headerlink" title="5、一道面试题"></a>5、一道面试题</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTest</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;good&quot;</span>);</span><br><span class="line">    <span class="type">char</span>[] ch = &#123; <span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;t&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(String str, <span class="type">char</span> ch[])</span> &#123;</span><br><span class="line">        str = <span class="string">&quot;test ok&quot;</span>;</span><br><span class="line">        ch[<span class="number">0</span>] = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">StringTest</span> <span class="variable">ex</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringTest</span>();</span><br><span class="line">        ex.change(ex.str, ex.ch);</span><br><span class="line">        System.out.println(ex.str);<span class="comment">//good</span></span><br><span class="line">        System.out.println(ex.ch);<span class="comment">//best</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6、JVM中涉及字符串的内存结构"><a href="#6、JVM中涉及字符串的内存结构" class="headerlink" title="6、JVM中涉及字符串的内存结构"></a>6、JVM中涉及字符串的内存结构</h4><p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/5f40e28ca82ae81c89448191221f92f0--83c8--f-06.png" alt="f-06"></p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/b49ce55a60f475317da97e9ee4b24e12--7a09--f-07.png" alt="f-07"></p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/8435cd3f8e1c81d70aea2e42ef381fbe--922d--f-08.png" alt="f-08"></p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/659ed8f50e7ce55076c5c296c3d69baf--6882--f-09.png" alt="f-09"></p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/4244078ff7a3b6a04d0d154bf6acc9f9--06e2--f-10.png" alt="f-10"></p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/40b729502feb4a579d2b142d353e93e8--4004--f-11.png" alt="f-11"></p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/a204f787a807f87378f7985085222d20--1859--f-12.png" alt="f-12"></p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/1b6c0ffa297bcdaceb4608573e08b701--5284--f-13.png" alt="f-13"></p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/23223b4d4c88ab5e9b5dff87bd1ea81d--4171--f-15.png" alt="f-15"></p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/bec0d1357c803bbce86c88c385b006c1--9cc2--f-16.png" alt="f-16"></p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/d8b42e2a9e4c2fab065e9a7160656ca5--acd9--f-17.png" alt="f-17"></p>
<h4 id="7、String常用的方法"><a href="#7、String常用的方法" class="headerlink" title="7、String常用的方法"></a>7、String常用的方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * int length()：返回字符串的长度：return value.length</span></span><br><span class="line"><span class="comment"> * char charAt(int index)：返回某索引处的字符return value[index]</span></span><br><span class="line"><span class="comment"> * boolean isEmpty()：判断是否是空字符串：return value.length==0</span></span><br><span class="line"><span class="comment"> * String toLowerCase()：使用默认语言环境，将String中的所有字符转换为小写</span></span><br><span class="line"><span class="comment"> * String toUpperCase()：使用默认语言环境，将String中的所有字符转换为大写</span></span><br><span class="line"><span class="comment"> * String trim()：返回字符串的副本，忽略前导空白和尾部空白</span></span><br><span class="line"><span class="comment"> * boolean equals(Object obj)：比较字符串的内容是否相同</span></span><br><span class="line"><span class="comment"> * boolean equals IgnoreCase(String anotherString)：与equals方法类似，忽略大小写</span></span><br><span class="line"><span class="comment"> * String concat(String str)：将指定字符串连接到此字符串的结尾。等价于用“+”</span></span><br><span class="line"><span class="comment"> * int compareTo(String anotherString)：比较两个字符串的大小</span></span><br><span class="line"><span class="comment"> * String substring(int beginIndex)：返回一个新的字符串，它是此字符串的从beginIndex开始截取到最后的一个子字符串。</span></span><br><span class="line"><span class="comment"> * String substring(int beginIndex,int endIndex)：返回一个新字符串，它是此字符串从beginIndex开始截取到endIndex(不包含)的一个子字符串。</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * boolean endsWith(String suffix)：测试此字符串是否以指定的后缀结束</span></span><br><span class="line"><span class="comment"> * boolean startsWith(String prefix)：测试此字符串是否以指定的前缀开始</span></span><br><span class="line"><span class="comment"> * boolean startsWith(String prefix, int toffset)：测试此字符串从指定索引开始的子字符串是否以指定前缀开始</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * boolean contains(CharSequence s)：当且仅当此字符串包含指定的 char 值序列时，返回 true</span></span><br><span class="line"><span class="comment"> * int indexOf(String str)：返回指定子字符串在此字符串中第一次出现处的索引</span></span><br><span class="line"><span class="comment"> * int indexOf(String str, int fromIndex)：返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始</span></span><br><span class="line"><span class="comment"> * int lastIndexOf(String str)：返回指定子字符串在此字符串中最右边出现处的索引</span></span><br><span class="line"><span class="comment"> * int lastIndexOf(String str, int fromIndex)：返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 注：indexOf和lastIndexOf方法如果未找到都是返回-1</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 替换：</span></span><br><span class="line"><span class="comment">    * String replace(char oldChar, char newChar)：返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的。</span></span><br><span class="line"><span class="comment">    * String replace(CharSequence target, CharSequence replacement)：使用指定的字面值替换序列替换此字符串所有匹配字面值目标序列的子字符串。</span></span><br><span class="line"><span class="comment">    * String replaceAll(String regex, String replacement)：使用给定的 replacement 替换此字符串所有匹配给定的正则表达式的子字符串。</span></span><br><span class="line"><span class="comment">    * String replaceFirst(String regex, String replacement)：使用给定的 replacement 替换此字符串匹配给定的正则表达式的第一个子字符串。</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * 匹配:</span></span><br><span class="line"><span class="comment">    * boolean matches(String regex)：告知此字符串是否匹配给定的正则表达式。</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * 切片：</span></span><br><span class="line"><span class="comment">    * String[] split(String regex)：根据给定正则表达式的匹配拆分此字符串。</span></span><br><span class="line"><span class="comment">    * String[] split(String regex, int limit)：根据匹配给定的正则表达式来拆分此字符串，最多不超过limit个，如果超过了，剩下的全部都放到最后一个元素中。</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    */</span></span><br></pre></td></tr></table></figure>

<h4 id="8-String与其他数据类型之间的转换"><a href="#8-String与其他数据类型之间的转换" class="headerlink" title="8.String与其他数据类型之间的转换"></a>8.String与其他数据类型之间的转换</h4><ul>
<li><p>String–&gt; int  使用 Integer.parseInt(str1);将字符串转换为数字</p>
</li>
<li><p>String –&gt; char[]:调用String的toCharArray()</p>
</li>
<li><p>char[] –&gt; String:调用String的构造器</p>
</li>
<li><p>String &lt;—&gt;  byte   </p>
<ul>
<li>编码：String –&gt; byte[]:调用String的getBytes()</li>
<li>解码：byte[] –&gt; String:调用String的构造器</li>
</ul>
</li>
</ul>
<h4 id="9、StringBuffer和StringBuilder的介绍"><a href="#9、StringBuffer和StringBuilder的介绍" class="headerlink" title="9、StringBuffer和StringBuilder的介绍"></a>9、StringBuffer和StringBuilder的介绍</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * String、StringBuffer、StringBuilder三者的异同？</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * String:不可变的字符序列；底层使用char[]存储</span></span><br><span class="line"><span class="comment"> * StringBuffer:可变的字符序列；线程安全的，效率低；底层使用char[]存储</span></span><br><span class="line"><span class="comment"> * StringBuilder:可变的字符序列；jdk5.0新增的，线程不安全的，效率高；底层使用char[]存储</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h4 id="10、StringBuffer的源码分析"><a href="#10、StringBuffer的源码分析" class="headerlink" title="10、StringBuffer的源码分析"></a>10、StringBuffer的源码分析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 源码分析：</span></span><br><span class="line"><span class="comment"> * String str = new String();//char[] value = new char[0];</span></span><br><span class="line"><span class="comment"> * String str1 = new String(&quot;abc&quot;);//char[] value = new char[]&#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;&#125;;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * StringBuffer sb1 = new StringBuffer();//char[] value = new char[16];底层创建了一个长度是16的数组。</span></span><br><span class="line"><span class="comment"> * System.out.println(sb1.length());//</span></span><br><span class="line"><span class="comment"> * sb1.append(&#x27;a&#x27;);//value[0] = &#x27;a&#x27;;</span></span><br><span class="line"><span class="comment"> * sb1.append(&#x27;b&#x27;);//value[1] = &#x27;b&#x27;;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * StringBuffer sb2 = new StringBuffer(&quot;abc&quot;);//char[] value = new char[&quot;abc&quot;.length() + 16];</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * //问题1.System.out.println(sb2.length());//3</span></span><br><span class="line"><span class="comment"> * //问题2.扩容问题:如果要添加的数据底层数组盛不下了，那就需要扩容底层的数组。</span></span><br><span class="line"><span class="comment"> *        默认情况下，扩容为原来容量的2倍 + 2，同时将原有数组中的元素复制到新的数组中。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 意义：开发中建议大家使用：StringBuffer(int capacity) 或 StringBuilder(int capacity)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h4 id="11、StringBuffer中的常用方法"><a href="#11、StringBuffer中的常用方法" class="headerlink" title="11、StringBuffer中的常用方法"></a>11、StringBuffer中的常用方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * StringBuffer的常用方法：</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * StringBuffer append(xxx)：提供了很多的append()方法，用于进行字符串拼接</span></span><br><span class="line"><span class="comment">     * StringBuffer delete(int start,int end)：删除指定位置的内容</span></span><br><span class="line"><span class="comment">     * StringBuffer replace(int start, int end, String str)：把[start,end)位置替换为str</span></span><br><span class="line"><span class="comment">     * StringBuffer insert(int offset, xxx)：在指定位置插入xxx</span></span><br><span class="line"><span class="comment">     * StringBuffer reverse() ：把当前字符序列逆转</span></span><br><span class="line"><span class="comment">     * public int indexOf(String str)</span></span><br><span class="line"><span class="comment">     * public String substring(int start,int end):返回一个从start开始到end索引结束的左闭右开区间的子字符串</span></span><br><span class="line"><span class="comment">     * public int length()</span></span><br><span class="line"><span class="comment">     * public char charAt(int n )</span></span><br><span class="line"><span class="comment">     * public void setCharAt(int n ,char ch)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 总结：</span></span><br><span class="line"><span class="comment">     *     增：append(xxx)</span></span><br><span class="line"><span class="comment">     *     删：delete(int start,int end)</span></span><br><span class="line"><span class="comment">     *     改：setCharAt(int n ,char ch) / replace(int start, int end, String str)</span></span><br><span class="line"><span class="comment">     *     查：charAt(int n )</span></span><br><span class="line"><span class="comment">     *     插：insert(int offset, xxx)</span></span><br><span class="line"><span class="comment">     *     长度：length();</span></span><br><span class="line"><span class="comment">     *     遍历：for() + charAt() / toString()</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure>

<p>12、String、StringBuffer、StringBuilder效率对比   —–相比String，其他两个</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对比String、StringBuffer、StringBuilder三者的效率：</span></span><br><span class="line"><span class="comment">     * 从高到低排列：StringBuilder &gt; StringBuffer &gt; String</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure>

<h3 id="2、JDK-8之前的日期时间API"><a href="#2、JDK-8之前的日期时间API" class="headerlink" title="2、JDK 8之前的日期时间API"></a>2、JDK 8之前的日期时间API</h3><p><img src="http://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/21debf6ef21a57f7c1120fe58649ef71--3936--f-18.png" alt="f-18"></p>
<h4 id="1、System类中获取时间戳的方法"><a href="#1、System类中获取时间戳的方法" class="headerlink" title="1、System类中获取时间戳的方法"></a>1、System类中获取时间戳的方法</h4><blockquote>
<p>System类提供的public static long currentTimeMillis()用来返回当前时间与1970年1月1日0时0分0秒之间以毫秒为单位的时间差。</p>
</blockquote>
<ul>
<li>此方法适于计算时间差。</li>
<li>计算世界时间的主要标准有：<ul>
<li>UTC(Coordinated Universal Time)</li>
<li>GMT(Greenwich Mean Time)</li>
<li>CST(Central Standard Time)</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//返回当前时间与1970年1月1日0时0分0秒之间以毫秒为单位的时间差。</span></span><br><span class="line">        <span class="comment">//称为时间戳</span></span><br></pre></td></tr></table></figure>

<h4 id="2、Java中两个Date类的使用"><a href="#2、Java中两个Date类的使用" class="headerlink" title="2、Java中两个Date类的使用"></a>2、Java中两个Date类的使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DateDemo</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * java.util.Date类 ---&gt; 表示特定的瞬间，精确到毫秒</span></span><br><span class="line"><span class="comment">     *            |---java.sql.Date类</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 1.两个构造器的使用</span></span><br><span class="line"><span class="comment">     *     &gt;构造器一：Date()：创建一个对应当前时间的Date对象</span></span><br><span class="line"><span class="comment">     *     &gt;构造器二：创建指定毫秒数的Date对象</span></span><br><span class="line"><span class="comment">     * 2.两个方法的使用</span></span><br><span class="line"><span class="comment">     *     &gt;toString():显示当前的年、月、日、时、分、秒</span></span><br><span class="line"><span class="comment">     *     &gt;getTime():获取当前Date对象对应的毫秒数。（时间戳）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 3. java.sql.Date对应着数据库中的日期类型的变量</span></span><br><span class="line"><span class="comment">     *     &gt;如何实例化</span></span><br><span class="line"><span class="comment">     *     &gt;如何将java.util.Date对象转换为java.sql.Date对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//构造器一：Date()：创建一个对应当前时间的Date对象</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">date1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        System.out.println(date1.toString());   <span class="comment">//Tue Sep 17 13:39:46 CST 2024</span></span><br><span class="line"></span><br><span class="line">        System.out.println(date1.getTime());    <span class="comment">//1726551586623</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//构造器二：创建指定毫秒数的Date对象</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">date2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">1726551586623L</span>);</span><br><span class="line">        System.out.println(date2.toString());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建java.sql.Date对象</span></span><br><span class="line">        java.sql.<span class="type">Date</span> <span class="variable">date3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">java</span>.sql.Date(<span class="number">35635325345L</span>);</span><br><span class="line">        System.out.println(date3);  <span class="comment">//1971-02-17</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//如何将java.util.Date对象转换为java.sql.Date对象</span></span><br><span class="line">        <span class="comment">//情况一：</span></span><br><span class="line"><span class="comment">//        Date date4 = new java.sql.Date(2343243242323L);</span></span><br><span class="line"><span class="comment">//        java.sql.Date date5 = (java.sql.Date) date4;</span></span><br><span class="line">        <span class="comment">//情况二：</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">date6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        java.sql.<span class="type">Date</span> <span class="variable">date7</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">java</span>.sql.Date(date6.getTime());</span><br><span class="line">        System.out.println(date7);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/dd405cec8a709e7320fbee9bd1727cda--f922--image-20240917134808187.png" alt="image-20240917134808187"></p>
<h4 id="3、SimpleDateFormate的使用"><a href="#3、SimpleDateFormate的使用" class="headerlink" title="3、SimpleDateFormate的使用"></a>3、SimpleDateFormate的使用</h4><ul>
<li>Date类的API不易于国际化，大部分被废弃了，java.text.SimpleDateFormat类是一个不与语言环境有关的方式来格式化和解析日期的具体类。</li>
<li>它允许进行<ul>
<li>格式化：日期—&gt;文本</li>
<li>解析：文本—&gt;日期</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/a51b3ad3b6fc096f0abfbedb5a5db10a--7906--image-20240917135507627.png" alt="image-20240917135507627"></p>
<ul>
<li>主要用于对格式日期的读取，或者对日期进行自定义格式化</li>
</ul>
<h4 id="4、Calendar日历类的使用"><a href="#4、Calendar日历类的使用" class="headerlink" title="4、Calendar日历类的使用"></a>4、Calendar日历类的使用</h4><ul>
<li>Calendar是一个抽象基类，主用用于完成日期字段之间相互操作的功能。</li>
<li>获取Calendar实例的方法<ul>
<li>使用Calendar.getInstance()方法</li>
<li>调用它的子类GregorianCalendar的构造器。</li>
</ul>
</li>
<li>一个Calendar的实例是系统时间的抽象表示，通过get(intfield)方法来取得想要的时间信息。比如YEAR、MONTH、DAY_OF_WEEK、HOUR_OF_DAY 、MINUTE、SECOND<ul>
<li>public void set(intfield,intvalue)</li>
<li>public void add(intfield,intamount)</li>
<li>public final Date getTime()</li>
<li>public final void setTime(Date date)</li>
</ul>
</li>
<li>注意:<ul>
<li>获取月份时：一月是0，二月是1，以此类推，12月是11</li>
<li>获取星期时：周日是1，周二是2，。。。。周六是7</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DateFormateDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Calendar</span> <span class="variable">calendar</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得是该月第几天</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">days</span> <span class="operator">=</span> calendar.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">        System.out.println(days); <span class="comment">// 17</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 可变性</span></span><br><span class="line">        calendar.set(Calendar.DAY_OF_MONTH, days + <span class="number">1</span>);</span><br><span class="line">        days = calendar.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">        System.out.println(days);  <span class="comment">// 18</span></span><br><span class="line"></span><br><span class="line">        calendar.add(Calendar.DAY_OF_MONTH, <span class="number">6</span>);</span><br><span class="line">        days = calendar.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">        System.out.println(days); <span class="comment">//24</span></span><br><span class="line"></span><br><span class="line">        System.out.println(calendar.getTime()); <span class="comment">//Tue Sep 24 14:29:29 CST 2024</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        calendar.setTime(date);</span><br><span class="line">        System.out.println(calendar.getTime());<span class="comment">// Tue Sep 17 14:29:29 CST 2024</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、JDK8中日期API的介绍"><a href="#3、JDK8中日期API的介绍" class="headerlink" title="3、JDK8中日期API的介绍"></a>3、JDK8中日期API的介绍</h3><ul>
<li>新日期时间API出现的背景</li>
</ul>
<blockquote>
<p>如果我们可以跟别人说：“我们在1502643933071见面，别晚了！”那么就再简单不过了。但是我们希望时间与昼夜和四季有关，于是事情就变复杂了。JDK 1.0中包含了一个java.util.Date类，但是它的大多数方法已经在JDK 1.1引入Calendar类之后被弃用了。而Calendar并不比Date好多少。它们面临的问题是：</p>
<blockquote>
<p>可变性：像日期和时间这样的类应该是不可变的。</p>
</blockquote>
<blockquote>
<p>偏移性：Date中的年份是从1900开始的，而月份都从0开始。</p>
</blockquote>
<blockquote>
<p>格式化：格式化只对Date有用，Calendar则不行。</p>
</blockquote>
<blockquote>
<p>此外，它们也不是线程安全的；不能处理闰秒等。</p>
</blockquote>
<p>总结：对日期和时间的操作一直是Java程序员最痛苦的地方之一。</p>
</blockquote>
<ul>
<li>Java 8 吸收了Joda-Time 的精华，以一个新的开始为Java 创建优秀的API。新的java.time 中包含了所有关于<strong>本地日期（LocalDate）、本地时间（LocalTime）、本地日期时间（LocalDateTime）、时区（ZonedDateTime）和持续时间（Duration）的类</strong>。历史悠久的Date 类新增了toInstant() 方法，用于把Date 转换成新的表示形式。这些新增的本地化时间日期API 大大简化了日期时间和本地化的管理。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java.time–包含值对象的基础包</span><br><span class="line">java.time.chrono–提供对不同的日历系统的访问java.time.format–格式化和解析时间和日期java.time.temporal–包括底层框架和扩展特性java.time.zone–包含时区支持的类</span><br><span class="line"></span><br><span class="line">说明：大多数开发者只会用到基础包和format包，也可能会用到temporal包。因此，尽管有68个新的公开类型，大多数开发者，大概将只会用到其中的三分之一。</span><br></pre></td></tr></table></figure>

<h4 id="1-LocalDate、LocalTime、LocalDateTime的使用"><a href="#1-LocalDate、LocalTime、LocalDateTime的使用" class="headerlink" title="1.LocalDate、LocalTime、LocalDateTime的使用"></a>1.LocalDate、LocalTime、LocalDateTime的使用</h4><ul>
<li><p>LocalDate、LocalTime、LocalDateTime 类是其中较重要的几个类，它们的实例是<strong>不可变的对象</strong>，分别表示使用ISO-8601日历系统的日期、时间、日期和时间。它们提供了简单的本地日期或时间，并不包含当前的时间信息，也不包含与时区相关的信息。</p>
<ul>
<li>LocalDate代表IOS格式（yyyy-MM-dd）的日期,可以存储生日、纪念日等日期。</li>
<li>LocalTime表示一个时间，而不是日期。</li>
<li>LocalDateTime是用来表示日期和时间的，<strong>这是一个最常用的类之一</strong>。</li>
</ul>
</li>
<li><p>注：ISO-8601日历系统是国际标准化组织制定的现代公民的日期和时间的表示法，也就是公历。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.LocalDate;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalTime;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DateFormate8</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//now():获取当前的日期、时间、日期+时间</span></span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">localDate</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line">        <span class="type">LocalTime</span> <span class="variable">localTime</span> <span class="operator">=</span> LocalTime.now();</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line"></span><br><span class="line">        System.out.println(localDate); <span class="comment">//2024-09-17</span></span><br><span class="line">        System.out.println(localTime);<span class="comment">//14:59:25.963644900</span></span><br><span class="line">        System.out.println(localDateTime);<span class="comment">//2024-09-17T14:59:25.963644900</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//of():设置指定的年、月、日、时、分、秒。没有偏移量</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">localDateTime1</span> <span class="operator">=</span> LocalDateTime.of(<span class="number">2024</span>, <span class="number">12</span>, <span class="number">6</span>, <span class="number">13</span>, <span class="number">25</span>, <span class="number">52</span>);</span><br><span class="line">        System.out.println(localDateTime1); <span class="comment">//2024-12-06T13:25:52</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//getXxx()：获取相关的属性</span></span><br><span class="line">        System.out.println(localDateTime.getDayOfMonth()); <span class="comment">//17</span></span><br><span class="line">        System.out.println(localDateTime.getDayOfWeek());<span class="comment">//TUESDAY</span></span><br><span class="line">        System.out.println(localDateTime.getMonth());<span class="comment">//SEPTEMBER</span></span><br><span class="line">        System.out.println(localDateTime.getMonthValue());<span class="comment">//9</span></span><br><span class="line">        System.out.println(localDateTime.getMinute());<span class="comment">//1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 体现不可变性</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">localDateTime2</span> <span class="operator">=</span> localDateTime.withDayOfMonth(<span class="number">23</span>);</span><br><span class="line">        System.out.println(localDateTime); <span class="comment">//2024-09-17T15:03:22.654453100</span></span><br><span class="line">        System.out.println(localDateTime2);<span class="comment">//2024-09-23T15:03:22.654453100</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/036c79ac6d7da45dda9da1226bf8facd--eb96--01.png" alt="01"></p>
<h4 id="2、Instant类的使用"><a href="#2、Instant类的使用" class="headerlink" title="2、Instant类的使用"></a>2、Instant类的使用</h4><ul>
<li>Instant：时间线上的一个瞬时点。这可能被用来记录应用程序中的事件时间戳。</li>
<li>在处理时间和日期的时候，我们通常会想到年,月,日,时,分,秒。然而，这只是时间的一个模型，是面向人类的。第二种通用模型是面向机器的，或者说是连续的。在此模型中，时间线中的一个点表示为一个很大的数，这有利于计算机处理。在UNIX中，这个数从1970年开始，以秒为的单位；同样的，在Java中，也是从1970年开始，但以毫秒为单位。</li>
<li>java.time包通过值类型Instant提供机器视图，不提供处理人类意义上的时间单位。Instant表示时间线上的一点，而不需要任何上下文信息，例如，时区。概念上讲，它只是简单的表示自1970年1月1日0时0分0秒（UTC）开始的秒数。因为java.time包是基于纳秒计算的，所以Instant的精度可以达到纳秒级。</li>
<li>(1 ns &#x3D; 10-9s)   1秒&#x3D; 1000毫秒&#x3D;10^6微秒&#x3D;10^9纳秒</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/4a960f7e7bfc8b68f5cb42eaebbc0064--95a7--02.png" alt="02"></p>
<ul>
<li>时间戳是指格林威治时间1970年01月01日00时00分00秒(北京时间1970年01月01日08时00分00秒)起至现在的总秒数。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/512c704c1691e6d466a59c9e120b99ba--9137--03.png" alt="03"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.Instant;</span><br><span class="line"><span class="keyword">import</span> java.time.OffsetDateTime;</span><br><span class="line"><span class="keyword">import</span> java.time.ZoneOffset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InstantDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//now():获取本初子午线对应的标准时间</span></span><br><span class="line">        <span class="type">Instant</span> <span class="variable">instant</span> <span class="operator">=</span> Instant.now();</span><br><span class="line">        System.out.println(instant);<span class="comment">//2024-09-17T07:10:05.668448200Z</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加时间的偏移量</span></span><br><span class="line">        <span class="type">OffsetDateTime</span> <span class="variable">offsetDateTime</span> <span class="operator">=</span> instant.atOffset(ZoneOffset.ofHours(<span class="number">8</span>));<span class="comment">//东八区</span></span><br><span class="line">        System.out.println(offsetDateTime); <span class="comment">//2024-09-17T15:10:05.668448200+08:00</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//toEpochMilli():获取自1970年1月1日0时0分0秒（UTC）开始的毫秒数  ---&gt; Date类的getTime()</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">milli</span> <span class="operator">=</span> instant.toEpochMilli();</span><br><span class="line">        System.out.println(milli);  <span class="comment">//1726557005668</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//ofEpochMilli():通过给定的毫秒数，获取Instant实例  --&gt;Date(long millis)</span></span><br><span class="line">        <span class="type">Instant</span> <span class="variable">instant1</span> <span class="operator">=</span> Instant.ofEpochMilli(<span class="number">1550475314878L</span>);</span><br><span class="line">        System.out.println(instant1);   <span class="comment">//2019-02-18T07:35:14.878Z</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、Java比较器"><a href="#4、Java比较器" class="headerlink" title="4、Java比较器"></a>4、Java比较器</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h4><blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 一、说明：Java中的对象，正常情况下，只能进行比较：==  或  != 。不能使用 &gt; 或 &lt; 的</span></span><br><span class="line"><span class="comment">*          但是在开发场景中，我们需要对多个对象进行排序，言外之意，就需要比较对象的大小。</span></span><br><span class="line"><span class="comment">*          如何实现？使用两个接口中的任何一个：Comparable 或 Comparator</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><p>Java实现对象排序的方式有两种：</p>
<ul>
<li>自然排序：java.lang.Comparable</li>
<li>定制排序：java.util.Comparator</li>
</ul>
</li>
<li><p>Comparable自然排序举例</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompareTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">          Comparable接口的使用举例：  自然排序</span></span><br><span class="line"><span class="comment">          1.像String、包装类等实现了Comparable接口，重写了compareTo(obj)方法，给出了比较两个对象大小的方式。</span></span><br><span class="line"><span class="comment">          2.像String、包装类重写compareTo()方法以后，进行了从小到大的排列</span></span><br><span class="line"><span class="comment">          3. 重写compareTo(obj)的规则：</span></span><br><span class="line"><span class="comment">             如果当前对象this大于形参对象obj，则返回正整数，</span></span><br><span class="line"><span class="comment">             如果当前对象this小于形参对象obj，则返回负整数，</span></span><br><span class="line"><span class="comment">             如果当前对象this等于形参对象obj，则返回零。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        String[] arr = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;AA&quot;</span>,<span class="string">&quot;CC&quot;</span>,<span class="string">&quot;KK&quot;</span>,<span class="string">&quot;MM&quot;</span>,<span class="string">&quot;GG&quot;</span>,<span class="string">&quot;JJ&quot;</span>,<span class="string">&quot;DD&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr)); <span class="comment">//[AA, CC, DD, GG, JJ, KK, MM]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、自定义类实现Comparable自然排序"><a href="#2、自定义类实现Comparable自然排序" class="headerlink" title="2、自定义类实现Comparable自然排序"></a>2、自定义类实现Comparable自然排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompareTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 4.对于自定义类来说，如果需要排序，我们可以让自定义类实现Comparable接口，重写compareTo(obj)方法。</span></span><br><span class="line"><span class="comment">     *   在compareTo(obj)方法中指明如何排序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        test2(); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">        Goods[] arr = <span class="keyword">new</span> <span class="title class_">Goods</span>[<span class="number">5</span>];</span><br><span class="line">        arr[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;lenovoMouse&quot;</span>,<span class="number">34</span>);</span><br><span class="line">        arr[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;dellMouse&quot;</span>,<span class="number">43</span>);</span><br><span class="line">        arr[<span class="number">2</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;xiaomiMouse&quot;</span>,<span class="number">12</span>);</span><br><span class="line">        arr[<span class="number">3</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;huaweiMouse&quot;</span>,<span class="number">65</span>);</span><br><span class="line">        arr[<span class="number">4</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;microsoftMouse&quot;</span>,<span class="number">43</span>);</span><br><span class="line"></span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line"></span><br><span class="line">        System.out.println(Arrays.toString(arr));  <span class="comment">//[Goods&#123;name=&#x27;xiaomiMouse&#x27;, price=12.0&#125;, Goods&#123;name=&#x27;lenovoMouse&#x27;, price=34.0&#125;, Goods&#123;name=&#x27;microsoftMouse&#x27;, price=43.0&#125;, Goods&#123;name=&#x27;dellMouse&#x27;, price=43.0&#125;, Goods&#123;name=&#x27;huaweiMouse&#x27;, price=65.0&#125;]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Goods类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Goods</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> price;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Goods</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Goods</span><span class="params">(String name, <span class="type">double</span> price)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getPrice</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPrice</span><span class="params">(<span class="type">double</span> price)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Goods&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, price=&quot;</span> + price +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指明商品比较大小的方式:按照价格从低到高排序,再按照产品名称从高到低排序</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object o)</span> &#123;</span><br><span class="line"><span class="comment">//        System.out.println(&quot;**************&quot;);</span></span><br><span class="line">        <span class="keyword">if</span>(o <span class="keyword">instanceof</span> Goods goods)&#123;</span><br><span class="line">            <span class="comment">//方式一：</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">this</span>.price &gt; goods.price)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">this</span>.price &lt; goods.price)&#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//                return 0;</span></span><br><span class="line">                <span class="keyword">return</span> -<span class="built_in">this</span>.name.compareTo(goods.name);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//方式二：</span></span><br><span class="line"><span class="comment">//           return Double.compare(this.price,goods.price);</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        return 0;</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;传入的数据类型不一致！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="3、使用Comparator实现定制排序"><a href="#3、使用Comparator实现定制排序" class="headerlink" title="3、使用Comparator实现定制排序"></a>3、使用Comparator实现定制排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompareTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Comparator接口的使用：定制排序</span></span><br><span class="line"><span class="comment">     *     1.背景：</span></span><br><span class="line"><span class="comment">     *     当元素的类型没有实现java.lang.Comparable接口而又不方便修改代码，</span></span><br><span class="line"><span class="comment">     *     或者实现了java.lang.Comparable接口的排序规则不适合当前的操作，</span></span><br><span class="line"><span class="comment">     *     那么可以考虑使用 Comparator 的对象来排序</span></span><br><span class="line"><span class="comment">     *     2.重写compare(Object o1,Object o2)方法，比较o1和o2的大小：</span></span><br><span class="line"><span class="comment">     *     如果方法返回正整数，则表示o1大于o2；</span></span><br><span class="line"><span class="comment">     *     如果返回0，表示相等；</span></span><br><span class="line"><span class="comment">     *     返回负整数，表示o1小于o2。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">        String[] arr = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;AA&quot;</span>,<span class="string">&quot;CC&quot;</span>,<span class="string">&quot;KK&quot;</span>,<span class="string">&quot;MM&quot;</span>,<span class="string">&quot;GG&quot;</span>,<span class="string">&quot;JJ&quot;</span>,<span class="string">&quot;DD&quot;</span>&#125;;</span><br><span class="line">        Arrays.sort(arr,<span class="keyword">new</span> <span class="title class_">Comparator</span>()&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//按照字符串从大到小的顺序排列</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(o1 <span class="keyword">instanceof</span> String &amp;&amp; o2 <span class="keyword">instanceof</span>  String)&#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> (String) o1;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> (String) o2;</span><br><span class="line">                    <span class="keyword">return</span> -s1.compareTo(s2);</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">//                return 0;</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;输入的数据类型不一致&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span>&#123;</span><br><span class="line">        Goods[] arr = <span class="keyword">new</span> <span class="title class_">Goods</span>[<span class="number">6</span>];</span><br><span class="line">        arr[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;lenovoMouse&quot;</span>,<span class="number">34</span>);</span><br><span class="line">        arr[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;dellMouse&quot;</span>,<span class="number">43</span>);</span><br><span class="line">        arr[<span class="number">2</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;xiaomiMouse&quot;</span>,<span class="number">12</span>);</span><br><span class="line">        arr[<span class="number">3</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;huaweiMouse&quot;</span>,<span class="number">65</span>);</span><br><span class="line">        arr[<span class="number">4</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;huaweiMouse&quot;</span>,<span class="number">224</span>);</span><br><span class="line">        arr[<span class="number">5</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;microsoftMouse&quot;</span>,<span class="number">43</span>);</span><br><span class="line"></span><br><span class="line">        Arrays.sort(arr, <span class="keyword">new</span> <span class="title class_">Comparator</span>() &#123;</span><br><span class="line">            <span class="comment">//指明商品比较大小的方式:按照产品名称从低到高排序,再按照价格从高到低排序</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(o1 <span class="keyword">instanceof</span> Goods &amp;&amp; o2 <span class="keyword">instanceof</span> Goods)&#123;</span><br><span class="line">                    <span class="type">Goods</span> <span class="variable">g1</span> <span class="operator">=</span> (Goods)o1;</span><br><span class="line">                    <span class="type">Goods</span> <span class="variable">g2</span> <span class="operator">=</span> (Goods)o2;</span><br><span class="line">                    <span class="keyword">if</span>(g1.getName().equals(g2.getName()))&#123;</span><br><span class="line">                        <span class="keyword">return</span> -Double.compare(g1.getPrice(),g2.getPrice());</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> g1.getName().compareTo(g2.getName());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;输入的数据类型不一致&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>Comparable接口与Comparator的使用的对比</strong>：<ul>
<li>Comparable接口的方式一旦一定，保证Comparable接口实现类的对象在任何位置都可以比较大小。</li>
<li>Comparator接口属于临时性的比较。</li>
</ul>
</li>
</ul>
<h3 id="5、System类、Math类、BigInteger与BigDecimal"><a href="#5、System类、Math类、BigInteger与BigDecimal" class="headerlink" title="5、System类、Math类、BigInteger与BigDecimal"></a>5、System类、Math类、BigInteger与BigDecimal</h3><h4 id="1、System类"><a href="#1、System类" class="headerlink" title="1、System类"></a>1、System类</h4><ul>
<li><p>System类代表系统，系统级的很多属性和控制方法都放置在该类的内部。该类位于java.lang包。</p>
</li>
<li><p>由于该类的构造器是private的，所以无法创建该类的对象，也就是无法实例化该类。其内部的成员变量和成员方法都是static的，所以也可以很方便的进行调用。</p>
</li>
<li><p>成员变量</p>
<ul>
<li>System类内部包含in、out和err三个成员变量，分别代表标准输入流(键盘输入)，标准输出流(显示器)和标准错误输出流(显示器)。</li>
</ul>
</li>
<li><p>成员方法</p>
<ul>
<li><p>native long currentTimeMillis()：</p>
<blockquote>
<p>该方法的作用是返回当前的计算机时间，时间的表达格式为当前计算机时间和GMT时间(格林威治时间)1970年1月1号0时0分0秒所差的毫秒数。</p>
</blockquote>
</li>
<li><p>void exit(int status)：</p>
<blockquote>
<p>该方法的作用是退出程序。其中status的值为0代表正常退出，非零代表异常退出。使用该方法可以在图形界面编程中实现程序的退出功能等。</p>
</blockquote>
</li>
<li><p>void gc()：</p>
<blockquote>
<p>该方法的作用是请求系统进行垃圾回收。至于系统是否立刻回收，则取决于系统中垃圾回收算法的实现以及系统执行时的情况。String </p>
</blockquote>
</li>
<li><p>getProperty(String key)：</p>
<blockquote>
<p>该方法的作用是获得系统中属性名为key的属性对应的值。系统中常见的属性名以及属性的作用如下表所示：</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/73bb56682e583202b5dce7dadb23a2d0--3b71--06.png" alt="06"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SystemDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">javaVersion</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;java.version&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;java的version:&quot;</span> + javaVersion);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">javaHome</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;java.home&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;java的home:&quot;</span> + javaHome);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">osName</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;os.name&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;os的name:&quot;</span> + osName);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">osVersion</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;os.version&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;os的version:&quot;</span> + osVersion);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">userName</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;user.name&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;user的name:&quot;</span> + userName);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">userHome</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;user.home&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;user的home:&quot;</span> + userHome);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">userDir</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;user.dir&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;user的dir:&quot;</span> + userDir);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*        java的version:22.0.2</span></span><br><span class="line"><span class="comment">        java的home:C:\Users\ASUS\.jdks\openjdk-22.0.2</span></span><br><span class="line"><span class="comment">        os的name:Windows 11</span></span><br><span class="line"><span class="comment">        os的version:10.0</span></span><br><span class="line"><span class="comment">        user的name:ASUS</span></span><br><span class="line"><span class="comment">        user的home:C:\Users\ASUS</span></span><br><span class="line"><span class="comment">        user的dir:E:\JavaWeb\Demo</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、Math类"><a href="#2、Math类" class="headerlink" title="2、Math类"></a>2、Math类</h4><ul>
<li>这个在之前也简单使用过的</li>
</ul>
<blockquote>
<p>java.lang.Math提供了一系列静态方法用于科学计算。其方法的参数和返回值类型一般为double型。</p>
</blockquote>
<blockquote>
<p>abs     绝对值</p>
<p>acos,asin,atan,cos,sin,tan  三角函数</p>
<p>sqrt     平方根</p>
<p>pow(double a,doble b)     a的b次幂</p>
<p>log    自然对数</p>
<p>exp    e为底指数</p>
<p>max(double a,double b)</p>
<p>min(double a,double b)</p>
<p>random()      返回0.0到1.0的随机数</p>
<p>long round(double a)     double型数据a转换为long型（四舍五入）</p>
<p>toDegrees(double angrad)     弧度—&gt;角度</p>
<p>toRadians(double angdeg)     角度—&gt;弧度</p>
</blockquote>
<h4 id="3、BigInteger与BigDecimal"><a href="#3、BigInteger与BigDecimal" class="headerlink" title="3、BigInteger与BigDecimal"></a>3、BigInteger与BigDecimal</h4><ul>
<li><p>Integer类作为int的包装类，能存储的最大整型值为2^31 -1，Long类也是有限的，最大为2^63 -1。如果要表示再大的整数，不管是基本数据类型还是他们的包装类都无能为力，更不用说进行运算了。</p>
</li>
<li><p>java.math包的BigInteger可以表示不可变的任意精度的整数。BigInteger 提供所有Java 的基本整数操作符的对应物，并提供java.lang.Math 的所有相关方法。另外，BigInteger 还提供以下运算：模算术、GCD 计算、质数测试、素数生成、位操作以及一些其他操作。</p>
</li>
<li><p>构造器</p>
<ul>
<li>BigInteger(String val)：根据字符串构建BigInteger对象</li>
</ul>
</li>
<li><p>常用方法</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/42ffa72f12011be3b40c0802081b0816--02c2--07.png" alt="07"></p>
<ul>
<li>一般的Float类和Double类可以用来做科学计算或工程计算，但<strong>在商业计算中，要求数字精度比较高，故用到java.math.BigDecimal类</strong>。</li>
<li>BigDecimal类支持不可变的、任意精度的有符号十进制定点数。</li>
<li>构造器<ul>
<li>public BigDecimal(double val)</li>
<li>public BigDecimal(String val)</li>
</ul>
</li>
<li>常用方法<ul>
<li>public BigDecimal add(BigDecimal augend)</li>
<li>public BigDecimal subtract(BigDecimal subtrahend)</li>
<li>public BigDecimal multiply(BigDecimal multiplicand)</li>
<li>public BigDecimal divide(BigDecimal divisor, int scale, int roundingMode)</li>
</ul>
</li>
</ul>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="1、Java集合框架概述"><a href="#1、Java集合框架概述" class="headerlink" title="1、Java集合框架概述"></a>1、Java集合框架概述</h3><h4 id="1、集合框架和数组的对比及概述"><a href="#1、集合框架和数组的对比及概述" class="headerlink" title="1、集合框架和数组的对比及概述"></a>1、集合框架和数组的对比及概述</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一、集合的框架</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1.集合、数组都是对多个数据进行存储操作的结构，简称Java容器。</span></span><br><span class="line"><span class="comment"> *   说明；此时的存储，主要是指能存层面的存储，不涉及到持久化的存储（.txt,.jpg,.avi,数据库中）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 2.1数组在存储多个数据封面的特点：</span></span><br><span class="line"><span class="comment"> *      》一旦初始化以后，它的长度就确定了。</span></span><br><span class="line"><span class="comment"> *      》数组一旦定义好，它的数据类型也就确定了。我们就只能操作指定类型的数据了。</span></span><br><span class="line"><span class="comment"> *      比如：String[] arr;int[] str;</span></span><br><span class="line"><span class="comment"> * 2.2数组在存储多个数据方面的特点：</span></span><br><span class="line"><span class="comment"> *      》一旦初始化以后，其长度就不可修改。</span></span><br><span class="line"><span class="comment"> *      》数组中提供的方法非常有限，对于添加、删除、插入数据等操作，非常不便，同时效率不高。</span></span><br><span class="line"><span class="comment"> *      》获取数组中实际元素的个数的需求，数组没有现成的属性或方法可用</span></span><br><span class="line"><span class="comment"> *      》数组存储数据的特点：有序、可重复。对于无序、不可重复的需求，不能满足。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>集合的使用场景</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-26/689411ff1ee20d9f4676a6f37a92f14e--e1a9--image-20240926103359953.png" alt="image-20240926103359953"></p>
</li>
</ul>
<h4 id="2、集合框架涉及到的API"><a href="#2、集合框架涉及到的API" class="headerlink" title="2、集合框架涉及到的API"></a>2、集合框架涉及到的API</h4><ul>
<li><p>Java 集合可分为Collection 和Map 两种体系</p>
<ul>
<li>Collection接口：单列数据，定义了存取一组对象的方法的集合<ul>
<li>List：元素有序、可重复的集合</li>
<li>Set：元素无序、不可重复的集合</li>
</ul>
</li>
<li>Map接口：双列数据，保存具有映射关系“key-value对”的集合</li>
</ul>
</li>
<li><p><strong>Collection接口继承树</strong></p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-26/e5c5d1664e576887561e0b5d345399a0--f2ed--image-20240926103900334.png" alt="image-20240926103900334"></p>
<ul>
<li><strong>Map接口继承树</strong></li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-26/49f74611c39b83069b6b4b3b4fc70fe0--4580--image-20240926103921057.png" alt="image-20240926103921057"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 二、集合框架</span></span><br><span class="line"><span class="comment"> *      &amp;---Collection接口：单列集合，用来存储一个一个的对象</span></span><br><span class="line"><span class="comment"> *          &amp;---List接口：存储有序的、可重复的数据。  --&gt;“动态”数组</span></span><br><span class="line"><span class="comment"> *              &amp;---ArrayList、LinkedList、Vector</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *          &amp;---Set接口：存储无序的、不可重复的数据   --&gt;高中讲的“集合”</span></span><br><span class="line"><span class="comment"> *              &amp;---HashSet、LinkedHashSet、TreeSet</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      &amp;---Map接口：双列集合，用来存储一对(key - value)一对的数据   --&gt;高中函数：y = f(x)</span></span><br><span class="line"><span class="comment"> *          &amp;---HashMap、LinkedHashMap、TreeMap、Hashtable、Properties</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h3 id="2、Collection接口方法"><a href="#2、Collection接口方法" class="headerlink" title="2、Collection接口方法"></a>2、Collection接口方法</h3><ul>
<li>Collection 接口是List、Set 和Queue 接口的父接口，该接口里定义的方法既可用于操作Set 集合，也可用于操作List 和Queue 集合。</li>
<li>JDK不提供此接口的任何直接实现，而是提供更具体的子接口(如：Set和List)实现。</li>
<li>在Java5 之前，Java 集合会丢失容器中所有对象的数据类型，把所有对象都当成Object 类型处理；从JDK 5.0 增加了<strong>泛型</strong>以后，Java 集合可以记住容器中对象的数据类型。</li>
</ul>
<h4 id="Collection接口中的常用方法"><a href="#Collection接口中的常用方法" class="headerlink" title="Collection接口中的常用方法"></a>Collection接口中的常用方法</h4><ol>
<li>添加<ul>
<li>add(Objectobj)</li>
<li>addAll(Collectioncoll)</li>
</ul>
</li>
<li>获取有效元素的个数<ul>
<li>intsize()</li>
</ul>
</li>
<li>清空集合<ul>
<li>voidclear()</li>
</ul>
</li>
<li>是否是空集合<ul>
<li>boolean isEmpty()</li>
</ul>
</li>
<li>是否包含某个元素<ul>
<li>booleancontains(Objectobj)：是通过元素的equals方法来判断是否是同一个对象</li>
<li>booleancontainsAll(Collectionc)：也是调用元素的equals方法来比较的。拿两个集合的元素挨个比较。</li>
</ul>
</li>
<li>删除<ul>
<li>boolean remove(Object obj) ：通过元素的equals方法判断是否是要删除的那个元素。只会删除找到的第一个元素</li>
<li>boolean removeAll(Collection coll)：取当前集合的差集</li>
</ul>
</li>
<li>取两个集合的交集<ul>
<li>boolean retainAll(Collection c)：把交集的结果存在当前集合中，不影响c</li>
</ul>
</li>
<li>集合是否相等<ul>
<li>boolean equals(Object obj)</li>
</ul>
</li>
<li>转成对象数组<ul>
<li>Object[] toArray()</li>
</ul>
</li>
<li>获取集合对象的哈希值<ul>
<li>hashCode()</li>
</ul>
</li>
<li>遍历<ul>
<li>iterator()：返回迭代器对象，用于集合遍历</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Collection</span> <span class="variable">collection</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        collection.add(<span class="number">1</span>);</span><br><span class="line">        collection.add(<span class="number">2</span>);</span><br><span class="line">        collection.add(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(collection); <span class="comment">//[1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-Iterator迭代器接口"><a href="#3-Iterator迭代器接口" class="headerlink" title="3.Iterator迭代器接口"></a>3.Iterator迭代器接口</h3><ul>
<li>Iterator对象称为迭代器(设计模式的一种)，主要用于遍历Collection 集合中的元素。</li>
<li>GOF给迭代器模式的定义为：提供一种方法访问一个容器(container)对象中各个元素，而又不需暴露该对象的内部细节。<strong>迭代器模式，就是为容器而生</strong>。类似于“公交车上的售票员”、“火车上的乘务员”、“空姐”。</li>
<li>Collection接口继承了java.lang.Iterable接口，该接口有一个iterator()方法，那么所有实现了Collection接口的集合类都有一个iterator()方法，用以返回一个实现了Iterator接口的对象。</li>
<li><strong>Iterator 仅用于遍历集合</strong>，Iterator本身并不提供承装对象的能力。如果需要创建Iterator 对象，则必须有一个被迭代的集合。</li>
<li><strong>集合对象每次调用iterator()方法都得到一个全新的迭代器对象</strong>，默认游标都在集合的第一个元素之前。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IteratorTest</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Collection</span> <span class="variable">coll</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        coll.add(<span class="number">123</span>);</span><br><span class="line">        coll.add(<span class="number">456</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;Jerry&quot;</span>);</span><br><span class="line">        coll.add(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Tom&quot;</span>));</span><br><span class="line">        coll.add(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> coll.iterator();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//方式一：</span></span><br><span class="line"><span class="comment">//        System.out.println(iterator.next());</span></span><br><span class="line"><span class="comment">//        System.out.println(iterator.next());</span></span><br><span class="line"><span class="comment">//        System.out.println(iterator.next());</span></span><br><span class="line"><span class="comment">//        System.out.println(iterator.next());</span></span><br><span class="line"><span class="comment">//        System.out.println(iterator.next());</span></span><br><span class="line"><span class="comment">//        //报异常：NoSuchElementException</span></span><br><span class="line"><span class="comment">//        //因为：在调用it.next()方法之前必须要调用it.hasNext()进行检测。若不调用，且下一条记录无效，直接调用it.next()会抛出NoSuchElementException异常。</span></span><br><span class="line"><span class="comment">//        System.out.println(iterator.next());</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//方式二：不推荐</span></span><br><span class="line"><span class="comment">//        for(int i = 0;i &lt; coll.size();i++)&#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(iterator.next());</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//方式三：推荐</span></span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="迭代器Iterator的执行原理"><a href="#迭代器Iterator的执行原理" class="headerlink" title="迭代器Iterator的执行原理"></a>迭代器Iterator的执行原理</h4><p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-26/2e1a01fbd76a3b98b8060678b8c652da--578a--image-20240926113011579.png" alt="image-20240926113011579"></p>
<h4 id="Iterator迭代器remove-的使用"><a href="#Iterator迭代器remove-的使用" class="headerlink" title="Iterator迭代器remove()的使用"></a>Iterator迭代器remove()的使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 集合元素的遍历操作，使用迭代器Iterator接口</span></span><br><span class="line"><span class="comment"> * 1.内部的方法：hasNext()和 next()</span></span><br><span class="line"><span class="comment"> * 2.集合对象每次调用iterator()方法都得到一个全新的迭代器对象，默认游标都在集合的第一个元素之前。</span></span><br><span class="line"><span class="comment"> * 3.内部定义了remove(),可以在遍历的时候，删除集合中的元素。此方法不同于集合直接调用remove()</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> subei</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-05-12 12:22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IteratorTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//测试Iterator中的remove()方法</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Collection</span> <span class="variable">coll</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        coll.add(<span class="number">123</span>);</span><br><span class="line">        coll.add(<span class="number">456</span>);</span><br><span class="line">        coll.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Jerry&quot;</span>,<span class="number">20</span>));</span><br><span class="line">        coll.add(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Tom&quot;</span>));</span><br><span class="line">        coll.add(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//删除集合中”Tom”</span></span><br><span class="line">        <span class="comment">//如果还未调用next()或在上一次调用 next 方法之后已经调用了 remove 方法，</span></span><br><span class="line">        <span class="comment">// 再调用remove都会报IllegalStateException。</span></span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> coll.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line"><span class="comment">//            iterator.remove();</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;Tom&quot;</span>.equals(obj))&#123;</span><br><span class="line">                iterator.remove();</span><br><span class="line"><span class="comment">//                iterator.remove();                </span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历集合</span></span><br><span class="line">        iterator = coll.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>注意：<ul>
<li>Iterator可以删除集合的元素，但是是遍历过程中通过迭代器对象的remove方法，不是集合对象的remove方法。</li>
<li><strong>如果还未调用next()或在上一次调用next方法之后已经调用了remove方法，再调用remove都会报IllegalStateException</strong>。</li>
</ul>
</li>
</ul>
<h4 id="新特性foreach循环遍历集合或数组"><a href="#新特性foreach循环遍历集合或数组" class="headerlink" title="新特性foreach循环遍历集合或数组"></a>新特性foreach循环遍历集合或数组</h4><ul>
<li>Java 5.0 提供了foreach循环迭代访问Collection和数组。</li>
<li>遍历操作不需获取Collection或数组的长度，无需使用索引访问元素。</li>
<li><strong>遍历集合的底层调用Iterator完成操作。</strong></li>
<li>foreach还可以用来遍历数组。</li>
</ul>
<h3 id="4、Collection子接口之一：List接口"><a href="#4、Collection子接口之一：List接口" class="headerlink" title="4、Collection子接口之一：List接口"></a>4、Collection子接口之一：List接口</h3><h3 id="4-Collection子接口之一：List接口"><a href="#4-Collection子接口之一：List接口" class="headerlink" title="4.Collection子接口之一：List接口"></a>4.Collection子接口之一：List接口</h3><ul>
<li>鉴于Java中数组用来存储数据的局限性，我们通常使用List替代数组</li>
<li>List集合类中元素有序、且可重复，集合中的每个元素都有其对应的顺序索引。</li>
<li>List容器中的元素都对应一个整数型的序号记载其在容器中的位置，可以根据序号存取容器中的元素。</li>
<li>JDK API中List接口的实现类常用的有：ArrayList、LinkedList和Vector。</li>
</ul>
<h4 id="List接口常用实现类的对比"><a href="#List接口常用实现类的对比" class="headerlink" title="List接口常用实现类的对比"></a>List接口常用实现类的对比</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1. List接口框架</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    |----Collection接口：单列集合，用来存储一个一个的对象</span></span><br><span class="line"><span class="comment"> *          |----List接口：存储有序的、可重复的数据。  --&gt;“动态”数组,替换原有的数组</span></span><br><span class="line"><span class="comment"> *              |----ArrayList：作为List接口的主要实现类；线程不安全的，效率高；底层使用Object[] elementData存储</span></span><br><span class="line"><span class="comment"> *              |----LinkedList：对于频繁的插入、删除操作，使用此类效率比ArrayList高；底层使用双向链表存储</span></span><br><span class="line"><span class="comment"> *              |----Vector：作为List接口的古老实现类；线程安全的，效率低；底层使用Object[] elementData存储</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 面试题：比较ArrayList、LinkedList、Vector三者的异同？</span></span><br><span class="line"><span class="comment"> *        同：三个类都是实现了List接口，存储数据的特点相同：存储有序的、可重复的数据</span></span><br><span class="line"><span class="comment"> *        不同：见上</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h4 id="ArrayList的源码分析"><a href="#ArrayList的源码分析" class="headerlink" title="ArrayList的源码分析"></a>ArrayList的源码分析</h4><ul>
<li>ArrayList是List 接口的典型实现类、主要实现类</li>
<li>本质上，ArrayList是对象引用的一个”变长”数组</li>
</ul>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 2.ArrayList的源码分析：</span></span><br><span class="line"><span class="comment"> *   2.1 jdk 7情况下</span></span><br><span class="line"><span class="comment"> *      ArrayList list = new ArrayList();//底层创建了长度是10的Object[]数组elementData</span></span><br><span class="line"><span class="comment"> *      list.add(123);//elementData[0] = new Integer(123);</span></span><br><span class="line"><span class="comment"> *      ...</span></span><br><span class="line"><span class="comment"> *      list.add(11);//如果此次的添加导致底层elementData数组容量不够，则扩容。</span></span><br><span class="line"><span class="comment"> *      默认情况下，扩容为原来的容量的1.5倍，同时需要将原有数组中的数据复制到新的数组中。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      结论：建议开发中使用带参的构造器：ArrayList list = new ArrayList(int capacity)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   2.2 jdk 8中ArrayList的变化：</span></span><br><span class="line"><span class="comment"> *      ArrayList list = new ArrayList();//底层Object[] elementData初始化为&#123;&#125;.并没有创建长度为10的数组</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      list.add(123);//第一次调用add()时，底层才创建了长度10的数组，并将数据123添加到elementData[0]</span></span><br><span class="line"><span class="comment"> *      ...</span></span><br><span class="line"><span class="comment"> *      后续的添加和扩容操作与jdk 7 无异。</span></span><br><span class="line"><span class="comment"> *   2.3 小结：jdk7中的ArrayList的对象的创建类似于单例的饿汉式，而jdk8中的ArrayList的对象</span></span><br><span class="line"><span class="comment"> *            的创建类似于单例的懒汉式，延迟了数组的创建，节省内存。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="LinkedList的源码分析"><a href="#LinkedList的源码分析" class="headerlink" title="LinkedList的源码分析"></a>LinkedList的源码分析</h4><ul>
<li><p>对于频繁的插入或删除元素的操作，建议使用LinkedList类，效率较高</p>
</li>
<li><p>LinkedList：双向链表，内部没有声明数组，而是定义了Node类型的first和last，用于记录首末元素。同时，定义内部类Node，作为LinkedList中保存数据的基本结构。</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-26/d310da4fde968e21e9c4cd5fb731e3e1--e5c3--image-20240926114757184.png" alt="image-20240926114757184"></p>
</li>
</ul>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 3.LinkedList的源码分析：</span></span><br><span class="line"><span class="comment">  *       LinkedList list = new LinkedList(); 内部声明了Node类型的first和last属性，默认值为null</span></span><br><span class="line"><span class="comment">  *       list.add(123);//将123封装到Node中，创建了Node对象。</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  *       其中，Node定义为：体现了LinkedList的双向链表的说法</span></span><br><span class="line"><span class="comment">  *       private static class Node&lt;E&gt; &#123;</span></span><br><span class="line"><span class="comment">  *            E item;</span></span><br><span class="line"><span class="comment">  *            Node&lt;E&gt; next;</span></span><br><span class="line"><span class="comment">  *            Node&lt;E&gt; prev;</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  *            Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span></span><br><span class="line"><span class="comment">  *            this.item = element;</span></span><br><span class="line"><span class="comment">  *            this.next = next;     //next变量记录下一个元素的位置</span></span><br><span class="line"><span class="comment">  *            this.prev = prev;     //prev变量记录前一个元素的位置</span></span><br><span class="line"><span class="comment">  *            &#125;</span></span><br><span class="line"><span class="comment">  *        &#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="Vector的源码分析"><a href="#Vector的源码分析" class="headerlink" title="Vector的源码分析"></a>Vector的源码分析</h4><ul>
<li>Vector 是一个古老的集合，JDK1.0就有了。大多数操作与ArrayList相同，区别之处在于Vector是线程安全的。</li>
<li>在各种list中，最好把ArrayList作为缺省选择。当插入、删除频繁时，使用LinkedList；Vector总是比ArrayList慢，所以尽量避免使用。</li>
</ul>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">  * 4.Vector的源码分析：jdk7和jdk8中通过Vector()构造器创建对象时，底层都创建了长度为10的数组。</span></span><br><span class="line"><span class="comment">  *      在扩容方面，默认扩容为原来的数组长度的2倍。</span></span><br><span class="line"><span class="comment">  */</span>    </span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="List接口中的常用方法测试"><a href="#List接口中的常用方法测试" class="headerlink" title="List接口中的常用方法测试"></a>List接口中的常用方法测试</h4><ul>
<li>List除了从Collection集合继承的方法外，List 集合里添加了一些根据索引来操作集合元素的方法。<ul>
<li>void add(intindex, Object ele):在index位置插入ele元素</li>
<li>boolean addAll(int index, Collection eles):从index位置开始将eles中的所有元素添加进来</li>
<li>Object get(int index):获取指定index位置的元素</li>
<li>int indexOf(Object obj):返回obj在集合中首次出现的位置</li>
<li>int lastIndexOf(Object obj):返回obj在当前集合中末次出现的位置</li>
<li>Object remove(int index):移除指定index位置的元素，并返回此元素</li>
<li>Object set(int index, Object ele):设置指定index位置的元素为ele</li>
<li>List subList(int fromIndex, int toIndex):返回从fromIndex到toIndex位置的子集合</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 5.List接口的常用方法</span></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * void add(int index, Object ele):在index位置插入ele元素</span></span><br><span class="line"><span class="comment">     * boolean addAll(int index, Collection eles):从index位置开始将eles中的所有元素添加进来</span></span><br><span class="line"><span class="comment">     * Object get(int index):获取指定index位置的元素</span></span><br><span class="line"><span class="comment">     * int indexOf(Object obj):返回obj在集合中首次出现的位置</span></span><br><span class="line"><span class="comment">     * int lastIndexOf(Object obj):返回obj在当前集合中末次出现的位置</span></span><br><span class="line"><span class="comment">     * Object remove(int index):移除指定index位置的元素，并返回此元素</span></span><br><span class="line"><span class="comment">     * Object set(int index, Object ele):设置指定index位置的元素为ele</span></span><br><span class="line"><span class="comment">     * List subList(int fromIndex, int toIndex):返回从fromIndex到toIndex位置的子集合</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 总结：常用方法</span></span><br><span class="line"><span class="comment">     * 增：add(Object obj)</span></span><br><span class="line"><span class="comment">     * 删：remove(int index) / remove(Object obj)</span></span><br><span class="line"><span class="comment">     * 改：set(int index, Object ele)</span></span><br><span class="line"><span class="comment">     * 查：get(int index)</span></span><br><span class="line"><span class="comment">     * 插：add(int index, Object ele)</span></span><br><span class="line"><span class="comment">     * 长度：size()</span></span><br><span class="line"><span class="comment">     * 遍历：① Iterator迭代器方式</span></span><br><span class="line"><span class="comment">     *      ② 增强for循环</span></span><br><span class="line"><span class="comment">     *      ③ 普通的循环</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure>

<h4 id="List的一个面试题"><a href="#List的一个面试题" class="headerlink" title="List的一个面试题"></a>List的一个面试题</h4><ul>
<li>面试题1</li>
</ul>
<blockquote>
<p>请问ArrayList&#x2F;LinkedList&#x2F;Vector的异同？谈谈你的理解？ArrayList底层是什么？扩容机制？Vector和ArrayList的最大区别?</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 请问ArrayList/LinkedList/Vector的异同？谈谈你的理解？</span></span><br><span class="line"><span class="comment">  * ArrayList底层是什么？扩容机制？Vector和ArrayList的最大区别?</span></span><br><span class="line"><span class="comment">  * </span></span><br><span class="line"><span class="comment">  * ArrayList和LinkedList的异同二者都线程不安全，相对线程安全的Vector，执行效率高。</span></span><br><span class="line"><span class="comment">  * 此外，ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。</span></span><br><span class="line"><span class="comment">  * 对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。</span></span><br><span class="line"><span class="comment">  * 对于新增和删除操作add(特指插入)和remove，LinkedList比较占优势，因为ArrayList要移动数据。</span></span><br><span class="line"><span class="comment">  * </span></span><br><span class="line"><span class="comment">  * ArrayList和Vector的区别Vector和ArrayList几乎是完全相同的,</span></span><br><span class="line"><span class="comment">  * 唯一的区别在于Vector是同步类(synchronized)，属于强同步类。</span></span><br><span class="line"><span class="comment">  * 因此开销就比ArrayList要大，访问要慢。正常情况下,</span></span><br><span class="line"><span class="comment">  * 大多数的Java程序员使用ArrayList而不是Vector,</span></span><br><span class="line"><span class="comment">  * 因为同步完全可以由程序员自己来控制。Vector每次扩容请求其大小的2倍空间，</span></span><br><span class="line"><span class="comment">  * 而ArrayList是1.5倍。Vector还有一个子类Stack。</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></table></figure>

<h3 id="5、Collection子接口之二：Set接口"><a href="#5、Collection子接口之二：Set接口" class="headerlink" title="5、Collection子接口之二：Set接口"></a>5、Collection子接口之二：Set接口</h3><ul>
<li>Set接口是Collection的子接口，set接口没有提供额外的方法</li>
<li>Set 集合不允许包含相同的元素，如果试把两个相同的元素加入同一个Set 集合中，则添加操作失败。</li>
<li>Set 判断两个对象是否相同不是使用&#x3D;&#x3D; 运算符，而是根据equals() 方法</li>
</ul>
<h4 id="Set接口实现类的对比"><a href="#Set接口实现类的对比" class="headerlink" title="Set接口实现类的对比"></a>Set接口实现类的对比</h4><blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1.Set接口的框架：</span></span><br><span class="line"><span class="comment"> * |----Collection接口：单列集合，用来存储一个一个的对象</span></span><br><span class="line"><span class="comment"> *          |----Set接口：存储无序的、不可重复的数据   --&gt;高中讲的“集合”</span></span><br><span class="line"><span class="comment"> *             |----HashSet：作为Set接口的主要实现类；线程不安全的；可以存储null值</span></span><br><span class="line"><span class="comment"> *                 |----LinkedHashSet：作为HashSet的子类；遍历其内部数据时，可以按照添加的顺序遍历</span></span><br><span class="line"><span class="comment"> *                                    对于频繁的遍历操作，LinkedHashSet效率高于HashSet.</span></span><br><span class="line"><span class="comment"> *             |----TreeSet：可以按照添加对象的指定属性，进行排序。</span></span><br><span class="line"><span class="comment"> *</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="HashSet中元素的添加过程"><a href="#HashSet中元素的添加过程" class="headerlink" title="HashSet中元素的添加过程"></a>HashSet中元素的添加过程</h4><ul>
<li><p>HashSet是Set 接口的典型实现，大多数时候使用Set 集合时都使用这个实现类。</p>
</li>
<li><p>HashSet按Hash 算法来存储集合中的元素，因此具有很好的存取、查找、删除性能。</p>
</li>
<li><p>HashSet具有以下特点：不能保证元素的排列顺序</p>
<ul>
<li>HashSet不是线程安全的</li>
<li>集合元素可以是null</li>
</ul>
</li>
<li><p>HashSet 集合判断两个元素相等的标准：两个对象通过hashCode() 方法比较相等，并且两个对象的equals() 方法返回值也相等。</p>
</li>
<li><p>对于存放在Set容器中的对象，对应的类一定要重写equals()和hashCode(Object obj)方法，以实现对象相等规则。即：“<strong>相等的对象必须具有相等的散列码</strong>”。</p>
</li>
<li></li>
</ul>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 一、Set:存储无序的、不可重复的数据</span></span><br><span class="line"><span class="comment">     *      1.无序性：不等于随机性。存储的数据在底层数组中并非按照数组索引的顺序添加，而是根据数据的哈希值决定的。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *      2.不可重复性：保证添加的元素按照equals()判断时，不能返回true.即：相同的元素只能添加一个。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 二、添加元素的过程：以HashSet为例：</span></span><br><span class="line"><span class="comment">     *      我们向HashSet中添加元素a,首先调用元素a所在类的hashCode()方法，计算元素a的哈希值，</span></span><br><span class="line"><span class="comment">     *      此哈希值接着通过某种算法计算出在HashSet底层数组中的存放位置（即为：索引位置），判断</span></span><br><span class="line"><span class="comment">     *      数组此位置上是否已经有元素：</span></span><br><span class="line"><span class="comment">     *          如果此位置上没有其他元素，则元素a添加成功。 ---&gt;情况1</span></span><br><span class="line"><span class="comment">     *          如果此位置上有其他元素b(或以链表形式存在的多个元素），则比较元素a与元素b的hash值：</span></span><br><span class="line"><span class="comment">     *              如果hash值不相同，则元素a添加成功。---&gt;情况2</span></span><br><span class="line"><span class="comment">     *              如果hash值相同，进而需要调用元素a所在类的equals()方法：</span></span><br><span class="line"><span class="comment">     *                    equals()返回true,元素a添加失败</span></span><br><span class="line"><span class="comment">     *                    equals()返回false,则元素a添加成功。---&gt;情况2</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *      对于添加成功的情况2和情况3而言：元素a 与已经存在指定索引位置上数据以链表的方式存储。</span></span><br><span class="line"><span class="comment">     *      jdk 7 :元素a放到数组中，指向原来的元素。</span></span><br><span class="line"><span class="comment">     *      jdk 8 :原来的元素在数组中，指向元素a</span></span><br><span class="line"><span class="comment">     *      总结：七上八下</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * HashSet底层：数组+链表的结构。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-26/4c965e78676367af02bdc233fcd4e21a--3bb8--image-20240926154223158.png" alt="image-20240926154223158"></p>
<p>底层也是数组，初始容量为16，当如果使用率超过0.75，（16*0.75&#x3D;12）就会扩大容量为原来的2倍。（16扩容为32，依次为64,128….等）</p>
<h4 id="关于hashCode-和equals-的重写"><a href="#关于hashCode-和equals-的重写" class="headerlink" title="关于hashCode()和equals()的重写"></a>关于hashCode()和equals()的重写</h4><h5 id="重写hashCode-方法的基本原则"><a href="#重写hashCode-方法的基本原则" class="headerlink" title="重写hashCode() 方法的基本原则"></a>重写hashCode() 方法的基本原则</h5><ul>
<li>在程序运行时，同一个对象多次调用hashCode() 方法应该返回相同的值。</li>
<li>当两个对象的equals() 方法比较返回true 时，这两个对象的hashCode() 方法的返回值也应相等。</li>
<li>对象中用作equals() 方法比较的Field，都应该用来计算hashCode 值。</li>
</ul>
<h5 id="重写equals-方法的基本原则"><a href="#重写equals-方法的基本原则" class="headerlink" title="重写equals() 方法的基本原则"></a>重写equals() 方法的基本原则</h5><blockquote>
<p>以自定义的Customer类为例，何时需要重写equals()？</p>
</blockquote>
<ul>
<li>当一个类有自己特有的“逻辑相等”概念,当改写equals()的时候，总是要改写hashCode()，根据一个类的equals方法（改写后），两个截然不同的实例有可能在逻辑上是相等的，但是，根据Object.hashCode()方法，它们仅仅是两个对象。</li>
<li>因此，违反了“<strong>相等的对象必须具有相等的散列码</strong>”。</li>
<li>结论：复写equals方法的时候一般都需要同时复写hashCode方法。通常参与计算hashCode的对象的属性也应该参与到equals()中进行计算。</li>
</ul>
<h5 id="Eclipse-IDEA工具里hashCode-的重写"><a href="#Eclipse-IDEA工具里hashCode-的重写" class="headerlink" title="Eclipse&#x2F;IDEA工具里hashCode()的重写"></a>Eclipse&#x2F;IDEA工具里hashCode()的重写</h5><blockquote>
<p>以Eclipse&#x2F;IDEA为例，在自定义类中可以调用工具自动重写equals和hashCode。问题：为什么用Eclipse&#x2F;IDEA复写hashCode方法，有31这个数字？</p>
</blockquote>
<ul>
<li>选择系数的时候要选择尽量大的系数。因为如果计算出来的hash地址越大，所谓的“冲突”就越少，查找起来效率也会提高。（减少冲突）</li>
<li>并且31只占用5bits,相乘造成数据溢出的概率较小。</li>
<li>31可以由i*31&#x3D;&#x3D; (i&lt;&lt;5)-1来表示,现在很多虚拟机里面都有做相关优化。（提高算法效率）</li>
<li>31是一个素数，素数作用就是如果我用一个数字来乘以这个素数，那么最终出来的结果只能被素数本身和被乘数还有1来整除！(减少冲突)</li>
</ul>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 2.要求：向Set(主要指：HashSet、LinkedHashSet)中添加的数据，其所在的类一定要重写hashCode()和equals()</span></span><br><span class="line"><span class="comment">  *   要求：重写的hashCode()和equals()尽可能保持一致性：相等的对象必须具有相等的散列码</span></span><br><span class="line"><span class="comment">  *        重写两个方法的小技巧：对象中用作 equals() 方法比较的 Field，都应该用来计算 hashCode 值。</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="LinkedHashSet的使用"><a href="#LinkedHashSet的使用" class="headerlink" title="LinkedHashSet的使用"></a>LinkedHashSet的使用</h4><ul>
<li>LinkedHashSet是HashSet的子类</li>
<li>LinkedHashSet根据元素的hashCode值来决定元素的存储位置，但它同时使用双向链表维护元素的次序，这使得元素看起来是以<strong>插入顺序保存</strong>的。</li>
<li><strong>LinkedHashSet插入性能略低于HashSet</strong>，但在迭代访问Set 里的全部元素时有很好的性能。</li>
<li>LinkedHashSet不允许集合元素重复。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-26/4cc23d898e14d8003b0ae66094b41ed2--e610--image-20240926154251866.png" alt="image-20240926154251866"></p>
<h4 id="TreeSet的自然排序"><a href="#TreeSet的自然排序" class="headerlink" title="TreeSet的自然排序"></a>TreeSet的自然排序</h4><ul>
<li><p>TreeSet是SortedSet接口的实现类，TreeSet可以确保集合元素处于排序状态。</p>
</li>
<li><p>TreeSet底层使用<strong>红黑树</strong>结构存储数据</p>
</li>
<li><p>新增的方法如下：(了解)</p>
<ul>
<li>Comparator comparator()</li>
<li>Object first()</li>
<li>Object last()</li>
<li>Object lower(Object e)</li>
<li>Object higher(Object e)</li>
<li>SortedSet subSet(fromElement, toElement)</li>
<li>SortedSet headSet(toElement)</li>
<li>SortedSet tailSet(fromElement)</li>
</ul>
</li>
<li><p>TreeSet两种排序方法：<strong>自然排序和定制排序</strong>。默认情况下，TreeSet采用自然排序。</p>
</li>
<li><p>TreeSet和后面要讲的TreeMap采用红黑树的存储结构</p>
</li>
<li><p>特点：有序，查询速度比List快</p>
</li>
</ul>
<p><img src="http://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-26/72532b7ff7aafd3013078e556dcd5789--c2f7--image-20240926155705628.png" alt="image-20240926155705628"></p>
<ul>
<li><p>自然排序：TreeSet会调用集合元素的compareTo(Object obj) 方法来比较元素之间的大小关系，然后将集合元素按升序(默认情况)排列。</p>
</li>
<li><p><strong>如果试图把一个对象添加到TreeSet时，则该对象的类必须实现Comparable 接口</strong>。</p>
<ul>
<li>实现Comparable 的类必须实现compareTo(Object obj) 方法，两个对象即通过compareTo(Object obj) 方法的返回值来比较大小。</li>
</ul>
</li>
<li><p>Comparable 的典型实现：</p>
<ul>
<li>BigDecimal、BigInteger 以及所有的数值型对应的包装类：按它们对应的数值大小进行比较</li>
<li>Character：按字符的unicode值来进行比较</li>
<li>Boolean：true 对应的包装类实例大于false 对应的包装类实例</li>
<li>String：按字符串中字符的unicode 值进行比较</li>
<li>Date、Time：后边的时间、日期比前面的时间、日期大</li>
</ul>
</li>
<li><p>向TreeSet中添加元素时，只有第一个元素无须比较compareTo()方法，后面添加的所有元素都会调用compareTo()方法进行比较。</p>
</li>
<li><p><strong>因为只有相同类的两个实例才会比较大小，所以向TreeSet中添加的应该是同一个类的对象</strong>。</p>
</li>
<li><p>对于TreeSet集合而言，它<strong>判断两个对象是否相等的唯一标准</strong>是：两个对象通过compareTo(Object obj) 方法比较返回值。</p>
</li>
<li><p>当需要把一个对象放入TreeSet中，重写该对象对应的equals() 方法时，应保证该方法与compareTo(Object obj) 方法有一致的结果：如果两个对象通过equals() 方法比较返回true，则通过compareTo(Object obj) 方法比较应返回0。否则，让人难以理解。</p>
</li>
</ul>
<h4 id="TreeSet的定制排序"><a href="#TreeSet的定制排序" class="headerlink" title="TreeSet的定制排序"></a>TreeSet的定制排序</h4><ul>
<li>TreeSet的自然排序要求元素所属的类实现Comparable接口，如果元素所属的类没有实现Comparable接口，或不希望按照升序(默认情况)的方式排列元素或希望按照其它属性大小进行排序，则考虑使用定制排序。定制排序，通过Comparator接口来实现。需要重写compare(T o1,T o2)方法。</li>
<li>利用int compare(T o1,T o2)方法，比较o1和o2的大小：如果方法返回正整数，则表示o1大于o2；如果返回0，表示相等；返回负整数，表示o1小于o2。</li>
<li>要实现定制排序，需要将实现Comparator接口的实例作为形参传递给TreeSet的构造器。</li>
<li>此时，仍然只能向TreeSet中添加类型相同的对象。否则发生ClassCastException异常。</li>
<li>使用定制排序判断两个元素相等的标准是：通过Comparator比较两个元素返回了0。</li>
</ul>
<h3 id="6、Map接口"><a href="#6、Map接口" class="headerlink" title="6、Map接口"></a>6、Map接口</h3><p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-26/016b16f866b8814053813f34ef5ecd04--3ebe--image-20240926160356106.png" alt="image-20240926160356106"></p>
<h4 id="Map中存储的key-value的特点"><a href="#Map中存储的key-value的特点" class="headerlink" title="Map中存储的key-value的特点"></a>Map中存储的key-value的特点</h4><ul>
<li>Map与Collection并列存在。用于保存具有映射关系的数据:key-value</li>
<li>Map 中的key 和value 都可以是任何引用类型的数据</li>
<li>Map 中的key 用Set来存放，不允许重复，即同一个Map 对象所对应的类，须重写hashCode()和equals()方法</li>
<li>常用String类作为Map的“键”</li>
<li>key 和value 之间存在单向一对一关系，即通过指定的key 总能找到唯一的、确定的value</li>
<li>Map接口的常用实现类：HashMap、TreeMap、LinkedHashMap和Properties。其中，HashMap是Map 接口使用频率最高的实现类</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-26/5c6b47f892f9a5a48d33dfd7eac19e22--580b--image-20240926160454945.png" alt="image-20240926160454945"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  *  二、Map结构的理解：</span></span><br><span class="line"><span class="comment">  *    Map中的key:无序的、不可重复的，使用Set存储所有的key  ---&gt; key所在的类要重写equals()和hashCode() （以HashMap为例）</span></span><br><span class="line"><span class="comment">  *    Map中的value:无序的、可重复的，使用Collection存储所有的value ---&gt;value所在的类要重写equals()</span></span><br><span class="line"><span class="comment">  *    一个键值对：key-value构成了一个Entry对象。</span></span><br><span class="line"><span class="comment">  *    Map中的entry:无序的、不可重复的，使用Set存储所有的entry</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  */</span>   </span><br></pre></td></tr></table></figure>

<h4 id="Map实现类之一：HashMap"><a href="#Map实现类之一：HashMap" class="headerlink" title="Map实现类之一：HashMap"></a>Map实现类之一：HashMap</h4><ul>
<li><strong>HashMap是Map 接口使用频率最高的实现类</strong>。</li>
<li>允许使用null键和null值，与HashSet一样，不保证映射的顺序。</li>
<li>所有的key构成的集合是Set:无序的、不可重复的。所以，key所在的类要重写：equals()和hashCode()</li>
<li>所有的value构成的集合是Collection:无序的、可以重复的。所以，value所在的类要重写：equals()</li>
<li>一个key-value构成一个entry</li>
<li>所有的entry构成的集合是Set:无序的、不可重复的</li>
<li>HashMap 判断两个key 相等的标准是：两个key 通过equals() 方法返回true，hashCode值也相等。</li>
<li>HashMap判断两个value相等的标准是：两个value 通过equals() 方法返回true。</li>
</ul>
<h4 id="HashMap的底层实现原理"><a href="#HashMap的底层实现原理" class="headerlink" title="HashMap的底层实现原理"></a>HashMap的底层实现原理</h4><blockquote>
<p>JDK 7及以前版本：HashMap是数组+链表结构(即为链地址法)</p>
<p>JDK 8版本发布以后：HashMap是数组+链表+红黑树实现。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-26/ec2168962e0afd8308af7a84307e36c3--d616--image-20240926161011409.png" alt="image-20240926161011409"></p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-26/f366179f78492670947d2f3c225434b1--5796--image-20240926161016501.png" alt="image-20240926161016501"></p>
<ul>
<li>HashMap源码中的重要常量</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *      DEFAULT_INITIAL_CAPACITY : HashMap的默认容量，16</span></span><br><span class="line"><span class="comment"> *      DEFAULT_LOAD_FACTOR：HashMap的默认加载因子：0.75</span></span><br><span class="line"><span class="comment"> *      threshold：扩容的临界值，=容量*填充因子：16 * 0.75 =&gt; 12</span></span><br><span class="line"><span class="comment"> *      TREEIFY_THRESHOLD：Bucket中链表长度大于该默认值，转化为红黑树:8</span></span><br><span class="line"><span class="comment"> *      MIN_TREEIFY_CAPACITY：桶中的Node被树化时最小的hash表容量:64</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h5 id="HashMap在JDK7中的底层实现原理"><a href="#HashMap在JDK7中的底层实现原理" class="headerlink" title="HashMap在JDK7中的底层实现原理"></a>HashMap在JDK7中的底层实现原理</h5><ul>
<li>HashMap的内部存储结构其实是<strong>数组和链表的结合</strong>。当实例化一个HashMap时，系统会创建一个长度为Capacity的Entry数组，这个长度在哈希表中被称为容量(Capacity)，在这个数组中可以存放元素的位置我们称之为“桶”(bucket)，每个bucket都有自己的索引，系统可以根据索引快速的查找bucket中的元素。</li>
<li>每个bucket中存储一个元素，即一个Entry对象，但每一个Entry对象可以带一个引用变量，用于指向下一个元素，因此，在一个桶中，就有可能生成一个Entry链。而且新添加的元素作为链表的head。</li>
<li>添加元素的过程：<ul>
<li>向HashMap中添加entry1(key，value)，需要首先计算entry1中key的哈希值(根据key所在类的hashCode()计算得到)，此哈希值经过处理以后，得到在底层Entry[]数组中要存储的位置i。如果位置i上没有元素，则entry1直接添加成功。如果位置i上已经存在entry2(或还有链表存在的entry3，entry4)，则需要通过循环的方法，依次比较entry1中key和其他的entry。如果彼此hash值不同，则直接添加成功。如果hash值不同，继续比较二者是否equals。如果返回值为true，则使用entry1的value去替换equals为true的entry的value。如果遍历一遍以后，发现所有的equals返回都为false,则entry1仍可添加成功。entry1指向原有的entry元素。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 三、HashMap的底层实现原理？以jdk7为例说明：</span></span><br><span class="line"><span class="comment"> *    HashMap map = new HashMap():</span></span><br><span class="line"><span class="comment"> *    在实例化以后，底层创建了长度是16的一维数组Entry[] table。</span></span><br><span class="line"><span class="comment"> *    ...可能已经执行过多次put...</span></span><br><span class="line"><span class="comment"> *    map.put(key1,value1):</span></span><br><span class="line"><span class="comment"> *    首先，调用key1所在类的hashCode()计算key1哈希值，此哈希值经过某种算法计算以后，得到在Entry数组中的存放位置。</span></span><br><span class="line"><span class="comment"> *    如果此位置上的数据为空，此时的key1-value1添加成功。 ----情况1</span></span><br><span class="line"><span class="comment"> *    如果此位置上的数据不为空，(意味着此位置上存在一个或多个数据(以链表形式存在)),比较key1和已经存在的一个或多个数据</span></span><br><span class="line"><span class="comment"> *    的哈希值：</span></span><br><span class="line"><span class="comment"> *           如果key1的哈希值与已经存在的数据的哈希值都不相同，此时key1-value1添加成功。----情况2</span></span><br><span class="line"><span class="comment"> *           如果key1的哈希值和已经存在的某一个数据(key2-value2)的哈希值相同，继续比较：调用key1所在类的equals(key2)方法，比较：</span></span><br><span class="line"><span class="comment"> *                如果equals()返回false:此时key1-value1添加成功。----情况3</span></span><br><span class="line"><span class="comment"> *                如果equals()返回true:使用value1替换value2。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   补充：关于情况2和情况3：此时key1-value1和原来的数据以链表的方式存储。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   在不断的添加过程中，会涉及到扩容问题，当超出临界值(且要存放的位置非空)时，扩容。默认的扩容方式：扩容为原来容量的2倍，并将原有的数据复制过来。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * HashMap的扩容</span></span><br><span class="line"><span class="comment">  *     当HashMap中的元素越来越多的时候，hash冲突的几率也就越来越高，</span></span><br><span class="line"><span class="comment">  *     因为数组的长度是固定的。所以为了提高查询的效率，</span></span><br><span class="line"><span class="comment">  *     就要对HashMap的数组进行扩容，而在HashMap数组扩容之后，</span></span><br><span class="line"><span class="comment">  *     最消耗性能的点就出现了：原数组中的数据必须重新计算其在新数组中的位置，</span></span><br><span class="line"><span class="comment">  *     并放进去，这就是resize。</span></span><br><span class="line"><span class="comment">  *     </span></span><br><span class="line"><span class="comment">  * 那么HashMap什么时候进行扩容呢？</span></span><br><span class="line"><span class="comment">  *      当HashMap中的元素个数超过数组大小(数组总大小length,</span></span><br><span class="line"><span class="comment">  *      不是数组中个数size)*loadFactor时，就 会 进 行 数 组 扩 容，</span></span><br><span class="line"><span class="comment">  *      loadFactor的默认值(DEFAULT_LOAD_FACTOR)为0.75，这是一个折中的取值。</span></span><br><span class="line"><span class="comment">  *      也就是说，默认情况下，数组大小(DEFAULT_INITIAL_CAPACITY)为16，</span></span><br><span class="line"><span class="comment">  *      那么当HashMap中元素个数超过16*0.75=12（这个值就是代码中的threshold值，</span></span><br><span class="line"><span class="comment">  *      也叫做临界值）的时候，就把数组的大小扩展为2*16=32，即扩大一倍，</span></span><br><span class="line"><span class="comment">  *      然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作，</span></span><br><span class="line"><span class="comment">  *      所以如果我们已经预知HashMap中元素的个数，</span></span><br><span class="line"><span class="comment">  *      那么预设元素的个数能够有效的提高HashMap的性能。</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></table></figure>

<h5 id="HashMap在JDK8中的底层实现原理"><a href="#HashMap在JDK8中的底层实现原理" class="headerlink" title="HashMap在JDK8中的底层实现原理"></a>HashMap在JDK8中的底层实现原理</h5><ul>
<li><p>HashMap的内部存储结构其实是数组+链表+树的结合。当实例化一个HashMap时，会初始化initialCapacity和loadFactor，在put第一对映射关系时，系统会创建一个长度为initialCapacity的Node数组，这个长度在哈希表中被称为容量(Capacity)，在这个数组中可以存放元素的位置我们称之为“桶”(bucket)，每个bucket都有自己的索引，系统可以根据索引快速的查找bucket中的元素。</p>
</li>
<li><p>每个bucket中存储一个元素，即一个Node对象，但每一个Node对象可以带一个引用变量next，用于指向下一个元素，因此，在一个桶中，就有可能生成一个Node链。也可能是一个一个TreeNode对象，每一个TreeNode对象可以有两个叶子结点left和right，因此，在一个桶中，就有可能生成一个TreeNode树。而新添加的元素作为链表的last，或树的叶子结点。</p>
</li>
<li><p><strong>那么HashMap什么时候进行扩容和树形化呢？</strong></p>
<blockquote>
<p>当HashMap中的元素个数超过数组大小(数组总大小length,不是数组中个数size)<em>loadFactor时，就会进行数组扩容，loadFactor的默认值(DEFAULT_LOAD_FACTOR)为0.75，这是一个折中的取值。也就是说，默认情况下，数组大小(DEFAULT_INITIAL_CAPACITY)为16，那么当HashMap中元素个数超过16</em>0.75&#x3D;12（这个值就是代码中的threshold值，也叫做临界值）的时候，就把数组的大小扩展为2*16&#x3D;32，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作，所以如果我们已经预知HashMap中元素的个数，那么预设元素的个数能够有效的提高HashMap的性能。</p>
</blockquote>
</li>
<li><p>当HashMap中的其中一个链的对象个数如果达到了8个，此时如果capacity没有达到64，那么HashMap会先扩容解决，如果已经达到了64，那么这个链会变成树，结点类型由Node变成TreeNode类型。当然，如果当映射关系被移除后，下次resize方法时判断树的结点个数低于6个，也会把树再转为链表。</p>
</li>
<li><p><strong>关于映射关系的key是否可以修改？answer：不要修改</strong></p>
<blockquote>
<p>映射关系存储到HashMap中会存储key的hash值，这样就不用在每次查找时重新计算每一个Entry或Node（TreeNode）的hash值了，因此如果已经put到Map中的映射关系，再修改key的属性，而这个属性又参与hashcode值的计算，那么会导致匹配不上。</p>
</blockquote>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 总结：</span></span><br><span class="line"><span class="comment"> *   jdk8 相较于jdk7在底层实现方面的不同：</span></span><br><span class="line"><span class="comment"> *      1.new HashMap():底层没有创建一个长度为16的数组</span></span><br><span class="line"><span class="comment"> *      2.jdk 8底层的数组是：Node[],而非Entry[]</span></span><br><span class="line"><span class="comment"> *      3.首次调用put()方法时，底层创建长度为16的数组</span></span><br><span class="line"><span class="comment"> *      4.jdk7底层结构只有：数组+链表。jdk8中底层结构：数组+链表+红黑树。</span></span><br><span class="line"><span class="comment"> *         4.1形成链表时，七上八下（jdk7:新的元素指向旧的元素。jdk8：旧的元素指向新的元素）</span></span><br><span class="line"><span class="comment"> *         4.2当数组的某一个索引位置上的元素以链表形式存在的数据个数 &gt; 8 且当前数组的长度 &gt; 64时，此时此索引位置上的所数据改为使用红黑树存储。</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h4 id="LinkedHashMap的底层实现原理（了解！！！）"><a href="#LinkedHashMap的底层实现原理（了解！！！）" class="headerlink" title="LinkedHashMap的底层实现原理（了解！！！）"></a>LinkedHashMap的底层实现原理（了解！！！）</h4><ul>
<li><p>LinkedHashMap是HashMap的子类</p>
</li>
<li><p>在HashMap存储结构的基础上，使用了一对双向链表来记录添加元素的顺序</p>
</li>
<li><p>与LinkedHashSet类似，LinkedHashMap可以维护Map 的迭代顺序：迭代顺序与Key-Value 对的插入顺序一致</p>
</li>
<li><p>HashMap中的内部类：Node</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-26/5def8a853d13145aec0fac58b21ec825--dc6e--image-20240926161107656.png" alt="image-20240926161107656"></p>
<ul>
<li>LinkedHashMap中的内部类：Entry</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-26/a74194cb166be60b7c14d33841288421--a599--image-20240926161127564.png" alt="image-20240926161127564"></p>
<h4 id="Map中的常用方法"><a href="#Map中的常用方法" class="headerlink" title="Map中的常用方法"></a>Map中的常用方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  五、Map中定义的方法：</span></span><br><span class="line"><span class="comment"> *      添加、删除、修改操作：</span></span><br><span class="line"><span class="comment"> *      Object put(Object key,Object value)：将指定key-value添加到(或修改)当前map对象中</span></span><br><span class="line"><span class="comment"> *      void putAll(Map m):将m中的所有key-value对存放到当前map中</span></span><br><span class="line"><span class="comment"> *      Object remove(Object key)：移除指定key的key-value对，并返回value</span></span><br><span class="line"><span class="comment"> *      void clear()：清空当前map中的所有数据</span></span><br><span class="line"><span class="comment"> *      元素查询的操作：</span></span><br><span class="line"><span class="comment"> *      Object get(Object key)：获取指定key对应的value</span></span><br><span class="line"><span class="comment"> *      boolean containsKey(Object key)：是否包含指定的key</span></span><br><span class="line"><span class="comment"> *      boolean containsValue(Object value)：是否包含指定的value</span></span><br><span class="line"><span class="comment"> *      int size()：返回map中key-value对的个数</span></span><br><span class="line"><span class="comment"> *      boolean isEmpty()：判断当前map是否为空</span></span><br><span class="line"><span class="comment"> *      boolean equals(Object obj)：判断当前map和参数对象obj是否相等</span></span><br><span class="line"><span class="comment"> *      元视图操作的方法：</span></span><br><span class="line"><span class="comment"> *      Set keySet()：返回所有key构成的Set集合</span></span><br><span class="line"><span class="comment"> *      Collection values()：返回所有value构成的Collection集合</span></span><br><span class="line"><span class="comment"> *      Set entrySet()：返回所有key-value对构成的Set集合</span></span><br><span class="line"><span class="comment"> *总结：常用方法：</span></span><br><span class="line"><span class="comment"> *    添加：put(Object key,Object value)</span></span><br><span class="line"><span class="comment"> *    删除：remove(Object key)</span></span><br><span class="line"><span class="comment"> *    修改：put(Object key,Object value)</span></span><br><span class="line"><span class="comment"> *    查询：get(Object key)</span></span><br><span class="line"><span class="comment"> *    长度：size()</span></span><br><span class="line"><span class="comment"> *    遍历：keySet() / values() / entrySet()</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  面试题：</span></span><br><span class="line"><span class="comment"> *  1. HashMap的底层实现原理？</span></span><br><span class="line"><span class="comment"> *  2. HashMap 和 Hashtable的异同？</span></span><br><span class="line"><span class="comment"> *      1.HashMap与Hashtable都实现了Map接口。由于HashMap的非线程安全性，效率上可能高于Hashtable。Hashtable的方法是Synchronize的，而HashMap不是，在多个线程访问Hashtable时，不需要自己为它的方法实现同步，而HashMap 就必须为之提供外同步。</span></span><br><span class="line"><span class="comment"> *      2.HashMap允许将null作为一个entry的key或者value，而Hashtable不允许。</span></span><br><span class="line"><span class="comment"> *      3.HashMap把Hashtable的contains方法去掉了，改成containsvalue和containsKey。因为contains方法容易让人引起误解。</span></span><br><span class="line"><span class="comment"> *      4.Hashtable继承自Dictionary类，而HashMap是Java1.2引进的Map interface的一个实现。</span></span><br><span class="line"><span class="comment"> *      5.Hashtable和HashMap采用的hash/rehash算法都大概一样，所以性能不会有很大的差异。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  3. CurrentHashMap 与 Hashtable的异同？（暂时不讲）</span></span><br><span class="line"><span class="comment"> *</span></span><br></pre></td></tr></table></figure>

<h4 id="TreeMap两种添加方式的使用"><a href="#TreeMap两种添加方式的使用" class="headerlink" title="TreeMap两种添加方式的使用"></a>TreeMap两种添加方式的使用</h4><ul>
<li>TreeMap存储Key-Value 对时，需要根据key-value 对进行排序。TreeMap可以保证所有的Key-Value 对处于<strong>有序</strong>状态。</li>
<li>TreeSet底层使用<strong>红黑树</strong>结构存储数据</li>
<li>TreeMap的Key 的排序：<ul>
<li><strong>自然排序</strong>：TreeMap的所有的Key 必须实现Comparable 接口，而且所有的Key 应该是同一个类的对象，否则将会抛出ClasssCastException</li>
<li><strong>定制排序</strong>：创建TreeMap时，传入一个Comparator 对象，该对象负责对TreeMap中的所有key 进行排序。此时不需要Map 的Key 实现Comparable 接口</li>
</ul>
</li>
<li>TreeMap判断<strong>两个key相等</strong>的标准：两个key通过compareTo()方法或者compare()方法返回0。</li>
</ul>
<h4 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h4><ul>
<li>Hashtable是个古老的Map 实现类，JDK1.0就提供了。不同于HashMap，Hashtable是线程安全的。</li>
<li>Hashtable实现原理和HashMap相同，功能相同。底层都使用哈希表结构，查询速度快，很多情况下可以互用。</li>
<li>与HashMap不同，Hashtable不允许使用null 作为key 和value</li>
<li>与HashMap一样，Hashtable也不能保证其中Key-Value 对的顺序</li>
<li>Hashtable判断两个key相等、两个value相等的标准，与HashMap一致。</li>
</ul>
<h4 id="Properties处理属性文件"><a href="#Properties处理属性文件" class="headerlink" title="Properties处理属性文件"></a>Properties处理属性文件</h4><ul>
<li>Properties 类是Hashtable的子类，该对象用于处理属性文件</li>
<li>由于属性文件里的key、value 都是字符串类型，所以<strong>Properties 里的key 和value 都是字符串类型</strong></li>
<li>存取数据时，建议使用setProperty(String key,Stringvalue)方法和getProperty(String key)方法</li>
</ul>
<h3 id="7、Collections工具类"><a href="#7、Collections工具类" class="headerlink" title="7、Collections工具类"></a>7、Collections工具类</h3><ul>
<li><p>操作数组的工具类：Arrays</p>
</li>
<li><p>Collections 是一个操作Set、List和Map 等集合的工具类</p>
</li>
<li><p>Collections 中提供了一系列静态的方法对集合元素进行排序、查询和修改等操作，还提供了对集合对象设置不可变、对集合对象实现同步控制等方法</p>
</li>
<li><p>排序操作：（均为static方法）</p>
<ul>
<li>reverse(List)：反转List 中元素的顺序</li>
<li>shuffle(List)：对List集合元素进行随机排序</li>
<li>sort(List)：根据元素的自然顺序对指定List 集合元素按升序排序</li>
<li>sort(List，Comparator)：根据指定的Comparator 产生的顺序对List 集合元素进行排序</li>
<li>swap(List，int，int)：将指定list 集合中的i处元素和j 处元素进行交换</li>
</ul>
</li>
</ul>
<h2 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h2><h3 id="1、File类的使用"><a href="#1、File类的使用" class="headerlink" title="1、File类的使用"></a>1、File类的使用</h3><h4 id="File类的实例化"><a href="#File类的实例化" class="headerlink" title="File类的实例化"></a>File类的实例化</h4><ul>
<li>java.io.File类：文件和文件目录路径的抽象表示形式，与平台无关</li>
<li>File 能新建、删除、重命名文件和目录，但File 不能访问文件内容本身。如果需要访问文件内容本身，则需要使用输入&#x2F;输出流。</li>
<li>想要在Java程序中表示一个真实存在的文件或目录，那么必须有一个File对象，但是Java程序中的一个File对象，可能没有一个真实存在的文件或目录。</li>
<li>File对象可以作为参数传递给流的构造器</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1.如何创建file类的实例</span></span><br><span class="line"><span class="comment">     *      File(String filePath):以filePath为路径创建File对象，可以是绝对路径或者相对路径</span></span><br><span class="line"><span class="comment">     *      File(String parentPath,String childPath):以parentPath为父路径，childPath为子路径创建File对象。</span></span><br><span class="line"><span class="comment">     *      File(File parentFile,String childPath):根据一个父File对象和子文件路径创建File对象</span></span><br><span class="line"><span class="comment">     * 2.</span></span><br><span class="line"><span class="comment">     *   相对路径：相较于某个路径下，指明的路径。</span></span><br><span class="line"><span class="comment">     *   绝对路径：包含盘符在内的文件或文件目录的路径</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 3.路径分隔符</span></span><br><span class="line"><span class="comment">     *      windows:\\</span></span><br><span class="line"><span class="comment">     *      unix:/</span></span><br><span class="line"><span class="comment">     * 4.Java程序支持跨平台运行，因此路径分隔符要慎用。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 5.为了解决这个隐患，File类提供了一个常量：</span></span><br><span class="line"><span class="comment">     *   public  static final String separator。</span></span><br><span class="line"><span class="comment">     *   根据操作系统，动态的提供分隔符。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * File file1= new File(&quot;d:\\Work\\info.txt&quot;);</span></span><br><span class="line"><span class="comment">     * File file2= new File(&quot;d:&quot;+ File.separator+ &quot;Work&quot;+ File.separator+ &quot;info.txt&quot;);</span></span><br><span class="line"><span class="comment">     * File file3= new File(&quot;d:/Work&quot;);</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure>

<h4 id="File类的常用方法"><a href="#File类的常用方法" class="headerlink" title="File类的常用方法"></a>File类的常用方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * public String getAbsolutePath()：获取绝对路径</span></span><br><span class="line"><span class="comment">     * public String getPath() ：获取路径</span></span><br><span class="line"><span class="comment">     * public String getName() ：获取名称</span></span><br><span class="line"><span class="comment">     * public String getParent()：获取上层文件目录路径。若无，返回null</span></span><br><span class="line"><span class="comment">     * public long length() ：获取文件长度（即：字节数）。不能获取目录的长度。</span></span><br><span class="line"><span class="comment">     * public long lastModified() ：获取最后一次的修改时间，毫秒值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 如下的两个方法适用于文件目录：</span></span><br><span class="line"><span class="comment">     * public String[] list() ：获取指定目录下的所有文件或者文件目录的名称数组</span></span><br><span class="line"><span class="comment">     * public File[] listFiles() ：获取指定目录下的所有文件或者文件目录的File数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * File类的重命名功能</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *  public boolean renameTo(File dest):把文件重命名为指定的文件路径</span></span><br><span class="line"><span class="comment">     *    比如：file1.renameTo(file2)为例：</span></span><br><span class="line"><span class="comment">     *         要想保证返回true,需要file1在硬盘中是存在的，且file2不能在硬盘中存在。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * public boolean isDirectory()：判断是否是文件目录</span></span><br><span class="line"><span class="comment">     * public boolean isFile() ：判断是否是文件</span></span><br><span class="line"><span class="comment">     * public boolean exists() ：判断是否存在</span></span><br><span class="line"><span class="comment">     * public boolean canRead() ：判断是否可读</span></span><br><span class="line"><span class="comment">     * public boolean canWrite() ：判断是否可写</span></span><br><span class="line"><span class="comment">     * public boolean isHidden() ：判断是否隐藏</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建硬盘中对应的文件或文件目录</span></span><br><span class="line"><span class="comment">     * public boolean createNewFile() ：创建文件。若文件存在，则不创建，返回false</span></span><br><span class="line"><span class="comment">     * public boolean mkdir() ：创建文件目录。如果此文件目录存在，就不创建了。如果此文件目录的上层目录不存在，也不创建。</span></span><br><span class="line"><span class="comment">     * public boolean mkdirs() ：创建文件目录。如果此文件目录存在，就不创建了。如果上层文件目录不存在，一并创建</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *     删除磁盘中的文件或文件目录</span></span><br><span class="line"><span class="comment">     * public boolean delete()：删除文件或者文件夹</span></span><br><span class="line"><span class="comment">     *     删除注意事项：Java中的删除不走回收站。</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure>

<h3 id="2-IO流原理及流的分类"><a href="#2-IO流原理及流的分类" class="headerlink" title="2.IO流原理及流的分类"></a>2.IO流原理及流的分类</h3><h4 id="IO流原理"><a href="#IO流原理" class="headerlink" title="IO流原理"></a>IO流原理</h4><ul>
<li>I&#x2F;O是Input&#x2F;Output的缩写，I&#x2F;O技术是非常实用的技术，用于处理设备之间的数据传输。如读&#x2F;写文件，网络通讯等。</li>
<li>Java程序中，对于数据的输入&#x2F;输出操作以“流(stream)”的方式进行。</li>
<li>java.io包下提供了各种“流”类和接口，用以获取不同种类的数据，并通过标准的方法输入或输出数据。</li>
<li>输入input：读取外部数据（磁盘、光盘等存储设备的数据）到程序（内存）中。</li>
<li>输出output：将程序（内存）数据输出到磁盘、光盘等存储设备中。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-02/0332c07d4172fd418c663af3cf0e62c9--dd7c--image-20241002172628012.png" alt="image-20241002172628012"></p>
<h4 id="流的分类"><a href="#流的分类" class="headerlink" title="流的分类"></a>流的分类</h4><ul>
<li>按操作<strong>数据单位</strong>不同分为：字节流(8 bit)，字符流(16 bit)</li>
<li>按数据流的<strong>流向</strong>不同分为：输入流，输出流</li>
<li>按流的<strong>角色</strong>的不同分为：节点流，处理流</li>
</ul>
<table>
<thead>
<tr>
<th align="center">抽象基类</th>
<th align="center">字节流</th>
<th align="center">字符流</th>
</tr>
</thead>
<tbody><tr>
<td align="center">输入流</td>
<td align="center">InputStream</td>
<td align="center">Reader</td>
</tr>
<tr>
<td align="center">输出流</td>
<td align="center">OutputStream</td>
<td align="center">Writer</td>
</tr>
</tbody></table>
<ol>
<li><p>Java的IO流共涉及40多个类，实际上非常规则，都是从如下4个抽象基类派生的。</p>
</li>
<li><p>由这四个类派生出来的子类名称都是以其父类名作为子类名后缀。</p>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-02/4fcecdfdeb30135c60b9f69d33e65dc4--7e07--image-20241002173511265.png" alt="image-20241002173511265"></p>
<h4 id="IO-流体系"><a href="#IO-流体系" class="headerlink" title="IO 流体系"></a>IO 流体系</h4><p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-02/548e94ddbf27a53c4ea5dc103380530a--eba7--image-20241002173536636.png" alt="image-20241002173536636"></p>
<h3 id="3-节点流-或文件流"><a href="#3-节点流-或文件流" class="headerlink" title="3.节点流(或文件流)"></a>3.节点流(或文件流)</h3><h4 id="FileReader读入数据的基本操作"><a href="#FileReader读入数据的基本操作" class="headerlink" title="FileReader读入数据的基本操作"></a>FileReader读入数据的基本操作</h4><ul>
<li>读取文件</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>建立一个流对象，将已存在的一个文件加载进流。		</span><br><span class="line">	FileReaderfr= <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="keyword">new</span> <span class="title class_">File</span>(“Test.txt”));</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>创建一个临时存放数据的数组。</span><br><span class="line">	<span class="type">char</span>[] ch= <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>调用流对象的读取方法将流中的数据读入到数组中。		</span><br><span class="line">	fr.read(ch);</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> 关闭资源。</span><br><span class="line">	fr.close();</span><br></pre></td></tr></table></figure>

<h4 id="FileWriter写出数据的操作"><a href="#FileWriter写出数据的操作" class="headerlink" title="FileWriter写出数据的操作"></a>FileWriter写出数据的操作</h4><ul>
<li>写入文件</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>创建流对象，建立数据存放文件</span><br><span class="line">    FileWriterfw= <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="keyword">new</span> <span class="title class_">File</span>(“Test.txt”));</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>调用流对象的写入方法，将数据写入流</span><br><span class="line">    fw.write(“atguigu-songhongkang”);</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>关闭流资源，并将流中的数据清空到文件中。</span><br><span class="line">    fw.close();</span><br></pre></td></tr></table></figure>

<h3 id="4-缓冲流"><a href="#4-缓冲流" class="headerlink" title="4.缓冲流"></a>4.缓冲流</h3><ul>
<li>为了提高数据读写的速度，Java API提供了带缓冲功能的流类，在使用这些流类时，会创建一个内部缓冲区数组，缺省使用8192个字节(8Kb)的缓冲区。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-02/e15a777941671c4cb10540b0dbdd135a--083a--image-20241002183552837.png" alt="image-20241002183552837"></p>
<ul>
<li><p>缓冲流要“套接”在相应的节点流之上，根据数据操作单位可以把缓冲流分为：</p>
<ul>
<li>BufferedInputStream和BufferedOutputStream</li>
<li>BufferedReader和BufferedWriter</li>
</ul>
</li>
<li><p>当读取数据时，数据按块读入缓冲区，其后的读操作则直接访问缓冲区</p>
</li>
<li><p>当使用BufferedInputStream读取字节文件时，BufferedInputStream会一次性从文件中读取8192个(8Kb)，存在缓冲区中，直到缓冲区装满了，才重新从文件中读取下一个8192个字节数组。</p>
</li>
<li><p>向流中写入字节时，不会直接写到文件，先写到缓冲区中直到缓冲区写满，BufferedOutputStream才会把缓冲区中的数据一次性写到文件里。使用方法flush()可以强制将缓冲区的内容全部写入输出流</p>
</li>
<li><p>关闭流的顺序和打开流的顺序相反。只要关闭最外层流即可，关闭最外层流也会相应关闭内层节点流</p>
</li>
<li><p>flush()方法的使用：手动将buffer中内容写入文件</p>
</li>
<li><p>如果是带缓冲区的流对象的close()方法，不但会关闭流，还会在关闭流之前刷新缓冲区，关闭后不能再写出。</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-02/b3b7754d04c3b7f5e3aac395d953838d--d9d6--image-20241002183634220.png" alt="image-20241002183634220"></p>
<h3 id="5-转换流"><a href="#5-转换流" class="headerlink" title="5.转换流"></a>5.转换流</h3><h4 id="转换流概述与InputStreamReader的使用"><a href="#转换流概述与InputStreamReader的使用" class="headerlink" title="转换流概述与InputStreamReader的使用"></a>转换流概述与InputStreamReader的使用</h4><ul>
<li><p>转换流提供了在字节流和字符流之间的转换</p>
</li>
<li><p>Java API提供了两个转换流：</p>
<ul>
<li>InputStreamReader：将InputStream转换为Reader<ul>
<li>实现将字节的输入流按指定字符集转换为字符的输入流。</li>
<li>需要和InputStream“套接”。</li>
<li>构造器<ul>
<li>public InputStreamReader(InputStreamin)</li>
<li>public InputSreamReader(InputStreamin,StringcharsetName)</li>
<li>如：Reader isr&#x3D; new InputStreamReader(System.in,”gbk”);</li>
</ul>
</li>
</ul>
</li>
<li>OutputStreamWriter：将Writer转换为OutputStream<ul>
<li>实现将字符的输出流按指定字符集转换为字节的输出流。</li>
<li>需要和OutputStream“套接”。</li>
<li>构造器<ul>
<li>public OutputStreamWriter(OutputStreamout)</li>
<li>public OutputSreamWriter(OutputStreamout,StringcharsetName)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>字节流中的数据都是字符时，转成字符流操作更高效。</p>
</li>
<li><p>很多时候我们使用转换流来处理文件乱码问题。实现编码和解码的功能。</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-02/1d2348b58ca17120964e61d189a8d294--c67c--image-20241002184541945.png" alt="image-20241002184541945"></p>
<h4 id="多种字符编码集的说明"><a href="#多种字符编码集的说明" class="headerlink" title="多种字符编码集的说明"></a>多种字符编码集的说明</h4><ul>
<li><p>编码表的由来</p>
<blockquote>
<p>计算机只能识别二进制数据，早期由来是电信号。为了方便应用计算机，让它可以识别各个国家的文字。就将各个国家的文字用数字来表示，并一一对应，形成一张表。这就是编码表。</p>
</blockquote>
</li>
<li><p>常见的编码表</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 4.字符集</span></span><br><span class="line"><span class="comment">  *  ASCII：美国标准信息交换码。</span></span><br><span class="line"><span class="comment">  *     用一个字节的7位可以表示。</span></span><br><span class="line"><span class="comment">  *  ISO8859-1：拉丁码表。欧洲码表</span></span><br><span class="line"><span class="comment">  *     用一个字节的8位表示。</span></span><br><span class="line"><span class="comment">  *  GB2312：中国的中文编码表。最多两个字节编码所有字符</span></span><br><span class="line"><span class="comment">  *  GBK：中国的中文编码表升级，融合了更多的中文文字符号。最多两个字节编码</span></span><br><span class="line"><span class="comment">  *  Unicode：国际标准码，融合了目前人类使用的所有字符。为每个字符分配唯一的字符码。所有的文字都用两个字节来表示。</span></span><br><span class="line"><span class="comment">  *  UTF-8：变长的编码方式，可用1-4个字节来表示一个字符。</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Unicode不完美，这里就有三个问题，一个是，我们已经知道，英文字母只用一个字节表示就够了，第二个问题是如何才能区别Unicode和ASCII？计算机怎么知道两个字节表示一个符号，而不是分别表示两个符号呢？第三个，如果和GBK等双字节编码方式一样，用最高位是1或0表示两个字节和一个字节，就少了很多值无法用于表示字符，不够表示所有字符。Unicode在很长一段时间内无法推广，直到互联网的出现。</li>
<li>面向传输的众多UTF（UCS Transfer Format）标准出现了，顾名思义，<strong>UTF-8就是每次8个位传输数据，而UTF-16就是每次16个位。</strong>这是为传输而设计的编码，并使编码无国界，这样就可以显示全世界上所有文化的字符了。</li>
<li>Unicode只是定义了一个庞大的、全球通用的字符集，并为每个字符规定了唯一确定的编号，具体存储成什么样的字节流，取决于字符编码方案。推荐的Unicode编码是UTF-8和UTF-16。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-02/44407cfc98725875886f4b92a502a464--d8e6--image-20241002185539502.png" alt="image-20241002185539502"></p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-02/d23001b07313a32006b232017fccbda7--c8d3--image-20241002185546613.png" alt="image-20241002185546613"></p>
<h3 id="6-标准输入、输出流"><a href="#6-标准输入、输出流" class="headerlink" title="6.标准输入、输出流"></a>6.标准输入、输出流</h3><ul>
<li>System.in和System.out分别代表了系统标准的输入和输出设备</li>
<li>默认输入设备是：键盘，输出设备是：显示器</li>
<li>System.in的类型是InputStream</li>
<li>System.out的类型是PrintStream，其是OutputStream的子类FilterOutputStream的子类</li>
<li>重定向：通过System类的setIn，setOut方法对默认设备进行改变。<ul>
<li>public static void setIn(InputStreamin)</li>
<li>public static void setOut(PrintStreamout)</li>
</ul>
</li>
</ul>
<h3 id="7-打印流"><a href="#7-打印流" class="headerlink" title="7.打印流"></a>7.打印流</h3><ul>
<li>实现将基本数据类型的数据格式转化为字符串输出</li>
<li>打印流：PrintStream和PrintWriter<ul>
<li>提供了一系列重载的print()和println()方法，用于多种数据类型的输出</li>
<li>PrintStream和PrintWriter的输出不会抛出IOException异常</li>
<li>PrintStream和PrintWriter有自动flush功能</li>
<li>PrintStream 打印的所有字符都使用平台的默认字符编码转换为字节。在需要写入字符而不是写入字节的情况下，应该使用PrintWriter 类。</li>
<li>System.out返回的是PrintStream的实例</li>
</ul>
</li>
</ul>
<h3 id="8-数据流"><a href="#8-数据流" class="headerlink" title="8.数据流"></a>8.数据流</h3><ul>
<li><p>为了方便地操作Java语言的基本数据类型和String的数据，可以使用数据流。</p>
</li>
<li><p>数据流有两个类：(用于读取和写出基本数据类型、String类的数据）</p>
<ul>
<li>DataInputStream和DataOutputStream</li>
<li>分别“套接”在InputStream和OutputStream子类的流上</li>
</ul>
</li>
<li><p>DataInputStream中的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">readBoolean</span><span class="params">()</span>	<span class="type">byte</span> <span class="title function_">readByte</span><span class="params">()</span></span><br><span class="line"><span class="type">char</span> <span class="title function_">readChar</span><span class="params">()</span>	<span class="type">float</span> <span class="title function_">readFloat</span><span class="params">()</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">readDouble</span><span class="params">()</span>	<span class="type">short</span> <span class="title function_">readShort</span><span class="params">()</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">readLong</span><span class="params">()</span>	<span class="type">int</span> <span class="title function_">readInt</span><span class="params">()</span></span><br><span class="line">String <span class="title function_">readUTF</span><span class="params">()</span>	<span class="keyword">void</span> <span class="title function_">readFully</span><span class="params">(<span class="type">byte</span>[s] b)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>DataOutputStream中的方法</p>
<ul>
<li>将上述的方法的read改为相应的write即可。</li>
</ul>
</li>
</ul>
<h3 id="9-对象流"><a href="#9-对象流" class="headerlink" title="9.对象流"></a>9.对象流</h3><h4 id="对象序列化机制的理解"><a href="#对象序列化机制的理解" class="headerlink" title="对象序列化机制的理解"></a>对象序列化机制的理解</h4><ul>
<li>ObjectInputStream和OjbectOutputSteam</li>
<li>用于存储和读取基本数据类型数据或对象的处理流。它的强大之处就是可以把Java中的对象写入到数据源中，也能把对象从数据源中还原回来。</li>
<li>序列化：用ObjectOutputStream类保存基本类型数据或对象的机制</li>
<li>反序列化：用ObjectInputStream类读取基本类型数据或对象的机制</li>
<li>ObjectOutputStream和ObjectInputStream不能序列化static和transient修饰的成员变量</li>
<li>对象序列化机制允许把内存中的Java对象转换成平台无关的二进制流，从而允许把这种二进制流持久地保存在磁盘上，或通过网络将这种二进制流传输到另一个网络节点。&#x2F;&#x2F;当其它程序获取了这种二进制流，就可以恢复成原来的Java对象</li>
<li>序列化的好处在于可将任何实现了Serializable接口的对象转化为字节数据，使其在保存和传输时可被还原</li>
<li>序列化是RMI（Remote Method Invoke –远程方法调用）过程的参数和返回值都必须实现的机制，而RMI 是JavaEE的基础。因此序列化机制是JavaEE平台的基础</li>
<li>如果需要让某个对象支持序列化机制，则必须让对象所属的类及其属性是可序列化的，为了让某个类是可序列化的，该类必须实现如下两个接口之一。否则，会抛出NotSerializableException异常<ul>
<li>Serializable</li>
<li>Externalizable</li>
</ul>
</li>
</ul>
<h4 id="自定义类实现序列化与反序列化操作"><a href="#自定义类实现序列化与反序列化操作" class="headerlink" title="自定义类实现序列化与反序列化操作"></a>自定义类实现序列化与反序列化操作</h4><ul>
<li><p>若某个类实现了Serializable接口，该类的对象就是可序列化的：</p>
<ul>
<li>创建一个ObjectOutputStream</li>
<li>调用ObjectOutputStream对象的writeObject(对象) 方法输出可序列化对象</li>
<li>注意写出一次，操作flush()一次</li>
</ul>
</li>
<li><p>反序列化</p>
<ul>
<li>创建一个ObjectInputStream调用readObject() 方法读取流中的对象</li>
</ul>
</li>
<li><p>强调：如果某个类的属性不是基本数据类型或String  类型，而是另一个引用类型，那么这个引用类型必须是可序列化的，否则拥有该类型的Field 的类也不能序列化</p>
</li>
<li><p>Person类</p>
</li>
</ul>
<h4 id="serialVersionUID的理解"><a href="#serialVersionUID的理解" class="headerlink" title="serialVersionUID的理解"></a>serialVersionUID的理解</h4><ul>
<li><p>凡是实现Serializable接口的类都有一个表示序列化版本标识符的静态变量：</p>
<ul>
<li>private static final long serialVersionUID;</li>
<li>serialVersionUID用来表明类的不同版本间的兼容性。简言之，其目的是以序列化对象进行版本控制，有关各版本反序列化时是否兼容。</li>
<li>如果类没有显示定义这个静态常量，它的值是Java运行时环境根据类的内部细节自动生成的。若类的实例变量做了修改，serialVersionUID可能发生变化。故建议，显式声明。</li>
</ul>
</li>
<li><p>简单来说，Java的序列化机制是通过在运行时判断类的serialVersionUID来验证版本一致性的。在进行反序列化时，JVM会把传来的字节流中的serialVersionUID与本地相应实体类的serialVersionUID进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常。(InvalidCastException)</p>
</li>
<li><p>Person类</p>
</li>
</ul>
<h3 id="10-随机存取文件流"><a href="#10-随机存取文件流" class="headerlink" title="10.随机存取文件流"></a>10.随机存取文件流</h3><ul>
<li><p>RandomAccessFile 声明在java.io包下，但直接继承于java.lang.Object类。并且它实现了DataInput、DataOutput这两个接口，也就意味着这个类既可以读也可以写。</p>
</li>
<li><p>RandomAccessFile 类支持“随机访问” 的方式，程序可以直接跳到文件的任意地方来读、写文件</p>
<ul>
<li>支持只访问文件的部分内容</li>
<li>可以向已存在的文件后追加内容</li>
</ul>
</li>
<li><p>RandomAccessFile 对象包含一个记录指针，用以标示当前读写处的位置。RandomAccessFile类对象可以自由移动记录指针：</p>
<ul>
<li>long getFilePointer()：获取文件记录指针的当前位置</li>
<li>void seek(long pos)：将文件记录指针定位到pos位置</li>
</ul>
</li>
<li><p>构造器</p>
<ul>
<li>public RandomAccessFile(Filefile, Stringmode) </li>
<li>public RandomAccessFile(Stringname, Stringmode)</li>
</ul>
</li>
<li><p>创建RandomAccessFile类实例需要指定一个mode 参数，该参数指定RandomAccessFile的访问模式：</p>
<ul>
<li>r: 以只读方式打开</li>
<li>rw：打开以便读取和写入</li>
<li>rwd:打开以便读取和写入；同步文件内容的更新</li>
<li>rws:打开以便读取和写入；同步文件内容和元数据的更新</li>
</ul>
</li>
<li><p>如果模式为只读r。则不会创建文件，而是会去读取一个已经存在的文件，如果读取的文件不存在则会出现异常。如果模式为rw读写。如果文件不存在则会去创建文件，如果存在则不会创建。</p>
</li>
</ul>
<h3 id="11-NIO-2中Path、Paths、Files类的使用"><a href="#11-NIO-2中Path、Paths、Files类的使用" class="headerlink" title="11.NIO.2中Path、Paths、Files类的使用"></a>11.NIO.2中Path、Paths、Files类的使用</h3><ul>
<li><p>Java NIO (New IO，Non-Blocking IO)是从Java 1.4版本开始引入的一套新的IO API，可以替代标准的Java IO API。NIO与原来的IO有同样的作用和目的，但是使用的方式完全不同，NIO支持面向缓冲区的(IO是面向流的)、基于通道的IO操作。NIO将以更加高效的方式进行文件的读写操作。</p>
</li>
<li><p>Java API中提供了两套NIO，一套是针对标准输入输出NIO，另一套就是网络编程NIO。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|-----java.nio.channels.Channel</span><br><span class="line">    |-----FileChannel:处理本地文件</span><br><span class="line">    |-----SocketChannel：TCP网络编程的客户端的Channel</span><br><span class="line">    |-----ServerSocketChannel:TCP网络编程的服务器端的Channel</span><br><span class="line">    |-----DatagramChannel：UDP网络编程中发送端和接收端的Channel</span><br></pre></td></tr></table></figure>
</li>
<li><p>随着JDK 7 的发布，Java对NIO进行了极大的扩展，增强了对文件处理和文件系统特性的支持，以至于我们称他们为NIO.2。因为NIO 提供的一些功能，NIO已经成为文件处理中越来越重要的部分。</p>
</li>
<li><p>早期的Java只提供了一个File类来访问文件系统，但File类的功能比较有限，所提供的方法性能也不高。而且，大多数方法在出错时仅返回失败，并不会提供异常信息。</p>
</li>
<li><p>NIO. 2为了弥补这种不足，引入了Path接口，代表一个平台无关的平台路径，描述了目录结构中文件的位置。Path可以看成是File类的升级版本，实际引用的资源也可以不存在。</p>
</li>
<li><p>在以前IO操作都是这样写的:</p>
<ul>
<li>import java.io.File;</li>
<li>File file &#x3D; new File(“index.html”);</li>
</ul>
</li>
<li><p>但在Java7 中，我们可以这样写：</p>
<ul>
<li>import java.nio.file.Path;</li>
<li>import java.nio.file.Paths;</li>
<li>Path path &#x3D; Paths.get(“index.html”);</li>
</ul>
</li>
<li><p>同时，NIO.2在java.nio.file包下还提供了Files、Paths工具类，Files包含了大量静态的工具方法来操作文件；Paths则包含了两个返回Path的静态工厂方法。</p>
</li>
<li><p>Paths 类提供的静态get() 方法用来获取Path 对象：</p>
<ul>
<li>static Pathget(String first, String … more) : 用于将多个字符串串连成路径</li>
<li>static Path get(URI uri): 返回指定uri对应的Path路径</li>
</ul>
</li>
<li><p>Path接口</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-02/a82dd7550a4c16ef3ea37fc6aa8609a6--7334--image-20241002190644089.png" alt="image-20241002190644089"></p>
<ul>
<li>Files 类</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-02/8254c3f67ca2c7111a66692567b84c67--2a50--image-20241002191211308.png" alt="image-20241002191211308"></p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-02/ba3be1ca719cecb6fcccee7568a403d6--ec6a--image-20241002191223484.png" alt="image-20241002191223484"></p>
<blockquote>
<p>一些对于NIO与IO的对比</p>
</blockquote>
<p>作者：终端研发部<br>链接：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/439681246/answer/1753604983">https://www.zhihu.com/question/439681246/answer/1753604983</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<p>NIO是为了弥补IO操作的不足而诞生的，NIO的一些新特性有：非阻塞I&#x2F;O，选择器，缓冲以及管道。管道（Channel），缓冲（Buffer） ，选择器（ Selector）是其主要特征。</p>
<p><img src="https://picx.zhimg.com/80/v2-db587ee075af848892e64f137ea9fd5e_1440w.webp?source=1def8aca" alt="img"></p>
<h5 id="概念解释："><a href="#概念解释：" class="headerlink" title="概念解释："></a>概念解释：</h5><p>Channel——管道实际上就像传统IO中的流，到任何目的地(或来自任何地方)的所有数据都必须通过一个 Channel 对象。一个 Buffer 实质上是一个<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=348917546&content_type=Answer&match_order=1&q=%E5%AE%B9%E5%99%A8%E5%AF%B9%E8%B1%A1&zhida_source=entity">容器对象</a>。</p>
<p>Selector——选择器用于监听多个管道的事件，使用传统的<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=348917546&content_type=Answer&match_order=1&q=%E9%98%BB%E5%A1%9EIO&zhida_source=entity">阻塞IO</a>时我们可以方便的知道什么时候可以进行读写，而使用非阻塞通道，我们需要一些方法来知道什么时候通道准备好了，选择器正是为这个需要而诞生的。</p>
<h5 id="NIO和传统的IO有什么区别呢"><a href="#NIO和传统的IO有什么区别呢" class="headerlink" title="NIO和传统的IO有什么区别呢?"></a>NIO和传统的IO有什么区别呢?</h5><p><strong>1，IO是面向流的，NIO是面向块（缓冲区）的。</strong></p>
<p>IO面向流的操作一次一个字节地处理数据。一个输入流产生一个字节的数据，一个输出流消费一个字节的数据。，导致了数据的读取和写入效率不佳；</p>
<p>NIO面向块的操作在一步中产生或者消费一个数据块。按块处理数据比按(流式的)字节处理数据要快得多，同时数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。通俗来说，NIO采取了“预读”的方式，当你读取某一部分数据时，他就会猜测你下一步可能会读取的数据而预先缓冲下来。</p>
<p><strong>2，IO是阻塞的，NIO是非阻塞的。</strong></p>
<p>对于传统的IO，当一个线程调用read() 或 write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。</p>
<p>而对于NIO，使用一个线程发送读取数据请求，没有得到响应之前，线程是空闲的，此时线程可以去执行别的任务，而不是像IO中那样只能等待响应完成。</p>
<p><strong>3，NIO和IO适用场景</strong></p>
<p>NIO是为弥补传统IO的不足而诞生的，但是<a href="https://link.zhihu.com/?target=https://www.baidu.com/s?wd=%E5%B0%BA%E6%9C%89%E6%89%80%E7%9F%AD&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd">尺有所短</a><a href="https://link.zhihu.com/?target=https://www.baidu.com/s?wd=%E5%AF%B8%E6%9C%89%E6%89%80%E9%95%BF&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd">寸有所长</a>，NIO也有缺点，因为NIO是面向缓冲区的操作，每一次的数据处理都是对缓冲区进行的，那么就会有一个问题，在数据处理之前必须要判断缓冲区的数据是否完整或者已经读取完毕，如果没有，假设数据只读取了一部分，那么对不完整的数据处理没有任何意义。所以每次数据处理之前都要检测缓冲区数据。</p>
<p><strong>那么NIO和IO各适用的场景是什么呢？</strong></p>
<p>如果需要管理同时打开的<a href="https://link.zhihu.com/?target=https://www.baidu.com/s?wd=%E6%88%90%E5%8D%83%E4%B8%8A%E4%B8%87&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd">成千上万</a>个连接，这些连接每次只是发送少量的数据，例如<a target="_blank" rel="noopener" href="https://zhida.zhihu.com/search?content_id=348917546&content_type=Answer&match_order=1&q=%E8%81%8A%E5%A4%A9%E6%9C%8D%E5%8A%A1%E5%99%A8&zhida_source=entity">聊天服务器</a>，这时候用NIO处理数据可能是个很好的选择。</p>
<p>而如果只有少量的连接，而这些连接每次要发送大量的数据，这时候传统的IO更合适。使用哪种处理数据，需要在数据的响应等待时间和检查缓冲区数据的时间上作比较来权衡选择。</p>
<p><strong>4，通俗解释</strong></p>
<h5 id="最后，对于NIO和传统IO，有一个网友讲的生动的例子："><a href="#最后，对于NIO和传统IO，有一个网友讲的生动的例子：" class="headerlink" title="最后，对于NIO和传统IO，有一个网友讲的生动的例子："></a>最后，对于NIO和传统IO，有一个网友讲的生动的例子：</h5><p>以前的流总是堵塞的，一个线程只要对它进行操作，其它操作就会被堵塞，也就相当于水管没有阀门，你伸手接水的时候，不管水到了没有，你就都只能耗在接水（流）上。</p>
<p>nio的Channel的加入，相当于增加了水龙头（有阀门），虽然一个时刻也只能接一个水管的水，但依赖轮换策略，在水量不大的时候，各个水管里流出来的水，都可以得到妥</p>
<p>善接纳，这个关键之处就是增加了一个接水工，也就是Selector，他负责协调，也就是看哪根水管有水了的话，在当前水管的水接到一定程度的时候，就切换一下：临时关上当前水龙头，试着打开另一个水龙头（看看有没有水）。</p>
<p>当其他人需要用水的时候，不是直接去接水，而是事前提了一个水桶给接水工，这个水桶就是Buffer。也就是，其他人虽然也可能要等，但不会在现场等，而是回家等，可以做其它事去，水接满了，接水工会通知他们。</p>
<p>这其实也是非常接近当前社会分工细化的现实，也是统分利用现有资源达到并发效果的一种很经济的手段，而不是动不动就来个并行处理，虽然那样是最简单的，但也是最浪费资源的方式。</p>
<h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><h3 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1.概述"></a>1.概述</h3><p>邮件：</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-02/cf09b1139d0685d05e0de851fd49a94d--4166--image-20241002192704353.png" alt="image-20241002192704353"></p>
<ul>
<li>计算机网络： 计算机网络是指将<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%9C%B0%E7%90%86">地理</a>位置不同的具有独立功能的多台<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA/140338">计算机</a>及其外部设备，通过通信线路连接起来，在<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3997">网络操作系统</a>，<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86%E8%BD%AF%E4%BB%B6/6579078">网络管理软件</a>及<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/4438611">网络通信协议</a>的管理和协调下，实现<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB/233480">资源共享</a>和信息传递的计算机系统。 </li>
<li>网络编程的目的：无线电台…传播交流信息，数据交换，通信。</li>
<li><strong>想要达到这个效果需要什么：</strong><ol>
<li>如何让准确的定位网络上的一台主机 192.168.16.124：端口， 定位上这个计算机上的某个资源。</li>
<li>找到了这个主机，如何传输数据呢？</li>
</ol>
</li>
<li>Javaweb:网页编程 、 B&#x2F;S架构</li>
<li>网络编程：TCP&#x2F;IP 、 C&#x2F;S</li>
</ul>
<h3 id="2-网络通信要素"><a href="#2-网络通信要素" class="headerlink" title="2.网络通信要素"></a>2.网络通信要素</h3><p><strong>如何实现网络的通信？</strong></p>
<ul>
<li>通信双方的地址：<ul>
<li>ip：192.168.16.124</li>
<li>端口：5900</li>
</ul>
</li>
<li><strong>规则：网络通信的协议</strong>：TCP&#x2F;IP</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-02/1248aa7b160d777171d9816f1f8e182c--de8e--image-20241002192722608.png" alt="image-20241002192722608"></p>
<blockquote>
<p>小结：</p>
</blockquote>
<ol>
<li>网络编程中有两个主要的问题：<ul>
<li>如何让准确的定位到网络上的一台或多台主机；</li>
<li>找到主机之后如何通信；</li>
</ul>
</li>
<li>网络编程中的要素：<ul>
<li>IP和端口号：IP</li>
<li>网络通信协议：UDP、TCP</li>
</ul>
</li>
<li>万物皆对象</li>
</ol>
<h3 id="3-IP"><a href="#3-IP" class="headerlink" title="3.IP"></a>3.IP</h3><p>IP 地址：InetAddress</p>
<ul>
<li><p>唯一定位一台网络上的计算机</p>
</li>
<li><p>127.0.0.1： 本机localhost</p>
</li>
<li><p>ip地址的父类</p>
<ul>
<li>&#x3D;&#x3D;IPV4&#x3D;&#x3D;： 127.0.0.1 ,4个字节组成。，0<del>255， 42亿</del>；30亿都在北美，亚洲4亿。2011年就用尽；</li>
<li>&#x3D;&#x3D;IPV6&#x3D;&#x3D;： fe80::f0e0:7383:ad8e:f32f%3 ，128位。8个无符号整数</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2406</span>:da18:ddf:<span class="number">4000</span>:67d5:b226:cad7:125b</span><br></pre></td></tr></table></figure>
</li>
<li><p>公网（互联网）–私网（局域网）</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://www.jb51.net/network/579228.html">ABCD地址</a></p>
</li>
<li><p>192.168.xx.xx,专门给组织内部使用。</p>
</li>
</ul>
</li>
<li><p>域名：记忆IP问题！</p>
<ul>
<li>IP：<a target="_blank" rel="noopener" href="http://www.vip.com/">www.vip.com</a></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.UnknownHostException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestInetAddress</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">InetAddress</span> <span class="variable">byName</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">            System.out.println(byName);</span><br><span class="line">            <span class="type">InetAddress</span> <span class="variable">byName2</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">            System.out.println(byName2);</span><br><span class="line">            <span class="type">InetAddress</span> <span class="variable">localHost</span> <span class="operator">=</span> InetAddress.getLocalHost();</span><br><span class="line">            System.out.println(localHost);</span><br><span class="line"></span><br><span class="line">            <span class="type">InetAddress</span> <span class="variable">byName1</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;www.taobao.com&quot;</span>);</span><br><span class="line">            System.out.println(byName1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">localhost/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">6pc1/<span class="number">192.168</span><span class="number">.56</span><span class="number">.1</span></span><br><span class="line">www.taobao.com/<span class="number">221.228</span><span class="number">.217</span><span class="number">.213</span></span><br></pre></td></tr></table></figure>

<h3 id="4-端口"><a href="#4-端口" class="headerlink" title="4.端口"></a>4.端口</h3><ul>
<li><p>端口表示计算机上一个程序的进程；</p>
</li>
<li><p>不同的进程有不同的端口号！用来区分软件！</p>
</li>
<li><p>被规定0~65535</p>
</li>
<li><p>TCP，UDP：65535*2个端口 tcp：80 udp：80 单个协议下，端口号不能冲突</p>
</li>
<li><p>端口分类</p>
<ul>
<li>共有端口 0~1023 内置的进程使用<ul>
<li>HTTP：80</li>
<li>HTTP：443 如访问https：&#x2F;&#x2F;<a target="_blank" rel="noopener" href="http://www.baidu.com:443/">www.baidu.com:443</a> 访问的还是百度</li>
<li>FTP：21</li>
<li>TELENT：23</li>
</ul>
</li>
<li>程序注册端口：1014-49151，分配给用户和程序<ul>
<li>Tomcat：8080</li>
<li>MySql：3306</li>
<li>Oracle：1521</li>
</ul>
</li>
<li>动态、私有端口：49152~65535</li>
</ul>
</li>
</ul>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">netstat -ano #查看所有的端口</span><br><span class="line">netstat -nao|<span class="built_in">findstr</span> &quot;<span class="number">7808</span>&quot; #查看指定的端口</span><br><span class="line">tasklist|<span class="built_in">findstr</span> &quot;<span class="number">8696</span>&quot;</span><br></pre></td></tr></table></figure>

<h3 id="5-通信协议"><a href="#5-通信协议" class="headerlink" title="5.通信协议"></a>5.通信协议</h3><p>协议：约定，就好比中国人交流说的是普通话</p>
<p><strong>网络通信协议：</strong> 速率，传输码率，代码结构，传输控制…</p>
<p><strong>问题</strong>：非常的复杂</p>
<p>大事化小：分层</p>
<p><strong>TCP&#x2F;IP协议簇：实际上是一组协议</strong></p>
<p>重要：</p>
<ul>
<li>TCP：用户传输协议</li>
<li>UDP：用户数据报协议</li>
</ul>
<p>出名的协议：</p>
<ul>
<li>TCP：</li>
<li>IP：网络互联协议</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-02/f1c84981f8b01587eff9be2fc64dd7a6--6362--image-20241002193643594.png" alt="image-20241002193643594"></p>
<p>CP UDP 对比**</p>
<ul>
<li><p>TCP：打电话</p>
<ul>
<li><p>连接，稳定</p>
</li>
<li><p>三次握手，四次挥手</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">最少需要三次，保证稳定连接！</span><br><span class="line">A：你瞅啥？</span><br><span class="line">B：瞅你咋地？</span><br><span class="line">A：干一场</span><br><span class="line"></span><br><span class="line">A：我要分手了</span><br><span class="line">B：我知道你要分手了</span><br><span class="line">B：你真的要分手吗？</span><br><span class="line">A：我真的要分手了</span><br></pre></td></tr></table></figure>
</li>
<li><p>客户端、服务器</p>
</li>
<li><p>传输完成，释放连接，效率低</p>
</li>
</ul>
</li>
<li><p>UDP;发短信</p>
<ul>
<li>不连接，不稳定</li>
<li>客户端、服务端：没有明确的解现</li>
<li>不管有没有准备好，都可以发给你</li>
<li>DDOS：洪水攻击！ 发垃圾包 堵塞线路 （饱和攻击）</li>
</ul>
</li>
</ul>
<h3 id="6-TCP"><a href="#6-TCP" class="headerlink" title="6.TCP"></a>6.TCP</h3><blockquote>
<p><strong>先启动服务端，再启动客户端！！！！</strong></p>
</blockquote>
<p><strong>客户端</strong></p>
<ul>
<li>连接服务器 Socket</li>
<li>发送消息</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TCPClientDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">accept</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1.要知道服务器的地址</span></span><br><span class="line">            <span class="type">InetAddress</span> <span class="variable">inetAddress</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">9999</span>;</span><br><span class="line">            <span class="comment">// 2.创建一个socket链接</span></span><br><span class="line">            accept = <span class="keyword">new</span> <span class="title class_">Socket</span>(inetAddress,port);</span><br><span class="line">            <span class="comment">// 3.发送信息IO流</span></span><br><span class="line">            os = accept.getOutputStream();</span><br><span class="line">            os.write(<span class="string">&quot;就这吧，什么鬼？咿呀咿呀哟咿呀咿呀哟&quot;</span>.getBytes());</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 关闭资源</span></span><br><span class="line">            <span class="keyword">if</span>(os != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    os.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(accept != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    accept.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>服务器端</strong></p>
<ul>
<li>建立服务的端口 ServerSocket</li>
<li>等待的用户的连接 accept</li>
<li>接收用户的消息</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TCPServerDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// 1.有一个地址</span></span><br><span class="line">            serverSocket = <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">9999</span>);</span><br><span class="line">            <span class="comment">// 2.等待客户端连接过来</span></span><br><span class="line">            socket = serverSocket.accept();</span><br><span class="line">            <span class="comment">// 3.读取客户端的消息</span></span><br><span class="line">            is = socket.getInputStream();</span><br><span class="line"></span><br><span class="line">           <span class="comment">/*</span></span><br><span class="line"><span class="comment">           //弃用 会有中文乱码</span></span><br><span class="line"><span class="comment">           byte[] buffer = new byte[1024];</span></span><br><span class="line"><span class="comment">            int len = 0;</span></span><br><span class="line"><span class="comment">            while ((len = is.read(bytes)) != -1)&#123;</span></span><br><span class="line"><span class="comment">                String s = new String(buffer,0,len);</span></span><br><span class="line"><span class="comment">                System.out.println(s);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 管道流</span></span><br><span class="line">            baos = <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line"></span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((len = is.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                baos.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(baos.toString());</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 关闭资源</span></span><br><span class="line">            <span class="keyword">if</span> (baos != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    baos.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (is != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    is.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (socket != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (serverSocket != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    serverSocket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-02/51f7dcfcdb8f0cd022e3ccd81021033a--b1f8--image-20241002194149715.png" alt="image-20241002194149715"></p>
<h4 id="2-初识Tomcat"><a href="#2-初识Tomcat" class="headerlink" title="2.初识Tomcat"></a>2.初识Tomcat</h4><blockquote>
<p>Tomcat乱码： conf\logging.properties 把UTF-8改为GBK</p>
</blockquote>
<p>服务端</p>
<ul>
<li>自定义 S</li>
<li>Tomcat服务器 S ：Java后台开发</li>
</ul>
<p>客户端</p>
<ul>
<li>自定义 C</li>
<li>浏览器 B</li>
</ul>
<h3 id="7-UDP"><a href="#7-UDP" class="headerlink" title="7.UDP"></a>7.UDP</h3><p> 发短信：不用连接，需要知道对方的地址 </p>
<h4 id="1-发送消息"><a href="#1-发送消息" class="headerlink" title="1.发送消息"></a>1.发送消息</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UDPClientDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 1、建立一个Socket</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">datagramSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();</span><br><span class="line">        <span class="comment">// 2、建个包</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;UDP服务器。你好！&quot;</span>;</span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">byName</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">9090</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 数据、数据的长度起始、要发送给谁</span></span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">datagramPacket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(msg.getBytes(), msg.getBytes().length, byName, port);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3、 发送包</span></span><br><span class="line">        datagramSocket.send(datagramPacket);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4、 关闭流</span></span><br><span class="line">        datagramSocket.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UDPServerDemo011</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//1、 开放端口</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">datagramSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">9090</span>);</span><br><span class="line">        <span class="comment">//2 、接受数据包</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">datagramPacket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(bytes, bytes.length);</span><br><span class="line"></span><br><span class="line">        datagramSocket.receive(datagramPacket);</span><br><span class="line">        System.out.println(datagramPacket.getAddress().getHostAddress());</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(datagramPacket.getData()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3、关闭连接</span></span><br><span class="line">        datagramSocket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-02/5470eb5dfe09d3ef6743df8efc80e6d6--759e--image-20241002195004190.png" alt="image-20241002195004190"></p>
<ul>
<li>长串乱码是接受使用的1024的byte</li>
</ul>
<h3 id="8-URL"><a href="#8-URL" class="headerlink" title="8.URL"></a>8.URL</h3><ul>
<li><p><a target="_blank" rel="noopener" href="https://www.baidu.com/">https://www.baidu.com</a></p>
</li>
<li><p>统一资源定位符：定位互联网上的某一个资源</p>
</li>
<li><p>DNS域名解析 <a target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a> —&gt; xxx.xxx.xxxx.xxx…xxx</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">协议：//ip地址：端口号/项目名/资源</span><br></pre></td></tr></table></figure>

<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="1、线程实现"><a href="#1、线程实现" class="headerlink" title="1、线程实现"></a>1、线程实现</h3><h4 id="1-线程的创建-三种方式"><a href="#1-线程的创建-三种方式" class="headerlink" title="1.线程的创建(三种方式)"></a>1.线程的创建(三种方式)</h4><blockquote>
<p>1.1 继承Thread类<strong>（重要）</strong></p>
<ul>
<li>自定义线程类继承<code>Thread</code>类；</li>
<li>重写<code>run()</code>方法，编写线程执行体；</li>
<li>创建线程对象，调用<code>start()</code>方法启动线程。</li>
</ul>
</blockquote>
<ul>
<li>可以直接使用lambo表达式开启多线程</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName());</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-02/a93581cde7b6ff6b5e0f388d3dc9bcbb--48bf--image-20241002200418140.png" alt="image-20241002200418140"></p>
<blockquote>
<p>1.2 实现Runnable接口</p>
<ul>
<li><strong>推荐使用Runnable对象,因为Java单继承的局限性</strong>；</li>
<li>自定义线程类实现<code>Runnable</code>接口；</li>
<li>实现<code>run()</code>方法,编写线程执行体；</li>
<li>创建线程对象,调用<code>start()</code>方法启动对象。</li>
</ul>
</blockquote>
<blockquote>
<p>1.3 实现Callable接口（了解）</p>
<ul>
<li>实现Callable接口，需要返回值类型；</li>
<li>重写call方法，需要抛出异常；</li>
<li>创建目标对象；</li>
<li>创建执行服务：ExecutorService ser &#x3D; Executors.newFixedThreadPool(1);</li>
<li>提交执行：Future result1 &#x3D; ser.submit(11);</li>
<li>获取结果：boolean r1 &#x3D; result1.get();</li>
<li>关闭服务：ser.shutdownNow();</li>
</ul>
</blockquote>
<h4 id="2-静态代理"><a href="#2-静态代理" class="headerlink" title="2.静态代理"></a>2.静态代理</h4><p><img src="http://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-06/0f21687c7dae4f514872b6eca338b761--d6f5--image-20241006132520284.png" alt="image-20241006132520284"></p>
<ul>
<li>总结<ul>
<li>真实对象和代理对象都要实现一个接口；</li>
<li>代理对象要代理真实角色。</li>
</ul>
</li>
<li>好处<ul>
<li>代理对象可以做很多真实对象做不了的事情；</li>
<li>真实对象专注做自己的事。</li>
</ul>
</li>
</ul>
<h4 id="3-Lambda表达式"><a href="#3-Lambda表达式" class="headerlink" title="3.Lambda表达式"></a>3.Lambda表达式</h4><p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-06/bfe245ecd11b4f7efae76acd496e5dfb--4306--image-20241006134641276.png" alt="image-20241006134641276"></p>
<ul>
<li>λ 希腊字母表中排序第十一位的字母，英语名称为 Lambda；</li>
<li>避免匿名内部类定义过多；</li>
<li>其实质属于函数式编程的概念；</li>
<li>去掉了一堆没有意义的代码,只留下核心逻辑。</li>
</ul>
<blockquote>
<ul>
<li><p>(params)-&gt; expression[表达式]</p>
</li>
<li><p>(params) -&gt; statement[语句]</p>
</li>
<li><p>(params)-&gt; {statements}</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a -&gt; System.out.println(<span class="string">&quot;i like lamda--&gt;&quot;</span>+a)</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>new Thread (()-&gt;System.out.println(“多线程学习。。。。”)).start()；</li>
<li>理解Functional Interface (函数式接口) 是学习Java 8 lambda表达式的关键</li>
</ul>
<blockquote>
<p>函数式接口的定义</p>
</blockquote>
<ul>
<li>任何接口，如果只包含唯一一个抽象方法，那么它就是一个函数式接口。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>对于函数式接口，我们可以通过Lambda表达式来创建该接口的对象。</li>
</ul>
<h3 id="2、线程状态"><a href="#2、线程状态" class="headerlink" title="2、线程状态"></a>2、线程状态</h3><h4 id="1-、线程的五大状态"><a href="#1-、线程的五大状态" class="headerlink" title="1 、线程的五大状态"></a>1 、线程的五大状态</h4><p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-06/6aa70bdff9b7d0ccaab0fcbf9e43512a--8967--image-20241006142241243.png" alt="image-20241006142241243"></p>
<h4 id="2、线程方法"><a href="#2、线程方法" class="headerlink" title="2、线程方法"></a>2、线程方法</h4><p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-06/93e398a6d304d22f3e9508b65e5d7db1--1d19--image-20241006142255177.png" alt="image-20241006142255177"></p>
<blockquote>
<p>停止线程</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-06/d789e0d2559d4467d10b7795d4a0f0b5--118e--image-20241006142311833.png" alt="image-20241006142311833"></p>
<blockquote>
<p>线程休眠</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-06/9b372cb18be71db388e8ce1c20f00bb7--45cf--image-20241006142329579.png" alt="image-20241006142329579"></p>
<blockquote>
<p>线程礼让</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-06/3c5e2afce39776a9856aa0325ae2015b--8dfd--image-20241006142802266.png" alt="image-20241006142802266"></p>
<blockquote>
<p>线程插队</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-06/a22edb7010caa4d6da813af49a570d10--683b--image-20241006142815613.png" alt="image-20241006142815613"></p>
<h4 id="3-线程状态观测"><a href="#3-线程状态观测" class="headerlink" title="3.线程状态观测"></a>3.线程状态观测</h4><p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-06/4558c3a3bcf24243d562cb6f6bc4fb81--e402--image-20241006142842061.png" alt="image-20241006142842061"></p>
<h4 id="4、线程优先级"><a href="#4、线程优先级" class="headerlink" title="4、线程优先级"></a>4、线程优先级</h4><p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-06/6f685bd89884419530aaba4167ddb2a0--365d--image-20241006142859222.png" alt="image-20241006142859222"></p>
<h4 id="5、守护线程"><a href="#5、守护线程" class="headerlink" title="5、守护线程"></a>5、守护线程</h4><ul>
<li>线程分为<strong>用户线程</strong>和<strong>守护线程</strong>；</li>
<li>虚拟机必须确保用户线程执行完毕；</li>
<li>虚拟机不用等待守护线程执行完毕；</li>
<li>如，后台记录操作日志，监控内存垃圾回收等待……</li>
</ul>
<h3 id="3、线程同步"><a href="#3、线程同步" class="headerlink" title="3、线程同步"></a>3、线程同步</h3><h4 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h4><ul>
<li>**多个线程操作同一个资源 **</li>
<li>并发：同一个对象被多个线程同时操作</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-06/d0acde08a8674b45418842b7d10eae38--d0c8--image-20241006143301494.png" alt="image-20241006143301494"></p>
<blockquote>
<p>线程同步：</p>
<ul>
<li>现实生活中我们会遇到“同—个资源，多个人都想使用”的问题，比如食堂排队打饭，每个人都想吃饭，最天然的解決办法就是：排队，一个个来。</li>
<li>处理多线程问题时，多个线程访问同一个对象，并且某些线程还想修改这个对象这时候我们就需要线程同步。线程同步其实就是一种等待机制，多个需要同时访问此对象的线程进入这个&#x3D;&#x3D;对象的等待池形&#x3D;&#x3D;成队列，等待前面线程使用完毕，下一个线程再使用。</li>
</ul>
</blockquote>
<ul>
<li>队列和锁</li>
</ul>
<blockquote>
<p>线程同步：</p>
<ul>
<li>由于同一进程的多个线程共享同一块存储空间，在带来方便的同时，也带来了访问冲突问题，为了保证数据在方法中被访问时的正确性，在访问时加入锁机制synchronized，当一个线程获得对象的排它锁，独占资源，其他线程必须等待使用后释放锁即可。存在以下问题：<ul>
<li>一个线程持有锁会导致其他所有需要此锁的线程挂起；</li>
<li>在多线程竞争下，加锁，释放锁会导致比较多的上下文切换和调度延时，引起性能问题；</li>
<li>如果一个优先级高的线程等待个优先级低的线程释放锁会导致优先级倒置，引起性能问题。</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="2、同步方法"><a href="#2、同步方法" class="headerlink" title="2、同步方法"></a>2、同步方法</h4><ul>
<li>由于我们可以通过 private关键字来保证数据对象只能被方法访问，所以我们只需要针对方法提岀一套机制，这套机制就是syη chronized关键字，它包括两种用法synchronized方法和 synchronized块。<ul>
<li>同步方法：public synchronized void method (int args) {}</li>
</ul>
</li>
<li>synchronized方法控制对“对象”的访问，每个对象对应一把锁，每个synchronized方法都必须获得调用该方法的对象的锁才能执行，否则线程会阻塞，方法一旦执行，就独占该锁，直到该方法返回才释放锁，后面被阻塞的线程才能获得这个锁，继续执行。<ul>
<li>缺陷：若将一个大的方法申明为 synchronized将会影响效率。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">BuyTicket</span> <span class="variable">buyTicket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BuyTicket</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(buyTicket, <span class="string">&quot;张三&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(buyTicket, <span class="string">&quot;李四&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(buyTicket, <span class="string">&quot;王五&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BuyTicket</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="comment">// 票</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">ticketNums</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                buy();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 买票</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">buy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ticketNums &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;拿到&quot;</span> + ticketNums--);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加锁前：</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-06/97851aa1659b6455ef2896b6e007843a--7088--image-20241006145802193.png" alt="image-20241006145802193"></p>
<p>加锁后：</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-06/2408cff000b434b3d05db3cbd12bdd9b--312f--image-20241006145827201.png" alt="image-20241006145827201"></p>
<h4 id="3-同步块"><a href="#3-同步块" class="headerlink" title="3.同步块"></a>3.同步块</h4><ul>
<li>同步块：synchronized (Obj) {}</li>
<li>obj称之为同步监视器<ul>
<li>Obj可以是任何对象，但是推存使用共享资源作为同步监视器。</li>
<li>同步方法中无需指定同步监视器，因为同步方法的同步监视器就是this，就是这个对象本身，或者是class。</li>
</ul>
</li>
<li>同步监视器的执行过程：<ul>
<li>1.第一个线程访问，锁定同步监视器，执行其中代码；</li>
<li>2.第二个线程访问，发现同步监视器被锁定，无法访问；</li>
<li>3.第一个线程访问完毕，解锁同步监视器；</li>
<li>4.第二个线程访问，发现同步监视器没有锁，然后锁定并访问。</li>
</ul>
</li>
</ul>
<p><strong>锁的对象就是变量的量,需要增删改查的对象</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Account</span> <span class="variable">account</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Account</span>(<span class="number">100</span>, <span class="string">&quot;养老基金&quot;</span>);</span><br><span class="line">        <span class="type">Drawing</span> <span class="variable">drawing</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Drawing</span>(account, <span class="number">60</span>, <span class="string">&quot;夸克&quot;</span>);</span><br><span class="line">        <span class="type">Drawing</span> <span class="variable">drawing2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Drawing</span>(account, <span class="number">100</span>, <span class="string">&quot;1111&quot;</span>);</span><br><span class="line">        <span class="type">Drawing</span> <span class="variable">same</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Drawing</span>(account, <span class="number">120</span>, <span class="string">&quot;same&quot;</span>);</span><br><span class="line">        drawing.start();</span><br><span class="line">        drawing2.start();</span><br><span class="line">        same.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span>&#123;</span><br><span class="line">    <span class="type">int</span> money;  <span class="comment">// 余额</span></span><br><span class="line">    String cardName;    <span class="comment">// 卡名</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Account</span><span class="params">(<span class="type">int</span> money, String cardName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.money = money;</span><br><span class="line">        <span class="built_in">this</span>.cardName = cardName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Drawing</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    Account account;    <span class="comment">// 账户</span></span><br><span class="line">    <span class="type">int</span> drawingMoney;   <span class="comment">// 取余额</span></span><br><span class="line">    <span class="type">int</span> nowMoney;   <span class="comment">// 个人手里的钱</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Drawing</span><span class="params">(Account account, <span class="type">int</span> drawingMoney, String name)</span> &#123;</span><br><span class="line">        <span class="comment">// super(name) =  父类构造方法(name)</span></span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        <span class="built_in">this</span>.account = account;</span><br><span class="line">        <span class="built_in">this</span>.drawingMoney = drawingMoney;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取钱</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 锁的对象就是变量的量,需要增删改查的对象</span></span><br><span class="line">        <span class="keyword">synchronized</span> (account) &#123;</span><br><span class="line">            <span class="comment">// 判断是否有钱</span></span><br><span class="line">            <span class="keyword">if</span> (account.money - drawingMoney &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;余额不足,不能进行取钱&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>); <span class="comment">// 放大问题的发生性</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 卡内金额 = 余额 - 个人手里的钱</span></span><br><span class="line">            account.money = account.money - drawingMoney;</span><br><span class="line">            <span class="comment">// 个人手里的钱</span></span><br><span class="line">            nowMoney = nowMoney + drawingMoney;</span><br><span class="line">            System.out.println(account.cardName + <span class="string">&quot;余额为:&quot;</span> + account.money);</span><br><span class="line">            <span class="comment">// this.getName()==Thread.currentThread().getName()</span></span><br><span class="line">            System.out.println(<span class="built_in">this</span>.getName() + <span class="string">&quot;手里的钱:&quot;</span> + nowMoney);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-死锁"><a href="#4-死锁" class="headerlink" title="4.死锁"></a>4.死锁</h4><ul>
<li>多个线程各自占有一些共享资源，并且互相等待其他线程占有的资源才能运行，而导致两个或者多个线程都在等待对方释放资源，都停止执行的情形。某一个同步块同时拥有“两个以上对象的锁”时，就可能会发生“死锁”的问题。</li>
</ul>
<blockquote>
<p>死锁:多个线程互相抱着对方需要的资源,然后形成僵持</p>
<p>解决:一个锁只锁一个对象</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Makeup</span> <span class="variable">makeup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Makeup</span>(<span class="number">0</span>, <span class="string">&quot;黄焖鸡&quot;</span>);</span><br><span class="line">        <span class="type">Makeup</span> <span class="variable">makeup1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Makeup</span>(<span class="number">1</span>, <span class="string">&quot;牛肉土豆粉&quot;</span>);</span><br><span class="line"></span><br><span class="line">        makeup.start();</span><br><span class="line">        makeup1.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 鸭脖</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DuckNeck</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 土豆粉</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PotatoPowder</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Makeup</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="comment">// 需要的资源只有一份,用static保证只有一份</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">DuckNeck</span> <span class="variable">duckneck</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DuckNeck</span>();</span><br><span class="line">    <span class="keyword">static</span> <span class="type">PotatoPowder</span> <span class="variable">potatoPowder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PotatoPowder</span>();</span><br><span class="line">    <span class="type">int</span> choice; <span class="comment">// 选择</span></span><br><span class="line">    String foodName;    <span class="comment">// 食品名称</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Makeup</span><span class="params">(<span class="type">int</span> choice, String foodName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.choice = choice;</span><br><span class="line">        <span class="built_in">this</span>.foodName = foodName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 美食</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            food();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">food</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line">        <span class="keyword">if</span>(choice == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (duckneck) &#123;    <span class="comment">// 获得鸭脖的锁</span></span><br><span class="line">                System.out.println(<span class="built_in">this</span>.foodName + <span class="string">&quot;获得鸭脖的锁&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (potatoPowder)&#123;    <span class="comment">// 一秒后想获得 土豆粉的锁</span></span><br><span class="line">                System.out.println(<span class="built_in">this</span>.foodName + <span class="string">&quot;获得土豆粉的锁&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (duckneck) &#123;    <span class="comment">// 获得鸭脖的锁</span></span><br><span class="line">                System.out.println(<span class="built_in">this</span>.foodName + <span class="string">&quot;获得鸭脖的锁&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (potatoPowder)&#123;    <span class="comment">// 一秒后想获得 土豆粉的锁</span></span><br><span class="line">                System.out.println(<span class="built_in">this</span>.foodName + <span class="string">&quot;获得土豆粉的锁&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>避免死锁的办法</p>
</blockquote>
<ul>
<li>产生死锁的四个必要条件<ul>
<li>1.互斥条件：一个资源毎次只能被一个进程使用。</li>
<li>2.请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li>
<li>3.不剥夺条件∶进程已获得的资源，在末使用完之前，不能强行剥夺。</li>
<li>4.循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。</li>
</ul>
</li>
<li>上面列出了死锁的四个必要条件，我们只要想办法破其中的任意一个或多个条件就可以避免死锁发生。</li>
</ul>
<h4 id="5、Lock（锁）"><a href="#5、Lock（锁）" class="headerlink" title="5、Lock（锁）"></a>5、Lock（锁）</h4><ul>
<li>从JDK 5.0开始, Java提供了更强大的线程同步机制一通过显式定义同步锁对象来实现同步。同步锁使用Lock对象充当。</li>
<li>java.util.concurrent.locks.Lock接口是控制多个线程对共享资源进行访问的工具。锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应先获得Lock对象。</li>
<li>ReentrantLock 类实现了 Lock，它拥有与 synchronized 相同的并发性和内存语义，在实现线程安全的控制中，比较常用的是ReentrantLock, 可以显式加锁、释放锁。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Reentrantlock lock <span class="keyword">new</span> <span class="title class_">Reen</span> TrantLock();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m</span><span class="params">()</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// 保证线程安全的代码</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span>&#123;</span><br><span class="line">            lock.unlock();	<span class="comment">// 如果同步代码有异常，要将unlock()写入finally语句块</span></span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h4 id="6-synchroized与Lock对比"><a href="#6-synchroized与Lock对比" class="headerlink" title="6.synchroized与Lock对比"></a>6.synchroized与Lock对比</h4><ul>
<li>Lock是显式锁 (手动开启和关闭锁，别忘记关闭锁) synchronized是隐式锁, 出了作用域自动释放。</li>
<li>Lock只有代码块锁, synchronized有代码块锁和方法锁。</li>
<li>使用Lock锁，JVM将花费较少的时间来调度线程, 性能更好。并且具有更好的扩展性 (提供更多的子类)。</li>
<li>优先使用顺序:<ul>
<li>Lock &gt; 同步代码块 (已经进入了方法体，分配了相应资源 $)&gt;$ 同步方法 (在方法体之外)</li>
</ul>
</li>
</ul>
<h3 id="4-线程通信问题"><a href="#4-线程通信问题" class="headerlink" title="4.线程通信问题"></a>4.线程通信问题</h3><ul>
<li>应用场景 : 生产者和消费者问题<ul>
<li>假设仓库中只能存放一件产品 , 生产者将生产出来的产品放入仓库，消费者将仓库中产品取走消费。</li>
<li>如果仓库中没有产品 , 则生产者将产品放入仓库，否则停止生产并等待，直到仓库中的产品被消费者取走为止。</li>
<li>如果仓库中放有产品 , 则消费者可以将产品取走消费，否则停止消费并等待，直到仓库中再次放入产品为止。</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-06/76a92767801a37f6cc81d492e28bb998--6b68--image-20241006152941896.png" alt="image-20241006152941896"></p>
<h4 id="1-线程通信方法"><a href="#1-线程通信方法" class="headerlink" title="1.线程通信方法"></a>1.线程通信方法</h4><ul>
<li>Java提供了几个方法解决线程之间的通信问题。</li>
</ul>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">wait()</td>
<td>表示线程一直等待，直到其他线程通知，与sleep不同会释放锁。</td>
</tr>
<tr>
<td align="center">wait(long timeout)</td>
<td>指定等待的毫秒数。</td>
</tr>
<tr>
<td align="center">notify()</td>
<td>唤醒一个处于等待状态的线程。</td>
</tr>
<tr>
<td align="center">notifyAll()</td>
<td>唤醒同一个对象上所有调用wait()方法的线程，优先级别高的线程优先调度。</td>
</tr>
</tbody></table>
<ul>
<li>注意：均是 Object类的方法，都只能在同步方法或者同步代码块中使用，否则会抛出异常IIIegalMonitorStateException。</li>
<li>这是一个线程同步问题，生产者和消费者共享同一个资源，并且生产者和消费者之间相互依赖，互为条件：<ul>
<li>对于生产者，没有生产产品之前，要通知消费者等待。而生产了产品之后，又需要马上通知消费者消费。</li>
<li>对于消费者，在消费之后，要通知生产者已经结束消费，需要生产新的产品以供消费。</li>
<li>在生产者消费者问题中，仅有 synchronized是不够的：<ul>
<li>synchronized可阻止并发更新同一个共享资源，实现了同步；</li>
<li>synchronized不能用来实现不同线程之间的消息传递通信。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-线程通信问题解决方式"><a href="#2-线程通信问题解决方式" class="headerlink" title="2.线程通信问题解决方式"></a>2.线程通信问题解决方式</h4><blockquote>
<p>解决方式一：</p>
<ul>
<li>并发协作模型“生产者&#x2F;消费者模式”–&gt;管程法：<ul>
<li>生产者∶负责生产数据的模块（可能是方法，对象，线程，进程）；</li>
<li>消费者：负责处理数据的模块（可能是方法，对象，线程，进程）；</li>
<li>缓冲区：消费者不能直接使用生产者的数据，他们之间有个“缓冲区”。</li>
</ul>
</li>
<li>生产者将生产好的数据放入缓冲区，消费者从缓冲区拿出数据。</li>
</ul>
</blockquote>
<h3 id="5-线程池"><a href="#5-线程池" class="headerlink" title="5.线程池"></a>5.线程池</h3><ul>
<li>背景：经常创建和销毁、使用量特别大的资源，比如并发情况下的线程，对性能影响很大。</li>
<li>思路：提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁、实现重复利用。类似生活中的公共交通工具。</li>
<li>好处：<ul>
<li>提高响应速度（减少了创建新线程的时间）；</li>
<li>降低资源消耗（重复利用线程池中线程，不需要毎次都创建）；</li>
<li>便于线程管理（…）<ul>
<li>corePoolsize：核心池的大小；</li>
<li>maximumPoolSize：最大线程数；</li>
<li>keepAliveTime：线程没有任务时最多保持多长时间后会终止。</li>
</ul>
</li>
</ul>
</li>
<li>JDK 5.0起提供了线程池相关AP:ExecutorService和 Executors。</li>
<li>ExecutorService：真正的线程池接口。常见子类 ThreadPoolExecutor。<ul>
<li>void execute（ Runnable command）：执行任务命令，没有返回值，一般用来执行 Runnable；</li>
<li><T> Future<T> submit（ Callable<T>妇ask）：执行任务，有返回值，一般又来执行Callable；</li>
<li>void shutdown（）：关闭连接池。</li>
</ul>
</li>
<li>Executors：工具类、线程池的工厂类，用于创建并返回不同类型的线程池。</li>
</ul>
<blockquote>
<p>多线程还得看JUC，后边也还会再记录的</p>
</blockquote>
<h2 id="注解与反射"><a href="#注解与反射" class="headerlink" title="注解与反射"></a>注解与反射</h2><p>注解使用的更多的是在后边的spring、springboot的框架中，会大量使用到各种注解。</p>
<h3 id="1、注解"><a href="#1、注解" class="headerlink" title="1、注解"></a>1、注解</h3><h4 id="1、注解入门"><a href="#1、注解入门" class="headerlink" title="1、注解入门"></a>1、注解入门</h4><ul>
<li><p>Annotation是jdk1.5开始引入的新技术。</p>
</li>
<li><p>Annotation的作用：</p>
<ul>
<li>不是程序本身，可以对程序作出解释；</li>
<li>可以被其他程序（例如编译器）读取。</li>
</ul>
</li>
<li><p>Annotation的格式</p>
<ul>
<li>“@注解名”，也可以带参数，例如：@SuppressWarnings(value&#x3D;“unchcked”)</li>
</ul>
</li>
<li><p>Annotation在哪里使用？</p>
<ul>
<li>可以附加在package、class、method、field上，相当于给它们添加了额外的辅助信息，还可以通过反射机制编程实现对这些元数据的访问。</li>
</ul>
</li>
</ul>
<h4 id="2-内置注解"><a href="#2-内置注解" class="headerlink" title="2.内置注解"></a>2.内置注解</h4><ul>
<li>@ Override：定义在 java. lang Override中，此注释只适用于修辞方法，表示一个方法声明打算重写超类中的另一个方法声明。</li>
<li>@ Deprecated：定义在 Java. lang. Deprecated中，此注释可以用于修辞方法，属性，类，表示不鼓励程序员使用这样的元素，通常是因为它很危险或者存在更好的选择。</li>
<li>@ SuppressWarnings：定义在 Java. lang. SuppressWarnings中，用来抑制编译时的警告信息。</li>
<li>与前两个注释有所不同，你需要添加一个参数才能正确使用，这些参数都是已经定义好了的，我们选择性的使用就好了。<ul>
<li>@SuppressWarnings （ “all”）</li>
<li>@SuppressWarnings （unchecked”）</li>
<li>@ SuppressWarnings（value&#x3D;f”unchecked”， “ deprecation “）</li>
<li>等等……</li>
</ul>
</li>
</ul>
<h4 id="3、自定义注解"><a href="#3、自定义注解" class="headerlink" title="3、自定义注解"></a>3、自定义注解</h4><ul>
<li>元注解的作用就是负责注解其他注解，Java定叉了4个标准的meta- annotation类型，他们被用来提供对其他 annotation类型作说明。</li>
<li>这些类型和它们所支持的类在 java. lang annotation包中可以找到。（@Target，@Retention，@Documented, @Inherited）<ul>
<li>@ Target：用于描述注解的使用范围（即被描述的注解可以用在什么地方）。</li>
<li>@ Retention：表示需要在什么级别保存该注释信息，用于描述注解的生命周期。<ul>
<li>SOURCE &lt; CLASS &lt; RUNTIME</li>
</ul>
</li>
<li>@ Document：说明该注解将被包含在 Javadoc中。</li>
<li>@ Inherited：说明子类可以继承父类中的该注解。</li>
</ul>
</li>
</ul>
<blockquote>
<p>自定义注解</p>
</blockquote>
<ul>
<li>使用@ interface自定义注解时，自动继承了 java. lang annotation. Annotation接口。</li>
<li>分析：<ul>
<li>@ interface用来声明一个注解，格式：public@ interface注解名{定义内容}</li>
<li>其中的每一个方法实际上是声明了一个配置参数；</li>
<li>方法的名称就是参数的名称。</li>
<li>返回值类型就是参数的类型（返回值只能是基本类型， Class, String,enum）</li>
<li>可以通过 defau来声明参数的默认值；</li>
<li>如果只有一个参数成员，一般参数名为vaue；</li>
<li>注解元素必须要有值，我们定义注解元素时，经常使用空字符串，0作为默认值</li>
</ul>
</li>
</ul>
<h3 id="2、反射机制"><a href="#2、反射机制" class="headerlink" title="2、反射机制"></a>2、反射机制</h3><h4 id="1-Java反射机制概念"><a href="#1-Java反射机制概念" class="headerlink" title="1.Java反射机制概念"></a>1.Java反射机制概念</h4><blockquote>
<ol>
<li>静态 &amp; 动态语言</li>
</ol>
</blockquote>
<ul>
<li>动态语言<ul>
<li>是一类在运行时可以改变其结构的语言：例如新的函数、对象、甚至代码可以被引进，已有的函数可以被删除或是其他结构上的变化。通俗点说就是在运行时代码可以根据某些条件改变自身结构。</li>
<li>主要动态语言：Object-C、C#、 JavaScript、PHP、 Python等。</li>
</ul>
</li>
<li>静态语言<ul>
<li>与动态语言相对应的，运行时结构不可变的语言就是静态语言。如Java、C、C++。</li>
<li>Java不是动态语言，但Java可以称之为“准动态语言”。即Java有一定的动态性我们可以利用反射机制获得类似动态语言的特性。Java的动态性让编程的时候更加灵活。</li>
</ul>
</li>
</ul>
<blockquote>
<ol start="2">
<li>反射机制概念</li>
</ol>
</blockquote>
<ul>
<li>Reflection（反射）是Java被视为动态语言的关键，反射机制允许程序在执行期借助于 Reflection AP取得仼何类的内部信息，并能直接操作任意对象的内部属性及方法。<ul>
<li>Class c&#x3D; Class.forName(“java. lang String”);</li>
</ul>
</li>
<li>加载完类之后，在堆內存的方法区中就产生了一个 Class类型的对象（一个类只有一个Cass对象），这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构，所以，我们形象的称之为：反射。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-06/35703c4b7c062b664191ec914bbb765c--ee70--image-20241006201713560.png" alt="image-20241006201713560"></p>
<blockquote>
<ol start="3">
<li>反射机制研究与应用</li>
</ol>
</blockquote>
<ul>
<li>Java反射机制提供的功能<ul>
<li>在运行时判断任意一个对象所属的类；</li>
<li>在运行时构造任意一个类的对象；</li>
<li>在运行时判断任意一个类所具有的成员变量和方法；</li>
<li>在运行时获取泛型信息；</li>
<li>在运行时调用任意一个对象的成员变量和方法；</li>
<li>在运行时处理注解；</li>
<li>生成动态代理；</li>
<li>……</li>
</ul>
</li>
</ul>
<blockquote>
<ol start="4">
<li>反射机制优缺点</li>
</ol>
</blockquote>
<ul>
<li>优点：<ul>
<li>可以实现动态创建对象和编译，体现出很大的灵活性。</li>
</ul>
</li>
<li>缺点<ul>
<li>对性能有影响。使用反射基本上是一种解释操作，我们可以告诉JVM，我们希望做什么并且它满足我们的要求。这类操作总是慢于直接执行相同的操作。</li>
</ul>
</li>
</ul>
<blockquote>
<p>&#x2F;*<br>        一个类在内存中只有一个Class对象<br>        一个类被加载后,类的整个结构都会被封装在Class对象中<br>        public native int hashCode();返回该对象的hash码值<br>        注：哈希值是根据哈希算法算出来的一个值，这个值跟地址值有关，但不是实际地址值。<br>         *&#x2F;</p>
</blockquote>
<h4 id="2-理解Class类并获取Class实例"><a href="#2-理解Class类并获取Class实例" class="headerlink" title="2.理解Class类并获取Class实例"></a>2.理解Class类并获取Class实例</h4><blockquote>
<ol>
<li>class类介绍</li>
</ol>
</blockquote>
<ul>
<li>在 Object类中定义了以下的方法，此方法将被所有子类继承<ul>
<li>public final Class getclass()</li>
</ul>
</li>
<li>以上的方法返回值的类型是一个 Class类，此类是Java反射的源头，实际上所谓反射从程序的运行结果来看也很好理解，即：可以通过对象反射求出类的名称。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-06/be9b8c63ed6e11166c584df0ec7d46bd--d62e--image-20241006203510092.png" alt="image-20241006203510092"></p>
<ul>
<li><p>对象照镜子后可以得到的信息：某个类的属性、方法和构造器、某个类到底实现了哪些接口对于每个类而言，JRE都为其保留一个不变的Cass类型的对象。一个Class对象包含了特定某个结构（ class&#x2F;interface&#x2F;enum&#x2F;annotation&#x2F; primitive type&#x2F;void&#x2F;[]）的有关信息。</p>
<ul>
<li>Class本身也是一个类；</li>
<li>Class对象只能由系统建立对象；</li>
<li>一个加载的类在JVM中只会有一个Class实例；</li>
<li>一个Cass对象对应的是一个加载到JM中的一个class文件；</li>
<li>每个类的实例都会记得自己是由哪个Class实例所生成；</li>
<li>通过class可以完整地得到一个类中的所有被加载的结构；</li>
<li>class类是 Reflection的根源，针对任何你想动态加载、运行的类，唯有先获得相应的Class对象。</li>
</ul>
</li>
<li><p>class类的常用方法</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>方法名</th>
<th>功能说明</th>
</tr>
</thead>
<tbody><tr>
<td>static ClassforName (String name)</td>
<td>返回指定类名name的class对象</td>
</tr>
<tr>
<td>Object newInstance ()</td>
<td>调用缺省构造函数，返回 Class对象的一个实例</td>
</tr>
<tr>
<td>getName ()</td>
<td>返回此Class对象所表示的实体（类，接口，数组类或void）的名称。</td>
</tr>
<tr>
<td>Class getSuperClass ()</td>
<td>返回当前class对象的父类的class对象</td>
</tr>
<tr>
<td>Class[] getinterfaces ()</td>
<td>获取当前 Class对象的接口</td>
</tr>
<tr>
<td>ClassLoader getclassLoader ()</td>
<td>返回该类的类加载器</td>
</tr>
<tr>
<td>Constructor getConstructors ()</td>
<td>返回一个包含某些 Constructor对象的数组</td>
</tr>
<tr>
<td>Method getMothed (String name, Class…T)</td>
<td>返回一个 Method对象，此对象的形参类型为paramType</td>
</tr>
<tr>
<td>Field[] getDeclaredFields ()</td>
<td>返回Field对象的一个数组</td>
</tr>
</tbody></table>
<blockquote>
<ol start="2">
<li>获取Class类的实例</li>
</ol>
</blockquote>
<ul>
<li>若已知具体的类，通过类的class属性获取，该方法最为安全可靠，程序性能最高。<ul>
<li>Class clazz&#x3D;Person.class;</li>
</ul>
</li>
<li>已知某个类的实例，调用该实例的 getclass () 方法获取Class对象。<ul>
<li>Class clazz&#x3D; person. getClass();</li>
</ul>
</li>
<li>已知一个类的全类名，且该类在类路径下，可通过class类的静态方法 forName（获取，可能抛出 ClassNotFound Exception。<ul>
<li>Class clazz Class forName（”demo01 Student”);</li>
</ul>
</li>
<li>内置基本数据类型可以直接用类名.Type。</li>
<li>还可以利用 Classloader。</li>
</ul>
<blockquote>
<ol start="3">
<li>哪些类型可以有Class对象</li>
</ol>
</blockquote>
<ul>
<li>class：外部类，成员（成员内部类，静态内部类），局部内部类，匿名内部类。</li>
<li>interface：接口</li>
<li>[]：数组</li>
<li>enum：枚举</li>
<li>annotation：注解@interface </li>
<li>primitive type：基本数据类型</li>
<li>void</li>
</ul>
<h4 id="3-类的加载与ClassLoader"><a href="#3-类的加载与ClassLoader" class="headerlink" title="3.类的加载与ClassLoader"></a>3.类的加载与ClassLoader</h4><blockquote>
<ol>
<li>Java内存分析</li>
</ol>
</blockquote>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-06/9738ef9679770afe7f810b8b1ec303a3--f08b--image-20241006203545571.png" alt="image-20241006203545571"></p>
<blockquote>
<ol start="2">
<li>类的加载</li>
</ol>
</blockquote>
<ul>
<li>当程序主动使用某个类时，如果该类还未被加载到内存中，则系统会通过如下三个步骤来对该类进行初始化。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-06/248f7b6bdbcc58f556d8a006ec4fd36b--6c52--image-20241006203555990.png" alt="image-20241006203555990"></p>
<ul>
<li>加载：将 class文件字节码內容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后生成一个代表这个类的 java. lang . Class对象。</li>
<li>链接：将Java类的二进制代码合并到JVM的运行状态之中的过程。<ul>
<li>验证：确保加载的类信息符合JVM规范，没有安全方面的问题。</li>
<li>准备：正式为类变量（ static）分配内存并设置类变量默认初始值的阶段，这些内存都将在方法区中进行分配。</li>
<li>解析：虚拟机常量池内的符号引用（常量名）替换为直接引用（地址）的过程。</li>
</ul>
</li>
<li>初始化：<ul>
<li>执行类构造器&lt; clinit&gt;方法的过程。类构造器&lt; clinit&gt;方法是由编译期自动收集类中所有类变量的赋值动作和静态代码块中的语句合并产生的。（类构造器是构造类信息的，不是构造该类对象的构造器）。</li>
<li>当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化。</li>
<li>虛拟机会保证一个类的&lt; clinit &gt;()方法在多线程环境中被正确加锁和同步。</li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_38075425/article/details/81627349">深刻理解类加载</a></li>
</ul>
<blockquote>
<ol start="3">
<li>什么时候会发生类初始化</li>
</ol>
</blockquote>
<ul>
<li>类的主动引用（一定会发生类的初始化）<ul>
<li>当虚拟机启动，先初始化main方法所在的类；</li>
<li>new一个类的对象；</li>
<li>调用类的静态成员（除了fina常量）和静态方法；</li>
<li>使用 java. lang. reflect包的方法对类进行反射调用；</li>
<li>当初始化一个类，如果其父类没有被初始化，则先会初始化它的父类。</li>
</ul>
</li>
<li>类的被动引用（不会发生类的初始化）<ul>
<li>当访问一个静态域时，只有真正声明这个域的类才会被初始化。如：当通过子类引用父类的静态变量，不会导致子类初始化；</li>
<li>通过数组定义类引用，不会触发此类的初始化；</li>
<li>引用常量不会触发此类的初始化（常量在链接阶段就存入调用类的常量池中了）。</li>
</ul>
</li>
</ul>
<blockquote>
<ol start="4">
<li>类加载器的作用</li>
</ol>
</blockquote>
<ul>
<li>类加载的作用：将 class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后在堆中生成一个代表这个类的 java. lang Class对象，作为方法区中类数据的访问入口。</li>
<li>类缓存：标准的 JavaSE类加载器可以按要求查找类，但一旦某个类被加载到类加载器中，它将维持加载（缓存）一段时间。不过JVM垃圾回收机制可以回收这些 Class对象</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-06/9281b634c599b8c2edfac30cb2009a79--e49a--image-20241006203627642.png" alt="image-20241006203627642"></p>
<ul>
<li>类加载器作用是用来把类（αlass）装载进内存的。JVM规范定义了如下类型的类的加载器。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-06/69b06ba5feeee963329165f6c7e8fae8--1373--image-20241006203652024.png" alt="image-20241006203652024"></p>
<ul>
<li>ClassLoader systemClassLoader &#x3D; ClassLoader.getSystemClassLoader();&#x2F;&#x2F;获取系统类的加载器</li>
<li>ClassLoader parent &#x3D; systemClassLoader.getParent();&#x2F;&#x2F;获取系统类加载器的父类加载器–&gt;扩展类加载器 jre1.8.0_91\lib\ext</li>
<li>ClassLoader parent1 &#x3D; parent.getParent();&#x2F;&#x2F;获取扩展类加载器父类加载器–&gt;根加载器(c&#x2F;c++) jre1.8.0_91\lib\rt.jar</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">// 获取系统类的加载器</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">systemClassLoader</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader();</span><br><span class="line">        System.out.println(systemClassLoader);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获得系统类加载器的父类加载器 ---&gt; 扩展类加载器   jre1.8.0_91\lib\ext</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">parent</span> <span class="operator">=</span> systemClassLoader.getParent();</span><br><span class="line">        System.out.println(parent);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取扩展类加载器的父类加载器  --&gt;  根加载器（C/c++）jre1.8.0_91\lib\rt.jar</span></span><br><span class="line">        <span class="comment">// 返回null是正常的，表示为根加载器</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">parent1</span> <span class="operator">=</span> parent.getParent();</span><br><span class="line">        System.out.println(parent1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试当前类是哪个加载器去加载的</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classDemo1</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;ClassDemo1&quot;</span>).getClassLoader();</span><br><span class="line">        System.out.println(classDemo1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试JDK内置的类是什么加载器加载的</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.String&quot;</span>).getClassLoader();</span><br><span class="line">        System.out.println(classLoader);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得系统类加载器可以加载的路径</span></span><br><span class="line">        System.out.println(System.getProperty(<span class="string">&quot;java.class.path&quot;</span>));</span><br><span class="line">        <span class="comment">//C:\Program Files\Java\jdk1.8.0_202\jre\lib\charsets.jar;C:\Program Files\Java\jdk1.8.0_202\jre\lib\deploy.jar;C:\Program Files\Java\jdk1.8.0_202\jre\lib\ext\access-bridge-64.jar;C:\Program Files\Java\jdk1.8.0_202\jre\lib\ext\cldrdata.jar;C:\Program Files\Java\jdk1.8.0_202\jre\lib\ext\dnsns.jar;C:\Program Files\Java\jdk1.8.0_202\jre\lib\ext\jaccess.jar;C:\Program Files\Java\jdk1.8.0_202\jre\lib\ext\jfxrt.jar;C:\Program Files\Java\jdk1.8.0_202\jre\lib\ext\localedata.jar;C:\Program Files\Java\jdk1.8.0_202\jre\lib\ext\nashorn.jar;C:\Program Files\Java\jdk1.8.0_202\jre\lib\ext\sunec.jar;C:\Program Files\Java\jdk1.8.0_202\jre\lib\ext\sunjce_provider.jar;C:\Program Files\Java\jdk1.8.0_202\jre\lib\ext\sunmscapi.jar;C:\Program Files\Java\jdk1.8.0_202\jre\lib\ext\sunpkcs11.jar;C:\Program Files\Java\jdk1.8.0_202\jre\lib\ext\zipfs.jar;C:\Program Files\Java\jdk1.8.0_202\jre\lib\javaws.jar;C:\Program Files\Java\jdk1.8.0_202\jre\lib\jce.jar;C:\Program Files\Java\jdk1.8.0_202\jre\lib\jfr.jar;C:\Program Files\Java\jdk1.8.0_202\jre\lib\jfxswt.jar;C:\Program Files\Java\jdk1.8.0_202\jre\lib\jsse.jar;C:\Program Files\Java\jdk1.8.0_202\jre\lib\management-agent.jar;C:\Program Files\Java\jdk1.8.0_202\jre\lib\plugin.jar;C:\Program Files\Java\jdk1.8.0_202\jre\lib\resources.jar;C:\Program Files\Java\jdk1.8.0_202\jre\lib\rt.jar;E:\JavaWeb\JVMDemo\out\production\JVMDemo;C:\Program Files\JetBrains\IntelliJ IDEA 2024.2.0.2\lib\idea_rt.jar</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="4-获取运行类的完整结构"><a href="#4-获取运行类的完整结构" class="headerlink" title="4.获取运行类的完整结构"></a>4.获取运行类的完整结构</h4><ul>
<li><p>通过反射获取运行时类的完整结构</p>
</li>
<li><p>Field、 Method、 Constructor.、 Superclass、 Interface、 Annotation</p>
</li>
<li><p>实现的全部接口</p>
</li>
<li><p>所继承的父类</p>
</li>
<li><p>全部的构造器</p>
</li>
<li><p>全部的方法</p>
</li>
<li><p>全部的Feld</p>
</li>
<li><p>注解</p>
</li>
<li><p>……</p>
</li>
<li><p>在实际的操作中，取得类的信息的操作代码，并不会经常开发。</p>
</li>
<li><p>一定要熟悉 java. lang .reflect包的作用，反射机制。</p>
</li>
<li><p>如何取得属性、方法、构造器的名称，修饰符等。</p>
</li>
</ul>
<h4 id="5-调用运行时类的指定结构"><a href="#5-调用运行时类的指定结构" class="headerlink" title="5.调用运行时类的指定结构"></a>5.调用运行时类的指定结构</h4><blockquote>
<ol>
<li>有Class对象,能做什么</li>
</ol>
</blockquote>
<ul>
<li>创建类的对象：调用 Class对象的 newInstance()方法<ul>
<li>1）类必须有一个无参数的构造器。</li>
<li>2）类的构造器的访问权限需要足够。</li>
</ul>
</li>
<li>思考？难道没有无参的构造器就不能创建对象了吗？只要在操作的时候明确的调用类中的构造器，并将参数传递进去之后，才可以实例化操作。</li>
<li>步骤如下：<ul>
<li>1）通过class类的 getDeclaredConstructor（ Class…， parameterTypes）取得本类的指定形参类型的构造器；</li>
<li>2）向构造器的形参中传递一个对象数组进去，里面包含了构造器中所需的各个参数。</li>
<li>3）通过 Constructo实例化对象</li>
</ul>
</li>
</ul>
<blockquote>
<p>2、方法及使用</p>
</blockquote>
<p>通过反射，调用类中的方法，通过 Method类完成。</p>
<ul>
<li>①通过Cas类的 getMethod（ String name, Class… parameterTypes）方法取得一个 Method对象，并设置此方法操作时所需要的参数类型。</li>
<li>②之后使用 Object invoke（ Object obj，Object[] args）进行调用，并向方法中传递要设置的ob对象的参数信息。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-07/7034533d6df0a76a9e47b90fe40965ff--d64e--image-20241007131846399.png" alt="image-20241007131846399"></p>
<blockquote>
<p>调用指定的方法：</p>
</blockquote>
<ul>
<li>Object invoke（object obj, Object. args）</li>
<li>Object对应原方法的返回值，若原方法无返回值，此时返回null；</li>
<li>若原方法若为静态方法，此时形参 Object obj可为null；</li>
<li>若原方法形参列表为空，则 Object[] args为null；</li>
<li>若原方法声明为 private，则需要在调用此 invoke（）方法前，显式调用方法对象的setAccessible（true）方法，将可访问 private的方法。</li>
</ul>
<blockquote>
<p>setAccessible </p>
</blockquote>
<ul>
<li>Method和 Field、 Constructor对象都有 setAccessible()方法。</li>
<li>setAccessible作用是启动和禁用访问安全检查的开关。</li>
<li>参数值为true则指示反射的对象在使用时应该取消Java语言访问检査。<ul>
<li>提高反射的效率。如果代码中必须用反射，而该句代码需要频繁的被调用，那么请设置为true；</li>
<li>使得原本无法访问的私有成员也可以访问；</li>
</ul>
</li>
<li>参数值为false则指示反射的对象应该实施Java语言访问检查。</li>
</ul>
<blockquote>
<ol start="3">
<li>性能检测</li>
</ol>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">经过反复测试得出结论：普通方式执行效率 &gt; 反射关闭检测方式执行效率 &gt; 反射方式执行效率</span><br></pre></td></tr></table></figure>

<h4 id="6-反射操作泛型"><a href="#6-反射操作泛型" class="headerlink" title="6.反射操作泛型"></a>6.反射操作泛型</h4><ul>
<li>Java采用泛型擦除的机制来引入泛型，Java中的泛型仅仅是给编译器javac使用的，确保数据的安全性和免去强制类型转换问题，但是，一旦编译完成，所有和泛型有关的类型全部擦除。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">泛型：</span><br><span class="line">Java 中的泛型仅仅是给编译器 javac 使用的，确保数据的 安全性和免去强制类型转换的麻烦，但是一旦编译完成，所 有与泛型有关的类型全部擦除。</span><br><span class="line">使用泛型直接读取泛型，是读取不到的，因为反射是操作 加载以后的类的。</span><br><span class="line">Java 新增的数据类型：</span><br><span class="line">为了通过反射操作这些类型以迎合实际开发的需要</span><br><span class="line">1) ParameterizedType： 表 示 一 种 参 数 化 的 类 型 ,比 如Collection&lt;String&gt;,可以获取 String 信息</span><br><span class="line">2) GenericArrayType：泛型数组类型</span><br><span class="line">3) TypeVariable：各种类型变量的公共父接口</span><br><span class="line">4) WildcardType：代表一种通配符类型表达式， 比如? extends Number,? super Integer (Wildcard 是一个单词，就是通配符)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">那么泛型是什么？？？</span><br><span class="line"></span><br><span class="line">泛型 ，顾名思义就是 广泛的数据类型，也就是说什么数据类型都可以。</span><br><span class="line">一般来说，我们见到的泛型就是这个样子，用 T 表示。</span><br><span class="line">如下所示，在类名后方申明泛型 T，接着就可以在成员变量、方法中使用泛型了。</span><br></pre></td></tr></table></figure>

<h4 id="7-反射操作注解"><a href="#7-反射操作注解" class="headerlink" title="7.反射操作注解"></a>7.反射操作注解</h4><ul>
<li>getAnnotations </li>
<li>getAnntation</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-07/50328b5e689195ee970a7c76472b1ada--b0a1--image-20241007134552563.png"></p>
<h2 id="JAVA-SE总结"><a href="#JAVA-SE总结" class="headerlink" title="JAVA SE总结"></a>JAVA SE总结</h2><p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-07/fd06ebf085a98d84cd36f4775d52280d--5015--Java%20SE.png" alt="Java SE"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://6pc1.github.io/2024/09/29/JVM%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="6pc1">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="6pc1's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 6pc1's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/09/29/JVM%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">JVM学习</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-09-29 14:42:54" itemprop="dateCreated datePublished" datetime="2024-09-29T14:42:54+08:00">2024-09-29</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-10-02 16:44:01" itemprop="dateModified" datetime="2024-10-02T16:44:01+08:00">2024-10-02</time>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2024/09/29/JVM%E5%AD%A6%E4%B9%A0/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2024/09/29/JVM%E5%AD%A6%E4%B9%A0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>6.4k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>6 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="一、JVM的学习方式"><a href="#一、JVM的学习方式" class="headerlink" title="一、JVM的学习方式"></a>一、JVM的学习方式</h1><ul>
<li>请你谈谈你对JVM的理解？java8虚拟机和之前的变化更新？</li>
<li>什么是OOM？什么是栈溢出？怎么分析？</li>
<li>JVM的常用调优参数有哪些？</li>
<li>内存快照如何抓取，怎么分析Dump文件？</li>
<li>谈谈JVM中，类加载器的认识？</li>
</ul>
<ol>
<li>JVM的位置</li>
<li>JVM的体系结构</li>
<li>类加载器</li>
<li>双亲委派机制</li>
<li>沙箱安全机制</li>
<li>Native</li>
<li>PC寄存器</li>
<li>方法区</li>
<li>栈</li>
<li>三种JVM</li>
<li>堆</li>
<li>新生区、老年区</li>
<li>永久区</li>
<li>堆内存调优</li>
<li>GC<ol>
<li>常用算法</li>
</ol>
</li>
<li>JMM</li>
<li>总结</li>
</ol>
<h1 id="二、JVM的体系结构"><a href="#二、JVM的体系结构" class="headerlink" title="二、JVM的体系结构"></a>二、JVM的体系结构</h1><p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-01/15f08b83cc36ebf5ba8c33bb4ca72c5c--fe5c--image-20241001184024276.png" alt="image-20241001184024276"></p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-01/2849f9431c9f35342055f25d9f9b4a7e--7c8c--image-20241001190719023.png" alt="image-20241001190719023"></p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-01/d1c23d6bb7bb20a3555f7a846826726f--6967--image-20241001190723436.png" alt="image-20241001190723436"></p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-01/360e596935f9e9d5556a8af031f0b6a0--ae8f--image-20241001190940381.png" alt="image-20241001190940381"></p>
<h1 id="三、类加载器及双亲委派机制"><a href="#三、类加载器及双亲委派机制" class="headerlink" title="三、类加载器及双亲委派机制"></a>三、类加载器及双亲委派机制</h1><p>作用：加载Class文件 </p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-01/8c000f95eebb45566d18867ed7a0aac3--536f--image-20241001191035701.png" alt="image-20241001191035701"></p>
<ol>
<li>虚拟机自带的加载器</li>
<li>启动类（根）加载器（<strong>BootstrapClassLoader</strong>）</li>
<li>扩展类加载器（<strong>ExtClassLoader</strong>）</li>
<li>应用程序（系统类）加载器（<strong>AppClassLoader</strong>）</li>
</ol>
<h1 id="四、Java历史-沙箱安全机制"><a href="#四、Java历史-沙箱安全机制" class="headerlink" title="四、Java历史-沙箱安全机制"></a>四、Java历史-沙箱安全机制</h1><p>java安全模型的核心就是java沙箱（sandbox）</p>
<blockquote>
<p>什么是沙箱?</p>
</blockquote>
<p>沙箱是一个限制程序运行的环境。</p>
<p>沙箱机制就是将java代码限定在虚拟机（JVM）特定的运行范围中，并且严格限制代码对本地系统资源的访问，通过这样的措施来保证对代码的有效隔离。防止对本地系统造成破坏。沙箱主要限制系统资源访问。</p>
<p>那系统资源包括什么？CPU、内存、文件系统、网络。不同级别的沙箱对这些资源访问的限制也不一样。</p>
<p>所有的java程序运行都可以指定沙箱，可以指定安全策略。</p>
<p>在java中将执行程序分成本地代码和远程代码两种，本地代码默认视为可信任的，而远程代码则被看作是不受信受信的。对于受信的本地代码，可以访问一切本地资源。而对于非受信的远程代码在早期的java实现中，安全依赖于沙箱机制。如下图所示 JDK1.0安全模型</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-02/b51342000f3683e90e3adf0e43c07bf2--9d4e--image-20241002123848724.png" alt="image-20241002123848724"></p>
<p>但是如此严格的安全机制也给程序的功能扩展带来障碍，比如当用户希望远程代码访问本地系统的文件时候，就无法实现。因此在后续的java1.1版本中，针对安全机制做了改进，增加了<strong>安全策略</strong>，允许用户指定代码对本地资源的访问权限，如下图所示JDK1.1安全模型</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-02/6a27a87f70d3c0cceab5d63de4c051e4--0658--image-20241002123904705.png" alt="image-20241002123904705"></p>
<p>在java1.2版本中，再次改进了安全机制，增加了<strong>代码签名</strong>，不论本地代码或者远程代码，都会按照用户的安全策略设定，由类加载器加载到虚拟机中权限不同的运行空间，来实现差异化的代码执行权限控制。如下图所示JDK1.2安全模型</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-02/ed4b55839bb408766121dea1a8bc1104--2a5a--image-20241002123934033.png" alt="image-20241002123934033"></p>
<p> 当前最新的安全机制实现，则引入了<strong>域（Domain）</strong>的概念。虚拟机会把所有代码加载到不同的系统域和应用域，系统域部分专门负责与关键资源进行交互，而各个应用域部分则通过系统域的部分代理来对各种需要的资源进行访问。虚拟机中不同的受保护域（Protected Domain），对应不一样的权限（Permission）。存在于不同域中的类文件，就具有当前域的全部权限，如下图所示，最新的安全模型（jdk1.6）</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-02/1edf21e9019ca08ebfecc32ee4c7e420--39e0--image-20241002123956626.png" alt="image-20241002123956626"></p>
<p>组成沙箱的基本组件</p>
<ul>
<li>字节码校验器（bytecode verifier）：确保Java类文件遵循Java语言规范。这样可以帮助Java程序实现内存保护。但并不是所有的类文件都会经过字节码校验，比如核心类。</li>
<li>类装载器（class loader）：其中类装载器在3个方面对Java沙箱起作用<ul>
<li>它防止恶意代码去干涉善意的代码；（双亲委派机制）</li>
<li>它守护了被信任的类库边界；</li>
<li>它将代码归入保护域，确定了代码可以进行哪些操作。</li>
</ul>
</li>
</ul>
<p>虚拟机为不同的类加载器载入的类提供不同的命名空间，命名空间由一系列唯一的名称组成，每一个被装载的类将有一个名字，这个命名空间是由Java虚拟机为每一个类装载器维护的，它们互相之间甚至不可见。</p>
<p>类装载器采用的机制是双亲委派模式。</p>
<ol>
<li>从最内层JVM自带类加载器开始加载，外层恶意同名类得不到加载从而无法使用；</li>
<li>由于严格通过包来区分了访问域，外层恶意的类通过内置代码也无法获得权限访问到内层类，破坏代码就自然无法生效。</li>
</ol>
<ul>
<li>存取控制器（access controller）：存取控制器可以控制核心API对操作系统的存取权限，而这个控制的策略设定，可以由用户指定。</li>
<li>安全管理器（security manager）：是核心API和操作系统之间的主要接口。实现权限控制，比存取控制器优先级高。</li>
<li>安全软件包（security package）：java.security下的类和扩展包下的类，允许用户为自己的应用增加新的安全特性，包括：<ul>
<li>安全提供者</li>
<li>消息摘要</li>
<li>数字签名（keytools）</li>
<li>加密</li>
<li>鉴别</li>
</ul>
</li>
</ul>
<h1 id="五、Native方法区"><a href="#五、Native方法区" class="headerlink" title="五、Native方法区"></a>五、Native方法区</h1><h1 id=""><a href="#" class="headerlink" title=""></a></h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * native :凡是带了native关键字的，说明java的作用范围达不到了，会去调用底层C语言的库！</span></span><br><span class="line"><span class="comment">     * 会进入本地方法栈</span></span><br><span class="line"><span class="comment">     * 调用本地方法接口！ JNI</span></span><br><span class="line"><span class="comment">     * JNI作用：扩展java的使用，融合不同的编程语言为java所用！最初：C、C++</span></span><br><span class="line"><span class="comment">     * java诞生的时候 C、C++横行，想要立足，必须要有调用C、C++的程序</span></span><br><span class="line"><span class="comment">     * 他在内存区域中专门开辟了一块标记区域：Native Method Stace，登记native方法</span></span><br><span class="line"><span class="comment">     * 在最终执行的时候，加载本地方法库中的方法，通过JNI</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//java程序驱动打印机，管理系统。掌握即可，在企业级应用中较为少见！</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">start0</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>PC寄存器</strong></p>
<p>程序计数器：program counter register</p>
<p>每个线程都有一个程序计数器，是线程私有的，就是一个指针，指向方法区中的方法字节码（用来存储指向一条执行的地址，也即将要执行的指令代码），在执行引擎读取下一条指令，是一个非常小的内存空间，几乎可以忽略不计</p>
<p><strong>方法区</strong></p>
<p>Method Area 方法区</p>
<p><strong>方法区是被所有线程共享</strong>，所有字段和方法字节码，以及一些特殊方法，如构造函数，接口代码也在此定义，简单说，所有定义的方法的信息都保存在该区域，<strong>此区域属于共享空间</strong></p>
<p><strong>静态变量，常量，类信息（构造方法，接口定义），运行时的常量池存在方法区中，但是实例变量存在堆内存中，和方法区无关</strong></p>
<h1 id="六、深入理解一下栈"><a href="#六、深入理解一下栈" class="headerlink" title="六、深入理解一下栈"></a>六、深入理解一下栈</h1><p><strong>栈：数据结构</strong></p>
<p><strong>栈：先进后出 、后进先出  （桶）</strong></p>
<p><strong>队列：先进先出（FIFO: first input first output）</strong></p>
<p>为什么main()方法先执行，最后结束！</p>
<p>栈：栈内存，主管程序的运行，生命周期和线程同步</p>
<p>线程结束，栈内存也就是释放，对于栈来说，<strong>不存在垃圾回收问题</strong></p>
<p>一旦线程结束，栈就over</p>
<p><strong>栈中可以存什么：</strong></p>
<ul>
<li>8大基本类型<ul>
<li>boolean</li>
<li>byte</li>
<li>char</li>
<li>short</li>
<li>int</li>
<li>long</li>
<li>float</li>
<li>double</li>
</ul>
</li>
<li>对象引用<ul>
<li>reference类型</li>
</ul>
</li>
<li>实例的方法</li>
</ul>
<p>栈运行原理：栈帧</p>
<p>栈满了会抛出:StackOverflowError</p>
<p>栈 + 堆 + 方法区 交互关系</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-02/5ad85f47f558bc9fc5ab633e705a9cb5--6a15--image-20241002124557784.png" alt="image-20241002124557784"></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/102316535">JVM虚拟机栈执行原理深入详解 - 知乎 (zhihu.com)</a></p>
<h1 id="七、走进HotSpot和堆"><a href="#七、走进HotSpot和堆" class="headerlink" title="七、走进HotSpot和堆"></a>七、走进HotSpot和堆</h1><p>三种JVM</p>
<ul>
<li>sun公司的 <strong>HotSpot</strong></li>
<li>BEA <strong>JRockit</strong></li>
<li>IBM <strong>J9 VM</strong></li>
</ul>
<p>我们学习的都是：HotSpot</p>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>Heap，一个JVM只有一个堆内存，堆内存的大小是可以调节的。</p>
<p>类加载器读取了类文件后，一般会把什么东西放到堆中? 类，方法，常量，变量~  保存我们所有引用类型的真实对象</p>
<p>堆内存中还要细分为三个区域：</p>
<ul>
<li>新生区（伊甸园区） Young&#x2F;New</li>
<li>养老区 Old</li>
<li>永久区 Perm</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-02/6b89aa39d8346bafa121bf1eeed1f66c--3716--image-20241002135759659.png" alt="image-20241002135759659"></p>
<p>GC垃圾回收，主要是在伊甸园区和养老区~</p>
<p>加入内存满了，OOM，堆内存不够! java.lang.OutOfMemoryError:java heap space</p>
<p>在JDK1.8以后，永久区改了一个名字~<strong>元空间</strong></p>
<h1 id="八、新生区、永久区、堆内存调优"><a href="#八、新生区、永久区、堆内存调优" class="headerlink" title="八、新生区、永久区、堆内存调优"></a>八、新生区、永久区、堆内存调优</h1><h2 id="新生区"><a href="#新生区" class="headerlink" title="新生区"></a>新生区</h2><ul>
<li>类：诞生和成长的地方，设置死亡！</li>
<li>伊甸园，所有的对象都是在伊甸园区new出来的</li>
<li>幸存者区（0,1）</li>
</ul>
<p>现象：经过研究，99%的对象都是临时对象！</p>
<h2 id="老年区"><a href="#老年区" class="headerlink" title="老年区"></a>老年区</h2><h2 id="永久区"><a href="#永久区" class="headerlink" title="永久区"></a>永久区</h2><p>这个区域常驻内存的，用来存放JDK自身携带的Class对象，Interface元数据，<strong>存储的是java运行时的一些环境或者类信息，这个区域不存在垃圾回收！关闭VM虚拟机就会释放这个区域的内存~</strong></p>
<p><strong>一个启动类，加载了大量的第三方jar包。tomcat部署了太多的应用，大量动态生成的反射类，不断的被加载。直到内存满了，就会出现OOM</strong></p>
<ul>
<li>jdk1.6之前：永久代，<strong>常量池在方法区</strong></li>
<li>jdk1.7:永久代，但是慢慢的退化了，去永久代，<strong>常量池在堆中</strong></li>
<li>jdk1.8之后：无永久代，<strong>常量池在元空间</strong></li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-02/d1abd1837ffaaff91149fd72a3b2fe45--f6ea--image-20241002140740183.png" alt="image-20241002140740183"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JVMDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//虚拟机试图使用的最大内存</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">maxMemory</span> <span class="operator">=</span> Runtime.getRuntime().maxMemory();</span><br><span class="line">        <span class="comment">//虚拟机的初始化总内存</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">totalMemory</span> <span class="operator">=</span> Runtime.getRuntime().totalMemory();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;maxMemory:&quot;</span> + maxMemory + <span class="string">&quot;字节\t&quot;</span> + (maxMemory / (<span class="type">double</span>) <span class="number">1024</span> / <span class="number">1024</span>) + <span class="string">&quot;MB&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;totalMemory:&quot;</span> + maxMemory + <span class="string">&quot;字节\t&quot;</span> + (totalMemory / (<span class="type">double</span>) <span class="number">1024</span> / <span class="number">1024</span>) + <span class="string">&quot;MB&quot;</span>);</span><br><span class="line">        <span class="comment">//默认情况下，分配的最大内存是电脑内存的1/4 而初始化的内存是 1/64</span></span><br><span class="line">        <span class="comment">//-Xms1024m -Xmx1024m -XX:+PrintGCDetails</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * OOM：</span></span><br><span class="line"><span class="comment">         *   1. 尝试扩大堆内存看结果</span></span><br><span class="line"><span class="comment">         *   2. 分析内存，看一下哪个地方出现了问题（专业工具）</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">maxMemory:4211081216字节	4016.0MB</span><br><span class="line">totalMemory:4211081216字节	252.0MB</span><br></pre></td></tr></table></figure>

<p>元空间：逻辑上存在，物理上不存在</p>
<p>idea设置JVM堆内存大小</p>
<p>这里要注意新版idea是默认隐藏vm option的</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-02/0b95074c40254505a543d8b1e4f5615f--f343--image-20241002143615421.png" alt="image-20241002143615421"></p>
<p>输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">maxMemory:<span class="number">1048576000</span>字节	<span class="number">1000.</span>0MB</span><br><span class="line">totalMemory:<span class="number">1048576000</span>字节	<span class="number">1000.</span>0MB</span><br><span class="line">[<span class="number">0.</span>183s][info   ][gc,heap,exit] Heap</span><br><span class="line">[<span class="number">0.</span>183s][info   ][gc,heap,exit]  garbage-first heap   total reserved 1024000K, committed 1024000K, used 6144K [<span class="number">0x00000000c1800000</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line">[<span class="number">0.</span>183s][info   ][gc,heap,exit]   region size 1024K, <span class="number">6</span> young (6144K), <span class="number">0</span> survivors (0K)</span><br><span class="line">[<span class="number">0.</span>183s][info   ][gc,heap,exit]  Metaspace       used 858K, committed 1024K, reserved 1114112K</span><br><span class="line">[<span class="number">0.</span>183s][info   ][gc,heap,exit]   <span class="keyword">class</span> <span class="title class_">space</span>    used 68K, committed 128K, reserved 1048576K</span><br></pre></td></tr></table></figure>

<p>如下代码设置</p>
<p><code>-Xms1m -Xmx1m -XX:+PrintGCDetails</code></p>
<p>-Xms 设置初始化内存分配大小，默认1&#x2F;64</p>
<p>-Xmx 设置最大分配内存大小，默认1&#x2F;4</p>
<p>-XX:+PrintGCDetails  — 打印GC垃圾回收信息</p>
<p>-XX:+HeapDumpOnOutOfMemoryError   — OOM DUMP</p>
<blockquote>
<p>拓展</p>
</blockquote>
<p>这里也可以使用一些工具去检测对应的堆内存问题的，推荐就是可以使用JPofiler</p>
<p>在一个项目中，突然出现了OOM故障，那么该如何排除~</p>
<ul>
<li>能够看到代码第几行出错：内存快照分析工具，MAT，Jprofiler</li>
<li>Dubug，一行行代码分析！</li>
</ul>
<p>MAT，Jprofiler作用：</p>
<ul>
<li>分析Dump内存文件，快速定位内存泄露</li>
<li>获得堆中的数据</li>
<li>获得大的对象</li>
<li>…</li>
</ul>
<h1 id="九、GC介绍之引用计数器"><a href="#九、GC介绍之引用计数器" class="headerlink" title="九、GC介绍之引用计数器"></a>九、GC介绍之引用计数器</h1><p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-02/3e08fdadcb276e8d69cb5f7e3b8c055e--f1a5--image-20241002150143735.png" alt="image-20241002150143735"></p>
<p>JVM在进行GC时，并不是对这三个区域统一回收，大部分的时候，回收都是新生代</p>
<ul>
<li>新生区</li>
<li>幸存区</li>
<li>老年区</li>
</ul>
<p>GC种类：</p>
<ul>
<li>轻GC（普通的GC）</li>
<li>重GC（全局的GC）</li>
</ul>
<p>GC题目：</p>
<ul>
<li>JVM的内存模型和分区，详细到每个区放什么？</li>
<li>堆里面的分区有哪些？Eden，from,to,老年区，说说他们的特点</li>
<li>GC的算法有哪些？怎么用？<ul>
<li>标记清除法</li>
<li>标记压缩</li>
<li>复制算法</li>
<li>引用计数器</li>
</ul>
</li>
<li>轻GC和重GC分别是在什么什么时候发生？</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-02/4decf139647e56d4315d0461f2a20f18--39c2--image-20241002150210872.png" alt="image-20241002150210872">s</p>
<h1 id="十、GC之复制算法"><a href="#十、GC之复制算法" class="headerlink" title="十、GC之复制算法"></a>十、GC之复制算法</h1><p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-02/22cc5c8b3199733d8c33c8bf306fe266--4c06--image-20241002151906956.png" alt="image-20241002151906956"></p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-02/26875756d86816c75926906a4d67903c--038c--image-20241002152233036.png" alt="image-20241002152233036"></p>
<p>好处：没有内存的碎片</p>
<p>坏处：浪费了内存空间，多了一半空间永远是空（To），假设对象100%存活(极端情况)</p>
<p>复制算法最佳使用场景：对象存活度较低的区域，新生区</p>
<h1 id="十一、GC之标记压缩清除算法"><a href="#十一、GC之标记压缩清除算法" class="headerlink" title="十一、GC之标记压缩清除算法"></a>十一、GC之标记压缩清除算法</h1><h2 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h2><p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-02/d9605fa66682ee4502ae00fc31e53fdb--c834--image-20241002152649930.png" alt="image-20241002152649930"></p>
<p>优点：不需要额外的空间！</p>
<p>缺点：两次扫描，严重浪费时间，会产生内存碎片</p>
<h2 id="标记压缩"><a href="#标记压缩" class="headerlink" title="标记压缩"></a>标记压缩</h2><p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-02/f62b9bdd6057a232b59795de140c44a1--1843--image-20241002152705256.png" alt="image-20241002152705256"></p>
<h2 id="标记清除压缩"><a href="#标记清除压缩" class="headerlink" title="标记清除压缩"></a>标记清除压缩</h2><p>先标记清除几次</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-02/c77c99081d771362defd654f3a2faf49--25b7--image-20241002152724230.png" alt="image-20241002152724230"></p>
<p>再压缩</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-02/4d9607858f7e3a699652c996668bb036--7231--image-20241002152734368.png" alt="image-20241002152734368"></p>
<h1 id="十二、GC算法总结"><a href="#十二、GC算法总结" class="headerlink" title="十二、GC算法总结"></a>十二、GC算法总结</h1><p>内存效率：复制算法 &gt; 标记清除算法 &gt; 标记压缩算法（时间复杂度）</p>
<p>内存整齐度：复制算法 &#x3D; 标记压缩算法 &gt; 标记清除算法</p>
<p>内存利用率： 标记压缩算法 &#x3D; 标记清除算法 &gt; 复制算法</p>
<p>思考：难道没有最优算法吗？</p>
<p>答案：没有，没有最好的算法，只有最合适的算法 —–》 GC：分代收集算法</p>
<p>年轻代：</p>
<ul>
<li>存活率低</li>
<li>复制算法</li>
</ul>
<p>老年代：</p>
<ul>
<li>区域大：存活率</li>
<li>标记清除（内存碎片不是太多）+ 标记压缩 混合实现</li>
</ul>
<p>一天时间学JVM,不现实，要深究，必须要花时间，多看面试题，以及《深入理解JVM》</p>
<p>但是，我们可以掌握一个学习JVM的方法</p>
<h1 id="十三、如何快速学习方法讲解"><a href="#十三、如何快速学习方法讲解" class="headerlink" title="十三、如何快速学习方法讲解"></a>十三、如何快速学习方法讲解</h1><p>JMM:java Memory Model（java内存模型）</p>
<ol>
<li><p>什么是JMM</p>
<p>【JMM】（Java Memory Model的缩写）</p>
</li>
<li><p>它干嘛的？– 官方，其他人的博客，对应的视频</p>
<p>作用：缓存一致性协议，用于定义数据读写的规则（遵守，找到这个规则）</p>
<p>JMM定义了线程工作内存和主内存之间的抽象关系，线程之间的共享变量存储在主内存（Main Memory）中，每个线程都有一个私有的本地内存（Local Memory）</p>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-02/a0441016fecf4962d73058e54efe8f11--fc1d--image-20241002152846508.png" alt="image-20241002152846508"></p>
<ol>
<li><p>解决共享对象可见性这个问题：volatile</p>
</li>
<li><p>它该如何学习？</p>
<p>JMM：抽象的概念，理论</p>
<p>JMM对这八种指令的使用，制定了如下规则：</p>
<ul>
<li><p>不允许read和load、store和write操作之一单独出现。即使用了read必须load，使用了store必须write</p>
</li>
<li><p>不允许线程丢弃他最近的assign操作，即工作变量的数据改变了之后，必须告知主存</p>
</li>
<li><p>不允许一个线程将没有assign的数据从工作内存同步回主内存</p>
</li>
<li><p>一个新的变量必须在主内存中诞生，不允许工作内存直接使用一个未被初始化的变量。就是怼变量实施use、store操作之前，必须经过assign和load操作</p>
</li>
<li><p>一个变量同一时间只有一个线程能对其进行lock。多次lock后，必须执行相同次数的unlock才能解锁</p>
</li>
<li><p>如果对一个变量进行lock操作，会清空所有工作内存中此变量的值，在执行引擎使用这个变量前，必须重新load或assign操作初始化变量的值</p>
</li>
<li><p>如果一个变量没有被lock，就不能对其进行unlock操作。也不能unlock一个被其他线程锁住的变量</p>
</li>
<li><p>对一个变量进行unlock操作之前，必须把此变量同步回主内存</p>
</li>
</ul>
<p>JMM对这八种操作规则和对<a target="_blank" rel="noopener" href="https://www.cnblogs.com/null-qige/p/8569131.html">volatile的一些特殊规则</a>就能确定哪里操作是线程安全，哪些操作是线程不安全的了。但是这些规则实在复杂，很难在实践中直接分析。所以一般我们也不会通过上述规则进行分析。更多的时候，使用java的happen-before规则来进行分析。</p>
</li>
</ol>
<hr>
<p>   学习新东西是常态</p>
<p>   针对面试学习</p>
<p>   针对技术学习</p>
<p>   面试：</p>
<p>   3&#x2F;10 &#x3D;&#x3D; pass ，面经 &#x3D;10 ，分析这10个？触类旁通：百度面试题</p>
<p>   通过大量的面试总结，得出一套解题思路</p>
<p>更多阅读：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/nSwNZpObWLGteG-v7n5PSw">https://mp.weixin.qq.com/s/nSwNZpObWLGteG-v7n5PSw</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://6pc1.github.io/2024/09/21/Docker%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="6pc1">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="6pc1's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 6pc1's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/09/21/Docker%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">Docker学习</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-09-21 20:01:51" itemprop="dateCreated datePublished" datetime="2024-09-21T20:01:51+08:00">2024-09-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-09-26 10:27:33" itemprop="dateModified" datetime="2024-09-26T10:27:33+08:00">2024-09-26</time>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2024/09/21/Docker%E5%AD%A6%E4%B9%A0/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2024/09/21/Docker%E5%AD%A6%E4%B9%A0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>49k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>44 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="一、Docker概述"><a href="#一、Docker概述" class="headerlink" title="一、Docker概述"></a>一、Docker概述</h1><h2 id="1、docker为什么会出现"><a href="#1、docker为什么会出现" class="headerlink" title="1、docker为什么会出现"></a>1、docker为什么会出现</h2><p>工作中，经常出现“在我的机器上可正常工作”的问题</p>
<p>因为环境不一致等原因导致。。。</p>
<p>Docker的思想就来自于集装箱！</p>
<p>隔离：Docker核心思想！打包装箱！每个箱子是互相隔离的。</p>
<p>Docker通过隔离机制，可以将服务器利用到极致！</p>
<h2 id="2、Docker的历史"><a href="#2、Docker的历史" class="headerlink" title="2、Docker的历史"></a>2、Docker的历史</h2><p>Docker 是基于Go 语言实现的开源容器项目，诞生于2013 年年初，最初发起者是 dotCloud 公司。Docker 自开源后受到广泛的关注和l 讨论，目前已有多个相关项目（包括 Docker 三剑客、Kubemetes 等），逐渐形成了围绕Docker 容器的生态体系。 由于Docker 在业界造成的影响力实在太大， dotCloud 公司后来也直接改名为Docker Inc ，并专注于Docker 相关技术和产品的开发。</p>
<p>自从dotCloud公司开源其Docker项目后，凭借其便捷的Docker镜像技术解决了当时困扰众多PaaS项目的难题：如何为应用打包，让用户将本地的应用顺利迁移到PaaS平台，而不用顾忌应用的开发语言、配置、依赖包等诸多因素，也因此开启了全新的Docker容器时代。</p>
<h2 id="3、Docker能干嘛"><a href="#3、Docker能干嘛" class="headerlink" title="3、Docker能干嘛"></a>3、Docker能干嘛</h2><p>对开发和运维（ <strong>DevOps</strong> ）人员来说，可能最梦寐以求的效果就是一次创建或配置， 之后可以在任意地方、任意时间让应用正常运行。</p>
<p>具体说来， Docker 在开发和运维过程中，具有如下几个方面的优势：</p>
<ol>
<li><p><strong>更快速的交付和部署</strong></p>
<p>使用Docker ，开发人员可以使用镜像来快速构建一套标准的开发环境；开发完成之后，测试和运维人员可以直接使用完全相同环境来部署代码。只要开发测试过的代码，就可以确保在生产环境无缝运行。Docker 可以快速创建和删除容器，实现快速迭代，大量节约开发、测试、部署的时间。并且，整个过程全程可见，使团队更容易理解应用的创建和工作过程。</p>
</li>
<li><p><strong>更高效的资源利用</strong></p>
<p>Docker 容器的运行不需要额外的虚拟化管理程序（Virtual Machine Manager, VMM ，以及Hypervisor）支持，它是内核级的虚拟化，可以实现更高的性能，同时对资源的额外需求很低。跟传统虚拟机方式相比，要提高一到两个数量级。</p>
</li>
<li><p><strong>更轻松的迁移和扩展</strong></p>
<p>Docker 容器几乎可以在任意的平台上运行，包括物理机、虚拟机、公有云、私有云、个人电脑、服务器等，同时支持主流的操作系统发行版本。这种兼容性让用户可以在不同平台之间轻松地迁移应用。</p>
</li>
<li><p><strong>更简单的更新管理</strong></p>
<p>使用Dockerfile ，只需要小小的配置修改，就可以替代以往大量的更新工作。并且所有修改都以增量的方式被分发和更新，从而实现自动化并且高效的容器管理。</p>
</li>
</ol>
<blockquote>
<p>Docker 和常见的虚拟化方式的不同之处</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-21/46de97d6c7d3ec4bc0c24d94f32025ee--6893--image-20240921201222753.png" alt="image-20240921201222753"></p>
<p><strong>传统方式是在硬件层面实现虚拟化，需要有额外的虚拟机管理应用和虚拟机操作系统</strong> <strong>层。Docker 容器是在操作系统层面上实现虚拟化，直接复用本地主机的操作系统，因此更加</strong> <strong>轻量级。</strong></p>
<p>Docker 在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护。使得 Docker 技术比虚拟机技术更为轻便、快捷。</p>
<p>作为一种新兴的虚拟化方式，Docker 跟传统的虚拟化方式相比具有众多的优势。Docker 容器的启动可以在秒级实现，这相比传统的虚拟机方式要快得多；Docker 对系统资源的利用率很高，一台主机上可以同时运行数千个 Docker 容器。</p>
<h1 id="二、Docker安装"><a href="#二、Docker安装" class="headerlink" title="二、Docker安装"></a>二、Docker安装</h1><h2 id="1、Docker的基本组成"><a href="#1、Docker的基本组成" class="headerlink" title="1、Docker的基本组成"></a>1、Docker的基本组成</h2><p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-21/cdad8f4b97c506bb09c7c4b085b817bb--d293--image-20240921201553913.png" alt="image-20240921201553913"></p>
<ul>
<li><p><strong>镜像（Image）</strong></p>
<p>什么是 Docker 镜像？简单的理解，Docker 镜像就是一个 Linux 的文件系统（Root FileSystem），这个文件系统里面包含可以运行在 Linux 内核的程序以及相应的数据。</p>
<p>通过镜像启动一个容器，一个镜像就是一个可执行的包，其中包括运行应用程序所需要的所有内容：包含代码，运行时间，库，环境变量和配置文件等。</p>
<p><strong>Docker 把 App 文件打包成为一个镜像</strong>，并且采用类似多次快照的存储技术，可以实现：</p>
<ul>
<li>多个 App 可以共用相同的底层镜像（初始的操作系统镜像）</li>
<li>App 运行时的 IO 操作和镜像文件隔离</li>
<li>通过挂载包含不同配置&#x2F;数据文件的目录或者卷（Volume），单个 App 镜像可以用来运行无数个不同业务的容器</li>
</ul>
</li>
<li><p><strong>容器（container）</strong></p>
<p>镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p>
<blockquote>
<p>通俗来讲，镜像相当于类，容器相当于对象</p>
</blockquote>
</li>
<li><p><strong>仓库（repository）</strong></p>
<p>仓库可看成一个代码控制中心，用来保存镜像。</p>
<p>仓库分为公有仓库和私有仓库。(很类似git)</p>
<p>Docker Hub是国外的。</p>
<p>阿里云…都有容器服务器(配置镜像加速!)</p>
</li>
</ul>
<h2 id="2、安装docker"><a href="#2、安装docker" class="headerlink" title="2、安装docker"></a>2、安装docker</h2><ul>
<li>使用云服务器的，可以直接去对应的官网寻找对应的安装配置方案</li>
<li>比如我这里使用的就是腾讯云的Ubuntu系统</li>
</ul>
<ol>
<li>执行以下命令，添加 Docker 软件源。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install ca-certificates curl</span><br><span class="line">sudo install -m 0755 -d /etc/apt/keyrings</span><br><span class="line">sudo curl -fsSL https://mirrors.cloud.tencent.com/docker-ce/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc</span><br><span class="line">sudo <span class="built_in">chmod</span> a+r /etc/apt/keyrings/docker.asc</span><br><span class="line"><span class="built_in">echo</span>   <span class="string">&quot;deb [arch=<span class="subst">$(dpkg --print-architecture)</span> signed-by=/etc/apt/keyrings/docker.asc] https://mirrors.cloud.tencent.com/docker-ce/linux/ubuntu/ \</span></span><br><span class="line"><span class="string">  <span class="subst">$(. /etc/os-release &amp;&amp; echo <span class="string">&quot;<span class="variable">$VERSION_CODENAME</span>&quot;</span>)</span> stable&quot;</span> |   sudo <span class="built_in">tee</span> /etc/apt/sources.list.d/docker.list &gt; /dev/null</span><br><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>执行以下命令，安装 Docker。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>执行以下命令，运行 Docker。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>执行以下命令，检查安装结果。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker info</span><br></pre></td></tr></table></figure>

<p>返回如下信息，即表示安装成功。</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-22/28470f218824e23ec82ce28a7b50fbba--134f--image-20240922094005847.png" alt="image-20240922094005847"></p>
<ul>
<li>配置对应的加速源</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/docker/daemon.json</span><br></pre></td></tr></table></figure>

<ul>
<li>然后添加以下内容</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="string">&quot;registry-mirrors&quot;</span>: [</span><br><span class="line">   <span class="string">&quot;https://mirror.ccs.tencentyun.com&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>执行以下命令，重启 Docker 即可。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>

<blockquote>
<p>测试使用</p>
</blockquote>
<p>运行hello-world</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-22/5bf1cdf230c3155be2fdda1beabb1ff3--764e--image-20240922095218341.png" alt="image-20240922095218341"></p>
<blockquote>
<p>查看镜像</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@VM-16-10-ubuntu:/home/ubuntu<span class="comment"># docker images</span></span><br><span class="line">REPOSITORY    TAG       IMAGE ID       CREATED         SIZE</span><br><span class="line">hello-world   latest    d2c94e258dcb   16 months ago   13.3kB</span><br></pre></td></tr></table></figure>

<blockquote>
<p>查看容器</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@VM-16-10-ubuntu:/home/ubuntu<span class="comment"># docker ps -a</span></span><br><span class="line">CONTAINER ID   IMAGE         COMMAND    CREATED              STATUS                          PORTS     NAMES</span><br><span class="line">03e09e9f8b65   hello-world   <span class="string">&quot;/hello&quot;</span>   About a minute ago   Exited (0) About a minute ago          compassionate_gates</span><br><span class="line"><span class="comment"># 加-a表示所有容器，包括未运行的，不加-a表示正在运行的容器</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>移除容器镜像        </p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@VM-16-10-ubuntu:/home/ubuntu<span class="comment"># docker rmi -f d2c94e258dcb  移除镜像</span></span><br><span class="line">Untagged: hello-world:latest</span><br><span class="line">Untagged: hello-world@sha256:91fb4b041da273d5a3273b6d587d62d518300a6ad268b28628f74997b93171b2</span><br><span class="line">Deleted: sha256:d2c94e258dcb3c5ac2798d32e1249e42ef01cba4841c2234249495f87264ac5a</span><br><span class="line">root@VM-16-10-ubuntu:/home/ubuntu<span class="comment"># docker rm 03e09e9f8b65  移除容器</span></span><br><span class="line">03e09e9f8b65</span><br></pre></td></tr></table></figure>

<h2 id="3、回滚hello-world流程"><a href="#3、回滚hello-world流程" class="headerlink" title="3、回滚hello-world流程"></a>3、回滚hello-world流程</h2><p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-22/5f27548b9d8f1e9607ec770f8163467d--85fa--image-20240922100450374.png" alt="image-20240922100450374"></p>
<p><strong>底层原理</strong></p>
<blockquote>
<p>docker是怎么工作的</p>
</blockquote>
<p>docker是一个client-server结构的系统，docker守护进程运行在主机上，然后通过socket连接从客户端访问docker守护进程。</p>
<p>docker守护进程从客户端接收命令，并按照命令，管理运行在主机上的容器。</p>
<p>一个docker容器，是一个运行时环境，可以简单理解为进程运行的集装箱。</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-22/d9a59b17ba24e343869da74322314fe6--cc31--image-20240922100554772.png" alt="image-20240922100554772"></p>
<blockquote>
<p>为什么docker比vm快</p>
</blockquote>
<ol>
<li>Docker有这比虚拟机更少的抽象层，<strong>由于Docker不需要Hypervisor实现硬件资源虚拟化</strong>，运行在Docker上的程序直接使用的都是实际物理机上的硬件资源，因此在CPU、内存利用率上有明显的优势。</li>
<li>**Docker利用的是宿主机的内核，而不需要使用Guest OS ** ，因此当新建一个容器时，docker不需要和虚拟机一样重新加载一个操作系统内核，而避免引寻 ，加载操作系统内核是个比较费事费资源的过程，当新建一个虚拟机时，虚拟机软件需要加载Guest OS，返回的新建的过程是分钟级别，而docker直接使用的是宿主机上的操作系统，则省略了返回这个的过程，因此新建一个docker容器只需要几秒钟。</li>
</ol>
<p>虚拟机与Docker架构对比图：</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-22/18b3c4595e4fcb446eec5aa6f07eb057--d721--image-20240922100609249.png" alt="image-20240922100609249"></p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-22/bd0035ab49544d13114ef688ea55e553--3f26--image-20240922100613510.png" alt="image-20240922100613510"></p>
<h1 id="三、Docker常见命令"><a href="#三、Docker常见命令" class="headerlink" title="三、Docker常见命令"></a>三、Docker常见命令</h1><p>官方文档常用命令地址:<a target="_blank" rel="noopener" href="https://docs.docker.com/reference/">https://docs.docker.com/reference/</a></p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-22/da3aea870e0b1d7fbb60aa86470e7314--c384--image-20240922101137679.png" alt="image-20240922101137679"></p>
<h2 id="1、帮助命令"><a href="#1、帮助命令" class="headerlink" title="1、帮助命令"></a>1、帮助命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#显示docker的版本信息。</span></span><br><span class="line">docker version    </span><br><span class="line"><span class="comment">#显示docker的系统信息，包括镜像和容器的数量</span></span><br><span class="line">docker info   </span><br><span class="line"><span class="comment">#帮助命令</span></span><br><span class="line">docker --<span class="built_in">help</span></span><br><span class="line">docker 命令 --<span class="built_in">help</span> </span><br></pre></td></tr></table></figure>

<h2 id="2、镜像命令"><a href="#2、镜像命令" class="headerlink" title="2、镜像命令"></a>2、镜像命令</h2><blockquote>
<p>docker image  查看所有本地主机上的镜像</p>
</blockquote>
<p>参数和选项</p>
<ul>
<li><code>-a</code>, –all             列出所有镜像</li>
<li><code>-q</code>, –quiet           只显示镜像id</li>
</ul>
<p>测试</p>
<p>1、查看本地主机上的镜像</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@VM-16-10-ubuntu:/home/ubuntu<span class="comment"># docker images</span></span><br><span class="line">REPOSITORY    TAG       IMAGE ID       CREATED         SIZE</span><br><span class="line">hello-world   latest    d2c94e258dcb   16 months ago   13.3kB</span><br></pre></td></tr></table></figure>

<p>解释：</p>
<ul>
<li>REPOSITORY 镜像的仓库源</li>
<li>TAG 镜像的标签（版本） latest表示最新的版本</li>
<li>IMAGE ID 镜像id</li>
<li>CREATED 镜像的创建时间</li>
<li>SIZE 镜像的大小</li>
</ul>
<p>2、列出所有镜像的id</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@VM-16-10-ubuntu:/home/ubuntu<span class="comment"># docker images -aq</span></span><br><span class="line">d2c94e258dcb</span><br></pre></td></tr></table></figure>

<blockquote>
<p>docker search 搜索镜像</p>
</blockquote>
<p>镜像仓库地址：<a target="_blank" rel="noopener" href="https://hub.docker.com/">https://hub.docker.com/</a></p>
<p>参数和选项</p>
<ul>
<li><code>-f</code>, –filter filter   基于条件过滤</li>
</ul>
<p>测试</p>
<p>1、搜索mysql镜像</p>
<p>在docker仓库上搜  <a target="_blank" rel="noopener" href="https://hub.docker.com/">https://hub.docker.com/</a></p>
<p>也可以直接使用命令去搜</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search ****</span><br></pre></td></tr></table></figure>

<p>不过服务器要是不太行，一般会直接超时。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@VM-16-10-ubuntu:/home/ubuntu<span class="comment"># docker search mysql</span></span><br><span class="line">Error response from daemon: Get <span class="string">&quot;https://index.docker.io/v1/search?q=mysql&amp;n=25&quot;</span>: dial tcp 199.59.150.39:443: i/o <span class="built_in">timeout</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>docker rmi删除镜像</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@VM-16-10-ubuntu:/home/ubuntu<span class="comment"># docker rmi -f 镜像id                    #删除指定镜像</span></span><br><span class="line">root@VM-16-10-ubuntu:/home/ubuntu<span class="comment"># docker rmi -f 镜像id1 镜像id2 镜像id3     #删除多个镜像</span></span><br><span class="line">root@VM-16-10-ubuntu:/home/ubuntu<span class="comment"># docker rmi -f $(docker images -aq)      #删除所有镜像 </span></span><br></pre></td></tr></table></figure>

<h2 id="3、容器命令"><a href="#3、容器命令" class="headerlink" title="3、容器命令"></a>3、容器命令</h2><p>我们有了镜像，才能创建容器，所以先下载一个centos镜像来学习</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@VM-16-10-ubuntu:/home/ubuntu<span class="comment"># docker pull centos</span></span><br><span class="line">Using default tag: latest</span><br><span class="line">latest: Pulling from library/centos</span><br><span class="line">a1d0c7532777: Pull complete </span><br><span class="line">Digest: sha256:a27fd8080b517143cbbbab9dfb7c8571c40d67d534bbdee55bd6c473f432b177</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> centos:latest</span><br><span class="line">docker.io/library/centos:latest</span><br></pre></td></tr></table></figure>

<blockquote>
<p>启动容器</p>
</blockquote>
<p>docker run [可选参数] 容器名或者容器id</p>
<p>创建一个新的容器并运行一个命令</p>
<p>可选参数</p>
<ul>
<li><strong>-i:</strong> 以交互模式运行容器，通常与 -t 同时使用</li>
<li><strong>-t:</strong> 为容器重新分配一个伪输入终端，通常与 -i 同时使用</li>
<li><strong>-P:</strong> 随机端口映射，容器内部端口<strong>随机</strong>映射到主机的端口</li>
<li><strong>-p:</strong> 指定端口映射，格式为：<strong>主机(宿主)端口:容器端口</strong></li>
<li><strong>-d:</strong> 后台运行容器，并返回容器ID；</li>
<li><strong>–name&#x3D;”nginx-lb”:</strong> 为容器指定一个名称</li>
<li><strong>-e username&#x3D;”ritchie”:</strong> 设置环境变量</li>
</ul>
<p>测试：</p>
<p>1、使用镜像centos以交互模式启动一个容器,在容器内执行&#x2F;bin&#x2F;bash命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@VM-16-10-ubuntu:/home/ubuntu<span class="comment"># docker run -it centos /bin/bash</span></span><br><span class="line">[root@5bfd7775d62f /]<span class="comment"># </span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@VM-16-10-ubuntu:/home/ubuntu<span class="comment"># docker ps</span></span><br><span class="line">CONTAINER ID   IMAGE     COMMAND       CREATED          STATUS          PORTS     NAMES</span><br><span class="line">5bfd7775d62f   centos    <span class="string">&quot;/bin/bash&quot;</span>   55 seconds ago   Up 54 seconds             goofy_ellis</span><br></pre></td></tr></table></figure>

<blockquote>
<p>退出容器</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exit</span>       <span class="comment">#直接退出容器并关闭</span></span><br><span class="line">快捷键：ctrl+p+q   <span class="comment">#容器不关闭退出 注意p和q的顺序！</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>列出所有的容器</p>
</blockquote>
<p>docker ps</p>
<p>可选参数</p>
<ul>
<li>**-a :**显示所有的容器，包括未运行的。</li>
<li>**-n :**列出最近创建的n个容器。</li>
<li>**-q :**静默模式，只显示容器编号。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@VM-16-10-ubuntu:/home/ubuntu<span class="comment"># docker ps</span></span><br><span class="line">CONTAINER ID   IMAGE     COMMAND       CREATED              STATUS              PORTS     NAMES</span><br><span class="line">5bfd7775d62f   centos    <span class="string">&quot;/bin/bash&quot;</span>   About a minute ago   Up About a minute             goofy_ellis</span><br><span class="line">root@VM-16-10-ubuntu:/home/ubuntu<span class="comment"># docker ps -a</span></span><br><span class="line">CONTAINER ID   IMAGE         COMMAND       CREATED              STATUS                      PORTS     NAMES</span><br><span class="line">5bfd7775d62f   centos        <span class="string">&quot;/bin/bash&quot;</span>   About a minute ago   Up About a minute                     goofy_ellis</span><br><span class="line">8d2482707137   hello-world   <span class="string">&quot;/hello&quot;</span>      12 minutes ago       Exited (0) 12 minutes ago             clever_mccarthy</span><br><span class="line">root@VM-16-10-ubuntu:/home/ubuntu<span class="comment"># </span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>删除容器</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">rm</span> -f 容器<span class="built_in">id</span>                       <span class="comment"># 删除指定容器</span></span><br><span class="line">docker <span class="built_in">rm</span> -f $(docker ps -aq)       <span class="comment"># 删除所有容器</span></span><br><span class="line">docker ps -a -q|xargs docker <span class="built_in">rm</span> -f  <span class="comment"># 删除所有的容器</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>启动和停止容器</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker start 容器<span class="built_in">id</span>           <span class="comment"># 启动容器</span></span><br><span class="line">docker restart 容器<span class="built_in">id</span>         <span class="comment"># 重启容器</span></span><br><span class="line">docker stop 容器<span class="built_in">id</span>            <span class="comment"># 停止当前正在运行的容器</span></span><br><span class="line">docker <span class="built_in">kill</span> 容器<span class="built_in">id</span>            <span class="comment"># 强制停止当前的容器</span></span><br></pre></td></tr></table></figure>

<h2 id="4、常用其他命令"><a href="#4、常用其他命令" class="headerlink" title="4、常用其他命令"></a>4、常用其他命令</h2><blockquote>
<p>后台启动命令</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@VM-16-10-ubuntu:/home/ubuntu<span class="comment"># docker run -d centos</span></span><br><span class="line">3c59ba355924fa7659dea00b40ee81e0b156ea8173cc3ed55d10abdda9b71346</span><br><span class="line">root@VM-16-10-ubuntu:/home/ubuntu<span class="comment"># docker ps</span></span><br><span class="line">CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES</span><br><span class="line"></span><br><span class="line"><span class="comment"># 问题，后端启动容器后，docker ps，发现centos停止了</span></span><br><span class="line"><span class="comment"># 常见的坑， docker 容器使用后台运行， 就必须要有一个前台进程，docker发现没有应用，就会自动停止</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@VM-16-10-ubuntu:/home/ubuntu<span class="comment"># docker run -d -it centos  #这种启动容器后就不会关闭了</span></span><br><span class="line">427021a3fe1bed3ce5a2950d50204b0b5c7ba6124e436132cb810791e04d7c9d</span><br><span class="line">root@VM-16-10-ubuntu:/home/ubuntu<span class="comment"># docker ps</span></span><br><span class="line">CONTAINER ID   IMAGE     COMMAND       CREATED         STATUS         PORTS     NAMES</span><br><span class="line">427021a3fe1b   centos    <span class="string">&quot;/bin/bash&quot;</span>   3 seconds ago   Up 3 seconds             brave_moore</span><br></pre></td></tr></table></figure>

<blockquote>
<p>查看日志</p>
</blockquote>
<p>docker logs [参数与参选] 容器id</p>
<p>参数与选项</p>
<ul>
<li><strong>-f :</strong> 跟踪日志输出</li>
<li><strong>-t :</strong> 显示时间戳</li>
<li>**–since :**显示某个开始时间的所有日志</li>
<li><strong>-n</strong>或者**–tail :**仅列出最新N条容器日志</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker logs -tf -n=10 容器id</span></span><br><span class="line">root@VM-16-10-ubuntu:/home/ubuntu<span class="comment"># docker logs -tf -n=10 427021a3fe1b</span></span><br><span class="line"><span class="comment"># 这里没有日志，我们自己编写一段shell脚本</span></span><br><span class="line">root@VM-16-10-ubuntu:/home/ubuntu<span class="comment"># docker run -d -it centos /bin/bash -c &quot;while true;do echo zyy hello;sleep 10;done&quot;</span></span><br><span class="line">26805bf07f643d921b05be3a9c3f9eff41481bc302406c8c64b8ffbfc72b52ee</span><br><span class="line">root@VM-16-10-ubuntu:/home/ubuntu<span class="comment"># docker logs -tf -n=10 26805bf07f6</span></span><br><span class="line">2024-09-22T02:29:02.878255691Z zyy hello</span><br><span class="line">2024-09-22T02:29:12.896589927Z zyy hello</span><br></pre></td></tr></table></figure>

<p><strong>命令<code>docker run -d -it centos /bin/bash -c &quot;while true;do echo zyy hello;sleep 1;done&quot;</code>解释：</strong></p>
<p>该命令会不停地输出字符串 “zyy hello”，每隔 1 秒钟输出一次，直到容器被停止。</p>
<p>其中，各个参数的含义如下：</p>
<ul>
<li><code>docker run</code> 是 Docker 命令的基本语法，用于启动一个新的容器。</li>
<li><code>-d</code> 参数表示在后台运行容器。</li>
<li><code>centos</code> 参数表示使用的镜像名称，这里使用的是 CentOS 镜像。</li>
<li><code>/bin/bash -c &quot;while true;do echo zyy hello;sleep 1;done&quot;</code> 参数表示在容器内部执行的 shell 命令。其中 <code>/bin/bash</code> 是 shell 的路径，<code>-c</code> 参数表示在 shell 中执行指定的命令。这里的命令是一个无限循环，不停地输出字符串 “zyy hello”。</li>
</ul>
<blockquote>
<p>查看容器中的进程信息</p>
</blockquote>
<p>docker top 容器id</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@VM-16-10-ubuntu:/home/ubuntu<span class="comment"># docker ps</span></span><br><span class="line">CONTAINER ID   IMAGE     COMMAND       CREATED         STATUS         PORTS     NAMES</span><br><span class="line">4ee256515d6e   centos    <span class="string">&quot;/bin/bash&quot;</span>   4 seconds ago   Up 3 seconds             frosty_swartz</span><br><span class="line">root@VM-16-10-ubuntu:/home/ubuntu<span class="comment"># docker top 4ee256515d6e</span></span><br><span class="line">UID                 PID                 PPID                C                   STIME               TTY                 TIME                CMD</span><br><span class="line">root                2564662             2564639             0                   10:33               pts/0               00:00:00            /bin/bash</span><br></pre></td></tr></table></figure>

<blockquote>
<p>查看镜像的元数据</p>
</blockquote>
<p>docker inspect 容器id<br>元数据 (meta data)——“data about data” 描述数据的数据，一般是结构化数据 </p>
<p>元数据是指从信息资源中抽取出来的用于说明其特征、内容的结构化的数据(如题名,版本、出版数据、相关说明,包括检索点等)，用于组织、描述、检索、保存、管理信息和知识资源</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@VM-16-10-ubuntu:/home/ubuntu<span class="comment"># docker inspect 4ee256515d6e</span></span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;Id&quot;</span>: <span class="string">&quot;4ee256515d6e776f4e2b6e8e80d1a65b67635347465ba27a08035cffb3f01983&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Created&quot;</span>: <span class="string">&quot;2024-09-22T02:33:02.5872125Z&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Path&quot;</span>: <span class="string">&quot;/bin/bash&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Args&quot;</span>: [],</span><br><span class="line">        <span class="string">&quot;State&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;Status&quot;</span>: <span class="string">&quot;running&quot;</span>,</span><br><span class="line">........</span><br></pre></td></tr></table></figure>

<blockquote>
<p>进入当前正在运行的容器</p>
</blockquote>
<p><strong>方式一：docker exec</strong></p>
<p>docker exec -it 容器id &#x2F;bin&#x2F;bash</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@VM-16-10-ubuntu:/home/ubuntu<span class="comment"># docker exec -it 4ee256515d6e /bin/sh</span></span><br><span class="line">sh-4.4<span class="comment"># ls</span></span><br><span class="line">bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br></pre></td></tr></table></figure>

<p><strong>方式二：docker attach</strong></p>
<p>docker attach 容器id</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@VM-16-10-ubuntu:/home/ubuntu<span class="comment"># docker attach 4ee256515d6e</span></span><br><span class="line">[root@4ee256515d6e /]<span class="comment"># ls</span></span><br><span class="line">bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br></pre></td></tr></table></figure>

<p>区别</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker exec       # 进入容器后开启一个新的终端，可以在里面操作</span></span><br><span class="line"><span class="comment"># docker attach     # 进入容器正在执行的终端，不会启动新的进程</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>从容器拷贝到主机上、从主机拷贝到容器上</p>
</blockquote>
<p>docker   cp   容器id:容器文件   主机路径</p>
<p>docker   cp   主机文件   容器id:容器路径</p>
<h2 id="5、命令大全"><a href="#5、命令大全" class="headerlink" title="5、命令大全"></a>5、命令大全</h2><p><a target="_blank" rel="noopener" href="https://pythondjango.cn/python/tools/2-docker-dockerfile/">https://pythondjango.cn/python/tools/2-docker-dockerfile/</a></p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-22/a35078a4e14770dc23e9e96e77b8fa78--3ca0--image-20240922104456381.png" alt="image-20240922104456381"></p>
<h1 id="四、Docker的使用练习"><a href="#四、Docker的使用练习" class="headerlink" title="四、Docker的使用练习"></a>四、Docker的使用练习</h1><h2 id="1、Docker安装nginx"><a href="#1、Docker安装nginx" class="headerlink" title="1、Docker安装nginx"></a>1、Docker安装nginx</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">root@VM-16-10-ubuntu:/home/ubuntu<span class="comment"># docker pull nginx 1、 拉取nginx</span></span><br><span class="line">Using default tag: latest</span><br><span class="line">latest: Pulling from library/nginx</span><br><span class="line">a2318d6c47ec: Pull complete </span><br><span class="line">095d327c79ae: Pull complete </span><br><span class="line">bbfaa25db775: Pull complete </span><br><span class="line">7bb6fb0cfb2b: Pull complete </span><br><span class="line">0723edc10c17: Pull complete </span><br><span class="line">24b3fdc4d1e3: Pull complete </span><br><span class="line">3122471704d5: Pull complete </span><br><span class="line">Digest: sha256:04ba374043ccd2fc5c593885c0eacddebabd5ca375f9323666f28dfd5a9710e3</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> nginx:latest</span><br><span class="line">docker.io/library/nginx:latest</span><br><span class="line">root@VM-16-10-ubuntu:/home/ubuntu<span class="comment"># docker images</span></span><br><span class="line">REPOSITORY    TAG       IMAGE ID       CREATED         SIZE</span><br><span class="line">nginx         latest    39286ab8a5e1   5 weeks ago     188MB</span><br><span class="line">hello-world   latest    d2c94e258dcb   16 months ago   13.3kB</span><br><span class="line">centos        latest    5d0da3dc9764   3 years ago     231MB</span><br><span class="line">root@VM-16-10-ubuntu:/home/ubuntu<span class="comment"># docker run -it -d --name nginx01 -p 3344:80 nginx 启动nginx</span></span><br><span class="line">6c511e58320a06a81eeec1708d7fecd85486d8b879711ab3993e6599849cb5d6</span><br><span class="line">root@VM-16-10-ubuntu:/home/ubuntu<span class="comment"># docker ps  查看nginx容器</span></span><br><span class="line">CONTAINER ID   IMAGE     COMMAND                  CREATED          STATUS          PORTS                                   NAMES</span><br><span class="line">6c511e58320a   nginx     <span class="string">&quot;/docker-entrypoint.…&quot;</span>   28 seconds ago   Up 28 seconds   0.0.0.0:3344-&gt;80/tcp, :::3344-&gt;80/tcp   nginx01</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-22/427e9af89ddfbabc7c02f78814a92408--610e--image-20240922105436716.png" alt="image-20240922105436716"></p>
<p>成功搭建（注意这里需要服务器开启对应的3344端口，外界才能访问到）</p>
<p><strong><code>docker run -it -d --name nginx02 -p 3344:80 nginx</code>解释</strong></p>
<ul>
<li><code>docker run</code>：启动一个新的容器</li>
<li><code>-it</code>：表示启用交互式终端并分配一个伪终端，这样我们可以在容器中交互式地执行命令。</li>
<li><code>-d</code>：表示将容器运行在后台（守护进程）。</li>
<li><code>--name nginx02</code>：给容器起一个名字叫做 <code>nginx02</code>。</li>
<li><code>-p 3344:80</code>：将主机的 3344 端口映射到容器的 80 端口，这样我们就可以通过主机的 3344 端口来访问容器内的 Nginx 服务。</li>
<li><code>nginx</code>：表示要启动的镜像名称为 <code>nginx</code>。</li>
</ul>
<p>因此，这个命令的作用是在 Docker 中启动一个名为 <code>nginx02</code> 的容器，运行 Nginx 服务，并将容器的 80 端口映射到主机的 3344 端口，以便我们可以通过访问主机的 3344 端口来访问 Nginx 服务。容器会在后台运行，并启用交互式终端。</p>
<h2 id="2、安装一个tomcat"><a href="#2、安装一个tomcat" class="headerlink" title="2、安装一个tomcat"></a>2、安装一个tomcat</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">root@VM-16-10-ubuntu:/home/ubuntu<span class="comment"># docker pull tomcat  拉取镜像</span></span><br><span class="line">Using default tag: latest</span><br><span class="line">latest: Pulling from library/tomcat</span><br><span class="line">32b824d45c61: Pull complete </span><br><span class="line">fe18bb7e114f: Pull complete </span><br><span class="line">581ebfe08d3f: Pull complete </span><br><span class="line">7c7bdd063feb: Pull complete </span><br><span class="line">28f1e2918031: Pull complete </span><br><span class="line">dbce9ebf04f0: Pull complete </span><br><span class="line">4f4fb700ef54: Pull complete </span><br><span class="line">2963b9c3d96f: Pull complete </span><br><span class="line">Digest: sha256:0298f25ea8171042fe610457ff0fd72382d36a144eae4483e2784bbbae31d68b</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> tomcat:latest</span><br><span class="line">docker.io/library/tomcat:latest</span><br><span class="line">root@VM-16-10-ubuntu:/home/ubuntu<span class="comment"># docker run -d -p 3355:8080 --name tomcat01 tomcat  启动容器</span></span><br><span class="line">c0186e2559f5fe67ca6b32f386859ea1a3028572c42c93237ef746581c59361e</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-22/9711f3688d4cf560af0826f568ab9078--c194--image-20240922110708559.png" alt="image-20240922110708559"></p>
<p>发现服务可以访问，但是没有页面</p>
<p>进入服务</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@VM-16-10-ubuntu:/home/ubuntu<span class="comment"># docker exec -it c0186e2559 /bin/bash 进入容器</span></span><br><span class="line">root@c0186e2559f5:/usr/local/tomcat/webapps<span class="comment"># ls</span></span><br></pre></td></tr></table></figure>

<p>发现webapp下为空</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 原因：阿里云镜像的原因，阿里云默认是最小的镜像，所以不必要的都剔除掉</span><br><span class="line"># 保证最小可运行的环境！</span><br></pre></td></tr></table></figure>

<p>解决方案：将webapps.dist下的文件都拷贝到webapps下即可</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@c0186e2559f5:/usr/local/tomcat<span class="comment"># cp -r webapps.dist/* webapps</span></span><br></pre></td></tr></table></figure>

<p>刷新一下服务，就有页面了</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-22/8f92f4b563b758a8b61da0eaabd8e257--ae1f--image-20240922111002319.png" alt="image-20240922111002319"></p>
<p>问题:我们以后要部署项目，如果每次都要进入容器是不是十分麻烦？要是可以在容器外部提供一个映射路径，比如webapps，我们在外部放置项目，就自动同步内部就好了！</p>
<h2 id="3、Docker安装Elesticsearch"><a href="#3、Docker安装Elesticsearch" class="headerlink" title="3、Docker安装Elesticsearch"></a>3、Docker安装Elesticsearch</h2><p>elasticsearch暴露的端口很多</p>
<p>十分耗内存（所以体现测试的时候可以提前把其他docker容器先停止，启动时可以限制堆内存大小）</p>
<p>es 的数据一般需要放置到安全目录！挂载</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">root@VM-16-10-ubuntu:/home/ubuntu<span class="comment"># docker run -d --name es -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; -e ES_JAVA_OPTS=&quot;-Xms64m -Xmx512m&quot; elasticsearch:7.6.2</span></span><br><span class="line">Unable to find image <span class="string">&#x27;elasticsearch:7.6.2&#x27;</span> locally</span><br><span class="line">7.6.2: Pulling from library/elasticsearch</span><br><span class="line">ab5ef0e58194: Pull complete </span><br><span class="line">c4d1ca5c8a25: Pull complete </span><br><span class="line">941a3cc8e7b8: Pull complete </span><br><span class="line">43ec483d9618: Pull complete </span><br><span class="line">c486fd200684: Pull complete </span><br><span class="line">1b960df074b2: Pull complete </span><br><span class="line">1719d48d6823: Pull complete </span><br><span class="line">Digest: sha256:1b09dbd93085a1e7bca34830e77d2981521a7210e11f11eda997add1c12711fa</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> elasticsearch:7.6.2</span><br><span class="line">6861a387a1cac6856d948d54b5ec3db63b04f762d0deb2a7f7ba4e77af3d7a62</span><br><span class="line">root@VM-16-10-ubuntu:/home/ubuntu<span class="comment"># curl localhost:9200</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span> : <span class="string">&quot;6861a387a1ca&quot;</span>,</span><br><span class="line">  <span class="string">&quot;cluster_name&quot;</span> : <span class="string">&quot;docker-cluster&quot;</span>,</span><br><span class="line">  <span class="string">&quot;cluster_uuid&quot;</span> : <span class="string">&quot;b2Wz4EljT7qCteo0VMyFMQ&quot;</span>,</span><br><span class="line">  <span class="string">&quot;version&quot;</span> : &#123;</span><br><span class="line">    <span class="string">&quot;number&quot;</span> : <span class="string">&quot;7.6.2&quot;</span>,</span><br><span class="line">    <span class="string">&quot;build_flavor&quot;</span> : <span class="string">&quot;default&quot;</span>,</span><br><span class="line">    <span class="string">&quot;build_type&quot;</span> : <span class="string">&quot;docker&quot;</span>,</span><br><span class="line">    <span class="string">&quot;build_hash&quot;</span> : <span class="string">&quot;ef48eb35cf30adf4db14086e8aabd07ef6fb113f&quot;</span>,</span><br><span class="line">    <span class="string">&quot;build_date&quot;</span> : <span class="string">&quot;2020-03-26T06:34:37.794943Z&quot;</span>,</span><br><span class="line">    <span class="string">&quot;build_snapshot&quot;</span> : <span class="literal">false</span>,</span><br><span class="line">    <span class="string">&quot;lucene_version&quot;</span> : <span class="string">&quot;8.4.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;minimum_wire_compatibility_version&quot;</span> : <span class="string">&quot;6.8.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;minimum_index_compatibility_version&quot;</span> : <span class="string">&quot;6.0.0-beta1&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;tagline&quot;</span> : <span class="string">&quot;You Know, for Search&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@VM-16-10-ubuntu:/home/ubuntu<span class="comment"># docker stats   #查看cpu状态</span></span><br><span class="line">CONTAINER ID   NAME      CPU %     MEM USAGE / LIMIT     MEM %     NET I/O           BLOCK I/O         PIDS</span><br><span class="line">6861a387a1ca   es        3.26%     368.8MiB / 1.918GiB   18.78%    4.11kB / 3.75kB   6.16MB / 2.03MB   45</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-22/b2631e9ff0347714db21901b08846644--be00--image-20240922112744309.png" alt="image-20240922112744309"></p>
<p><strong><code>docker run -d --name es -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; -e ES_JAVA_OPTS=&quot;-Xms64m -Xmx512m&quot; elasticsearch:7.6.2</code>命令解释</strong></p>
<p>这是一个使用 Docker 命令行工具来启动一个 Elasticsearch 版本为 7.6.2 的容器，并设置了一些选项和参数。</p>
<p>具体来说，这些选项和参数的含义如下：</p>
<ul>
<li><code>-d</code> 表示在后台运行容器，即以“守护进程”模式运行，不会占用当前终端的控制台；</li>
<li><code>--name es</code> 表示给容器起一个名称为 “es”；</li>
<li><code>-p 9200:9200 -p 9300:9300</code> 表示将容器内部的 9200 端口和 9300 端口映射到主机的 9200 和 9300 端口上，以便在主机上通过浏览器或客户端连接 Elasticsearch；</li>
<li><code>-e &quot;discovery.type=single-node&quot;</code> 表示设置 Elasticsearch 的节点类型为 “single-node”，即单节点模式，这是一个简单的运行 Elasticsearch 的方式，适用于测试或开发环境；</li>
<li><code>-e ES_JAVA_OPTS=&quot;-Xms64m -Xmx512m&quot;</code> 表示设置 Elasticsearch 的 Java 虚拟机参数，其中 “-Xms64m” 表示设置初始堆大小为 64MB，”-Xmx512m” 表示设置最大堆大小为 512MB；</li>
<li><code>elasticsearch:7.6.2</code> 表示要运行的容器镜像名称和版本号，这里是 Elasticsearch 官方提供的 7.6.2 版本。</li>
</ul>
<p>总体来说，这个命令的作用是在 Docker 中启动一个 Elasticsearch 7.6.2 的容器，并将容器内部的端口映射到主机上，以便在主机上访问 Elasticsearch。其中的选项和参数可以根据需要进行修改或调整。</p>
<h1 id="五、portainer可视化面板安装"><a href="#五、portainer可视化面板安装" class="headerlink" title="五、portainer可视化面板安装"></a>五、portainer可视化面板安装</h1><ul>
<li>portainer(先用这个)</li>
<li>rancher(CI&#x2F;DI再用)</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@VM-16-10-ubuntu:/home/ubuntu<span class="comment"># docker run -d -p 8088:9000 --restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true portainer/portainer</span></span><br><span class="line">Unable to find image <span class="string">&#x27;portainer/portainer:latest&#x27;</span> locally</span><br><span class="line">latest: Pulling from portainer/portainer</span><br><span class="line">772227786281: Pull complete </span><br><span class="line">96fd13befc87: Pull complete </span><br><span class="line">0bad1d247b5b: Pull complete </span><br><span class="line">b5d1b01b1d39: Pull complete </span><br><span class="line">Digest: sha256:47b064434edf437badf7337e516e07f64477485c8ecc663ddabbe824b20c672d</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> portainer/portainer:latest</span><br><span class="line">8de613bef9cc0af508c8db2433789ee570f1a7737260130c36ab03d7fcfd54a9</span><br></pre></td></tr></table></figure>

<p><strong><code>docker run -d -p 8088:9000 --restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true portainer/portainer</code>解释</strong></p>
<p>这是一个用于运行 Docker 容器的 Docker 命令。具体来说，该命令启动了一个名为 Portainer 的 Docker 容器，并将容器的 9000 端口映射到主机的 8088 端口，以便在主机上通过浏览器访问 Portainer。</p>
<p>以下是各个参数的含义：</p>
<ul>
<li><code>-d</code>：表示以后台模式运行容器。</li>
<li><code>-p 8088:9000</code>：表示将容器的 9000 端口映射到主机的 8088 端口。</li>
<li><code>--restart=always</code>：表示容器在停止后总是会自动重启。</li>
<li><code>-v /var/run/docker.sock:/var/run/docker.sock</code>：表示将主机的 Docker 守护进程的 Unix 套接字文件（&#x2F;var&#x2F;run&#x2F;docker.sock）挂载到容器的同一位置，从而让 Portainer 可以管理主机上的其他 Docker 容器。</li>
<li><code>--privileged=true</code>：表示在容器中开启特权模式，以便 Portainer 能够访问主机上的 Docker 守护进程。</li>
</ul>
<p>总之，这个命令的作用是在主机上启动一个 Portainer 容器，以便通过 web 界面来管理和监控其他 Docker 容器。</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-22/5ed9c8b958e7da80cce2ec4be260697e--a128--image-20240922151045620.png" alt="image-20240922151045620"></p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-22/1723b6decc7608a24c3ab59cf2dadd75--6e31--image-20240922151150791.png" alt="image-20240922151150791"></p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-22/3af376d05b8b74bd529ba6cee95b464d--6a23--image-20240922151227485.png" alt="image-20240922151227485"></p>
<ul>
<li>使用图形化界面对docker容器镜像进行对应的管理</li>
</ul>
<h1 id="六、Docker镜像"><a href="#六、Docker镜像" class="headerlink" title="六、Docker镜像"></a>六、Docker镜像</h1><h2 id="1、镜像是什么"><a href="#1、镜像是什么" class="headerlink" title="1、镜像是什么"></a>1、镜像是什么</h2><p>镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含</p>
<p>运行某个软件所需的所有内容，包括代码、运行时、库、环境变量和配置文件。</p>
<h2 id="2、Docker镜像加载原理"><a href="#2、Docker镜像加载原理" class="headerlink" title="2、Docker镜像加载原理"></a>2、Docker镜像加载原理</h2><blockquote>
<p>UnionFS(联合文件系统)</p>
</blockquote>
<p>UnionFS（联合文件系统）：Union文件系统（UnionFS）是一种分层、轻量级并且高性能的文件系统，</p>
<p>它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系</p>
<p>统下(unite several directories into a single virtual fifilesystem)。Union 文件系统是 Docker 镜像的基</p>
<p>础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。</p>
<p>特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件</p>
<p>系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录</p>
<blockquote>
<p>docker镜像加载原理</p>
</blockquote>
<p>docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统UnionFS。</p>
<p>bootfs(boot fifile system)主要包含bootloader和kernel, bootloader主要是引导加载kernel, Linux刚启</p>
<p>动时会加载bootfs文件系统，在Docker镜像的最底层是bootfs。这一层与我们典型的Linux&#x2F;Unix系统是</p>
<p>一样的，包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已</p>
<p>由bootfs转交给内核，此时系统也会卸载bootfs。 </p>
<p>rootfs (root fifile system) ，在bootfs之上。包含的就是典型 Linux 系统中的 &#x2F;dev, &#x2F;proc, &#x2F;bin, &#x2F;etc 等标</p>
<p>准目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu，Centos等等。</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-22/6bbe15637a9c22909ba22cf0ea4aa6d0--89e1--image-20240922152448693.png" alt="image-20240922152448693"></p>
<p>平时我们安装进虚拟机的CentOS都是好几个G，为什么Docker这里才200M？</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-22/bbdf1be4d587d57210e07181711d1724--2253--image-20240922152528402.png" alt="image-20240922152528402"></p>
<p>对于一个精简的OS，rootfs 可以很小，只需要包含最基本的命令，工具和程序库就可以了，因为底层直</p>
<p>接用Host的kernel，自己只需要提供rootfs就可以了。由此可见对于不同的linux发行版, bootfs基本是一</p>
<p>致的, rootfs会有差别, 因此不同的发行版可以公用bootfs。 </p>
<h2 id="3、分层理解"><a href="#3、分层理解" class="headerlink" title="3、分层理解"></a>3、分层理解</h2><p>我们可以去下载一个镜像，注意观察下载的日志输出，可以看到是一层一层的在下载！</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">root@VM-16-10-ubuntu:/home/ubuntu<span class="comment"># docker pull redis</span></span><br><span class="line">Using default tag: latest</span><br><span class="line">latest: Pulling from library/redis</span><br><span class="line">a2318d6c47ec: Pull complete </span><br><span class="line">ed7fd66f27f2: Pull complete </span><br><span class="line">410a3d5b3155: Pull complete </span><br><span class="line">9312cf3f6b3e: Pull complete </span><br><span class="line">c39877ab23d0: Pull complete </span><br><span class="line">01394ffc7248: Pull complete </span><br><span class="line">4f4fb700ef54: Pull complete </span><br><span class="line">5a03cb6163ab: Pull complete </span><br><span class="line">Digest: sha256:eadf354977d428e347d93046bb1a5569d701e8deb68f090215534a99dbcb23b9</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> redis:latest</span><br><span class="line">docker.io/library/redis:latest</span><br></pre></td></tr></table></figure>

<p>思考：为什么Docker镜像要采用这种分层的结构呢？</p>
<p>最大的好处，我觉得莫过于是资源共享了！比如有多个镜像都从相同的Base镜像构建而来，那么宿主机</p>
<p>只需在磁盘上保留一份base镜像，同时内存中也只需要加载一份base镜像，这样就可以为所有的容器服</p>
<p>务了，而且镜像的每一层都可以被共享。</p>
<p>查看镜像分层的方式可以通过 <code>docker image inspect</code> 命令！</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;RootFS&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;Type&quot;</span>: <span class="string">&quot;layers&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Layers&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;sha256:8e2ab394fabf557b00041a8f080b10b4e91c7027b7c174f095332c7ebb6501cb&quot;</span>,</span><br><span class="line">                <span class="string">&quot;sha256:9a978e3d8066b448323af0ea471da443c1e9da9dd8d0663d380b6af6a5ef14ed&quot;</span>,</span><br><span class="line">                <span class="string">&quot;sha256:a64e92ee12394b08486442cb272116d6b0a4f363748434316a2e9ed2fdd379c0&quot;</span>,</span><br><span class="line">                <span class="string">&quot;sha256:40710ab1222c055362a531507662df6177a4a2c97095b5ead8389c1e5b797615&quot;</span>,</span><br><span class="line">                <span class="string">&quot;sha256:15ef09f0323042ab4d842cd2d5d53d1cdd99414ee787d08f7d7064bf69d2d146&quot;</span>,</span><br><span class="line">                <span class="string">&quot;sha256:e4dbf0bd9d9df4561e608086d426c8edca8dd2fd9b83b2bc76b4fbc88066fc1d&quot;</span>,</span><br><span class="line">                <span class="string">&quot;sha256:5f70bf18a086007016e948b04aed3b82103a36bea41755b6cddfaf10ace3c6ef&quot;</span>,</span><br><span class="line">                <span class="string">&quot;sha256:950a085c0a1cd3e27102081e4a7bfb4bd0a624325b1cd3caf71f0d5f5eced6b6&quot;</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>理解：</p>
<p>所有的 Docker 镜像都起始于一个基础镜像层，当进行修改或增加新的内容时，就会在当前镜像层之</p>
<p>上，创建新的镜像层。</p>
<p>举一个简单的例子，假如基于 Ubuntu Linux 16.04 创建一个新的镜像，这就是新镜像的第一层；如果</p>
<p>在该镜像中添加 Python包，就会在基础镜像层之上创建第二个镜像层；如果继续添加一个安全补丁，就</p>
<p>会创建第三个镜像层。</p>
<p>该镜像当前已经包含 3 个镜像层，如下图所示（这只是一个用于演示的很简单的例子）。</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-22/f9c144e64ca90a0bb064c43099abc990--97ab--image-20240922152707544.png" alt="image-20240922152707544"></p>
<p>上图中的镜像层跟之前图中的略有区别，主要目的是便于展示文件。</p>
<p>下图中展示了一个稍微复杂的三层镜像，在外部看来整个镜像只有 6 个文件，这是因为最上层中的文件</p>
<p>7 是文件 5 的一个更新版本。</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-22/89e58c04d92f0d2023bf15fba34c7dc9--1bf4--image-20240922152716981.png" alt="image-20240922152716981"></p>
<p>这种情况下，上层镜像层中的文件覆盖了底层镜像层中的文件。这样就使得文件的更新版本作为一个新</p>
<p>镜像层添加到镜像当中。</p>
<p>Docker 通过存储引擎（新版本采用快照机制）的方式来实现镜像层堆栈，并保证多镜像层对外展示为统</p>
<p>一的文件系统。</p>
<p>Linux 上可用的存储引擎有 AUFS、Overlay2、Device Mapper、Btrfs 以及 ZFS。顾名思义，每种存储</p>
<p>引擎都基于 Linux 中对应的文件系统或者块设备技术，并且每种存储引擎都有其独有的性能特点。</p>
<p>Docker 在 Windows 上仅支持 windowsfifilter 一种存储引擎，该引擎基于 NTFS 文件系统之上实现了分</p>
<p>层和 CoW。</p>
<p>下图展示了与系统显示相同的三层镜像。所有镜像层堆叠并合并，对外提供统一的视图。</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-22/1a734a4154eeeaac48593ce23297d7ad--628f--image-20240922152734675.png" alt="image-20240922152734675"></p>
<blockquote>
<p>特点</p>
</blockquote>
<p>Docker镜像都是只读的，当容器启动时，一个新的可写层被加载到镜像的顶部！</p>
<p>这一层就是我们通常说的容器层，容器之下的都叫镜像层！</p>
<h2 id="4、镜像commit"><a href="#4、镜像commit" class="headerlink" title="4、镜像commit"></a>4、镜像commit</h2><p><strong>docker commit</strong> <strong>从容器创建一个新的镜像。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker commit 提交容器副本使之成为一个新的镜像！</span><br><span class="line"></span><br><span class="line"># 语法 </span><br><span class="line">docker commit -m=&quot;提交的描述信息&quot; -a=&quot;作者&quot; 容器id 要创建的目标镜像名:[标签名]</span><br></pre></td></tr></table></figure>

<p>实际操作</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@VM-16-10-ubuntu:/home/ubuntu<span class="comment"># docker run -it -p 3355:8080 --name tomcat01 tomcat  启动tomcat</span></span><br><span class="line">root@c8e254e9555b:/usr/local/tomcat<span class="comment"># cp -r webapps.dist/* webapps   进行tomcat的修改</span></span><br><span class="line">root@VM-16-10-ubuntu:/home/ubuntu<span class="comment"># docker commit -a=&quot;6pc1&quot; -m=&quot;add webapps tomcat&quot; c8e254e9555b mytomcat:1.0  将新的容器提交</span></span><br><span class="line">sha256:c4cc1b3de0ff0849bccb0dffa83397f0a6ff1af3a4907bca933856a5da04745a</span><br><span class="line">root@VM-16-10-ubuntu:/home/ubuntu<span class="comment"># docker images  成功提交对应镜像</span></span><br><span class="line">REPOSITORY   TAG       IMAGE ID       CREATED          SIZE</span><br><span class="line">mytomcat     1.0       c4cc1b3de0ff   13 seconds ago   474MB</span><br><span class="line">tomcat       latest    7f14c7d5cf60   4 days ago       469MB</span><br><span class="line">redis        latest    590b81f2fea1   7 weeks ago      117MB</span><br><span class="line">centos       latest    5d0da3dc9764   3 years ago      231MB</span><br></pre></td></tr></table></figure>

<p>如果你想要保存你当前的状态，可以通过commit，来提交镜像，方便使用，类似于 VM 中的快照！</p>
<h1 id="七、容器数据卷"><a href="#七、容器数据卷" class="headerlink" title="七、容器数据卷"></a>七、容器数据卷</h1><h2 id="1、什么是容器数据卷"><a href="#1、什么是容器数据卷" class="headerlink" title="1、什么是容器数据卷"></a>1、什么是容器数据卷</h2><p><strong>docker的理念回顾：</strong></p>
<p>将应用和运行的环境打包形成容器运行，运行可以伴随着容器，但是我们对于数据的要求，是希望能够</p>
<p>持久化的！</p>
<p>就好比，你安装一个MySQL，结果你把容器删了，就相当于删库跑路了，这TM也太扯了吧！</p>
<p>所以我们希望容器之间有可能可以共享数据，Docker容器产生的数据，如果不通过docker commit 生成</p>
<p>新的镜像，使得数据作为镜像的一部分保存下来，那么当容器删除后，数据自然也就没有了！这样是行</p>
<p>不通的！</p>
<p>为了能保存数据在Docker中我们就可以使用卷！让数据挂载到我们本地！这样数据就不会因为容器删除</p>
<p>而丢失了！</p>
<p><strong>作用：</strong></p>
<p>卷就是目录或者文件，存在一个或者多个容器中，由docker挂载到容器，但不属于联合文件系统，因此</p>
<p>能够绕过 Union File System ， 提供一些用于持续存储或共享数据的特性</p>
<p>卷的设计目的就是数据的持久化，完全独立于容器的生存周期，因此Docker不会在容器删除时删除其挂</p>
<p>载的数据卷</p>
<p><strong>特点：</strong></p>
<ol>
<li>数据卷可在容器之间共享或重用数据</li>
<li>卷中的更改可以直接生效</li>
<li>数据卷中的更改不会包含在镜像的更新中</li>
<li>数据卷的生命周期一直持续到没有容器使用它为止</li>
</ol>
<p><strong>所以：总结一句话： 就是容器的持久化，以及容器间的继承和数据共享！</strong></p>
<h2 id="2、使用容器数据卷"><a href="#2、使用容器数据卷" class="headerlink" title="2、使用容器数据卷"></a>2、使用容器数据卷</h2><blockquote>
<p>方式一：容器中直接使用命令来添加</p>
</blockquote>
<p>挂载</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">命令</span><br><span class="line"><span class="comment"># docker run -it -v 宿主机绝对路径目录:容器内目录 镜像名</span></span><br><span class="line">测试</span><br><span class="line"><span class="comment"># docker run -it -v /home/test:/home centos /bin/bash</span></span><br></pre></td></tr></table></figure>

<p>查看数据卷是否挂载成功<code>docker inspect 容器id</code></p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-22/2eba256a73aa2ce5c8c6877044c1f6d9--61d8--image-20240922162754059.png" alt="image-20240922162754059"></p>
<p>测试容器和宿主机之间数据共享：可以发现，在容器中，创建的会在宿主机中看到！</p>
<p>测试容器停止退出后，主机修改数据是否会同步！</p>
<ol>
<li>停止容器</li>
<li>在宿主机上修改文件</li>
<li>启动刚才停止的容器</li>
<li>然后查看对应的文件，发现数据依旧同步</li>
</ol>
<blockquote>
<p>实战：使用docker安装mysql</p>
</blockquote>
<p>思考：mysql 数据持久化的问题！</p>
<ol>
<li><p>下载镜像</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">root@VM-16-10-ubuntu:/home/ubuntu<span class="comment"># docker pull mysql:5.7</span></span><br><span class="line">5.7: Pulling from library/mysql</span><br><span class="line">20e4dcae4c69: Pull complete </span><br><span class="line">1c56c3d4ce74: Pull complete </span><br><span class="line">e9f03a1c24ce: Pull complete </span><br><span class="line">68c3898c2015: Pull complete </span><br><span class="line">6b95a940e7b6: Pull complete </span><br><span class="line">90986bb8de6e: Pull complete </span><br><span class="line">ae71319cb779: Pull complete </span><br><span class="line">ffc89e9dfd88: Pull complete </span><br><span class="line">43d05e938198: Pull complete </span><br><span class="line">064b2d298fba: Pull complete </span><br><span class="line">df9a4d85569b: Pull complete </span><br><span class="line">Digest: sha256:4bc6bc963e6d8443453676cae56536f4b8156d78bae03c0145cbe47c2aad73bb</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> mysql:5.7</span><br><span class="line">docker.io/library/mysql:5.7	</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动容器</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@VM-16-10-ubuntu:/home/ubuntu<span class="comment"># docker run -d -p 3310:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql:5.7</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>可以成功同步对应的信息，使用mysql连接工具就可以变相直接控制docker内的数据库了</p>
</li>
</ol>
<p><code>docker run -d -p 3310:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql:5.7</code>命名解释</p>
<p>这个命令使用 Docker 运行 MySQL 5.7 容器，并做出以下配置：</p>
<ul>
<li><code>-d</code> 表示容器在后台运行（即“守护进程”模式）。</li>
<li><code>-p 3310:3306</code> 将容器内的 MySQL 端口 3306 映射到主机的端口 3310 上，这样你就可以通过主机上的端口 3310 访问 MySQL 服务。</li>
<li><code>-v /home/mysql/conf:/etc/mysql/conf.d</code> 将主机上的目录 <code>/home/mysql/conf</code> 挂载到容器的 <code>/etc/mysql/conf.d</code> 目录中，这样你可以在主机上编辑 MySQL 配置文件，并且它们会在容器内生效。</li>
<li><code>-v /home/mysql/data:/var/lib/mysql</code> 将主机上的目录 <code>/home/mysql/data</code> 挂载到容器的 <code>/var/lib/mysql</code> 目录中，这样你可以在主机上保存 MySQL 数据文件，并且它们会在容器内生效。</li>
<li><code>-e MYSQL_ROOT_PASSWORD=123456</code> 设置 MySQL root 用户的密码为 <code>123456</code>。</li>
<li><code>--name mysql01</code> 指定容器的名称为 <code>mysql01</code>，以便于管理和查找。</li>
<li><code>mysql:5.7</code> 指定使用官方提供的 MySQL 5.7 镜像。</li>
</ul>
<p>这个命令的作用是在 Docker 中创建并运行一个 MySQL 容器，同时将主机上的目录挂载到容器中，以便于配置和保存数据。</p>
<h2 id="3、匿名和具名挂载"><a href="#3、匿名和具名挂载" class="headerlink" title="3、匿名和具名挂载"></a>3、匿名和具名挂载</h2><ul>
<li>-v 容器内路径         #匿名挂载</li>
<li>-v 卷名:容器内路径      #具名挂载</li>
<li>-v &#x2F;宿主机路径:容器内路径   #指定路径挂载</li>
</ul>
<h2 id="4、初识Dockerfile"><a href="#4、初识Dockerfile" class="headerlink" title="4、初识Dockerfile"></a>4、初识Dockerfile</h2><p>DockerFile 是用来构建Docker镜像的构建文件，是由一些列命令和参数构成的脚本。</p>
<p>我们在这里，先体验下，后面我们会详细讲解 DockerFile ！</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1.进入宿主机目录，在目录下再创建一个目录docker-test-volume，在这个新建目录下新建一个文件dockerfile</span></span><br><span class="line">root@VM-16-10-ubuntu:/home/ubuntu/test<span class="comment"># mkdir docker-test-volumn</span></span><br><span class="line">root@VM-16-10-ubuntu:/home/ubuntu/test<span class="comment"># cd docker-test-volumn/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.编辑dockerfile1这个文件</span></span><br><span class="line"><span class="comment">#说明：在编写DockerFile文件中使用 VOLUME 指令来给镜像添加一个或多个数据卷</span></span><br><span class="line"><span class="comment">#出于可移植和分享的考虑，我们之前使用的 -v 主机目录:容器目录 这种方式不能够直接在 DockerFile中实现</span></span><br><span class="line"><span class="comment">#由于宿主机目录是依赖于特定宿主机的，并不能够保证在所有宿主机上都存在这样的特定目录</span></span><br><span class="line">root@VM-16-10-ubuntu:/home/ubuntu/test/docker-test-volumn<span class="comment"># vim dockerfile</span></span><br><span class="line">FROM centos</span><br><span class="line">VOLUME [<span class="string">&quot;volume1&quot;</span>,<span class="string">&quot;volume2&quot;</span>]</span><br><span class="line">CMD <span class="built_in">echo</span> <span class="string">&quot;-----end-----&quot;</span></span><br><span class="line">CMD /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment">#3.build后生成镜像，获得一个新镜像 my-centos</span></span><br><span class="line"><span class="comment">#注意最后有一个.</span></span><br><span class="line">root@VM-16-10-ubuntu:/home/ubuntu/test/docker-test-volumn<span class="comment"># docker build -t my-centos .</span></span><br><span class="line">[+] Building 0.3s (5/5) FINISHED                                                                    docker:default</span><br><span class="line"> =&gt; [internal] load build definition from dockerfile                                                          0.0s</span><br><span class="line"> =&gt; =&gt; transferring dockerfile: 123B                                                                          0.0s</span><br><span class="line"> =&gt; [internal] load metadata <span class="keyword">for</span> docker.io/library/centos:latest                                              0.0s</span><br><span class="line"> =&gt; [internal] load .dockerignore                                                                             0.0s</span><br><span class="line"> =&gt; =&gt; transferring context: 2B                                                                               0.0s</span><br><span class="line"> =&gt; [1/1] FROM docker.io/library/centos:latest                                                                0.0s</span><br><span class="line"> =&gt; exporting to image                                                                                        0.0s</span><br><span class="line"> =&gt; =&gt; exporting layers                                                                                       0.0s</span><br><span class="line"> =&gt; =&gt; writing image sha256:f0839ab2b921916360f89feb21d60cec317c13b76274d4c6de29d9d6bb404f52                  0.0s</span><br><span class="line"> =&gt; =&gt; naming to docker.io/library/my-centos                                                                  0.0s</span><br><span class="line">root@VM-16-10-ubuntu:/home/ubuntu/test/docker-test-volumn<span class="comment"># docker images</span></span><br><span class="line">REPOSITORY   TAG       IMAGE ID       CREATED             SIZE</span><br><span class="line">mytomcat     1.0       c4cc1b3de0ff   About an hour ago   474MB</span><br><span class="line">tomcat       latest    7f14c7d5cf60   4 days ago          469MB</span><br><span class="line">redis        latest    590b81f2fea1   7 weeks ago         117MB</span><br><span class="line">mysql        5.7       5107333e08a8   9 months ago        501MB</span><br><span class="line">my-centos    latest    f0839ab2b921   3 years ago         231MB</span><br><span class="line">centos       latest    5d0da3dc9764   3 years ago         231MB</span><br><span class="line"></span><br><span class="line"><span class="comment">#4.启动容器 发现数据卷目录volume1和volume2</span></span><br><span class="line">root@VM-16-10-ubuntu:/home/ubuntu/test/docker-test-volumn<span class="comment"># docker run -it f0839ab2b921 /bin/bash</span></span><br><span class="line">[root@20aafb95c23c /]<span class="comment"># ls</span></span><br><span class="line">bin  etc   lib	  lost+found  mnt  proc  run   srv  tmp  var	  volumn2</span><br><span class="line">dev  home  lib64  media       opt  root  sbin  sys  usr  volumn1</span><br><span class="line"><span class="comment">#5.进入容器，进入volume1目录，1.txt文件，然后退出容器</span></span><br><span class="line">[root@20aafb95c23c /]<span class="comment"># cd volumn1</span></span><br><span class="line">[root@20aafb95c23c volumn1]<span class="comment"># ls</span></span><br><span class="line">[root@20aafb95c23c volumn1]<span class="comment"># touch 1.txt</span></span><br><span class="line">[root@20aafb95c23c volumn1]<span class="comment"># ls</span></span><br><span class="line">1.txt</span><br><span class="line">[root@20aafb95c23c volumn1]<span class="comment"># exit</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line"><span class="comment">#问题:通过上述步骤，容器内的卷目录地址就已经知道了，但是对应的主机目录地址在哪里呢？</span></span><br><span class="line"><span class="comment">#6.查看容器信息</span></span><br><span class="line">root@VM-16-10-ubuntu:/home/ubuntu/test/docker-test-volumn<span class="comment"># docker ps -a</span></span><br><span class="line">CONTAINER ID   IMAGE          COMMAND       CREATED              STATUS                      PORTS     NAMES</span><br><span class="line">20aafb95c23c   f0839ab2b921   <span class="string">&quot;/bin/bash&quot;</span>   About a minute ago   Exited (0) 23 seconds ago             busy_greider</span><br><span class="line">root@VM-16-10-ubuntu:/home/ubuntu/test/docker-test-volumn<span class="comment"># docker inspect f0839ab2b921</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-22/25d8e823103f845e6a23f7221dc68d5a--07be--image-20240922170917802.png" alt="image-20240922170917802"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#8、发现宿主机文件</span></span><br><span class="line">root@VM-16-10-ubuntu:/home/ubuntu/test/docker-test-volume<span class="comment"># cd /var/lib/docker/volumes/5408b9e55fc0210903273841542b6fdb1cf0e3e1286994f19d08db8c78c6963b/_data</span></span><br><span class="line">root@VM-16-10-ubuntu:/var/lib/docker/volumes/5408b9e55fc0210903273841542b6fdb1cf0e3e1286994f19d08db8c78c6963b/_data<span class="comment"># ls</span></span><br><span class="line">1.txt</span><br></pre></td></tr></table></figure>

<p>注意：如果访问出现了 cannot open directory: Permission denied</p>
<p>解决办法：在挂载目录后多加一个 –privileged&#x3D;true参数即可</p>
<h2 id="5、数据卷容器"><a href="#5、数据卷容器" class="headerlink" title="5、数据卷容器"></a>5、数据卷容器</h2><p>命名的容器挂载数据卷，其他容器通过挂载这个（父容器）实现数据共享，挂载数据卷的容器，称之为</p>
<p>数据卷容器。</p>
<p>我们使用上一步的镜像：my-centos 为模板，运行容器 docker01，docker02，docker03，他</p>
<p>们都会具有容器卷volume1和volume2</p>
<p><strong>我们来测试下，容器间传递共享</strong></p>
<ol>
<li><p>用my-centos镜像，启动容器docker01，在volume2目录下新建一个文件from_docker01.txt</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@VM-16-10-ubuntu:/home/ubuntu<span class="comment"># docker run -it --name docker01 my-centos</span></span><br><span class="line">[root@a31ad75c98e6 /]<span class="comment"># cd volume2</span></span><br><span class="line">[root@a31ad75c98e6 volume2]<span class="comment"># touch from_docker01.txt</span></span><br><span class="line">[root@a31ad75c98e6 volume2]<span class="comment"># ls</span></span><br><span class="line">from_docker01.txt</span><br></pre></td></tr></table></figure>
</li>
<li><p>退出不停止容器：ctrl+p+q</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># root@VM-16-10-ubuntu:/home/ubuntu# docker ps</span></span><br><span class="line">CONTAINER ID   IMAGE       COMMAND                  CREATED              STATUS              PORTS     NAMES</span><br><span class="line">a31ad75c98e6   my-centos   <span class="string">&quot;/bin/sh -c /bin/bash&quot;</span>   About a minute ago   Up About a minute             docker01</span><br></pre></td></tr></table></figure>
</li>
<li><p>用my-centos镜像，启动容器docker02，让docker02继承docker01  <code>--volumes-from</code></p>
<p>在volume2目录下新建一个文件from_docker02.txt</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@VM-16-10-ubuntu:/home/ubuntu<span class="comment"># docker run -it --name docker02 --volumes-from docker01 my-centos</span></span><br><span class="line">[root@de7b3fc3cf53 /]<span class="comment"># cd volume2</span></span><br><span class="line">[root@de7b3fc3cf53 volume2]<span class="comment"># ls</span></span><br><span class="line">from_docker01.txt</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>容器之间配置信息的传递，数据卷的生命周期一直持续到没有容器使用它为止。</strong></p>
<p><strong>存储在本机的文件则会一直保留！</strong></p>
<h1 id="八、dockerfile"><a href="#八、dockerfile" class="headerlink" title="八、dockerfile"></a>八、dockerfile</h1><p>大家想想，Nginx，tomcat，mysql 这些镜像都是哪里来的？官方能写，我们不能写吗？</p>
<p>我们要研究自己如何做一个镜像，而且我们写的微服务项目以及springboot打包上云部署，Docker就是</p>
<p>最方便的。</p>
<p>微服务打包成镜像，任何装了Docker的地方，都可以下载使用，极其的方便。</p>
<p>流程：开发应用&#x3D;&gt;DockerFile&#x3D;&gt;打包为镜像&#x3D;&gt;上传到仓库（私有仓库，公有仓库）&#x3D;&gt; 下载镜像 &#x3D;&gt; 启动</p>
<p>运行。</p>
<p>还可以方便移植！</p>
<h2 id="1、什么是dockerfile"><a href="#1、什么是dockerfile" class="headerlink" title="1、什么是dockerfile"></a>1、什么是dockerfile</h2><p>dockerfifile是用来构建Docker镜像的构建文件，是由一系列命令和参数构成的脚本。</p>
<p>构建步骤：</p>
<ol>
<li>编写DockerFile文件</li>
<li>docker build 构建镜像</li>
<li>docker run</li>
</ol>
<p>dockerfifile文件我们刚才已经编写过了一次，这里我们继续使用 centos 来看！</p>
<p><a target="_blank" rel="noopener" href="https://hub.docker.com/_/centos">https://hub.docker.com/_/centos</a></p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-22/56b9338be70822d6aaca2a507ee2b04f--4fcc--image-20240922172857074.png" alt="image-20240922172857074"></p>
<h2 id="2、dockerfile的构建过程"><a href="#2、dockerfile的构建过程" class="headerlink" title="2、dockerfile的构建过程"></a>2、dockerfile的构建过程</h2><p><strong>基础知识</strong></p>
<ol>
<li>每条保留字指令都必须为大写字母且后面要跟随至少一个参数</li>
<li>指令按照从上到下，顺序执行</li>
<li># 表示注释</li>
<li>每条指令都会创建一个新的镜像层，并对镜像进行提交</li>
</ol>
<p><strong>流程：</strong></p>
<ol>
<li>docker从基础镜像运行一个容器</li>
<li>执行一条指令并对容器做出修改</li>
<li>执行类似 docker commit 的操作提交一个新的镜像层</li>
<li>Docker再基于刚提交的镜像运行一个新容器</li>
<li>执行dockerfifile中的下一条指令直到所有指令都执行完成！</li>
</ol>
<p><strong>说明：</strong></p>
<p>从应用软件的角度来看，DockerFile，docker镜像与docker容器分别代表软件的三个不同阶段。</p>
<ul>
<li>DockerFile 是软件的原材料 （代码）</li>
<li>Docker 镜像则是软件的交付品 （.apk）</li>
<li>Docker 容器则是软件的运行状态 （客户下载安装执行）</li>
</ul>
<p><strong>DockerFile 面向开发，Docker镜像成为交付标准，Docker容器则涉及部署与运维，三者缺一不可！</strong></p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-22/f5913e68843f79d565a56a4ef914875c--d5b3--image-20240922173620477.png" alt="image-20240922173620477"></p>
<p>DockerFile：需要定义一个DockerFile，DockerFile定义了进程需要的一切东西。DockerFile涉及的内容</p>
<p>包括执行代码或者是文件、环境变量、依赖包、运行时环境、动态链接库、操作系统的发行版、服务进</p>
<p>程和内核进程（当引用进行需要和系统服务和内核进程打交道，这时需要考虑如何设计 namespace的权</p>
<p>限控制）等等。</p>
<p>Docker镜像：在DockerFile 定义了一个文件之后，Docker build 时会产生一个Docker镜像，当运行</p>
<p>Docker 镜像时，会真正开始提供服务；</p>
<p>Docker容器：容器是直接提供服务的。</p>
<h2 id="3、Dockerfile指令"><a href="#3、Dockerfile指令" class="headerlink" title="3、Dockerfile指令"></a>3、Dockerfile指令</h2><p>关键字：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">FROM        <span class="comment"># 基础镜像，当前新镜像是基于哪个镜像的</span></span><br><span class="line">MAINTAINER  <span class="comment"># maintainer 镜像维护者的姓名和邮箱地址</span></span><br><span class="line">RUN         <span class="comment"># 容器构建时需要运行的命令</span></span><br><span class="line">EXPOSE      <span class="comment"># 当前容器对外暴露出的端口</span></span><br><span class="line">WORKDIR	    <span class="comment"># 指定在创建容器后，终端默认登录进来的工作目录，一个落脚点</span></span><br><span class="line">ENV         <span class="comment"># 用来在构建镜像过程中设置环境变量</span></span><br><span class="line">ADD         <span class="comment"># 将宿主机目录下的文件拷贝进镜像且ADD命令会自动处理URL和解压tar压缩包</span></span><br><span class="line">COPY        <span class="comment"># 类似ADD，拷贝文件和目录到镜像中！但是是不会自动解压文件，也不能访问网络资源</span></span><br><span class="line">VLIUME      <span class="comment"># 容器数据卷，用于数据保存和持久化工作</span></span><br><span class="line">CMD         <span class="comment"># 指定一个容器启动时要运行的命令，dockerFile中可以有多个CMD指令，但只有最 后一个生效！</span></span><br><span class="line">ENTRYPOINT  <span class="comment"># entrypoint 指定一个容器启动时要运行的命令！和CMD一样 可以追加命令</span></span><br><span class="line">ONBUILD     <span class="comment"># 当构建一个被继承的DockerFile时运行命令，父镜像在被子镜像继承后，父镜像的 ONBUILD被触发</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-23/b691757752d20b3ed9330eeecc587ec9--0eed--image-20240923190649837.png" alt="image-20240923190649837"></p>
<h2 id="4、实战测试"><a href="#4、实战测试" class="headerlink" title="4、实战测试"></a>4、实战测试</h2><p>Docker Hub 中99% 的镜像都是通过在base镜像（Scratch）中安装和配置需要的软件构建出来的</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-23/d3d17cf58aff5777ea3ecad37eb764d4--fd02--image-20240923190944663.png" alt="image-20240923190944663"></p>
<blockquote>
<p>自定一个centos镜像</p>
</blockquote>
<ol>
<li><p>编写dockerfile</p>
<p>直接运行centos的官方镜像</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@VM-16-10-ubuntu:/home/ubuntu/test/docker-test-volume<span class="comment"># docker run -it centos /bin/bash</span></span><br><span class="line">Unable to find image <span class="string">&#x27;centos:latest&#x27;</span> locally</span><br><span class="line">latest: Pulling from library/centos</span><br><span class="line">a1d0c7532777: Already exists </span><br><span class="line">Digest: sha256:a27fd8080b517143cbbbab9dfb7c8571c40d67d534bbdee55bd6c473f432b177</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> centos:latest</span><br><span class="line">[root@bcf6eb6bf82f /]<span class="comment"># vim a</span></span><br><span class="line">bash: vim: <span class="built_in">command</span> not found</span><br><span class="line">[root@bcf6eb6bf82f /]<span class="comment"># ifconfig</span></span><br><span class="line">bash: ifconfig: <span class="built_in">command</span> not found</span><br></pre></td></tr></table></figure>

<p>发现，不支持vim和ifconfig命令，登陆后的默认路径是&#x2F;</p>
<p>目的：使我们自己的镜像具备如下：登陆后的默认路径、vim编辑器、查看网络配置ifconfifig支持</p>
<p>准备编写DockerFlie文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">root@VM-16-10-ubuntu:/home/ubuntu/test/docker-test-volume<span class="comment"># vim mydockerfile-centos</span></span><br><span class="line">root@VM-16-10-ubuntu:/home/ubuntu/test/docker-test-volume<span class="comment"># cat mydockerfile-centos </span></span><br><span class="line">FROM centos</span><br><span class="line">MAINTATINER 6pc1&lt;pc6pc1@qq.com&gt;</span><br><span class="line"></span><br><span class="line">ENV MYPATH /usr/local</span><br><span class="line">WORKDIR <span class="variable">$MYPATH</span></span><br><span class="line"></span><br><span class="line">RUN <span class="built_in">cd</span> /etc/yum.repos.d/</span><br><span class="line">RUN sed -i <span class="string">&#x27;s/mirrorlist/#mirrorlist/g&#x27;</span> /etc/yum.repos.d/CentOS-*</span><br><span class="line">RUN sed -i <span class="string">&#x27;s|#baseurl=http://mirror.centos.org|baseurl=http://vault.centos.org|g&#x27;</span> /etc/yum.repos.d/CentOS-*</span><br><span class="line">RUN yum -y install vim</span><br><span class="line"></span><br><span class="line">RUN yun -y install net-tools</span><br><span class="line"></span><br><span class="line">EXPOSE 80</span><br><span class="line"></span><br><span class="line">CMD <span class="built_in">echo</span> <span class="variable">$MYPATH</span></span><br><span class="line">CMD <span class="built_in">echo</span> <span class="string">&quot;----end------&quot;</span></span><br><span class="line">CMD /bin/bash</span><br></pre></td></tr></table></figure>

<p>说明：dockerfile中直接<code>RUN yum -y install vim</code>可能会报下面错误</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#0 1.607 Error: Failed to download metadata for repo &#x27;appstream&#x27;: Cannot prepare internal mirrorlist: No URLs in mirrorlist</span></span><br></pre></td></tr></table></figure>

<p>说明下面这些，其实就是为了让<code>RUN yum -y install vim</code>可以执行成功</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RUN <span class="built_in">cd</span> /etc/yum.repos.d/</span><br><span class="line">RUN sed -i <span class="string">&#x27;s/mirrorlist/#mirrorlist/g&#x27;</span> /etc/yum.repos.d/CentOS-*</span><br><span class="line">RUN sed -i <span class="string">&#x27;s|#baseurl=http://mirror.centos.org|baseurl=http://vault.centos.org|g&#x27;</span> /etc/yum.repos.d/CentOS-*</span><br><span class="line">RUN yum -y install vim</span><br></pre></td></tr></table></figure>
</li>
<li><p>构建</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">root@VM-16-10-ubuntu:/home/ubuntu/test/docker-test-volume<span class="comment"># docker build -f mydockerfile-centos -t mycentos:1.0 .</span></span><br><span class="line">[+] Building 4.3s (11/11) FINISHED                                                                  docker:default</span><br><span class="line"> =&gt; [internal] load build definition from mydockerfile-centos                                                 0.0s</span><br><span class="line"> =&gt; =&gt; transferring dockerfile: 452B                                                                          0.0s</span><br><span class="line"> =&gt; [internal] load metadata <span class="keyword">for</span> docker.io/library/centos:latest                                              0.0s</span><br><span class="line"> =&gt; [internal] load .dockerignore                                                                             0.0s</span><br><span class="line"> =&gt; =&gt; transferring context: 2B                                                                               0.0s</span><br><span class="line"> =&gt; [1/7] FROM docker.io/library/centos:latest                                                                0.0s</span><br><span class="line"> =&gt; CACHED [2/7] WORKDIR /usr/local                                                                           0.0s</span><br><span class="line"> =&gt; CACHED [3/7] RUN <span class="built_in">cd</span> /etc/yum.repos.d/                                                                     0.0s</span><br><span class="line"> =&gt; CACHED [4/7] RUN sed -i <span class="string">&#x27;s/mirrorlist/#mirrorlist/g&#x27;</span> /etc/yum.repos.d/CentOS-*                            0.0s</span><br><span class="line"> =&gt; CACHED [5/7] RUN sed -i <span class="string">&#x27;s|#baseurl=http://mirror.centos.org|baseurl=http://vault.centos.org|g&#x27;</span> /etc/yum  0.0s</span><br><span class="line"> =&gt; CACHED [6/7] RUN yum -y install vim                                                                       0.0s</span><br><span class="line"> =&gt; [7/7] RUN yum -y install net-tools                                                                        3.4s</span><br><span class="line"> =&gt; exporting to image                                                                                        0.8s</span><br><span class="line"> =&gt; =&gt; exporting layers                                                                                       0.8s</span><br><span class="line"> =&gt; =&gt; writing image sha256:c3dec9b6a3f811c4d5e5038392822da54ab5e069560708059a1f8bc636eca32d                  0.0s </span><br><span class="line"> =&gt; =&gt; naming to docker.io/library/mycentos:1.0</span><br><span class="line"> root@VM-16-10-ubuntu:/home/ubuntu/test/docker-test-volume<span class="comment"># docker images</span></span><br><span class="line">REPOSITORY   TAG       IMAGE ID       CREATED          SIZE                                                        </span><br><span class="line">mycentos     1.0       c3dec9b6a3f8   30 seconds ago   312MB</span><br><span class="line">centos       latest    5d0da3dc9764   3 years ago      231MB</span><br></pre></td></tr></table></figure>

<p>命令：<code>docker build -f mydockerfile-centos -t mycentos:1.0 .</code>解释：</p>
<p>这是一个Docker命令，将使用指定的Dockerfile构建一个新的Docker镜像。</p>
<p>具体来说，该命令的各个部分的含义如下：</p>
<ul>
<li><code>docker build</code>：使用Docker命令构建新的镜像</li>
<li><code>-f mydockerfile-centos</code>：指定Dockerfile的名称为<code>mydockerfile-centos</code>。默认情况下，Docker使用当前目录下的名为<code>Dockerfile</code>的文件作为Dockerfile，但是在这里我们指定了一个不同的名称。</li>
<li><code>-t mycentos:1.0</code>：指定构建的镜像名称为<code>mycentos</code>，标签为<code>1.0</code>。标签可用于标识同一镜像的不同版本或变体。</li>
<li><code>.</code>：指定上下文路径，即构建过程中所使用的文件路径。这里的<code>.</code>表示使用当前目录作为上下文路径。</li>
</ul>
<p>因此，该命令的含义是使用<code>mydockerfile-centos</code>文件作为Dockerfile，将当前目录下的文件作为上下文构建一个名为<code>mycentos</code>、标签为<code>1.0</code>的新Docker镜像。</p>
</li>
<li><p>运行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">root@VM-16-10-ubuntu:/home/ubuntu/test/docker-test-volume<span class="comment"># docker run -it mycentos:1.0</span></span><br><span class="line">[root@391dcbf08c75 <span class="built_in">local</span>]<span class="comment"># pwd</span></span><br><span class="line">/usr/local</span><br><span class="line">[root@391dcbf08c75 <span class="built_in">local</span>]<span class="comment"># ifconfig</span></span><br><span class="line">eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 172.17.0.2  netmask 255.255.0.0  broadcast 172.17.255.255</span><br><span class="line">        ether 02:42:ac:11:00:02  txqueuelen 0  (Ethernet)</span><br><span class="line">        RX packets 9  bytes 806 (806.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;</span><br><span class="line">        loop  txqueuelen 1000  (Local Loopback)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">[root@391dcbf08c75 <span class="built_in">local</span>]<span class="comment"># vim a</span></span><br><span class="line">[root@391dcbf08c75 <span class="built_in">local</span>]<span class="comment"># ls</span></span><br><span class="line">a  bin	etc  games  include  lib  lib64  libexec  sbin	share  src</span><br></pre></td></tr></table></figure>
</li>
<li><p>列出镜像的历史</p>
<p><strong>docker history 镜像id</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">root@VM-16-10-ubuntu:/home/ubuntu/test/docker-test-volume<span class="comment"># docker history c3dec9b6a3f8</span></span><br><span class="line">IMAGE          CREATED         CREATED BY                                      SIZE      COMMENT</span><br><span class="line">c3dec9b6a3f8   5 minutes ago   CMD [<span class="string">&quot;/bin/sh&quot;</span> <span class="string">&quot;-c&quot;</span> <span class="string">&quot;/bin/bash&quot;</span>]                0B        buildkit.dockerfile.v0</span><br><span class="line">&lt;missing&gt;      5 minutes ago   CMD [<span class="string">&quot;/bin/sh&quot;</span> <span class="string">&quot;-c&quot;</span> <span class="string">&quot;echo \&quot;----end------\&quot;&quot;</span>]   0B        buildkit.dockerfile.v0</span><br><span class="line">&lt;missing&gt;      5 minutes ago   CMD [<span class="string">&quot;/bin/sh&quot;</span> <span class="string">&quot;-c&quot;</span> <span class="string">&quot;echo <span class="variable">$MYPATH</span>&quot;</span>]             0B        buildkit.dockerfile.v0</span><br><span class="line">&lt;missing&gt;      5 minutes ago   EXPOSE map[80/tcp:&#123;&#125;]                           0B        buildkit.dockerfile.v0</span><br><span class="line">&lt;missing&gt;      5 minutes ago   RUN /bin/sh -c yum -y install net-tools <span class="comment"># bu…   14.7MB    buildkit.dockerfile.v0</span></span><br><span class="line">&lt;missing&gt;      6 minutes ago   RUN /bin/sh -c yum -y install vim <span class="comment"># buildkit    66.3MB    buildkit.dockerfile.v0</span></span><br><span class="line">&lt;missing&gt;      6 minutes ago   RUN /bin/sh -c sed -i <span class="string">&#x27;s|#baseurl=http://mir…   8.8kB     buildkit.dockerfile.v0</span></span><br><span class="line"><span class="string">&lt;missing&gt;      6 minutes ago   RUN /bin/sh -c sed -i &#x27;</span>s/mirrorlist/<span class="comment">#mirrorl…   8.82kB    buildkit.dockerfile.v0</span></span><br><span class="line">&lt;missing&gt;      6 minutes ago   RUN /bin/sh -c <span class="built_in">cd</span> /etc/yum.repos.d/ <span class="comment"># buildk…   0B        buildkit.dockerfile.v0</span></span><br><span class="line">&lt;missing&gt;      6 minutes ago   WORKDIR /usr/local                              0B        buildkit.dockerfile.v0</span><br><span class="line">&lt;missing&gt;      6 minutes ago   ENV MYPATH=/usr/local                           0B        buildkit.dockerfile.v0</span><br><span class="line">&lt;missing&gt;      6 minutes ago   MAINTAINER 6pc1&lt;pc6pc1@qq.com&gt;                  0B        buildkit.dockerfile.v0</span><br><span class="line">&lt;missing&gt;      3 years ago     /bin/sh -c <span class="comment">#(nop)  CMD [&quot;/bin/bash&quot;]            0B        </span></span><br><span class="line">&lt;missing&gt;      3 years ago     /bin/sh -c <span class="comment">#(nop)  LABEL org.label-schema.sc…   0B        </span></span><br><span class="line">&lt;missing&gt;      3 years ago     /bin/sh -c <span class="comment">#(nop) ADD file:805cb5e15fb6e0bb0…   231MB     </span></span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>CMD和ENTRYPOINT的去呗</p>
</blockquote>
<p>我们之前说过，两个命令都是指定一个容器启动时要运行的命令</p>
<p><strong>CMD</strong>：Dockerfifile 中可以有多个CMD 指令，但只有最后一个生效，CMD 会被 docker run 之后的参数</p>
<p>替换！</p>
<p><strong>ENTRYPOINT</strong>：docker run 之后的参数会被当做参数传递给 ENTRYPOINT，之后形成新的命令组合！</p>
<blockquote>
<p>自定义镜像tomcat</p>
</blockquote>
<ol>
<li><p>新建一个路径，并准备好tomcat和jdk的压缩包（官网下载后本地上传到服务器），并新建一个read.txt、新建一个Dockfile文件，并编辑</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">root@VM-16-10-ubuntu:/home/ubuntu/test/docker-test-volume/tomcat<span class="comment"># cat Dockerfile </span></span><br><span class="line">FROM centos</span><br><span class="line"></span><br><span class="line">MAINTAINER 6pc1&lt;pc6pc1@qq.com&gt;</span><br><span class="line"></span><br><span class="line">COPY 1.txt /usr/local/read.txt</span><br><span class="line"></span><br><span class="line">ADD apache-tomcat-9.0.95.tar /usr/local/</span><br><span class="line">ADD jdk-8u202-linux-x64.tar /usr/local/</span><br><span class="line"></span><br><span class="line">RUN <span class="built_in">cd</span> /etc/yum.repos.d/</span><br><span class="line">RUN sed -i <span class="string">&#x27;s/mirrorlist/#mirrorlist/g&#x27;</span> /etc/yum.repos.d/CentOS-*</span><br><span class="line">RUN sed -i <span class="string">&#x27;s|#baseurl=http://mirror.centos.org|baseurl=http://vault.centos.org|g&#x27;</span> /etc/yum.repos.d/CentOS-*</span><br><span class="line">RUN yum -y install vim</span><br><span class="line"></span><br><span class="line">ENV MYPATH /usr/local</span><br><span class="line"></span><br><span class="line">WORKDIR <span class="variable">$MYPATH</span></span><br><span class="line"></span><br><span class="line">ENV JAVA_HOME /usr/local/jdk_1.8.0_202</span><br><span class="line">ENV CLASSPATH <span class="variable">$JAVA_HOME</span>/lib/dt.jar:<span class="variable">$JAVA_HOME</span>/lib/tools.jar</span><br><span class="line">ENV CATALINA_HOME /usr/local/apache-tomcat-9.0.95</span><br><span class="line">ENV CATALINA_BASE /usr/local/apache-tomcat-9.0.95</span><br><span class="line">ENV PATH <span class="variable">$PATH</span>:<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$CATALINA_HOME</span>/lib:<span class="variable">$CATALINA_HOME</span>/bin</span><br><span class="line"></span><br><span class="line">EXPOSE 8080</span><br><span class="line"></span><br><span class="line">CMD /usr/local/apache-tomcat-9.0.95/bin/startup.sh &amp;&amp; <span class="built_in">tail</span> -F /usr/local/apache-tomcat-9.0.95/bin/logs/catalina.out</span><br></pre></td></tr></table></figure>
</li>
<li><p>构建镜像</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">root@VM-16-10-ubuntu:/home/ubuntu/test/docker-test-volume/tomcat<span class="comment"># docker build -t diytomcat .</span></span><br><span class="line">[+] Building 146.5s (14/14) FINISHED                                                                docker:default</span><br><span class="line"> =&gt; [internal] load build definition from Dockerfile                                                          0.0s</span><br><span class="line"> =&gt; =&gt; transferring dockerfile: 866B                                                                          0.0s</span><br><span class="line"> =&gt; [internal] load metadata <span class="keyword">for</span> docker.io/library/centos:latest                                              0.0s</span><br><span class="line"> =&gt; [internal] load .dockerignore                                                                             0.0s</span><br><span class="line"> =&gt; =&gt; transferring context: 2B                                                                               0.0s</span><br><span class="line"> =&gt; CACHED [1/9] FROM docker.io/library/centos:latest                                                         0.0s</span><br><span class="line"> =&gt; [internal] load build context                                                                             2.5s</span><br><span class="line"> =&gt; =&gt; transferring context: 206.81MB                                                                         2.5s</span><br><span class="line"> =&gt; [2/9] COPY 1.txt /usr/local/read.txt                                                                      0.3s</span><br><span class="line"> =&gt; [3/9] ADD apache-tomcat-9.0.95.tar.gz /usr/local/                                                         0.4s</span><br><span class="line"> =&gt; [4/9] ADD jdk-8u202-linux-x64.tar.gz /usr/local/                                                          4.1s</span><br><span class="line"> =&gt; [5/9] RUN <span class="built_in">cd</span> /etc/yum.repos.d/                                                                            0.7s</span><br><span class="line"> =&gt; [6/9] RUN sed -i <span class="string">&#x27;s/mirrorlist/#mirrorlist/g&#x27;</span> /etc/yum.repos.d/CentOS-*                                   0.3s</span><br><span class="line"> =&gt; [7/9] RUN sed -i <span class="string">&#x27;s|#baseurl=http://mirror.centos.org|baseurl=http://vault.centos.org|g&#x27;</span> /etc/yum.repos.  0.4s</span><br><span class="line"> =&gt; [8/9] RUN yum -y install vim                                                                            134.1s</span><br><span class="line"> =&gt; [9/9] WORKDIR /usr/local                                                                                  0.1s </span><br><span class="line"> =&gt; exporting to image                                                                                        3.3s </span><br><span class="line"> =&gt; =&gt; exporting layers                                                                                       3.2s </span><br><span class="line"> =&gt; =&gt; writing image sha256:88021913b4f29d54ed2453c16e79d7259ab5414f3dc616c6d4e98ca6dad90743                  0.0s </span><br><span class="line"> =&gt; =&gt; naming to docker.io/library/diytomcat  </span><br><span class="line"> root@VM-16-10-ubuntu:/home/ubuntu/test/docker-test-volume/tomcat<span class="comment"># docker images                                    </span></span><br><span class="line">REPOSITORY   TAG       IMAGE ID       CREATED          SIZE</span><br><span class="line">diytomcat    latest    88021913b4f2   34 seconds ago   718MB</span><br><span class="line">mycentos     1.0       c3dec9b6a3f8   59 minutes ago   312MB</span><br><span class="line">centos       latest    5d0da3dc9764   3 years ago      231MB</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动容器</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@VM-16-10-ubuntu:/home/ubuntu/test/docker-test-volume/tomcat<span class="comment"># docker run -d -p 9090:8080 --name mydiytomcat -v /home/ubuntu/test/docker-test-volume/tomcat/test:/usr/local/apache-tomcat-9.0.95/webapps/test diytomcat</span></span><br><span class="line">99f621377dba54b318e382d8f72a16ddf321888392d27b5772e1a7eeb3b1fadf</span><br></pre></td></tr></table></figure>
</li>
<li><p>结合前面学习的容器卷将测试的web服务test发布</p>
<p>WEB-INF下新建一个web.xml</p>
<p>web.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns</span>=<span class="string">&quot;http://java.sun.com/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">id</span>=<span class="string">&quot;WebApp_ID&quot;</span> <span class="attr">version</span>=<span class="string">&quot;2.5&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">display-name</span>&gt;</span>test<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在test下新建一个a.jsp</p>
<p>a.jsp</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">&quot;java&quot;</span> contentType=<span class="string">&quot;text/html; charset=UTF-8&quot;</span> pageEncoding=<span class="string">&quot;UTF-8&quot;</span>%&gt; </span><br><span class="line">&lt;!DOCTYPE html PUBLIC <span class="string">&quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;</span> <span class="string">&quot;http://www.w3.org/TR/html4/loose.dtd&quot;</span>&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">	&lt;<span class="built_in">head</span>&gt;</span><br><span class="line">		&lt;meta http-equiv=<span class="string">&quot;Content-Type&quot;</span> content=<span class="string">&quot;text/html; charset=UTF-8&quot;</span>&gt;</span><br><span class="line">		&lt;title&gt;hello，kuangshen&lt;/title&gt;</span><br><span class="line">	&lt;/head&gt;</span><br><span class="line">	&lt;body&gt;</span><br><span class="line">		-----------welcome------------</span><br><span class="line">		&lt;%=<span class="string">&quot; my docker tomcat &quot;</span>%&gt;</span><br><span class="line">		&lt;br&gt;</span><br><span class="line">		&lt;br&gt;</span><br><span class="line">		&lt;% System.out.println(<span class="string">&quot;-------my docker tomcat-------&quot;</span>);%&gt;</span><br><span class="line">	&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="5、发布镜像"><a href="#5、发布镜像" class="headerlink" title="5、发布镜像"></a>5、发布镜像</h2><blockquote>
<p>DockerHub（不建议，大概率登录超时感觉）</p>
</blockquote>
<ol>
<li>注册dockerhub  <a target="_blank" rel="noopener" href="https://hub.docker.com/%EF%BC%8C%E6%B3%A8%E5%86%8C%E4%B8%80%E4%B8%AA%E8%B4%A6%E5%8F%B7">https://hub.docker.com/，注册一个账号</a></li>
</ol>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-23/a6ca8d34b74dcf6ad91395705579a106--078a--image-20240923204922044.png" alt="image-20240923204922044"></p>
<ol start="2">
<li>登录</li>
<li>docker push直接push到仓库中，记得加tag</li>
</ol>
<blockquote>
<p>腾讯云镜像服务</p>
</blockquote>
<ol>
<li><p>使用个人免费版仓库</p>
<p>这要注意，只有个别地方才能选择个人免费版仓库，这边我选择的是广州</p>
</li>
<li><p>创建命名空间和仓库</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-25/09d9e244fac1fcb6e6451bd95a5dd738--c8bc--image-20240925165555292.png" alt="image-20240925165555292"></p>
</li>
<li><p>直接快捷指令就能将容器上传至仓库了</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-25/20829e4b625bcd77961e47cf15fe20fe--9066--image-20240925165713786.png" alt="image-20240925165713786"></p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@VM-16-10-ubuntu:/home/ubuntu<span class="comment"># docker login ccr.ccs.tencentyun.com --username=100036351621</span></span><br><span class="line">Password: </span><br><span class="line">WARNING! Your password will be stored unencrypted <span class="keyword">in</span> /root/.docker/config.json.</span><br><span class="line">Configure a credential helper to remove this warning. See</span><br><span class="line">https://docs.docker.com/engine/reference/commandline/login/<span class="comment">#credentials-store</span></span><br><span class="line"></span><br><span class="line">Login Succeeded</span><br></pre></td></tr></table></figure>

<h2 id="6、总结"><a href="#6、总结" class="headerlink" title="6、总结"></a>6、总结</h2><p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-25/f728c102a55c9969c391697ddb24b104--7952--image-20240925183039622.png" alt="image-20240925183039622"></p>
<h1 id="九、Docker网络"><a href="#九、Docker网络" class="headerlink" title="九、Docker网络"></a>九、Docker网络</h1><h2 id="1、理解docker0"><a href="#1、理解docker0" class="headerlink" title="1、理解docker0"></a>1、理解docker0</h2><p>准备工作：清空所有的容器，清空所有的镜像</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">rm</span> -f $(docker ps -a -q)    <span class="comment"># 删除所有容器 </span></span><br><span class="line">docker rmi -f $(docker images -qa) <span class="comment"># 删除全部镜像</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>先做个测试–现象</p>
</blockquote>
<ol>
<li><p>制作一个可以使用<code>ip addr</code>和<code>ping</code>命令的镜像（已经支持的，可以忽略这个步骤）</p>
<p>下载tomcat原生镜像并启动tomcat容器<code>tomcat01</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@VM-16-10-ubuntu:/home/ubuntu/test/docker-test-volume/tomcat<span class="comment"># docker run -d -P --name tomcat01 tomcat</span></span><br></pre></td></tr></table></figure>

<p>查看容器<code>tomcat01</code>内部的ip地址，发现报错如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@VM-16-10-ubuntu:/home/ubuntu/test/docker-test-volume/tomcat<span class="comment"># docker exec -it tomcat01 ip addr</span></span><br><span class="line">OCI runtime <span class="built_in">exec</span> failed: <span class="built_in">exec</span> failed: unable to start container process: <span class="built_in">exec</span>: <span class="string">&quot;ip&quot;</span>: executable file not found <span class="keyword">in</span> <span class="variable">$PATH</span>: unknown</span><br><span class="line">root@VM-16-10-ubuntu:/home/ubuntu/test/docker-test-volume/tomcat<span class="comment"># docker exec -it tomcat01 /bin/bash</span></span><br><span class="line">\\root@fb4000629c55:/usr/local/tomcat<span class="comment"># ip addr</span></span><br><span class="line">bash: ip: <span class="built_in">command</span> not found</span><br></pre></td></tr></table></figure>

<p>进入容器执行命令，即可解决</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt update &amp;&amp; apt install -y iproute2</span><br></pre></td></tr></table></figure>

<p>在容器<code>tomcat01</code>ping一下，发现报错如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@fb4000629c55:/usr/local/tomcat<span class="comment"># ping 172.17.0.2</span></span><br><span class="line">bash: ping: <span class="built_in">command</span> not found</span><br></pre></td></tr></table></figure>

<p>进入容器执行命令，即可解决</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get update &amp;&amp; apt-get install -y iputils-ping</span><br></pre></td></tr></table></figure>

<p>容器执行了上面两个命令后，就可以正常使用<code>ip addr</code>和<code>ping</code>这两个命令了，然后我们把容器commit一下，就有个一个新的镜像了</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@VM-16-10-ubuntu:/home/ubuntu/test/docker-test-volume/tomcat<span class="comment"># docker commit fb4000629c55 my-tomcat01:1.0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>查看一下主机本地的ip 地址<code>ip addr</code></p>
<ul>
<li><p>lo 本机回环地址</p>
</li>
<li><p>eth0 阿里云的私有ip</p>
</li>
<li><p>docker0  docker网桥</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-25/846f432f3bb1ac63bb7d25b7de5f8c2f--fb7d--image-20240925185532091.png" alt="image-20240925185532091"></p>
</li>
<li><p>启动容器<code>tomcat01</code>,查看一下容器的ip，然后再查一下主机本地ip</p>
<p>docker会给每个容器都分配一个ip</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-25/9791e62266d3c6d5a8bc17a6068664f7--1062--image-20240925185336056.png" alt="image-20240925185336056"></p>
</li>
<li><p>我们再起一个容器，结果能够发现两个容器之间是能够ping通的</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@fb4000629c55:/usr/local/tomcat<span class="comment"># ping 172.17.0.3</span></span><br><span class="line">PING 172.17.0.3 (172.17.0.3) 56(84) bytes of data.</span><br><span class="line">64 bytes from 172.17.0.3: icmp_seq=1 ttl=64 time=0.099 ms</span><br><span class="line">64 bytes from 172.17.0.3: icmp_seq=2 ttl=64 time=0.067 ms</span><br><span class="line">64 bytes from 172.17.0.3: icmp_seq=3 ttl=64 time=0.064 ms</span><br><span class="line">64 bytes from 172.17.0.3: icmp_seq=4 ttl=64 time=0.060 ms</span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>原理</p>
</blockquote>
<ol>
<li><p>每一个安装了Docker的linux主机都有一个docker0的虚拟网卡。这是个桥接网卡，使用了veth-pair</p>
<p>技术！</p>
</li>
<li><p>每启动一个容器，linux主机就会多了一个虚拟网卡。</p>
<p>veth-pair 就是一对的虚拟设备接口，它都是成对出现的。一端连着协议栈，一端彼此相连着。</p>
<p>正因为有这个特性，它常常充当着一个桥梁，连接着各种虚拟网络设备!</p>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-25/e4b78b4838e2a9c46e21b74356f18387--5b2e--image-20240925185927195.png" alt="image-20240925185927195"></p>
<p>结论：tomcat1和tomcat2共用一个路由器。是的，他们使用的一个，就是docker0。任何一个容器启动</p>
<p>默认都是docker0网络。</p>
<p>docker默认会给容器分配一个可用ip。</p>
<blockquote>
<p>小结</p>
</blockquote>
<p>Docker使用Linux桥接，在宿主机虚拟一个Docker容器网桥(docker0)，Docker启动一个容器时会根据</p>
<p>Docker网桥的网段分配给容器一个IP地址，称为Container-IP，同时Docker网桥是每个容器的默认网</p>
<p>关。因为在同一宿主机内的容器都接入同一个网桥，这样容器之间就能够通过容器的Container-IP直接</p>
<p>通信。</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-25/b5514df66fdbaa3587500b1413900596--f81e--image-20240925185950744.png" alt="image-20240925185950744"></p>
<p>Docker容器网络就很好的利用了Linux虚拟网络技术，在本地主机和容器内分别创建一个虚拟接口，并</p>
<p>让他们彼此联通（这样一对接口叫veth pair）；</p>
<p>Docker中的网络接口默认都是虚拟的接口。虚拟接口的优势就是转发效率极高（因为Linux是在内核中</p>
<p>进行数据的复制来实现虚拟接口之间的数据转发，无需通过外部的网络设备交换），对于本地系统和容</p>
<p>器系统来说，虚拟接口跟一个正常的以太网卡相比并没有区别，只是他的速度快很多。</p>
<h2 id="2、–link"><a href="#2、–link" class="headerlink" title="2、–link"></a>2、–link</h2><p>思考一个场景，我们编写一个微服务，数据库连接地址原来是使用ip的，如果ip变化就不行了，那我们</p>
<p>能不能使用服务名访问呢？</p>
<p>jdbc:mysql:&#x2F;&#x2F;mysql:3306，这样的话哪怕mysql重启，我们也不需要修改配置了！docker提供了 –link</p>
<p>的操作！</p>
<blockquote>
<p>原理</p>
</blockquote>
<p>单纯是修改了host文件使容器名指向了对应的ip地址</p>
<p>从而可以直接访问对应的容器名</p>
<p>–link早都过时了，我们不推荐使用！我们可以使用自定义网络的方式</p>
<h2 id="3、自定义网络"><a href="#3、自定义网络" class="headerlink" title="3、自定义网络"></a>3、自定义网络</h2><blockquote>
<p>基本命令查看</p>
</blockquote>
<p>命令如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">root@VM-16-10-ubuntu:/home/ubuntu/test/docker-test-volume/tomcat<span class="comment"># docker network --help</span></span><br><span class="line"></span><br><span class="line">Usage:  docker network COMMAND</span><br><span class="line"></span><br><span class="line">Manage networks</span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line">  connect     Connect a container to a network</span><br><span class="line">  create      Create a network</span><br><span class="line">  disconnect  Disconnect a container from a network</span><br><span class="line">  inspect     Display detailed information on one or more networks</span><br><span class="line">  <span class="built_in">ls</span>          List networks</span><br><span class="line">  prune       Remove all unused networks</span><br><span class="line">  <span class="built_in">rm</span>          Remove one or more networks</span><br><span class="line"></span><br><span class="line">Run <span class="string">&#x27;docker network COMMAND --help&#x27;</span> <span class="keyword">for</span> more information on a <span class="built_in">command</span>.</span><br></pre></td></tr></table></figure>

<p><strong>查看所有网络</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@VM-16-10-ubuntu:/home/ubuntu/test/docker-test-volume/tomcat<span class="comment"># docker network ls</span></span><br><span class="line">NETWORK ID     NAME      DRIVER    SCOPE</span><br><span class="line">6ebce816547d   bridge    bridge    <span class="built_in">local</span></span><br><span class="line">05ae65613256   host      host      <span class="built_in">local</span></span><br><span class="line">e0876b8be916   none      null      <span class="built_in">local</span></span><br></pre></td></tr></table></figure>

<p>所有网络模式</p>
<table>
<thead>
<tr>
<th>网络模式</th>
<th>配置</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>bridge模式</td>
<td>–net&#x3D;bridge</td>
<td>默认值，在Docker网桥docker0上为容器创建新的网络栈</td>
</tr>
<tr>
<td>none模式</td>
<td>–net&#x3D;none</td>
<td>不配置网络，用户可以稍后进入容器，自行配置</td>
</tr>
<tr>
<td>container模式</td>
<td>–net&#x3D;container:name&#x2F;id</td>
<td>容器和另外一个容器共享Network namespace。kubernetes中的pod就是多个容器共享一个Network namespace</td>
</tr>
<tr>
<td>host模式</td>
<td>–net&#x3D;host</td>
<td>容器和宿主机共享Network namespace</td>
</tr>
<tr>
<td>用户自定义模式</td>
<td>–net&#x3D;自定义网络</td>
<td>用户自己使用network相关命令定义网络，创建容器的时候可以指定为自己定义的网络</td>
</tr>
</tbody></table>
<p><strong>查看一个具体的网络的详情</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">root@VM-16-10-ubuntu:/home/ubuntu/test/docker-test-volume/tomcat<span class="comment"># docker network inspect 6ebce816547d</span></span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;bridge&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Id&quot;</span>: <span class="string">&quot;6ebce816547d589207a8b545c4a79bb1f3f0f4219a3794b08e2669c97f2c52f8&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Created&quot;</span>: <span class="string">&quot;2024-09-21T20:29:18.36204997+08:00&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Scope&quot;</span>: <span class="string">&quot;local&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Driver&quot;</span>: <span class="string">&quot;bridge&quot;</span>,</span><br><span class="line">        <span class="string">&quot;EnableIPv6&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">&quot;IPAM&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;Driver&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Options&quot;</span>: null,</span><br><span class="line">            <span class="string">&quot;Config&quot;</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="string">&quot;Subnet&quot;</span>: <span class="string">&quot;172.17.0.0/16&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;Gateway&quot;</span>: <span class="string">&quot;172.17.0.1&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;Internal&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">&quot;Attachable&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">&quot;Ingress&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">&quot;ConfigFrom&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;Network&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;ConfigOnly&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">&quot;Containers&quot;</span>: &#123;&#125;,</span><br><span class="line">        <span class="string">&quot;Options&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;com.docker.network.bridge.default_bridge&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">            <span class="string">&quot;com.docker.network.bridge.enable_icc&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">            <span class="string">&quot;com.docker.network.bridge.enable_ip_masquerade&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">            <span class="string">&quot;com.docker.network.bridge.host_binding_ipv4&quot;</span>: <span class="string">&quot;0.0.0.0&quot;</span>,</span><br><span class="line">            <span class="string">&quot;com.docker.network.bridge.name&quot;</span>: <span class="string">&quot;docker0&quot;</span>,</span><br><span class="line">            <span class="string">&quot;com.docker.network.driver.mtu&quot;</span>: <span class="string">&quot;1500&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;Labels&quot;</span>: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>拓展：</p>
<ul>
<li>172.17.0.0&#x2F;16 是一个 CIDR 地址，其中 &#x2F;16 表示子网掩码的位数，即 255.255.0.0。这个地址范围内的 IP 地址数量是 2^16 - 2 &#x3D; 65534。其中，2^16 表示该地址范围内的 IP 地址总数，而减去 2 是因为该地址范围内的第一个 IP 地址是网络地址，最后一个 IP 地址是广播地址，不能使用</li>
<li>172.17.0.0&#x2F;24 是一个 CIDR 地址，其中 &#x2F;24 表示子网掩码的位数，即 255.255.255.0。这个地址范围内的 IP 地址数量是 2^8 - 2 &#x3D; 254。其中，2^8 表示该地址范围内的 IP 地址总数，而减去 2 是因为该地址范围内的第一个 IP 地址是网络地址，最后一个 IP 地址是广播地址，不能使用。</li>
</ul>
<blockquote>
<p>自定义网卡</p>
</blockquote>
<ol>
<li><p>删除原来的所有的容器（这样干净一点）</p>
<p>这样网络就恢复最初的样子了</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">root@VM-16-10-ubuntu:/home/ubuntu/test/docker-test-volume/tomcat<span class="comment"># ip addr</span></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    <span class="built_in">link</span>/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1/128 scope host </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP group default qlen 1000</span><br><span class="line">    <span class="built_in">link</span>/ether 52:54:00:58:5e:1a brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    altname enp0s5</span><br><span class="line">    altname ens5</span><br><span class="line">    inet 10.0.16.10/22 metric 100 brd 10.0.19.255 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::5054:ff:fe58:5e1a/64 scope <span class="built_in">link</span> </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">3: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN group default </span><br><span class="line">    <span class="built_in">link</span>/ether 02:42:99:03:57:1b brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::42:99ff:fe03:571b/64 scope <span class="built_in">link</span> </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure>
</li>
<li><p>自定义网络</p>
<p>查看命令使用</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自定义一个网络</span></span><br><span class="line">root@VM-16-10-ubuntu:/home/ubuntu/test/docker-test-volume/tomcat<span class="comment"># docker network create --driver bridge --subnet 192.17.0.0/16 --gateway 192.17.0.1 mynet</span></span><br><span class="line">ecef3e6ceef718e93c001b8068e0c824086046e1e5196b050fab6ef65a8903b9</span><br><span class="line">root@VM-16-10-ubuntu:/home/ubuntu/test/docker-test-volume/tomcat<span class="comment"># docker network ls</span></span><br><span class="line">NETWORK ID     NAME      DRIVER    SCOPE</span><br><span class="line">6ebce816547d   bridge    bridge    <span class="built_in">local</span></span><br><span class="line">05ae65613256   host      host      <span class="built_in">local</span></span><br><span class="line">ecef3e6ceef7   mynet     bridge    <span class="built_in">local</span></span><br><span class="line">e0876b8be916   none      null      <span class="built_in">local</span></span><br><span class="line">root@VM-16-10-ubuntu:/home/ubuntu/test/docker-test-volume/tomcat<span class="comment"># docker network inspect mynet</span></span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;mynet&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Id&quot;</span>: <span class="string">&quot;ecef3e6ceef718e93c001b8068e0c824086046e1e5196b050fab6ef65a8903b9&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Created&quot;</span>: <span class="string">&quot;2024-09-25T19:29:21.684869939+08:00&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Scope&quot;</span>: <span class="string">&quot;local&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Driver&quot;</span>: <span class="string">&quot;bridge&quot;</span>,</span><br><span class="line">        <span class="string">&quot;EnableIPv6&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">&quot;IPAM&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;Driver&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Options&quot;</span>: &#123;&#125;,</span><br><span class="line">            <span class="string">&quot;Config&quot;</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="string">&quot;Subnet&quot;</span>: <span class="string">&quot;192.17.0.0/16&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;Gateway&quot;</span>: <span class="string">&quot;192.17.0.1&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;Internal&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">&quot;Attachable&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">&quot;Ingress&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">&quot;ConfigFrom&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;Network&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;ConfigOnly&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">&quot;Containers&quot;</span>: &#123;&#125;,</span><br><span class="line">        <span class="string">&quot;Options&quot;</span>: &#123;&#125;,</span><br><span class="line">        <span class="string">&quot;Labels&quot;</span>: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
</li>
<li><p>基于自定义网络启动容器</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用自定义网络</span></span><br><span class="line">root@VM-16-10-ubuntu:/home/ubuntu/test/docker-test-volume/tomcat<span class="comment"># docker run -d -P --name tomcat-net-1 --net mynet my-tomcat01:1.0</span></span><br><span class="line"><span class="comment"># 发现已经成功使用上</span></span><br><span class="line">root@VM-16-10-ubuntu:/home/ubuntu/test/docker-test-volume/tomcat<span class="comment"># docker network inspect mynet</span></span><br><span class="line">&#125;,</span><br><span class="line">        <span class="string">&quot;ConfigOnly&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">&quot;Containers&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;6ccd4eceb20ec77000793369ee924106f698c236e48f53e082b0cbd830289b13&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;tomcat-net-1&quot;</span>,</span><br><span class="line">                <span class="string">&quot;EndpointID&quot;</span>: <span class="string">&quot;cf8a18045268e43e29e3e7ae2315af57a58560860f8fe9ce64c5f015c599dc17&quot;</span>,</span><br><span class="line">                <span class="string">&quot;MacAddress&quot;</span>: <span class="string">&quot;02:42:c0:11:00:02&quot;</span>,</span><br><span class="line">                <span class="string">&quot;IPv4Address&quot;</span>: <span class="string">&quot;192.17.0.2/16&quot;</span>,</span><br><span class="line">                <span class="string">&quot;IPv6Address&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure>


</li>
<li><p>发现，我们自定义的网络docker都已经帮我们维护好了对应的关系 </p>
<p>所以我们平时都可以这样使用网络，不使用–link效果一样，所有东西实时维护好，直接域名 ping 通。</p>
</li>
</ol>
<h2 id="4、网络连通"><a href="#4、网络连通" class="headerlink" title="4、网络连通"></a>4、网络连通</h2><ol>
<li><p>启动两个容器（默认，基于docker0的网络）</p>
<p>启动两个容器（默认，基于docker0的网络）</p>
</li>
<li><p>使用network connect 命令连接</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@iZwz9efdd2ukk4oauustczZ ~]<span class="comment"># docker network connect mynet tomcat-1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>再次验证，通了</p>
</li>
<li><p>看一下tomcat-1的网络信息(tomcat01拥有了双ip)</p>
</li>
<li><p>再看一下mynet的网络信息</p>
</li>
</ol>
<p>结论：如果要跨网络操作别人，就需要使用 <code>docker network connect [OPTIONS] NETWORK CONTAINER</code> 连接</p>
<h1 id="十、Docker-compose"><a href="#十、Docker-compose" class="headerlink" title="十、Docker compose"></a>十、Docker compose</h1><p>Compose 是用于定义和运行多容器 Docker 应用程序的工具。</p>
<p>通过 Compose，您可以使用 YML 文件来配置应用程序需要的所有服务。然后，使用一个命令，就可以从 YML 文件配置中创建并启动所有服务。</p>
<p>Compose 使用的三个步骤：</p>
<ul>
<li>使用 Dockerfile 定义应用程序的环境</li>
<li>使用 docker-compose.yml 定义构成应用程序的服务，这样它们可以在隔离环境中一起运行</li>
<li>最后，执行 docker-compose up 命令来启动并运行整个应用程序</li>
</ul>
<p>中文文档：<a target="_blank" rel="noopener" href="http://www.dockerinfo.net/docker-compose-%e9%a1%b9%e7%9b%ae">http://www.dockerinfo.net/docker-compose-%e9%a1%b9%e7%9b%ae</a></p>
<p>官方文档：<a target="_blank" rel="noopener" href="https://docs.docker.com/compose/">https://docs.docker.com/compose/</a></p>
<blockquote>
<p>compose安装  要注意和Docker同一个版本</p>
</blockquote>
<blockquote>
<p>这里有独立版和插件版两种，区别感觉不大，主要就是命令的使用的一点点差别，我这主要使用的是独立版</p>
</blockquote>
<blockquote>
<p><strong>Compose 独立版</strong></p>
<p>请注意，Compose standalone 使用<code>-compose</code>语法 而不是当前标准语法<code>compose</code>。<br>例如，<code>docker-compose up</code>使用 Compose standalone 时输入 ，而不是<code>docker compose up</code>。</p>
</blockquote>
<ol>
<li><p>要下载并安装 Compose 独立版，请运行：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl -SL https://github.com/docker/compose/releases/download/v2.29.6/docker-compose-linux-x86_64 -o /usr/local/bin/docker-compose</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>将可执行权限应用于安装目标路径中的独立二进制文件。</p>
</li>
<li><p>使用 测试并执行撰写命令<code>docker-compose</code>。</p>
<blockquote>
<p><strong>提示</strong></p>
<p>如果安装后命令<code>docker-compose</code>失败，请检查您的路径。您还可以创建指向或路径中任何其他目录的符号链接<code>/usr/bin</code>。例如：</p>
<p>$ sudo ln -s &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose &#x2F;usr&#x2F;bin&#x2F;docker-compose</p>
</blockquote>
</li>
</ol>
<blockquote>
<p>compose使用</p>
</blockquote>
<p>1、设置</p>
<ol>
<li><p>为项目创建目录：</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> composetest</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> composetest</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在您的项目目录中创建一个名为的文件<code>app.py</code>并粘贴以下代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">cache = redis.Redis(host=<span class="string">&#x27;redis&#x27;</span>, port=<span class="number">6379</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_hit_count</span>():</span><br><span class="line">    retries = <span class="number">5</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> cache.incr(<span class="string">&#x27;hits&#x27;</span>)</span><br><span class="line">        <span class="keyword">except</span> redis.exceptions.ConnectionError <span class="keyword">as</span> exc:</span><br><span class="line">            <span class="keyword">if</span> retries == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">raise</span> exc</span><br><span class="line">            retries -= <span class="number">1</span></span><br><span class="line">            time.sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello</span>():</span><br><span class="line">    count = get_hit_count()</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello World! I have been seen &#123;&#125; times.\n&#x27;</span>.<span class="built_in">format</span>(count)</span><br></pre></td></tr></table></figure>

<p>在此示例中，是应用程序网络上的 redis 容器的主机名，并使用<code>redis</code>默认端口。<code>6379</code></p>
<blockquote>
<p><strong>笔记</strong></p>
<p>请注意函数的编写方式<code>get_hit_count</code>。如果 Redis 服务不可用，此基本重试循环会多次尝试请求。这在应用程序上线时启动时很有用，但如果在应用程序的生命周期内需要随时重新启动 Redis 服务，也会使应用程序更具弹性。在集群中，这也有助于处理节点之间的瞬时连接断开。</p>
</blockquote>
</li>
<li><p>在您的项目目录中创建另一个名为的文件<code>requirements.txt</code>并粘贴以下代码：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flask</span><br><span class="line">redis</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建一个<code>Dockerfile</code>并粘贴以下代码：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># syntax=docker/dockerfile:1</span></span><br><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.10</span>-alpine</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /code</span></span><br><span class="line"><span class="keyword">ENV</span> FLASK_APP=app.py</span><br><span class="line"><span class="keyword">ENV</span> FLASK_RUN_HOST=<span class="number">0.0</span>.<span class="number">0.0</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apk add --no-cache gcc musl-dev linux-headers</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> requirements.txt requirements.txt</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> pip install -r requirements.txt</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">5000</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . .</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;flask&quot;</span>, <span class="string">&quot;run&quot;</span>, <span class="string">&quot;--debug&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>重要的</strong></p>
<p>检查<code>Dockerfile</code>文件扩展名是否为<code>.txt</code>。某些编辑器可能会自动附加此文件扩展名，从而导致运行应用程序时出现错误。</p>
</blockquote>
</li>
</ol>
<p>2、在Compose文件中定义服务</p>
<p>Compose 简化了整个应用程序堆栈的控制，使您可以轻松地在单个易于理解的 YAML 配置文件中管理服务、网络和卷。</p>
<p>在您的项目目录中创建一个名为的文件<code>compose.yaml</code>并粘贴以下内容：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">.</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8000:5000&quot;</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">&quot;redis:alpine&quot;</span></span><br></pre></td></tr></table></figure>

<p>该Compose文件定义了两个服务：<code>web</code>和<code>redis</code>。</p>
<p>该<code>web</code>服务使用从当前目录中构建的镜像<code>Dockerfile</code>。然后它将容器和主机绑定到公开端口。<code>8000</code>此示例服务使用 Flask Web 服务器的默认端口<code>5000</code>。</p>
<p>该<code>redis</code>服务使用 从 Docker Hub 注册表中提取的公共<a target="_blank" rel="noopener" href="https://registry.hub.docker.com/_/redis/">Redis映像。</a></p>
<p>3、使用 Compose 构建并运行您的应用</p>
<p>使用单个命令，您可以从配置文件创建并启动所有服务。</p>
<ol>
<li>从您的项目目录中，通过运行启动您的应用程序<code>docker compose up</code>。、</li>
<li>每访问一次网站，次数应该都会增加</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://6pc1.github.io/2024/09/17/redis%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="6pc1">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="6pc1's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 6pc1's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/09/17/redis%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">redis学习</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-09-17 19:33:45" itemprop="dateCreated datePublished" datetime="2024-09-17T19:33:45+08:00">2024-09-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-09-21 19:03:01" itemprop="dateModified" datetime="2024-09-21T19:03:01+08:00">2024-09-21</time>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2024/09/17/redis%E5%AD%A6%E4%B9%A0/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2024/09/17/redis%E5%AD%A6%E4%B9%A0/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>59k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>54 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="一、NoSQL概述"><a href="#一、NoSQL概述" class="headerlink" title="一、NoSQL概述"></a>一、NoSQL概述</h1><ul>
<li>NoSQL，指的是<strong>非关系型数据库</strong>。NoSQL有时也称为Not Only SQL的缩写，是对不同于传统的关系型数据库的数据库管理系统的统称。</li>
</ul>
<h2 id="1、为什么要用NoSQL"><a href="#1、为什么要用NoSQL" class="headerlink" title="1、为什么要用NoSQL"></a>1、为什么要用NoSQL</h2><blockquote>
<p>1、单机mysql的年代</p>
</blockquote>
<ul>
<li><p>在早期90年代，一个网站的访问量一般都不大，用单个数据库完全够用。</p>
</li>
<li><p>在那个时代，网站更多使用的都是静态网页，动态交互型界面使用不多。</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/74ae8f5de7c59c31894dc4916eb11691--7826--image-20240917194252427.png" alt="image-20240917194252427"></p>
<blockquote>
<p>DAL：Data Access Layer（数据访问层-Hibernate，Mybatis）</p>
</blockquote>
<p>但使用该架构的情况下，也随之存在不少问题，网站存在对应的瓶颈</p>
<ol>
<li>数据量的总大小一个机器放不下时</li>
<li>数据的索引（B+Tree）一个机器的内存放不下时</li>
<li>访问量（读写混合）一个实例Mysql不能接受</li>
</ol>
<p>只要出现上述三种情况之一，可能就会导致网站的无法正常使用，只能对数据库的整体架构进行重构</p>
<blockquote>
<p>2、memcached（缓存）+mysql+垂直拆分（读写分离）</p>
</blockquote>
<ul>
<li>随着网站访问量的不断上升，几乎大部分使用单机mysql架构的网站在数据库上都出现了性能问题</li>
<li>随之而来的实际，使用缓存技术来环节数据库的压力，优化数据库结构和索引。。开始比较流行的是通过文件缓存来缓解数据库压力，但是当访问量继续增大的时候，多台web机器通过文件缓存不能共享，大量的小文件缓存也带了了比较高的IO压力。</li>
<li>在这个时候，Memcached就自然的成为一个非常时尚的技术产品。</li>
<li>网站80%的情况都是在读，每次都要去查询数据库的话就十分的麻烦！所以说我们希望减轻数据的压力，我们可以使用缓存来保证效率！</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/13b5c05c18f27f7137ded7fa5cab0482--f695--image-20240917195408498.png" alt="image-20240917195408498"></p>
<ul>
<li>Memcached作为一个独立的分布式的缓存服务器，为多个web服务器提供了一个共享的高性能缓存服务，在Memcached服务器上，又发展了根据hash算法来进行多台Memcached缓存服务的扩展，然后又出现了一致性hash来解决增加或减少缓存服务器导致重新hash带来的大量缓存失效的弊端。</li>
<li>由于数据库的写入压力增加，Memcached只能缓解数据库的读取压力。读写集中在一个数据库上让数据库不堪重负，大部分网站开始使用主从复制技术来达到<strong>读写分离</strong>，以提高读写性能和读库的可扩展性。Mysql的master-slave模式成为这个时候的网站标配了。</li>
</ul>
<blockquote>
<p>3、分库分表+水平拆分+mysql集群</p>
</blockquote>
<ul>
<li>本质：数据库的读写</li>
<li>早些年的MyISAM：表锁，十分影响效率，高并发情况下就会出现严重的锁问题</li>
<li>当下的转战Innodb：行锁</li>
<li>技术和业务在发展的同时，对人的要求也越来越高！</li>
<li>慢慢的就开始使用分库分表来解决写的压力！MySQL在某个年代推出了表分区，但并没有什么公司用！</li>
<li>为满足需求，随之诞生的则是MySQL的集群，很好满足那个时代的所有需求！</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/66ca9710d7e23fe4ea3cec952545b379--1556--image-20240917200604469.png" alt="image-20240917200604469"></p>
<blockquote>
<p>4、如今最近的年代</p>
</blockquote>
<ul>
<li>2010-2020十年之间，世界已经发生了翻天覆地的变化；（定位，音乐。热榜也是一种数据）</li>
<li>MySQL等关系型数据库就不够用了！当下数据量很多（大数据时代），变化很快！</li>
<li>MySQL用它存储一些比较大的文件，效率就低了，比如博客，图片等！如果有一种数据库去专门处理这种数据。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/7fdcc82c9489aaca67f2f368789f63f1--03fc--image-20240917202025446.png" alt="image-20240917202025446"></p>
<p>最前面的是企业级防火墙，后面通过负载均衡主机（软负载：Nginx，硬负载：F5）在 web 服务器集群之间进行调度，再由具体的 web 服务器（Tomcat）去访问缓存，访问数据库。</p>
<blockquote>
<p>为什么要nosql</p>
</blockquote>
<p>今天我们可以通过第三方平台（如：Google,Facebook等）可以很容易的访问和抓取数据。用户的个人信息，社交网络，地理位置，用户生成的数据和用户操作日志已经成倍的增加。我们如果要对这些用户数据进行挖掘，那SQL数据库已经不适合这些应用了, NoSQL数据库的发展也却能很好的处理这些大的数据。</p>
<h2 id="2、什么是NoSQL"><a href="#2、什么是NoSQL" class="headerlink" title="2、什么是NoSQL"></a>2、什么是NoSQL</h2><blockquote>
<p>NoSQL</p>
</blockquote>
<p>NoSQL &#x3D; Not Only SQL（不仅仅是SQL）</p>
<p>关系型数据库：表格 （行 ，列）</p>
<p>泛指非关系型数据库的，随着web2.0互联网的诞生！传统的关系型数据库很难对付web2.0时代！尤其是超大规模的高并发的社区！ 暴露出来很多难以克服的问题，NoSQL在当今大数据环境下发展的十分迅速，Redis是发展最快的，而且是我们当下必须要掌握的一个技术！</p>
<p>很多的数据类型用户的个人信息，社交网络，地理位置。这些数据类型的存储不需要一个固定的格式！不需要多余的操作就可以横向扩展的 ！ <strong>Map&lt;String,Object&gt; 使用键值对来控制！</strong></p>
<blockquote>
<p>NoSQL特点</p>
</blockquote>
<p><strong>解耦！！</strong></p>
<ul>
<li><p>方便拓展（数据之间没有关系，很好扩展！）</p>
</li>
<li><p>大数据量高性能（Redis一秒写8万次，读取11万，NoSQL的缓存记录级，是一种细粒度的缓存，性能会比较高）</p>
</li>
<li><p>数据类型是多样型的！（不需要事先设计数据库！随取随用！如果数据量非常大的表，很多人就无法设计了）</p>
</li>
<li><p>传统RDBMS（关系型数据库）和NoSQL的对比</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">传统的 RDBMS</span><br><span class="line">- 高度组织化结构化数据</span><br><span class="line">- 结构化查询语言（SQL）</span><br><span class="line">- 数据和关系都存储在单独的表中。</span><br><span class="line">- 数据操纵语言，数据定义语言</span><br><span class="line">- 严格的一致性</span><br><span class="line">- 基础事务 </span><br><span class="line">- .....</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Nosql </span><br><span class="line">- 代表着不仅仅是SQL</span><br><span class="line">- 没有声明性查询语言</span><br><span class="line">- 没有预定义的模式</span><br><span class="line">- 键值对存储，列存储，文档存储，图形数据库</span><br><span class="line">- 最终一致性，而非ACID属性</span><br><span class="line">- 非结构化和不可预知的数据</span><br><span class="line">- CAP定理(C：强一致性 A：高可用性 P：分布式容忍性)</span><br><span class="line">- 高性能，高可用性和可伸缩性</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>理解：3V+3高</p>
</blockquote>
<p>大数据时代的3V：主要是描述问题的</p>
<ol>
<li>海量Volume</li>
<li>多样Variety</li>
<li>实时Velocity</li>
</ol>
<p>大数据时代的3高：主要是对程序的要求</p>
<ol>
<li><strong>高并发</strong></li>
<li><strong>高可扩</strong></li>
<li><strong>高性能</strong></li>
</ol>
<p>真正在公司中的实践：NoSQL + RDBMS 一起使用才是最强的，阿里巴巴的架构演进！</p>
<h2 id="3、阿里巴巴演进分析"><a href="#3、阿里巴巴演进分析" class="headerlink" title="3、阿里巴巴演进分析"></a>3、阿里巴巴演进分析</h2><p>思考问题：这么多东西难道都是在一个数据库中的吗?</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/4414c8742049d823bf81956bb7e3fb8b--cc92--image-20240917204812689.png" alt="image-20240917204812689"></p>
<p>技术急不得，越是慢慢学，才能越扎实！</p>
<p>开源才是技术的王道！</p>
<p>任何一家互联网的公司，都不可能只是简简单单让用户能用就好了</p>
<p>大量公司做的都是相同的业务（竞品协议）</p>
<p>随着这样的竞争，业务是越来越完善，然后对于开发者的要求也是越来越高</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/b3e70a7822276f757b5937187b81f21f--63fe--image-20240917204835195.png" alt="image-20240917204835195"></p>
<p>如果你未来相当一个架构师： 没有什么是加一层解决不了的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># 1、商品的基本信息</span><br><span class="line">  名称、价格、商家信息</span><br><span class="line">  关系型数据库就可以解决了！ MySQL / Oracle （淘宝早年就去IOE了！- 王坚：推荐文章：阿里云的这群疯子）</span><br><span class="line">  淘宝内部的 MySQL 不是大家用的 MySQL</span><br><span class="line"># 2、商品的描述、评论（文字比较多）</span><br><span class="line">  文档型数据库中，MongoDB</span><br><span class="line"># 3、图片</span><br><span class="line">  - 分布式文件系统 FastDFS</span><br><span class="line">  - 淘宝自己的 TFS</span><br><span class="line">  - Google的 GFS</span><br><span class="line">  - Hadoop HDFS</span><br><span class="line">  - 阿里云的 oss</span><br><span class="line"># 4、商品的关键字 （搜索）</span><br><span class="line">  - 搜索引擎 solr elasticsearch</span><br><span class="line">  - ISearch：多隆（多去了解一下这些技术大佬！）</span><br><span class="line">  - 所有牛逼的人都有一段苦逼的岁月！但是你只要像SB一样的去坚持，终将牛逼！</span><br><span class="line"># 5、商品热门信息</span><br><span class="line">  - 内存数据库</span><br><span class="line">  - Redis、 Tair、Memache...</span><br><span class="line"># 6、商品的交易，外部的支付接口</span><br><span class="line">  - 三方应用 </span><br><span class="line">.....</span><br></pre></td></tr></table></figure>

<p>要知道，一个简单地网页背后的技术一定不是大家所想的那么简单</p>
<p>大型互联网应用问题</p>
<ul>
<li>数据类型太多了</li>
<li>数据源繁多，经常重构</li>
<li>数据要改造，大面积改造</li>
</ul>
<p>解决问题：</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/a4cce34dabdbf7356b024032970e5231--14a5--image-20240917204845891.png" alt="image-20240917204845891"></p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/d7215a33aceaa04e565ac394bff08bf1--643b--image-20240917204854879.png" alt="image-20240917204854879"></p>
<p>这里以上都是NoSQL入门概述，不仅能够提高大家的知识，还可以帮助大家了解大厂的工作内容</p>
<h2 id="4、NoSQL的四大分类"><a href="#4、NoSQL的四大分类" class="headerlink" title="4、NoSQL的四大分类"></a>4、NoSQL的四大分类</h2><ol>
<li><p>键值(Key-Value)存储数据库</p>
<p><strong>这一类数据库主要会使用到一个哈希表，这个表中有一个特定的键和一个指针指向特定的数据</strong>。Key&#x2F;value模型对于IT系统来说的优势在于简单、易部署。但是如果DBA（数据库管理员）只对部分值进行查询或更新的时候，Key&#x2F;value就显得效率低下了。举例如：Tokyo Cabinet&#x2F;Tyrant, <strong>Redis</strong>, Voldemort, Oracle BDB</p>
</li>
<li><p>列存储数据库</p>
<p>这部分数据库通常是用来应对分布式存储的海量数据。键仍然存在，但是它们的特点是指向了多个列。这些列是由列家族来安排的。如：Cassandra, <strong>HBase</strong>, Riak.</p>
</li>
<li><p>文档型数据库</p>
<p>文档型数据库的灵感是来自于Lotus Notes办公软件的，而且它同第一种键值存储相类似。该类型的数据模型是版本化的文档，半结构化的文档以特定的格式存储，比如JSON。文档型数据库可 以看作是键值数据库的升级版，允许之间嵌套键值。而且文档型数据库比键值数据库的查询效率更高。如：CouchDB, <strong>MongoDb</strong>. 国内也有文档型数据库SequoiaDB，目前已经开源</p>
</li>
<li><p>图形(Graph)数据库</p>
<p>图形结构的数据库同其他行列以及刚性结构的SQL数据库不同，它是使用灵活的图形模型，并且能够扩展到多个服务器上。NoSQL数据库没有标准的查询语言(SQL)，因此进行数据库查询需要制定数据模型。许多NoSQL数据库都有REST式的数据接口或者查询API。 如：<strong>Neo4J</strong>, InfoGrid, Infinite Graph</p>
</li>
</ol>
<blockquote>
<p>对比</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/0b29faa408d9be60261b86f242bf839c--c4b5--image-20240917205245441.png" alt="image-20240917205245441"></p>
<h1 id="二、redis入门"><a href="#二、redis入门" class="headerlink" title="二、redis入门"></a>二、redis入门</h1><h2 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h2><blockquote>
<p>redis是什么？？</p>
</blockquote>
<p><strong>Redis</strong>（Remote Dictionary Server )，即远程字典服务 !</p>
<p>是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/2c859dce2432fbf1b9d4ad58eacad586--2e0a--image-20240917205629626.png" alt="image-20240917205629626"></p>
<p>redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。</p>
<p>免费和开源！是当下最热门的 NoSQL 技术之一！也被人们称之为结构化数据库！</p>
<blockquote>
<p>redis能干嘛？</p>
</blockquote>
<ol>
<li>内存存储、持久化，内存中是断电即失、所以说持久化很重要（rdb，aof）</li>
<li>效率高，可以用于高速缓存</li>
<li>发布订阅系统</li>
<li>地图信息分析</li>
<li>计时器、计数器（浏览量！）</li>
<li>…</li>
</ol>
<blockquote>
<p>特性</p>
</blockquote>
<ol>
<li>多样的数据类型</li>
<li>持久化</li>
<li>集群</li>
<li>事务</li>
<li>…</li>
</ol>
<blockquote>
<p>学习中用到的东西</p>
</blockquote>
<ol>
<li><p>官网：<a target="_blank" rel="noopener" href="https://redis.io/">https://redis.io/</a></p>
</li>
<li><p>中文网：<a target="_blank" rel="noopener" href="http://www.redis.cn/">http://www.redis.cn/</a></p>
</li>
<li><p>下载地址：<a target="_blank" rel="noopener" href="https://redis.io/download/">https://redis.io/download/</a></p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/3d70629585eeb9924216c692083c3396--b22c--image-20240917205651085.png" alt="image-20240917205651085"></p>
<p>注意：Wdinow在 Github上下载（停更很久了！）</p>
<p>Redis推荐都是在Linux服务器上搭建的，我们是基于Linux学习！</p>
</li>
</ol>
<h2 id="2、WIndows下Redis的安装"><a href="#2、WIndows下Redis的安装" class="headerlink" title="2、WIndows下Redis的安装"></a>2、WIndows下Redis的安装</h2><p>1、下载压缩包直接使用即可。下载地址：<a target="_blank" rel="noopener" href="https://github.com/tporadowski/redis/releases">https://github.com/tporadowski/redis/releases</a></p>
<p>2、打开server服务，再使用client去连接，即可直接命令行使用。</p>
<blockquote>
<p>记住一句话，Window下使用确实简单，但是Redis 推荐我们使用Linux去开发使用！</p>
</blockquote>
<h2 id="3、Linux安装"><a href="#3、Linux安装" class="headerlink" title="3、Linux安装"></a>3、Linux安装</h2><ul>
<li>直接找到官网链接对应的下载安装方法   链接：<a target="_blank" rel="noopener" href="https://redis.io/docs/latest/operate/oss_and_stack/install/install-redis/install-redis-on-linux/">https://redis.io/docs/latest/operate/oss_and_stack/install/install-redis/install-redis-on-linux/</a></li>
<li>使用snap再Ubuntu上安装</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install redis-tools <span class="comment"># for redis-cli</span></span><br><span class="line">sudo snap install redis</span><br></pre></td></tr></table></figure>

<ul>
<li>一些常见的snap操作redis的命令</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo snap start redis</span><br><span class="line">sudo snap stop redis</span><br><span class="line">sudo snap restart redis</span><br><span class="line">sudo snap services redis</span><br></pre></td></tr></table></figure>

<ul>
<li>但这里我们就不使用这种方式了，我们可以去自己下载对应的源码编译</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wget https://download.redis.io/redis-stable.tar.gz</span><br><span class="line"></span><br><span class="line">tar -zxvf redis-stable.tar.gz</span><br><span class="line"></span><br><span class="line">make</span><br><span class="line"></span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<ul>
<li>然后就是可以进入我们默认的安装路径<code>/usr/local/bin/</code>，可以发现已经成功安装上了</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-18/08fda3803d6cf30473591657d682416a--379d--image-20240918162219684.png" alt="image-20240918162219684"></p>
<ul>
<li>然后我们就可以去创建一个文件夹专门去存放我们的配置文件，方便我们之后的使用</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> myconfig</span><br><span class="line"></span><br><span class="line"><span class="built_in">cp</span> /home/ubuntu/tools/redis/redis-stable/redis.conf myconfig/</span><br></pre></td></tr></table></figure>

<ul>
<li>修改配置文件，开启守护进程，使redis能够在后台运行</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-18/ba0c73fe44558e4c53d074f59bfb16d9--1e37--image-20240918162915219.png" alt="image-20240918162915219"></p>
<ul>
<li>使用我们自己的配置文件去启动redis服务</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@VM-16-10-ubuntu:/usr/local/bin# redis-server myconfig/redis.conf</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-18/b350fb9a014f081cc57605c128f8a231--84f1--image-20240918163216764.png" alt="image-20240918163216764"></p>
<ul>
<li>成功完成启动和连接</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-18/e2619002790475090bd5f274f37086ae--742f--image-20240918163307637.png" alt="image-20240918163307637"></p>
<ul>
<li>关闭redis并退出</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; shutdown</span><br><span class="line">not connected&gt; <span class="built_in">exit</span></span><br><span class="line">root@VM-16-10-ubuntu:/usr/local/bin<span class="comment"># </span></span><br></pre></td></tr></table></figure>

<h2 id="4、压力测试"><a href="#4、压力测试" class="headerlink" title="4、压力测试"></a>4、压力测试</h2><ul>
<li>redis-benchmark是一个压力测试工具</li>
<li>官方自带的性能测试工具</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-18/1cd8394c333815e2933deb276bc14f2c--d917--image-20240918163836563.png" alt="image-20240918163836563"></p>
<p>我们来简单测试一下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">测试100个并发，100个请求</span><br><span class="line">redis-benchmark -h localhost -p 6379 -c 100 -n 100</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-18/292b8273c8c6db63fe7d6bf7d2d3e327--6b75--image-20240918164542352.png" alt="image-20240918164542352"></p>
<p>中间的部分就是不同毫秒时处理总数据的百分比以及延迟；最后的部分就是算出的平均吞吐量了。总体来说，吞吐速度还是很不错的。</p>
<h2 id="5、基础知识"><a href="#5、基础知识" class="headerlink" title="5、基础知识"></a>5、基础知识</h2><ul>
<li>redis默认有16个数据库，这可以在redis.conf配置文件中可以看到</li>
<li>可以在配置文件中修改databases的值去修改默认的数据库的数量</li>
<li>数据库默认使用的是第0个数据库</li>
<li>redis使用时可以使用select去切换数据库</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; dbsize <span class="comment"># 查看db大小</span></span><br><span class="line">(<span class="built_in">integer</span>) 9</span><br><span class="line">127.0.0.1:6379&gt; keys * <span class="comment"># 查看当前数据库所有的key</span></span><br><span class="line">1) <span class="string">&quot;key:__rand_int__&quot;</span></span><br><span class="line">2) <span class="string">&quot;c&quot;</span></span><br><span class="line">3) <span class="string">&quot;b&quot;</span></span><br><span class="line">4) <span class="string">&quot;mystream&quot;</span></span><br><span class="line">5) <span class="string">&quot;myhash&quot;</span></span><br><span class="line">6) <span class="string">&quot;counter:__rand_int__&quot;</span></span><br><span class="line">7) <span class="string">&quot;a&quot;</span></span><br><span class="line">8) <span class="string">&quot;d&quot;</span></span><br><span class="line">9) <span class="string">&quot;mylist&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="keyword">select</span> 3 <span class="comment"># 切换至3号数据库</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[3]&gt; <span class="comment"># 切换成功</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>清空当前数据库<code>flushdb</code></p>
</li>
<li><p>清除所有数据库<code>flushall</code></p>
</li>
</ul>
<blockquote>
<p>Redis 是单线程的！</p>
</blockquote>
<p>明白Redis是很快的，官方表示，<strong>Redis是基于内存操作，CPU不是Redis性能瓶颈，Redis的瓶颈是根据机器的内存和网络带宽</strong>，既然可以使用单线程来实现，就使用单线程了！所以就使用了单线程了！</p>
<p>Redis 是C 语言写的，官方提供的数据为 10W+ 的QPS，完全不比同样是使用 key-vale的Memecache差！</p>
<p><strong>Redis为什么单线程还这么快？</strong></p>
<p>1、误区1：高性能的服务器一定是多线程的？</p>
<p>2、误区2：多线程（CPU上下文会切换！）一定比单线程效率高！</p>
<p>速度：CPU&gt;内存&gt;硬盘</p>
<p>核心：redis 是将所有的数据全部放在内存中的，所以说使用单线程去操作效率就是最高的，</p>
<p>多线程（CPU上下文会切换：耗时的操作！！！），对于内存系统来说，如果没有上下文切换效率就是最高的！</p>
<p>多次读写都是在一个CPU上的，在内存情况下，这个就是最佳的方案！</p>
<h1 id="三、五大数据类型"><a href="#三、五大数据类型" class="headerlink" title="三、五大数据类型"></a>三、五大数据类型</h1><p>Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件MQ。 它支持多种类型的数据结构，如 字符串（strings）， 散列（hashes）， 列表（lists）， 集合（sets）， 有序集合（sorted sets） 与范围查询， bitmaps， hyperloglogs 和 地理空间（geospatial） 索引半径查询。 Redis 内置了 复制（replication），LUA脚本（Lua scripting）， LRU驱动事件（LRU eviction），事务（transactions） 和不同级别的 磁盘持久化（persistence）， 并通过Redis哨兵（Sentinel）和自动 分区（Cluster）提供高可用性（high availability）。</p>
<h2 id="1、常见命令"><a href="#1、常见命令" class="headerlink" title="1、常见命令"></a>1、常见命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379[3]&gt; keys *  <span class="comment"># 查看所有的key</span></span><br><span class="line">(empty array)</span><br><span class="line">127.0.0.1:6379[3]&gt; clear <span class="comment"># 清屏</span></span><br><span class="line">127.0.0.1:6379[3]&gt; <span class="built_in">set</span> name zyy <span class="comment"># set key</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[3]&gt; keys *</span><br><span class="line">1) <span class="string">&quot;name&quot;</span></span><br><span class="line">127.0.0.1:6379[3]&gt; <span class="built_in">set</span> age 1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[3]&gt; keys *</span><br><span class="line">1) <span class="string">&quot;age&quot;</span></span><br><span class="line">2) <span class="string">&quot;name&quot;</span></span><br><span class="line">127.0.0.1:6379[3]&gt; exists name <span class="comment"># 判断key是否存在 1存在，0不存在</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379[3]&gt; exists name1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379[3]&gt; move name 1 <span class="comment"># 将key移动到1号数据库</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379[3]&gt; keys *</span><br><span class="line">1) <span class="string">&quot;age&quot;</span></span><br><span class="line">127.0.0.1:6379[3]&gt; <span class="keyword">select</span> 1 <span class="comment"># 切换1号数据库</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[1]&gt; keys *</span><br><span class="line">1) <span class="string">&quot;name&quot;</span></span><br><span class="line">127.0.0.1:6379[1]&gt; get name <span class="comment"># get value</span></span><br><span class="line"><span class="string">&quot;zyy&quot;</span></span><br><span class="line">127.0.0.1:6379[1]&gt; <span class="keyword">select</span> 3</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[3]&gt; keys *</span><br><span class="line">1) <span class="string">&quot;age&quot;</span></span><br><span class="line">127.0.0.1:6379[3]&gt; ttl name <span class="comment"># 返回key的过期时间，-2 代表key不存在，-1代表存在可以，但是没有设置过期时间</span></span><br><span class="line">(<span class="built_in">integer</span>) -2</span><br><span class="line">127.0.0.1:6379[3]&gt; ttl age</span><br><span class="line">(<span class="built_in">integer</span>) -1</span><br><span class="line">127.0.0.1:6379[3]&gt; <span class="built_in">set</span> name3 3</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[3]&gt; keys *</span><br><span class="line">1) <span class="string">&quot;age&quot;</span></span><br><span class="line">2) <span class="string">&quot;name3&quot;</span></span><br><span class="line">127.0.0.1:6379[3]&gt; <span class="built_in">set</span> name zyy</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[3]&gt; keys *</span><br><span class="line">1) <span class="string">&quot;age&quot;</span></span><br><span class="line">2) <span class="string">&quot;name&quot;</span></span><br><span class="line">3) <span class="string">&quot;name3&quot;</span></span><br><span class="line">127.0.0.1:6379[3]&gt; expire name 10 <span class="comment">#设置key的过期时间，单位秒</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379[3]&gt; ttl name</span><br><span class="line">(<span class="built_in">integer</span>) 6</span><br><span class="line">127.0.0.1:6379[3]&gt; ttl name</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379[3]&gt; ttl name</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379[3]&gt; ttl name</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379[3]&gt; ttl name</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379[3]&gt; ttl name</span><br><span class="line">(<span class="built_in">integer</span>) -2</span><br><span class="line">127.0.0.1:6379[3]&gt; keys *</span><br><span class="line">1) <span class="string">&quot;age&quot;</span></span><br><span class="line">2) <span class="string">&quot;name3&quot;</span></span><br><span class="line">127.0.0.1:6379[3]&gt; <span class="built_in">type</span> age <span class="comment"># 查看key的数据类型</span></span><br><span class="line">string</span><br><span class="line">127.0.0.1:6379[3]&gt; del k1 <span class="comment"># 删除已存在的键。不存在的 key 会被忽略。</span></span><br></pre></td></tr></table></figure>

<h2 id="2、String（字符串）"><a href="#2、String（字符串）" class="headerlink" title="2、String（字符串）"></a>2、String（字符串）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#################################################</span></span><br><span class="line"><span class="comment">## 设置值 获取值 字符串长度  追加</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> key1 v1 <span class="comment"># 设置值</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get key1 <span class="comment"># 获取值</span></span><br><span class="line"><span class="string">&quot;v1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; keys * <span class="comment"># 查看所有的key</span></span><br><span class="line">1) <span class="string">&quot;key1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; exists key1 <span class="comment"># 判断key是否存在，存在返回1 ，不存在返回0</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; exists key2</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; append key1 <span class="string">&quot; hello&quot;</span> <span class="comment"># 追加字符串，返回总长度  当key存在就追加，当key不存在就相当于set key</span></span><br><span class="line">(<span class="built_in">integer</span>) 8</span><br><span class="line">127.0.0.1:6379&gt; get key1</span><br><span class="line"><span class="string">&quot;v1 hello&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; strlen key1 <span class="comment"># 获取字符串的长度</span></span><br><span class="line">(<span class="built_in">integer</span>) 8</span><br><span class="line">127.0.0.1:6379&gt; strlen key2</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;key1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; append key1 <span class="string">&quot;,zyy&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 12</span><br><span class="line">127.0.0.1:6379&gt; strlen key1</span><br><span class="line">(<span class="built_in">integer</span>) 12</span><br><span class="line">127.0.0.1:6379&gt; append key2 <span class="string">&quot;zyy&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; get key1</span><br><span class="line"><span class="string">&quot;v1 hello,zyy&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; get key2</span><br><span class="line"><span class="string">&quot;zyy&quot;</span></span><br><span class="line"><span class="comment">#################################################</span></span><br><span class="line"><span class="comment">## 自增 自检 ###</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> views 0</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get views</span><br><span class="line"><span class="string">&quot;0&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; incr views <span class="comment"># 自增1 </span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; incr views</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; get views</span><br><span class="line"><span class="string">&quot;2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; decr views <span class="comment"># 自减1 </span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; decr views</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; decr views</span><br><span class="line">(<span class="built_in">integer</span>) -1</span><br><span class="line">127.0.0.1:6379&gt; decr views</span><br><span class="line">(<span class="built_in">integer</span>) -2</span><br><span class="line">127.0.0.1:6379&gt; get views</span><br><span class="line"><span class="string">&quot;-2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; incrby views 10 <span class="comment"># 可以设置步长，指定增量</span></span><br><span class="line">(<span class="built_in">integer</span>) 8</span><br><span class="line">127.0.0.1:6379&gt; decrby views 5</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"><span class="comment">#################################################</span></span><br><span class="line"><span class="comment">## 截取字符串  替换字符串</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> key1 <span class="string">&quot;hello,zyy&quot;</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get key1</span><br><span class="line"><span class="string">&quot;hello,zyy&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; getrange key1 0 3  <span class="comment"># 截取字符串[0,3]</span></span><br><span class="line"><span class="string">&quot;hell&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; getrange key1 0 -1 <span class="comment"># 获取全部字符串 和 get key 一样</span></span><br><span class="line"><span class="string">&quot;hello,zyy&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> key2 123456</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get key2</span><br><span class="line"><span class="string">&quot;123456&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; setrange key2 1 bcd <span class="comment"># 替换指定位置开始的字符串</span></span><br><span class="line">(<span class="built_in">integer</span>) 6</span><br><span class="line">127.0.0.1:6379&gt; get key2</span><br><span class="line"><span class="string">&quot;1bcd56&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; </span><br><span class="line"><span class="comment">#################################################</span></span><br><span class="line"><span class="comment">## 设置过期时间  setnx可用于分布式锁</span></span><br><span class="line">127.0.0.1:6379&gt; setex key1 30 <span class="string">&quot;hello&quot;</span> <span class="comment"># 设置key1的值为hello 并且30秒后过期</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; ttl key1 <span class="comment"># 剩余时间</span></span><br><span class="line">(<span class="built_in">integer</span>) 24</span><br><span class="line">127.0.0.1:6379&gt; ttl key1</span><br><span class="line">(<span class="built_in">integer</span>) 22</span><br><span class="line">127.0.0.1:6379&gt; setnx key2 <span class="string">&quot;123&quot;</span> <span class="comment"># 如果key2不存在，就创建key2,创建成功，返回1</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;key2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; setnx key2 <span class="string">&quot;456&quot;</span> <span class="comment"># 如果key2存在，就创建key2失败，返回0</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; </span><br><span class="line"><span class="comment">#################################################</span></span><br><span class="line">127.0.0.1:6379&gt; mset k1 v1 k2 v2 k3 v3 <span class="comment"># 同时设置多个值</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;k2&quot;</span></span><br><span class="line">2) <span class="string">&quot;k3&quot;</span></span><br><span class="line">3) <span class="string">&quot;k1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; mget k1 k2 k3 <span class="comment"># 同时获取多个值</span></span><br><span class="line">1) <span class="string">&quot;v1&quot;</span></span><br><span class="line">2) <span class="string">&quot;v2&quot;</span></span><br><span class="line">3) <span class="string">&quot;v3&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; mget k1 k2 k3 k4</span><br><span class="line">1) <span class="string">&quot;v1&quot;</span></span><br><span class="line">2) <span class="string">&quot;v2&quot;</span></span><br><span class="line">3) <span class="string">&quot;v3&quot;</span></span><br><span class="line">4) (nil)</span><br><span class="line">127.0.0.1:6379&gt; msetnx k1 v1 k4 v4  <span class="comment"># msetnx 是一个原子性的操作，要么一起成功，要么一起失败！</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; get k4</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> user:1 &#123;name:zyy,age:18&#125; <span class="comment"># 设置一个user:1 对象，值为json字符来保存一个对象</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;k2&quot;</span></span><br><span class="line">2) <span class="string">&quot;k3&quot;</span></span><br><span class="line">3) <span class="string">&quot;k1&quot;</span></span><br><span class="line">4) <span class="string">&quot;user:1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; get user:1:name</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; get user:1</span><br><span class="line"><span class="string">&quot;&#123;name:zyy,age:18&#125;&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> user:2 &#123;name:zyy2,age:18&#125;</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;k2&quot;</span></span><br><span class="line">2) <span class="string">&quot;k1&quot;</span></span><br><span class="line">3) <span class="string">&quot;k3&quot;</span></span><br><span class="line">4) <span class="string">&quot;user:1&quot;</span></span><br><span class="line">5) <span class="string">&quot;user:2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; mset user:1:name zyy user:1:age 18 <span class="comment"># 这里的key是一个巧妙的设计： user:&#123;id&#125;:&#123;filed&#125; , 如此设计在Redis中是完全OK了！</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;k2&quot;</span></span><br><span class="line">2) <span class="string">&quot;k1&quot;</span></span><br><span class="line">3) <span class="string">&quot;k3&quot;</span></span><br><span class="line">4) <span class="string">&quot;user:1&quot;</span></span><br><span class="line">5) <span class="string">&quot;user:1:age&quot;</span></span><br><span class="line">6) <span class="string">&quot;user:1:name&quot;</span></span><br><span class="line">7) <span class="string">&quot;user:2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; mget user:1:name user:1:age</span><br><span class="line">1) <span class="string">&quot;zyy&quot;</span></span><br><span class="line">2) <span class="string">&quot;18&quot;</span></span><br><span class="line"><span class="comment">#################################################</span></span><br><span class="line"><span class="comment">## getset 先get再set</span></span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(empty array)</span><br><span class="line">127.0.0.1:6379&gt; getset k1 v1 <span class="comment"># 先get，再set  如果一开始key就不存在，就返回nil</span></span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line"><span class="string">&quot;v1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; getset k1 1 <span class="comment"># # 先get，再set  如果一开始值存在，就反正这个值（返回的旧值，设置的新值）</span></span><br><span class="line"><span class="string">&quot;v1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line"><span class="string">&quot;1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; </span><br></pre></td></tr></table></figure>

<p>String类似的使用场景：value除了是我们的字符串还可以是我们的数字！</p>
<ul>
<li>计数器</li>
<li>粉丝数</li>
<li>对象缓存存储</li>
</ul>
<h2 id="3、List（列表）"><a href="#3、List（列表）" class="headerlink" title="3、List（列表）"></a>3、List（列表）</h2><p>Redis列表是简单的字符串列表，按照插入顺序排序。按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）</p>
<p>在redis里面，我们可以把list玩成 栈、队列、阻塞队列！</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#################################################</span></span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(empty array)</span><br><span class="line">127.0.0.1:6379&gt; lpush list a b c <span class="comment"># 将一个或者多个值插入列表头部（左）</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 1 <span class="comment"># 获取指定范围的列表</span></span><br><span class="line">1) <span class="string">&quot;c&quot;</span></span><br><span class="line">2) <span class="string">&quot;b&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1 <span class="comment"># 获取列表中的所有值</span></span><br><span class="line">1) <span class="string">&quot;c&quot;</span></span><br><span class="line">2) <span class="string">&quot;b&quot;</span></span><br><span class="line">3) <span class="string">&quot;a&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; rpush list2 a b c <span class="comment"># 将一个或者多个值插入列表尾部（右）</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; lrange list2 0 -1</span><br><span class="line">1) <span class="string">&quot;a&quot;</span></span><br><span class="line">2) <span class="string">&quot;b&quot;</span></span><br><span class="line">3) <span class="string">&quot;c&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; </span><br><span class="line"><span class="comment">#################################################</span></span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(empty array)</span><br><span class="line">127.0.0.1:6379&gt; rpush list 1 2 3</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) <span class="string">&quot;1&quot;</span></span><br><span class="line">2) <span class="string">&quot;2&quot;</span></span><br><span class="line">3) <span class="string">&quot;3&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; rrange list 0 -1 <span class="comment"># 没有rrange这个命令哦</span></span><br><span class="line">(error) ERR unknown <span class="built_in">command</span> <span class="string">&#x27;rrange&#x27;</span>, with args beginning with: <span class="string">&#x27;list&#x27;</span> <span class="string">&#x27;0&#x27;</span> <span class="string">&#x27;-1&#x27;</span> </span><br><span class="line">127.0.0.1:6379&gt; lpop list  <span class="comment"># 移除list第一个元素</span></span><br><span class="line"><span class="string">&quot;1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1 <span class="comment">#移除list最后一个元素</span></span><br><span class="line">1) <span class="string">&quot;2&quot;</span></span><br><span class="line">2) <span class="string">&quot;3&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; rpop list </span><br><span class="line"><span class="string">&quot;3&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) <span class="string">&quot;2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; </span><br><span class="line"><span class="comment">#################################################</span></span><br><span class="line">127.0.0.1:6379&gt; rpush list 1 2 3 4</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; lrange list</span><br><span class="line">(error) ERR wrong number of arguments <span class="keyword">for</span> <span class="string">&#x27;lrange&#x27;</span> <span class="built_in">command</span></span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) <span class="string">&quot;1&quot;</span></span><br><span class="line">2) <span class="string">&quot;2&quot;</span></span><br><span class="line">3) <span class="string">&quot;3&quot;</span></span><br><span class="line">4) <span class="string">&quot;4&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; lindex list 0 <span class="comment"># 通过下标获得 list 中的某一个值！</span></span><br><span class="line"><span class="string">&quot;1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; lindex list 5</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; lindex list 3</span><br><span class="line"><span class="string">&quot;4&quot;</span></span><br><span class="line"><span class="comment">#################################################</span></span><br><span class="line">127.0.0.1:6379&gt; clear</span><br><span class="line">127.0.0.1:6379&gt; rpush list 1 2 3 4</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) <span class="string">&quot;1&quot;</span></span><br><span class="line">2) <span class="string">&quot;2&quot;</span></span><br><span class="line">3) <span class="string">&quot;3&quot;</span></span><br><span class="line">4) <span class="string">&quot;4&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; llen list <span class="comment"># 返回列表长度</span></span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; </span><br><span class="line"><span class="comment">#################################################</span></span><br><span class="line">127.0.0.1:6379&gt; rpush list 1 2 3 4</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) <span class="string">&quot;1&quot;</span></span><br><span class="line">2) <span class="string">&quot;2&quot;</span></span><br><span class="line">3) <span class="string">&quot;3&quot;</span></span><br><span class="line">4) <span class="string">&quot;4&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; llen list</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; lrem list 1 1</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) <span class="string">&quot;2&quot;</span></span><br><span class="line">2) <span class="string">&quot;3&quot;</span></span><br><span class="line">3) <span class="string">&quot;4&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; lrem list 2 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; lpush list 1 1</span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) <span class="string">&quot;1&quot;</span></span><br><span class="line">2) <span class="string">&quot;1&quot;</span></span><br><span class="line">3) <span class="string">&quot;2&quot;</span></span><br><span class="line">4) <span class="string">&quot;3&quot;</span></span><br><span class="line">5) <span class="string">&quot;4&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; lrem list 1 2</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) <span class="string">&quot;1&quot;</span></span><br><span class="line">2) <span class="string">&quot;1&quot;</span></span><br><span class="line">3) <span class="string">&quot;3&quot;</span></span><br><span class="line">4) <span class="string">&quot;4&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; lrem list 2 1 <span class="comment"># 移除list集合中指定个数的value，精确匹配</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) <span class="string">&quot;3&quot;</span></span><br><span class="line">2) <span class="string">&quot;4&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; </span><br><span class="line"><span class="comment">#################################################</span></span><br><span class="line">127.0.0.1:6379&gt; rpush list 1 2 3 4</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) <span class="string">&quot;1&quot;</span></span><br><span class="line">2) <span class="string">&quot;2&quot;</span></span><br><span class="line">3) <span class="string">&quot;3&quot;</span></span><br><span class="line">4) <span class="string">&quot;4&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; ltrim list 1 2 <span class="comment"># 通过下标截取指定的长度，这个list已经被改变了，截断了 只剩下截取的元素！</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) <span class="string">&quot;2&quot;</span></span><br><span class="line">2) <span class="string">&quot;3&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; </span><br><span class="line"><span class="comment">#################################################</span></span><br><span class="line">127.0.0.1:6379&gt; rpush list 1 2 3 4</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) <span class="string">&quot;1&quot;</span></span><br><span class="line">2) <span class="string">&quot;2&quot;</span></span><br><span class="line">3) <span class="string">&quot;3&quot;</span></span><br><span class="line">4) <span class="string">&quot;4&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; rpoplpush list list2 <span class="comment"># 移除列表的最后一个元素，将他移动到新的列表的头部！</span></span><br><span class="line"><span class="string">&quot;4&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) <span class="string">&quot;1&quot;</span></span><br><span class="line">2) <span class="string">&quot;2&quot;</span></span><br><span class="line">3) <span class="string">&quot;3&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; lrange list2 0 -1</span><br><span class="line">1) <span class="string">&quot;4&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; </span><br><span class="line"><span class="comment">#################################################</span></span><br><span class="line">127.0.0.1:6379&gt; rpush list 1 2 3 4</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; exists list <span class="comment"># 判断列表是否存在，返回1就是存在， 返回0就是不存在</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; exists list2</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; lset list 0 a <span class="comment"># 替换这个下面对应的值</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) <span class="string">&quot;a&quot;</span></span><br><span class="line">2) <span class="string">&quot;2&quot;</span></span><br><span class="line">3) <span class="string">&quot;3&quot;</span></span><br><span class="line">4) <span class="string">&quot;4&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; lset list2 0 a <span class="comment"># 替换时，列表不存在报这个错误</span></span><br><span class="line">(error) ERR no such key</span><br><span class="line">127.0.0.1:6379&gt; lset list 4 a</span><br><span class="line">(error) ERR index out of range <span class="comment"># 替换时，下标越界报这个错误</span></span><br><span class="line">127.0.0.1:6379&gt; </span><br><span class="line"><span class="comment">#################################################</span></span><br><span class="line">127.0.0.1:6379&gt; flushdb</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; rpush list 1 2 3 4</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; linsert list before 1 0 <span class="comment"># 将某个具体的value插入到列把你中某个元素的前面或者后面！</span></span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) <span class="string">&quot;0&quot;</span></span><br><span class="line">2) <span class="string">&quot;1&quot;</span></span><br><span class="line">3) <span class="string">&quot;2&quot;</span></span><br><span class="line">4) <span class="string">&quot;3&quot;</span></span><br><span class="line">5) <span class="string">&quot;4&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; linsert list after 4 5</span><br><span class="line">(<span class="built_in">integer</span>) 6</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) <span class="string">&quot;0&quot;</span></span><br><span class="line">2) <span class="string">&quot;1&quot;</span></span><br><span class="line">3) <span class="string">&quot;2&quot;</span></span><br><span class="line">4) <span class="string">&quot;3&quot;</span></span><br><span class="line">5) <span class="string">&quot;4&quot;</span></span><br><span class="line">6) <span class="string">&quot;5&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; </span><br></pre></td></tr></table></figure>

<blockquote>
<p>小结</p>
</blockquote>
<ul>
<li>他实际上是一个链表，before Node after ， left，right 都可以插入值</li>
<li>如果key 不存在，创建新的链表</li>
<li>如果key存在，新增内容</li>
<li>如果移除了所有值，空链表，也代表不存在</li>
<li>在两边插入或者改动值，效率最高！ 中间元素，相对来说效率会低一点~</li>
</ul>
<p>消息队列（Lpush Rpop）</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-18/ce6a1c42a3b3c6be6148e81ac4cfe196--2f13--image-20240918193951067.png" alt="image-20240918193951067"></p>
<p>栈（ Lpush Lpop）</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-18/b456052fd61d13bc0061169663b6b004--1542--image-20240918193959804.png" alt="image-20240918193959804"></p>
<h2 id="4、Set集合"><a href="#4、Set集合" class="headerlink" title="4、Set集合"></a>4、Set集合</h2><p>Redis 的 Set 是 String 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#################################################</span></span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(empty array)</span><br><span class="line">127.0.0.1:6379&gt; sadd setkey1 1 2 3 4 <span class="comment"># 	set集合中添加元素</span></span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; smembers setkey1 <span class="comment"># 查看指定set的所有值</span></span><br><span class="line">1) <span class="string">&quot;1&quot;</span></span><br><span class="line">2) <span class="string">&quot;2&quot;</span></span><br><span class="line">3) <span class="string">&quot;3&quot;</span></span><br><span class="line">4) <span class="string">&quot;4&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; sismember setkey1 1  <span class="comment"># 判断某一个值是不是在set集合中！ 返回1代表存在，返回0代表不存在</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sismember setkey1 5</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; sadd setkey1 5</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; smembers setkey1</span><br><span class="line">1) <span class="string">&quot;1&quot;</span></span><br><span class="line">2) <span class="string">&quot;2&quot;</span></span><br><span class="line">3) <span class="string">&quot;3&quot;</span></span><br><span class="line">4) <span class="string">&quot;4&quot;</span></span><br><span class="line">5) <span class="string">&quot;5&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; sadd setkey1 1 2 <span class="comment"># set集合不可添加重复的值</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; smembers setkey1</span><br><span class="line">1) <span class="string">&quot;1&quot;</span></span><br><span class="line">2) <span class="string">&quot;2&quot;</span></span><br><span class="line">3) <span class="string">&quot;3&quot;</span></span><br><span class="line">4) <span class="string">&quot;4&quot;</span></span><br><span class="line">5) <span class="string">&quot;5&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; scard setkey1 <span class="comment"># 获取set集合中的内容元素个数！</span></span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line">127.0.0.1:6379&gt; </span><br><span class="line"><span class="comment">#################################################</span></span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(empty array)</span><br><span class="line">127.0.0.1:6379&gt; sadd set1 1 2 3 4</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; smembers set1</span><br><span class="line">1) <span class="string">&quot;1&quot;</span></span><br><span class="line">2) <span class="string">&quot;2&quot;</span></span><br><span class="line">3) <span class="string">&quot;3&quot;</span></span><br><span class="line">4) <span class="string">&quot;4&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; srem set1 1 <span class="comment"># 移除set集合中的指定元素</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; smembers set1</span><br><span class="line">1) <span class="string">&quot;2&quot;</span></span><br><span class="line">2) <span class="string">&quot;3&quot;</span></span><br><span class="line">3) <span class="string">&quot;4&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; scard set1</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; </span><br><span class="line"><span class="comment">#################################################</span></span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(empty array)</span><br><span class="line">127.0.0.1:6379&gt; sadd set1 1 2 3 4</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; smembers set1</span><br><span class="line">1) <span class="string">&quot;1&quot;</span></span><br><span class="line">2) <span class="string">&quot;2&quot;</span></span><br><span class="line">3) <span class="string">&quot;3&quot;</span></span><br><span class="line">4) <span class="string">&quot;4&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; srandmember set1 <span class="comment"># 随机抽选出一个元素</span></span><br><span class="line"><span class="string">&quot;3&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; srandmember set1</span><br><span class="line"><span class="string">&quot;1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; srandmember set1 2 <span class="comment"># 随机抽选出指定个数的元素</span></span><br><span class="line">1) <span class="string">&quot;2&quot;</span></span><br><span class="line">2) <span class="string">&quot;1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; srandmember set1 2</span><br><span class="line">1) <span class="string">&quot;3&quot;</span></span><br><span class="line">2) <span class="string">&quot;2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; </span><br><span class="line"><span class="comment">#################################################</span></span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(empty array)</span><br><span class="line">127.0.0.1:6379&gt; sadd set1 1 2 3 4</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; smembers set1</span><br><span class="line">1) <span class="string">&quot;1&quot;</span></span><br><span class="line">2) <span class="string">&quot;2&quot;</span></span><br><span class="line">3) <span class="string">&quot;3&quot;</span></span><br><span class="line">4) <span class="string">&quot;4&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; spop set1 <span class="comment"># 随机删除一些set集合中的元素！</span></span><br><span class="line"><span class="string">&quot;1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; spop set1 </span><br><span class="line"><span class="string">&quot;3&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; spop set1 2 <span class="comment"># 随机删除指定个数的元素</span></span><br><span class="line">1) <span class="string">&quot;2&quot;</span></span><br><span class="line">2) <span class="string">&quot;4&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; spop set1 </span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; smembers set1</span><br><span class="line">(empty array)</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(empty array)</span><br><span class="line">127.0.0.1:6379&gt; </span><br><span class="line"><span class="comment">#################################################</span></span><br><span class="line">127.0.0.1:6379&gt; sadd set1 1 2 3 4</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; smembers set1</span><br><span class="line">1) <span class="string">&quot;1&quot;</span></span><br><span class="line">2) <span class="string">&quot;2&quot;</span></span><br><span class="line">3) <span class="string">&quot;3&quot;</span></span><br><span class="line">4) <span class="string">&quot;4&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; smove set1 set2 1 <span class="comment"># 将集合中的一个指定的值，移动到另外一个set集合！</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; smembers set1</span><br><span class="line">1) <span class="string">&quot;2&quot;</span></span><br><span class="line">2) <span class="string">&quot;3&quot;</span></span><br><span class="line">3) <span class="string">&quot;4&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; smembers set2</span><br><span class="line">1) <span class="string">&quot;1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; </span><br><span class="line"><span class="comment">#################################################</span></span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(empty array)</span><br><span class="line">127.0.0.1:6379&gt; sadd set1 1 2 3 4</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; sadd set2 3 4 5 6</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; smembers set1</span><br><span class="line">1) <span class="string">&quot;1&quot;</span></span><br><span class="line">2) <span class="string">&quot;2&quot;</span></span><br><span class="line">3) <span class="string">&quot;3&quot;</span></span><br><span class="line">4) <span class="string">&quot;4&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; smembers set2</span><br><span class="line">1) <span class="string">&quot;3&quot;</span></span><br><span class="line">2) <span class="string">&quot;4&quot;</span></span><br><span class="line">3) <span class="string">&quot;5&quot;</span></span><br><span class="line">4) <span class="string">&quot;6&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; sdiff set1 set2 <span class="comment"># 差集</span></span><br><span class="line">1) <span class="string">&quot;1&quot;</span></span><br><span class="line">2) <span class="string">&quot;2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; sinter set1 set2 <span class="comment"># 交集  通用好友就可以这样实现</span></span><br><span class="line">1) <span class="string">&quot;3&quot;</span></span><br><span class="line">2) <span class="string">&quot;4&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; sunion set1 set2 <span class="comment">#并集</span></span><br><span class="line">1) <span class="string">&quot;1&quot;</span></span><br><span class="line">2) <span class="string">&quot;2&quot;</span></span><br><span class="line">3) <span class="string">&quot;3&quot;</span></span><br><span class="line">4) <span class="string">&quot;4&quot;</span></span><br><span class="line">5) <span class="string">&quot;5&quot;</span></span><br><span class="line">6) <span class="string">&quot;6&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; </span><br></pre></td></tr></table></figure>

<h2 id="5、Hash（哈希）"><a href="#5、Hash（哈希）" class="headerlink" title="5、Hash（哈希）"></a>5、Hash（哈希）</h2><p>Redis hash 是一个 string 类型的 field（字段） 和 value（值） 的映射表，hash 特别适合用于存储对象。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#################################################</span></span><br><span class="line">127.0.0.1:6379&gt; hset myhash1 f1 v1 <span class="comment"># set一个具体 key-vlaue</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; hget myhash1 f1 <span class="comment"># 获取一个字段值</span></span><br><span class="line"><span class="string">&quot;v1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; hmset myhash2 f1 v1 f2 v2  <span class="comment"># set多个 key-vlaue</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;myhash2&quot;</span></span><br><span class="line">2) <span class="string">&quot;myhash1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; hmget myhash2 f1 f2 <span class="comment"># 获取多个字段值</span></span><br><span class="line">1) <span class="string">&quot;v1&quot;</span></span><br><span class="line">2) <span class="string">&quot;v2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; hgetall myhash2 <span class="comment"># 获取全部的数据</span></span><br><span class="line">1) <span class="string">&quot;f1&quot;</span></span><br><span class="line">2) <span class="string">&quot;v1&quot;</span></span><br><span class="line">3) <span class="string">&quot;f2&quot;</span></span><br><span class="line">4) <span class="string">&quot;v2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; hdel myhash2 f1 <span class="comment"># 删除hash指定key字段！对应的value值也就消失了！</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; hgetall myhash2</span><br><span class="line">1) <span class="string">&quot;f2&quot;</span></span><br><span class="line">2) <span class="string">&quot;v2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; </span><br><span class="line"><span class="comment">#################################################</span></span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(empty array)</span><br><span class="line">127.0.0.1:6379&gt; hmset myhash1 f1 v1 f2 v2</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; hgetall myhash1</span><br><span class="line">1) <span class="string">&quot;f1&quot;</span></span><br><span class="line">2) <span class="string">&quot;v1&quot;</span></span><br><span class="line">3) <span class="string">&quot;f2&quot;</span></span><br><span class="line">4) <span class="string">&quot;v2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; hlen myhash1 <span class="comment"># 获取hash表的字段数量！</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt;</span><br><span class="line"><span class="comment">#################################################</span></span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(empty array)</span><br><span class="line">127.0.0.1:6379&gt; hmset myhash1 f1 v2 f2 v2</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; hgetall myhash1</span><br><span class="line">1) <span class="string">&quot;f1&quot;</span></span><br><span class="line">2) <span class="string">&quot;v2&quot;</span></span><br><span class="line">3) <span class="string">&quot;f2&quot;</span></span><br><span class="line">4) <span class="string">&quot;v2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; hexists myhash1 f1 <span class="comment"># 判断hash中指定字段是否存在 返回1说明存在，返回0说明不存在</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; hexists myhash1 f3</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; </span><br><span class="line"></span><br><span class="line"><span class="comment">#################################################</span></span><br><span class="line">127.0.0.1:6379&gt; hmset myhash1 f1 v1 f2 v2</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; hkeys myhash1 <span class="comment"># 只获得所有field</span></span><br><span class="line">1) <span class="string">&quot;f1&quot;</span></span><br><span class="line">2) <span class="string">&quot;f2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; hvals myhash1 <span class="comment"># 只获得所有value</span></span><br><span class="line">1) <span class="string">&quot;v1&quot;</span></span><br><span class="line">2) <span class="string">&quot;v2&quot;</span></span><br><span class="line"><span class="comment">#################################################</span></span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(empty array)</span><br><span class="line">127.0.0.1:6379&gt; hset myhash1 f1 1</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; hgetall myhash1</span><br><span class="line">1) <span class="string">&quot;f1&quot;</span></span><br><span class="line">2) <span class="string">&quot;1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; hincrby myhash1 f1 1 <span class="comment">#指定增量 自增</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; hincrby myhash1 f1 1</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; hincrby myhash1 f1 3</span><br><span class="line">(<span class="built_in">integer</span>) 6</span><br><span class="line">127.0.0.1:6379&gt; hincrby myhash1 f1 -1</span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line">127.0.0.1:6379&gt; hsetnx myhash2 f1 v1 <span class="comment"># 如果field不存在，则设置成功，返回1</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; hgetall myhash2</span><br><span class="line">1) <span class="string">&quot;f1&quot;</span></span><br><span class="line">2) <span class="string">&quot;v1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; hsetnx myhash2 f1 v11  <span class="comment">#如果field存在，则设置失败，返回1</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; hsetnx myhash2 f2 v2</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; </span><br></pre></td></tr></table></figure>

<p>hash变更的数据 user name age,尤其是是用户信息之类的，经常变动的信息！ </p>
<p>hash 更适合于对象的存储，String更加适合字符串存储！</p>
<h2 id="6、Zset（有序集合）"><a href="#6、Zset（有序集合）" class="headerlink" title="6、Zset（有序集合）"></a>6、Zset（有序集合）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#################################################</span></span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(empty array)</span><br><span class="line">127.0.0.1:6379&gt; zadd myset 1 a  <span class="comment"># 添加一个值</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd myset 2 b </span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd myset 3 c 4 d <span class="comment"># 添加多个值</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; zrange myset 0 -1 <span class="comment"># 获取所有的值</span></span><br><span class="line">1) <span class="string">&quot;a&quot;</span></span><br><span class="line">2) <span class="string">&quot;b&quot;</span></span><br><span class="line">3) <span class="string">&quot;c&quot;</span></span><br><span class="line">4) <span class="string">&quot;d&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; </span><br><span class="line"><span class="comment">#################################################</span></span><br><span class="line">127.0.0.1:6379&gt; zadd salary 60 zhangsan</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd salary 80 lisi</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd salary 50 wangwu</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; zrange salary 0 -1</span><br><span class="line">1) <span class="string">&quot;wangwu&quot;</span></span><br><span class="line">2) <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line">3) <span class="string">&quot;lisi&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; zrangebyscore salary -inf +inf <span class="comment"># 显示全部的用户 从小到大！（-inf 代表负无穷  +inf代表正无穷）</span></span><br><span class="line">1) <span class="string">&quot;wangwu&quot;</span></span><br><span class="line">2) <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line">3) <span class="string">&quot;lisi&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; zrevrange salary 0 -1 <span class="comment"># 从大大小排序</span></span><br><span class="line">1) <span class="string">&quot;lisi&quot;</span></span><br><span class="line">2) <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line">3) <span class="string">&quot;wangwu&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; zrangebyscore salary -inf +inf withscores <span class="comment">#从小到大显示所有的用户并附带薪资</span></span><br><span class="line">1) <span class="string">&quot;wangwu&quot;</span></span><br><span class="line">2) <span class="string">&quot;50&quot;</span></span><br><span class="line">3) <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line">4) <span class="string">&quot;60&quot;</span></span><br><span class="line">5) <span class="string">&quot;lisi&quot;</span></span><br><span class="line">6) <span class="string">&quot;80&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; zrangebyscore salary -inf 60 withscores <span class="comment"># 显示薪资小于等于60的用户并附带薪资</span></span><br><span class="line">1) <span class="string">&quot;wangwu&quot;</span></span><br><span class="line">2) <span class="string">&quot;50&quot;</span></span><br><span class="line">3) <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line">4) <span class="string">&quot;60&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; </span><br><span class="line"><span class="comment">#################################################</span></span><br><span class="line">127.0.0.1:6379&gt; zadd salary 5000 zhangsan 6000 lisi 10000 wangwu 3000 zhaoliu</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; zrange salary 0 -1</span><br><span class="line">1) <span class="string">&quot;zhaoliu&quot;</span></span><br><span class="line">2) <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line">3) <span class="string">&quot;lisi&quot;</span></span><br><span class="line">4) <span class="string">&quot;wangwu&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; zrem salary lisi <span class="comment"># 移除有序集合中的指定元素</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; zrange salary 0 -1</span><br><span class="line">1) <span class="string">&quot;zhaoliu&quot;</span></span><br><span class="line">2) <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line">3) <span class="string">&quot;wangwu&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; zcard salary <span class="comment"># 获取有序集合中的个数</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; </span><br><span class="line"><span class="comment">#################################################</span></span><br><span class="line">127.0.0.1:6379&gt; zadd myset 1 a 2 b 3 c</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; zcount myset 1 3 <span class="comment"># 获取指定区间的成员数量！</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; zcount myset 1 2</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; zcount myset 2 3</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; </span><br><span class="line"><span class="comment">#################################################</span></span><br></pre></td></tr></table></figure>

<p>其余的一些api，可以去查询官方文档</p>
<p>案例思路：</p>
<ul>
<li><p>set 排序、存储班级成绩，工资表排序</p>
</li>
<li><p>加权：1-重要消息 0-普通消息</p>
</li>
<li><p>排行榜应用实现，取top 10</p>
</li>
</ul>
<h1 id="四、三种特殊数据类型"><a href="#四、三种特殊数据类型" class="headerlink" title="四、三种特殊数据类型"></a>四、三种特殊数据类型</h1><p>Redis在3.2版本中加入了地理空间(geospatial)以及索引半径查询的功能</p>
<p>主要用在需要地理位置的应用上</p>
<p>朋友的定位，附近的人，打车距离计算</p>
<p>查询城市经纬度：<a target="_blank" rel="noopener" href="http://www.jsons.cn/lngcode/">http://www.jsons.cn/lngcode/</a></p>
<blockquote>
<p>geodd 功能说明: 将指定的地理空间位置（纬度、经度、名称）添加到指定的key中。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># getadd 添加地理位置</span></span><br><span class="line"><span class="comment"># 规则：两级无法直接添加，我们一般会下载城市数据，直接通过java程序一次性导入！</span></span><br><span class="line"><span class="comment"># 有效的经度从-180度到180度。 有效的纬度从-85.05112878度到85.05112878度。 当坐标位置超出上述指定范围时，该命令将会返回一个错误。</span></span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(empty array)</span><br><span class="line">127.0.0.1:6379&gt; geoadd china:city 116.40 39.90 beijing</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; GEOADD china:city 121.47 31.23 shanghai</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; GEOADD china:city 120.15 30.28 hangzhou 106.50 29.53 chongqin 125.14 42.92 xian</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br></pre></td></tr></table></figure>

<blockquote>
<p>geopos   功能说明: 从key里返回所有给定位置元素的位置（经度和纬度）</p>
</blockquote>
<p>GEOPOS 命令返回一个数组， 数组中的每个项都由两个元素组成： 第一个元素为给定位置元素的经度， 而第二个元素则为给定位置元素的纬度。</p>
<p>当给定的位置元素不存在时， 对应的数组项为空值</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; geopos china:city xian</span><br><span class="line">1) 1) <span class="string">&quot;125.13999849557876587&quot;</span></span><br><span class="line">   2) <span class="string">&quot;42.92000122112879268&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>geodist    两人之间的距离！</p>
</blockquote>
<p>功能说明</p>
<ul>
<li>返回两个给定位置之间的距离，如果两个位置之间的其中一个不存在， 那么命令返回空值</li>
<li>指定单位的参数 unit 必须是以下单位的其中一个<ul>
<li>m 表示单位为米（默认值）</li>
<li>km 表示单位为千米</li>
<li>mi 表示单位为英里</li>
<li>ft 表示单位为英尺</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; geodist china:city beijing shanghai</span><br><span class="line"><span class="string">&quot;1067378.7564&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; geodist china:city beijing shanghai km</span><br><span class="line"><span class="string">&quot;1067.3788&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>georadius   </p>
</blockquote>
<p>我附近的人？ （获得所有附近的人的地址，定位！）通过半径来查询！</p>
<p>以给定的经纬度为中心， 返回键包含的位置元素当中，与中心的距离不超过给定最大距离的所有位置元素</p>
<p>在给定以下可选项时， 命令会返回额外的信息：</p>
<ul>
<li><p>withdist</p>
<p>在返回位置元素的同时， 将位置元素与中心之间的距离也一并返回。 距离的单位和用户给定的范围单位保持一致。</p>
</li>
<li><p>withcoord</p>
<p>将位置元素的经度和维度也一并返回。</p>
</li>
<li><p>withhash</p>
<p>以 52 位有符号整数的形式， 返回位置元素经过原始 geohash 编码的有序集合分值。 这个选项主要用于底层应用或者调试， 实际中的作用并不大。 命令默认返回未排序的位置元素。</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; georadius china:city 110 30 1000 km <span class="comment"># 以110，30 这个经纬度为中心，寻找方圆1000km内的城市</span></span><br><span class="line">1) <span class="string">&quot;chongqi&quot;</span></span><br><span class="line">2) <span class="string">&quot;hangzhou&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; georadius china:city 110 30 400 km</span><br><span class="line">1) <span class="string">&quot;chongqi&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; georadius china:city 110 30 400 km withdist <span class="comment"># 显示直线距离</span></span><br><span class="line">1) 1) <span class="string">&quot;chongqi&quot;</span></span><br><span class="line">   2) <span class="string">&quot;341.9374&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; georadius china:city 110 30 400 km withcoord <span class="comment"># 显示经纬度</span></span><br><span class="line">1) 1) <span class="string">&quot;chongqi&quot;</span></span><br><span class="line">   2) 1) <span class="string">&quot;106.49999767541885376&quot;</span></span><br><span class="line">      2) <span class="string">&quot;29.52999957900659211&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; georadius china:city 110 30 400 km withhash</span><br><span class="line">1) 1) <span class="string">&quot;chongqi&quot;</span></span><br><span class="line">   2) (<span class="built_in">integer</span>) 4026042091628984</span><br><span class="line">127.0.0.1:6379&gt; georadius china:city 110 30 400 km withcoord count 1 <span class="comment"># 筛选出指定数量的结果</span></span><br><span class="line">1) 1) <span class="string">&quot;chongqi&quot;</span></span><br><span class="line">   2) 1) <span class="string">&quot;106.49999767541885376&quot;</span></span><br><span class="line">      2) <span class="string">&quot;29.52999957900659211&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; georadius china:city 110 30 1000 km withcoord count 2</span><br><span class="line">1) 1) <span class="string">&quot;chongqi&quot;</span></span><br><span class="line">   2) 1) <span class="string">&quot;106.49999767541885376&quot;</span></span><br><span class="line">      2) <span class="string">&quot;29.52999957900659211&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;hangzhou&quot;</span></span><br><span class="line">   2) 1) <span class="string">&quot;120.15000075101852417&quot;</span></span><br><span class="line">      2) <span class="string">&quot;30.2800007575645509&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>georadiusbymember</p>
</blockquote>
<p>功能说明: 这个命令和 GEORADIUS 命令一样， 都可以找出位于指定范围内的元素， 但是 <strong>GEORADIUSBYMEMBER 的中心点是由给定的位置元素决定的</strong>， 而不是像 GEORADIUS 那样， 使用输入的经度和纬度来决定中心点指定成员的位置被用作查询的中心</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; GEORADIUSBYMEMBER china:city beijing 1000 km  <span class="comment"># 以北京为中心，附近1000米的城市</span></span><br><span class="line">1) <span class="string">&quot;beijing&quot;</span></span><br><span class="line">2) <span class="string">&quot;xian&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>geohash</p>
</blockquote>
<p>该命令将返回11个字符的Geohash字符串!</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将二维的经纬度转换为一维的字符串，如果两个字符串越接近，那么则距离越近！</span></span><br><span class="line">127.0.0.1:6379&gt; GEOHASH china:city beijing</span><br><span class="line">1) <span class="string">&quot;wx4fbxxfke0&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>geo底层的实现原理其实就是zset！我们可以使用zset命令来操作geo！</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zrange china:city 0 -1 <span class="comment"># 查看全部的元素</span></span><br><span class="line">1) <span class="string">&quot;chongqi&quot;</span></span><br><span class="line">2) <span class="string">&quot;hangzhou&quot;</span></span><br><span class="line">3) <span class="string">&quot;shanghai&quot;</span></span><br><span class="line">4) <span class="string">&quot;beijing&quot;</span></span><br><span class="line">5) <span class="string">&quot;xian&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; zrem china:city xian <span class="comment"># 移除指定的元素</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; zrange china:city 0 -1</span><br><span class="line">1) <span class="string">&quot;chongqi&quot;</span></span><br><span class="line">2) <span class="string">&quot;hangzhou&quot;</span></span><br><span class="line">3) <span class="string">&quot;shanghai&quot;</span></span><br><span class="line">4) <span class="string">&quot;beijing&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; </span><br></pre></td></tr></table></figure>



<h2 id="2、hyperloglog"><a href="#2、hyperloglog" class="headerlink" title="2、hyperloglog"></a>2、hyperloglog</h2><blockquote>
<p>什么是基数</p>
</blockquote>
<p>比如数据集 {1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为 {1, 3, 5 ,7, 8}, </p>
<p>基数(不重复元素)为5。 基数估计就是在误差可接受的范围内，快速计算基数。</p>
<blockquote>
<p>简介</p>
</blockquote>
<p>Redis 2.8.9 版本就更新了 Hyperloglog 数据结构！</p>
<p>Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。</p>
<p>在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基 数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。</p>
<p>但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。</p>
<p><strong>网页的UV 一个人访问一个网站多次，但是还是算作一个人！）</strong></p>
<p>传统的方式， set 保存用户的id，然后就可以统计 set 中的元素数量作为标准判断 !</p>
<p>这个方式如果保存大量的用户id，就会比较麻烦！我们的目的是为了计数，而不是保存用户id；</p>
<blockquote>
<p>测试使用</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; pfadd mykey a b c d e  <span class="comment"># 创建第一组元素 mykey</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; pfcount mykey <span class="comment"># 统计 mykey 元素的基数数量</span></span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line">127.0.0.1:6379&gt; pfadd mykey2 e d f g h k  <span class="comment"># 创建第二组元素 mykey2</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; pfcount mykey2</span><br><span class="line">(<span class="built_in">integer</span>) 6</span><br><span class="line">127.0.0.1:6379&gt; pfmerge mykey3 mykey mykey2 <span class="comment"># 合并两组 mykey mykey2 ---&gt; mykey3  并集</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; pfcount mykey3</span><br><span class="line">(<span class="built_in">integer</span>) 9</span><br><span class="line">127.0.0.1:6379&gt; </span><br></pre></td></tr></table></figure>

<p>0.81% 错误率！ 统计UV任务，可以忽略不计的！</p>
<p>如果允许容错，那么一定可以使用 Hyperloglog </p>
<p>如果不允许容错，就使用 set 或者自己的数据类型即可！</p>
<h2 id="3、bitmap"><a href="#3、bitmap" class="headerlink" title="3、bitmap"></a>3、bitmap</h2><p>BitMap 原本的含义是用一个比特位来映射某个元素的状态。由于一个比特位只能表示 0 和 1 两种状态，所以 BitMap 能映射的状态有限，但是使用比特位的优势是能大量的节省内存空间。</p>
<blockquote>
<p>应用场景</p>
</blockquote>
<ul>
<li>用户签到</li>
<li>统计活跃用户（用户登陆情况）</li>
<li>统计用户是否在线</li>
<li>实现布隆过滤器</li>
</ul>
<blockquote>
<p>测试</p>
</blockquote>
<p>使用bitmap 来记录 周一到周日的打卡！</p>
<p>7天打卡</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; setbit sign 1 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 2 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 3 0</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 4 0</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 5 0</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 6 0</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 7 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure>

<p>查看某一天的打开情况</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; getbit sign 1</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; getbit sign 2</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; getbit sign 4</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>统计操作，统计 打卡的天数！</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; bitcount sign  <span class="comment"># 统计这周的打卡记录，就可以看到是否有全勤！</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; </span><br></pre></td></tr></table></figure>



<h1 id="五、事务"><a href="#五、事务" class="headerlink" title="五、事务"></a>五、事务</h1><p>Redis 事务本质：一组命令的集合！ 一个事务中的所有命令都会被序列化，在事务执行过程的中，会按照顺序执行！</p>
<p>一次性、顺序性、排他性！执行一系列的命令！</p>
<p>Redis事务没有没有隔离级别的概念！</p>
<p>所有的命令在事务中，并没有直接被执行！只有发起执行命令的时候才会执行！<code>exec</code></p>
<p><strong>Redis单条命令式保证原子性的，但是事务不保证原子性！</strong></p>
<p>Redis 事务可以一次执行多个命令， 并且带有以下三个重要的保证：</p>
<ul>
<li>批量操作在发送 EXEC 命令前被放入队列缓存</li>
<li>收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被执行</li>
<li>在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中</li>
</ul>
<p>一个事务从开始到执行会经历以下三个阶段：</p>
<ul>
<li>开启事务（multi）</li>
<li>命令入队（……）</li>
<li>执行事务（exec）</li>
</ul>
<blockquote>
<p>正常执行事务</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi  <span class="comment"># 开启事务</span></span><br><span class="line">OK</span><br><span class="line"><span class="comment"># 命名入队</span></span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k1 v1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k2 v2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; get k2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k3 v3</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">exec</span> <span class="comment"># 执行事务</span></span><br><span class="line">1) OK</span><br><span class="line">2) OK</span><br><span class="line">3) <span class="string">&quot;v2&quot;</span></span><br><span class="line">4) OK</span><br></pre></td></tr></table></figure>

<blockquote>
<p>放弃事务</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">discard <span class="comment"># 取消事务</span></span><br><span class="line"><span class="comment"># 取消事务后，事务中的命令都不会去执行</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>编译型异常（代码有误！命令有误！）事务中所有的命令都不会执行</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(empty array)</span><br><span class="line">127.0.0.1:6379&gt; multi <span class="comment"># 开启事务</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k1 v1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k2 v2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k3 v3</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; setget k3 <span class="comment"># 没有这个命令</span></span><br><span class="line">(error) ERR unknown <span class="built_in">command</span> <span class="string">&#x27;setget&#x27;</span>, with args beginning with: <span class="string">&#x27;k3&#x27;</span> </span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">exec</span> <span class="comment"># 执行事务报错！</span></span><br><span class="line">(error) EXECABORT Transaction discarded because of previous errors.</span><br><span class="line">127.0.0.1:6379&gt; get k1 <span class="comment"># 所有的命令都不会被执行！</span></span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>运行时异常，如果事务队列中存在语法性错误，那么执行命令的时候，其他命令是可以正常执行的，错误命令抛出错误</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(empty array)</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k1 v1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi <span class="comment"># 开启事务</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; incr k1 <span class="comment"># 执行的时候会失败</span></span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k2 v2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k3 v3</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; get k3</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">exec</span> <span class="comment"># 执行事务，虽然第一条命令报错了，但是后面的依旧正常执行成功了</span></span><br><span class="line">1) (error) ERR value is not an <span class="built_in">integer</span> or out of range</span><br><span class="line">2) OK</span><br><span class="line">3) OK</span><br><span class="line">4) <span class="string">&quot;v3&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; get k2</span><br><span class="line"><span class="string">&quot;v2&quot;</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>监控 watch</p>
</blockquote>
<ul>
<li><p>悲观锁</p>
<p>很悲观，认为什么时候都会出问题，无论做什么都会加锁！</p>
</li>
<li><p>乐观锁</p>
<p>很乐观，认为什么时候都不会出问题，所以不会上锁，更新数据的时候去判断一下，再此期间是否有人修改过这个数据</p>
<p>获取version</p>
<p>更新的时候带上version条件</p>
</li>
</ul>
<blockquote>
<p>redis监视</p>
</blockquote>
<p>正常情况</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> money 100 <span class="comment"># 现在有100块钱</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> out 0 <span class="comment"># 花出去了0元</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; watch money <span class="comment"># 监视money</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi <span class="comment">#开启事务</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; decrby money 20 <span class="comment"># 花了20，余额-20</span></span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; incrby out 20 <span class="comment"># 花出去的钱+20</span></span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">exec</span> <span class="comment"># 执行事务</span></span><br><span class="line">1) (<span class="built_in">integer</span>) 80 <span class="comment"># 结果：余额还有80</span></span><br><span class="line">2) (<span class="built_in">integer</span>) 20 <span class="comment"># 结果：花出去了20</span></span><br><span class="line">127.0.0.1:6379&gt; </span><br></pre></td></tr></table></figure>

<p>失败情况，模拟多线程修改值 , 使用watch 可以当做redis的乐观锁操作！</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; watch money <span class="comment"># 监视money</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi <span class="comment"># 开启事务</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; decrby money 10 <span class="comment"># 又花了10，余额-10</span></span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; incrby out 10 <span class="comment"># 花出去的钱+10</span></span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="comment"># exec 这里暂时不执行事务</span></span><br></pre></td></tr></table></figure>

<p>在上面执行事务之前，另外一个线程又往money中充了100块</p>
<p>重新开启一个redis服务</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;out&quot;</span></span><br><span class="line">2) <span class="string">&quot;money&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; get money</span><br><span class="line"><span class="string">&quot;80&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; incrby money 100 <span class="comment"># 充了100，余额+100</span></span><br><span class="line">(<span class="built_in">integer</span>) 180</span><br><span class="line">127.0.0.1:6379&gt; </span><br></pre></td></tr></table></figure>

<p>回到原来的redis服务，执行事务，发现执行失败</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">exec</span> <span class="comment"># 执行之前，另外一个线程，修改了我们的值，这个时候，就会导致事务执行失 败！</span></span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; </span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-21/94ebcbefd366a9f975240c018c79ab71--6aec--image-20240921095731846.png" alt="image-20240921095731846"></p>
<p>如何解决这个问题呢？</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; unwatch <span class="comment"># 1.如果发现事务执行失败，就先解锁</span></span><br><span class="line">127.0.0.1:6379&gt; watch money <span class="comment"># 2.获取最新的值，再次监视，select version</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; decrby money 10</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; incrby out 10</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">exec</span> <span class="comment"># 对比监视的值是否发生了变化，如果没有变化，就可以执行成功，如果变了就执行失败</span></span><br><span class="line">1) (<span class="built_in">integer</span>) 170</span><br><span class="line">2) (<span class="built_in">integer</span>) 30</span><br></pre></td></tr></table></figure>



<h1 id="六、jedis"><a href="#六、jedis" class="headerlink" title="六、jedis"></a>六、jedis</h1><p>什么是Jedis 是 Redis 官方推荐的 java连接开发工具！ 使用Java 操作Redis 中间件！如果你要使用</p>
<p>java操作redis，那么一定要对Jedis 十分的熟悉！</p>
<blockquote>
<p>测试使用</p>
</blockquote>
<p>1、首先就是新建一个maven项目，导入对应所需要的依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/redis.clients/jedis --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2、由于我们是在windows上进行测试，所以我们可以开启windows的redis服务端去测试一下。</p>
<p>3、编写简单的代码去测试redis的连接</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.github;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        System.out.println(jedis.ping());</span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-21/31d26b20c93072dc06423796cb2898fb--370a--image-20240921134438489.png" alt="image-20240921134438489"></p>
<p>5、测试功能（简单使用一下事务功能）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Transaction;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 类描述</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: zyy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2023/04/20 17:02</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestTX</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//连接redis</span></span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        <span class="comment">//清空key</span></span><br><span class="line">        jedis.flushDB();</span><br><span class="line">        <span class="comment">//开启事务</span></span><br><span class="line">        <span class="type">Transaction</span> <span class="variable">multi</span> <span class="operator">=</span> jedis.multi();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            multi.set(<span class="string">&quot;k1&quot;</span>, <span class="string">&quot;v1&quot;</span>);</span><br><span class="line">            multi.set(<span class="string">&quot;k2&quot;</span>, <span class="string">&quot;v2&quot;</span>);</span><br><span class="line">            <span class="comment">//这里抛出异常，应该事务执行失败</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//执行事务</span></span><br><span class="line">            multi.exec();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">//放弃事务</span></span><br><span class="line">            multi.discard();</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//获取key对应的值</span></span><br><span class="line">            System.out.println(jedis.get(<span class="string">&quot;k1&quot;</span>));</span><br><span class="line">            <span class="comment">//关闭连接</span></span><br><span class="line">            jedis.close();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-21/2d6155bbc2e8d5bd49448f0662266a75--97f2--image-20240921134812192.png" alt="image-20240921134812192"></p>
<p>事务执行失败，我们将异常代码注释后再次去执行</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-21/16528c65767cc3261262bd29ce9df9de--7e3f--image-20240921134859639.png" alt="image-20240921134859639"></p>
<p>成功完成对应事务的执行</p>
<h1 id="七、springboot整合"><a href="#七、springboot整合" class="headerlink" title="七、springboot整合"></a>七、springboot整合</h1><p>SpringData 也是和 SpringBoot 齐名的项目</p>
<p>官方：<a target="_blank" rel="noopener" href="https://spring.io/projects/spring-data-redis">https://spring.io/projects/spring-data-redis</a></p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-21/b0acc7270139d7e8b3ae9f05a3d7e2a9--f176--image-20240921134944904.png" alt="image-20240921134944904"></p>
<p>说明： 在 SpringBoot2.x 之后，原来使用的jedis 被替换为了 lettuce?</p>
<ul>
<li><p>jedis：采用的直连，多个线程操作的话，是不安全的，如果想要避免不安全，使用redis pool连接池，更像BIO模式！</p>
</li>
<li><p>lettuce：采用netty，实例可以再多个线程中进行共享，不存在线程不安全的情况，可以减少线程数据。更新NIO模式！</p>
</li>
</ul>
<blockquote>
<p>简单的使用</p>
</blockquote>
<p>1、首先就是配置对应的连接</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置redis1</span></span><br><span class="line"><span class="attr">spring.data.redis.host</span>=<span class="string">127.0.0.1</span></span><br><span class="line"><span class="attr">spring.data.redis.port</span>=<span class="string">6379</span></span><br></pre></td></tr></table></figure>

<p>2、编写简单的测试项目</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//redisTemplate 操作不同的数据类型，api和我们的linux指令一样</span></span><br><span class="line">        <span class="comment">//opsForValue 操作字符串</span></span><br><span class="line">        <span class="comment">//opsForList 操作List</span></span><br><span class="line">        <span class="comment">//opsForSet</span></span><br><span class="line">        <span class="comment">//opsForZSet</span></span><br><span class="line">        <span class="comment">//opsForHash</span></span><br><span class="line">        <span class="comment">//opsForGeo</span></span><br><span class="line">        <span class="comment">//opsForHyperLogLog</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//除了基本的操作，我们常用的方法都可以通过redisTemplate操作，比如事务，和基本的CRUD</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取redis的连接对象</span></span><br><span class="line"><span class="comment">//        RedisConnection connection = redisTemplate.getConnectionFactory().getConnection();</span></span><br><span class="line"><span class="comment">//        connection.flushDb();</span></span><br><span class="line"><span class="comment">//        connection.flushAll();</span></span><br><span class="line"></span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;zyy&quot;</span>);</span><br><span class="line">        System.out.println(redisTemplate.opsForValue().get(<span class="string">&quot;name&quot;</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-21/adc889f8e480d9101e9a682cf07cc03e--5f82--image-20240921141546981.png" alt="image-20240921141546981"></p>
<blockquote>
<p>进阶使用，使用redis存储对象</p>
</blockquote>
<p>User.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.github.demo.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">lizhua</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;lizhua&quot;</span>, <span class="number">15</span>);</span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;lizhua&quot;</span>, lizhua);</span><br><span class="line">        System.out.println(redisTemplate.opsForValue().get(<span class="string">&quot;lizhua&quot;</span>));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-21/d54e39df5466feaae7298cf97aee5e9a--02fa--image-20240921141850293.png" alt="image-20240921141850293"></p>
<blockquote>
<p>注！！！！！如需存储对象到redis中需要将对象继承序列化方法才可以</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-21/5fb2c887df536e08e31f621f6cf8adb8--df92--image-20240921142050011.png" alt="image-20240921142050011"></p>
<p>但是仅仅是这样还是不够完美，我们发现使用客户端去直接查看时，中文就变成乱码了</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-21/aea4bca65b7304367936beaf35015e1b--43f7--image-20240921142355477.png" alt="image-20240921142355477"></p>
<blockquote>
<p>为解决上述问题，自定义RedisTemplate</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.github.demo.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.JsonAutoDetect;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.JsonTypeInfo;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.PropertyAccessor;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.jsontype.impl.LaissezFaireSubTypeValidator;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.StringRedisSerializer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span> &#123;</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//连接工厂</span></span><br><span class="line">        template.setConnectionFactory(factory);</span><br><span class="line"></span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">objectMapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">        objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        <span class="comment">//enableDefaultTyping过期了</span></span><br><span class="line"><span class="comment">//        objectMapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span></span><br><span class="line">        <span class="comment">//用activateDefaultTyping代替</span></span><br><span class="line">        objectMapper.activateDefaultTyping(</span><br><span class="line">                LaissezFaireSubTypeValidator.instance ,</span><br><span class="line">                ObjectMapper.DefaultTyping.NON_FINAL,</span><br><span class="line">                JsonTypeInfo.As.WRAPPER_ARRAY);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//jackson序列化</span></span><br><span class="line">        Jackson2JsonRedisSerializer&lt;Object&gt; jackson2JsonRedisSerializer = <span class="keyword">new</span> <span class="title class_">Jackson2JsonRedisSerializer</span>&lt;&gt;(objectMapper, Object.class);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//String序列化</span></span><br><span class="line">        <span class="type">StringRedisSerializer</span> <span class="variable">stringRedisSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>();</span><br><span class="line">        <span class="comment">//key采用String的序列化方式</span></span><br><span class="line">        template.setKeySerializer(stringRedisSerializer);</span><br><span class="line">        <span class="comment">//hash的key也采用String的序列化方式</span></span><br><span class="line">        template.setHashKeySerializer(stringRedisSerializer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//value序列化方式采用jackson</span></span><br><span class="line">        template.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        <span class="comment">//hash的value序列化方式采用jackson</span></span><br><span class="line">        template.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line"></span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>再次运行上面的</p>
<p>正常取值</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-21/cc250327ab2d4ee774839c919d390770--b259--image-20240921143716188.png"></p>
<p>现在显示就是正常的了</p>
<p>所有的redis操作，其实对于java开发人员来说，十分的简单，更重要是要去理解redis的思想和每一种数</p>
<p>据结构的用处和作用场景！</p>
<h1 id="八、Redis-conf详解"><a href="#八、Redis-conf详解" class="headerlink" title="八、Redis.conf详解"></a>八、Redis.conf详解</h1><p>启动的时候，可以在启动加上配置文件位置，使用对应的配置文件去启动</p>
<blockquote>
<p>表明了对应的单位，并且表示大小写不敏感</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-21/fda14849b1e9af594d4baed01e26179c--d09c--image-20240921144117554.png" alt="image-20240921144117554"></p>
<blockquote>
<p>包含include，表名可以应用其他的配置文件</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-21/4f70669716fa4ed2b31fef9a7a32271f--d02d--image-20240921144208388.png" alt="image-20240921144208388"></p>
<blockquote>
<p>network 网络</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bind</span> 127.0.0.1  <span class="comment"># 绑定ip</span></span><br><span class="line">protected-mode <span class="built_in">yes</span> <span class="comment"># 是否开启保护模式，默认开启。要是配置里没有指定bind和密码。开启该参数后，redis只会本地进行访问，拒绝外部访问。要是开启了密码和bind，可以关闭。否则最好开启，设置为yes。</span></span><br><span class="line">port 6379 <span class="comment"># 端口</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>general 通用</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">daemonize <span class="built_in">yes</span> <span class="comment"># 以守护进程的方式运行(是否在后台执行)，默认是 no </span></span><br><span class="line">pidfile /var/run/redis_6379.pid <span class="comment"># 在后台的方式运行，我们就需要指定一个pid文件</span></span><br><span class="line">loglevel notice <span class="comment"># 设置日志等级</span></span><br><span class="line">logfile <span class="string">&quot;&quot;</span> <span class="comment"># 指定了记录日志的文件 空字符串的话，日志会打印到标准输出设备。后台运行的redis标准输出是/dev/null</span></span><br><span class="line">databases 16  <span class="comment"># 数据库的数量，默认是16个数据库</span></span><br><span class="line">always-show-logo no <span class="comment"># 是否总显示logo</span></span><br></pre></td></tr></table></figure>

<p>日志等级</p>
<ul>
<li>debug (a lot of information, useful for development&#x2F;testing)  很多信息，方便开发、测试</li>
<li>verbose (many rarely useful info, but not a mess like the debug level) 许多有用的信息，但是没有debug级别信息多</li>
<li>notice (moderately verbose, what you want in production probably) 适当的日志级别，适合生产环境</li>
<li>warning (only very important &#x2F; critical messages are logged) 许多有用的信息，但是没有debug级别信息多</li>
</ul>
<blockquote>
<p>snapshotting 快照</p>
</blockquote>
<p>持久化， 在规定的时间内，执行了多少次操作，则会持久化到文件</p>
<p>redis 是内存数据库，如果没有持久化，那么数据断电及失！</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">save 900 1 <span class="comment"># 如果900秒内，如果至少 1 个key进行了修改，我们则进行持久化操作</span></span><br><span class="line">save 300 10 <span class="comment"># 如果300秒内，如果至少 10 个key进行了修改，我们则进行持久化操作</span></span><br><span class="line">save 60 10000 <span class="comment"># 如果60秒内，如果至少 10000 个key进行了修改，我们则进行持久化操作</span></span><br><span class="line">stop-writes-on-bgsave-error <span class="built_in">yes</span> <span class="comment">#当RDB持久化出现错误后，是否依然进行继续进行工作，yes：不能进行工作，no：可以继续进行工作，可以通过info中的rdb_last_bgsave_status了解RDB持久化是否有错误</span></span><br><span class="line">rdbcompression <span class="built_in">yes</span> <span class="comment">#使用压缩rdb文件，rdb文件压缩使用LZF压缩算法，yes：压缩，但是需要一些cpu的消耗。no：不压缩，需要更多的磁盘空间</span></span><br><span class="line">rdbchecksum <span class="built_in">yes</span> <span class="comment">#是否校验rdb文件。从rdb格式的第五个版本开始，在rdb文件的末尾会带上CRC64的校验和。这跟有利于文件的容错性，但是在保存rdb文件的时候，会有大概10%的性能损耗，所以如果你追求高性能，可以关闭该配置。</span></span><br><span class="line"><span class="built_in">dir</span> ./ <span class="comment"># rdb文件保存的目录</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>replication 复制，后面讲到主从复制的时候再说</p>
</blockquote>
<blockquote>
<p>security 安全</p>
</blockquote>
<p>可以在这里设置redis的密码，默认是没有密码！</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ping</span><br><span class="line">PONG</span><br><span class="line">127.0.0.1:6379&gt; config get requirepass <span class="comment"># 获取redis的密码</span></span><br><span class="line">1) <span class="string">&quot;requirepass&quot;</span></span><br><span class="line">2) <span class="string">&quot;&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; config <span class="built_in">set</span> requirepass 123456 <span class="comment"># 设置redis的密码  取消密码的话，这样设置即可  config set requirepass &quot;&quot;</span></span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<p>重新打开一个服务</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@iZwz9efdd2ukk4oauustczZ ~]<span class="comment"># /usr/local/bin/redis-cli -p 6379</span></span><br><span class="line">127.0.0.1:6379&gt; ping <span class="comment"># 发现所有的命令都没有权限了</span></span><br><span class="line">(error) NOAUTH Authentication required.</span><br><span class="line">127.0.0.1:6379&gt; auth 123456  <span class="comment"># 密码验证</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; ping <span class="comment"># 然后就可以正常使用命令了</span></span><br><span class="line">PONG</span><br><span class="line">127.0.0.1:6379&gt; config get requirepass</span><br><span class="line">1) <span class="string">&quot;requirepass&quot;</span></span><br><span class="line">2) <span class="string">&quot;123456&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; </span><br></pre></td></tr></table></figure>



<blockquote>
<p>clients 限制</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">maxclients 10000 <span class="comment"># 设置能连上redis的最大客户端连接数量。默认是10000个客户端连接。由于redis不区分连接是客户端连接还是内部打开文件或者和slave连接等，所以maxclients最小建议设置到32。如果超过了maxclients，redis会给新的连接发送’max number of clients reached’，并关闭连接。</span></span><br><span class="line">maxmemory &lt;bytes&gt; <span class="comment">#redis配置的最大内存容量。当内存满了，需要配合maxmemory-policy策略进行处理。注意slave的输出缓冲区是不计算在maxmemory内的。所以为了防止主机内存使用完，建议设置的maxmemory需要更小一些。</span></span><br><span class="line">maxmemory-policy noeviction <span class="comment"># 内存达到上限的处理策略</span></span><br></pre></td></tr></table></figure>

<p>当 Redis 内存使用达到 <code>maxmemory </code>时，需要选择设置好的 <code>maxmemory-policy </code>进行对数据进行淘汰机制。</p>
<p>​    1.volatile-lru(least recently used):最近最少使用算法，从设置了过期时间的键key中选择空转时间最长的键值对清除掉；</p>
<p>​    2.volatile-lfu(least frequently used):最近最不经常使用算法，从设置了过期时间的键中选择某段时间之内使用频次最小的键值对清除掉；</p>
<p>​    3.volatile-ttl:从设置了过期时间的键中选择过期时间最早的键值对清除；</p>
<p>​    4.volatile-random:从设置了过期时间的键中，随机选择键进行清除；</p>
<p>​    5.allkeys-lru:最近最少使用算法，从所有的键中选择空转时间最长的键值对清除；</p>
<p>​    6.allkeys-lfu:最近最不经常使用算法，从所有的键中选择某段时间之内使用频次最少的键值对清除；</p>
<p>​    7.allkeys-random:所有的键中，随机选择键进行删除；</p>
<p>​    8.noeviction:不做任何的清理工作，在redis的内存超过限制之后，所有的写入操作都会返回错误；但是读操作都能正常的进行;</p>
<blockquote>
<p>append only mode </p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">appendonly no <span class="comment">#默认redis使用的是rdb方式持久化，这种方式在许多应用中已经足够用了。但是redis如果中途宕机，会导致可能有几分钟的数据丢失，根据save来策略进行持久化，Append Only File是另一种持久化方式，可以提供更好的持久化特性。Redis会把每次写入的数据在接收后都写入 appendonly.aof 文件，每次启动时Redis都会先把这个文件的数据读入内存里，先忽略RDB文件。</span></span><br><span class="line">appendfilename <span class="string">&quot;appendonly.aof&quot;</span> <span class="comment"># aof文件名</span></span><br><span class="line"><span class="comment"># appendfsync always # 表示每次写入都执行fsync，以保证数据同步到磁盘</span></span><br><span class="line">appendfsync everysec <span class="comment"># 表示每次写入都执行fsync，以保证数据同步到磁盘</span></span><br><span class="line"><span class="comment"># appendfsync no # 表示不执行fsync，由操作系统保证数据同步到磁盘，速度最快</span></span><br></pre></td></tr></table></figure>

<h1 id="九、redis持久化"><a href="#九、redis持久化" class="headerlink" title="九、redis持久化"></a>九、redis持久化</h1><p>Redis 是内存数据库，如果不将内存中的数据库状态保存到磁盘，那么一旦服务器进程退出，服务器中的数据库状态也会消失。所以 Redis 提供了持久化功能！</p>
<h2 id="1、RDB-redis-dbbase"><a href="#1、RDB-redis-dbbase" class="headerlink" title="1、RDB(redis dbbase)"></a>1、RDB(redis dbbase)</h2><blockquote>
<p>什么是rdb</p>
</blockquote>
<p>RDB是一种快照存储持久化方式，具体就是将Redis某一时刻的内存数据保存到硬盘的文件当中，默认保存的文件名为dump.rdb，而在Redis服务器启动时，会重新加载dump.rdb文件的数据到内存当中恢复数据。</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-21/34284700d944fa3b29da668861c41351--9603--image-20240921145925849.png" alt="image-20240921145925849"></p>
<p>在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是行话讲的Snapshot快照，它恢复时是将快照文件直接读到内存里。</p>
<p>Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的。这就确保了极高的性能。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失。我们默认的就是RDB，一般情况下不需要修改这个配置！</p>
<p>有时候在生产环境我们会将这个文件进行备份！</p>
<p>rdb保存的文件是dump.rdb 都是在我们的配置文件中快照中进行配置的！</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-21/86df4f368190fdf8395ace68bc36dc3f--e7a8--image-20240921150223612.png" alt="image-20240921150223612"></p>
<p>启动并登陆redis</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@iZwz9efdd2ukk4oauustczZ ~]<span class="comment"># /usr/local/bin/redis-server /usr/local/bin/myconfig/redis.conf</span></span><br><span class="line">[root@iZwz9efdd2ukk4oauustczZ ~]<span class="comment"># /usr/local/bin/redis-cli -p 6379</span></span><br></pre></td></tr></table></figure>

<p>查看dump.rdb文件保存的路径</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; config get <span class="built_in">dir</span></span><br><span class="line">1) <span class="string">&quot;dir&quot;</span></span><br><span class="line">2) <span class="string">&quot;/usr/local/bin&quot;</span>   <span class="comment"># 如果在这个目录下存在 dump.rdb 文件，启动就会自动恢复其中的数据</span></span><br></pre></td></tr></table></figure>

<p>去root目录先把dump.rdb删除了</p>
<p>然后如下操作</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(empty array)</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k1 v1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k2 v2</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k3 v3 </span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k4 v4</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k5 v5</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<p><code>set k5 v5</code>的时候发现，root目录下生成了一个dump.rdb</p>
<p><img src="https://typora-picture1234.oss-cn-shenzhen.aliyuncs.com/typora/img/image-20230425154907012.png" alt="image-20230425154907012"></p>
<p>然后我们关闭redis服务（断电即失）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; shutdown</span><br><span class="line">not connected&gt; <span class="built_in">exit</span></span><br></pre></td></tr></table></figure>

<p>这个时候我们再次登陆redis服务，然后<code>get k1</code>,发现仍然可以取到值</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@iZwz9efdd2ukk4oauustczZ ~]<span class="comment"># /usr/local/bin/redis-server /usr/local/bin/myconfig/redis.conf</span></span><br><span class="line">[root@iZwz9efdd2ukk4oauustczZ ~]<span class="comment"># /usr/local/bin/redis-cli -p 6379</span></span><br><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line"><span class="string">&quot;v1&quot;</span></span><br></pre></td></tr></table></figure>

<p>验证完了，把redis.conf配置的save还原了</p>
<blockquote>
<p>触发机制</p>
</blockquote>
<ol>
<li>save的规则满足的情况下，会自动触发rdb规则</li>
<li>执行 flushall 命令，也会触发我们的rdb规则</li>
<li>退出redis，也会产生 rdb 文件</li>
</ol>
<p>备份就自动生成一个 dump.rdb</p>
<blockquote>
<p>如何恢复rdb文件</p>
</blockquote>
<ol>
<li><p>只需要将rdb文件放在我们redis启动目录就可以，redis启动的时候会自动检查dump.rdb 恢复其中的数据！</p>
</li>
<li><p>查看需要存在的位置</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; config get <span class="built_in">dir</span></span><br><span class="line">1) <span class="string">&quot;dir&quot;</span></span><br><span class="line">2) <span class="string">&quot;/root&quot;</span>  <span class="comment"># 如果在这个目录下存在 dump.rdb 文件，启动就会自动恢复其中的数据</span></span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>优缺点</p>
</blockquote>
<p>优点：</p>
<ol>
<li>适合大规模的数据恢复</li>
<li>对数据的完整性要不高</li>
</ol>
<p>缺点：</p>
<ol>
<li>需要一定的时间间隔进程操作！如果redis意外宕机了，这个最后一次修改数据就没有的了</li>
<li>fork进程的时候，会占用一定的内容空间</li>
</ol>
<h2 id="2、AOF-append-only-file"><a href="#2、AOF-append-only-file" class="headerlink" title="2、AOF(append only file)"></a>2、AOF(append only file)</h2><p>与RDB存储某个时刻的快照不同，AOF持久化方式会记录客户端对服务器的每一次写操作命令，并将这些写操作以Redis协议追加保存到以后缀为aof文件末尾，在Redis服务器重启时，会加载并运行aof文件的命令，以达到恢复数据的目的。</p>
<blockquote>
<p>aof什么</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-21/f1a9fc29e65fc6c28a6a03bfafc5ae37--39b6--image-20240921150618250.png" alt="image-20240921150618250"></p>
<p>以日志的形式来记录每个写操作，将Redis执行过的所有指令记录下来（读操作不记录），只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">有点类似于mysql导出的sql文件</span><br></pre></td></tr></table></figure>

<p>Aof保存的是 appendonly.aof 文件</p>
<blockquote>
<p>append</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-21/d8874bfb0e7fc795e1cfa6eaf9fbf1f9--23ac--image-20240921150627559.png" alt="image-20240921150627559"></p>
<p>然后重启redis,就可以生效了</p>
<p>如果这个 aof 文件有错位，这时候 redis 是启动不起来的吗，我们需要修复这个aof文件</p>
<p>redis 给我们提供了一个工具 <code>redis-check-aof --fix</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@iZwz9efdd2ukk4oauustczZ bin]<span class="comment"># redis-check-aof --fix /root/appendonlydir/appendonly.aof.1.incr.aof</span></span><br><span class="line">Start checking Old-Style AOF</span><br><span class="line">0x              30: Expected \r\n, got: 3131</span><br><span class="line">AOF analyzed: filename=/root/appendonlydir/appendonly.aof.1.incr.aof, size=68, ok_up_to=23, ok_up_to_line=12, diff=45</span><br><span class="line">This will shrink the AOF /root/appendonlydir/appendonly.aof.1.incr.aof from 68 bytes, with 45 bytes, to 23 bytes</span><br><span class="line">Continue? [y/N]: y</span><br><span class="line">Successfully truncated AOF /root/appendonlydir/appendonly.aof.1.incr.aof</span><br><span class="line">[root@iZwz9efdd2ukk4oauustczZ bin]<span class="comment"># </span></span><br></pre></td></tr></table></figure>

<p>如果文件正常，重启就可以恢复了</p>
<blockquote>
<p>重写规则说明</p>
</blockquote>
<p>aof 默认就是文件的无限追加，文件会越来越大</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-21/ab219ac86957fd3ae82d2b8e8f0cb5d0--81d6--image-20240921150715489.png" alt="image-20240921150715489"></p>
<p>如果 aof 文件大于 64m，太大了！ fork一个新的进程来将我们的文件进行重写！</p>
<blockquote>
<p>优点缺点</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># appendfsync always # 表示每次写入都执行fsync，以保证数据同步到磁盘</span></span><br><span class="line">appendfsync everysec <span class="comment"># 表示每次写入都执行fsync，以保证数据同步到磁盘</span></span><br><span class="line"><span class="comment"># appendfsync no # 表示不执行fsync，由操作系统保证数据同步到磁盘，速度最快</span></span><br></pre></td></tr></table></figure>

<p>优点：</p>
<ol>
<li>每一次修改都同步，文件的完整性会更加好</li>
<li>每秒同步一次，可能会丢失一秒的数据</li>
<li>从不同步，效率最高的</li>
</ol>
<p>缺点：</p>
<ol>
<li>相对于数据文件来说，aof远远大于 rdb，修复的速度也比 rdb慢</li>
<li>Aof 运行效率也要比 rdb 慢，所以我们redis默认的配置就是rdb持久化</li>
</ol>
<h2 id="3、拓展"><a href="#3、拓展" class="headerlink" title="3、拓展"></a>3、拓展</h2><ol>
<li><p>RDB 持久化方式能够在指定的时间间隔内对你的数据进行快照存储</p>
</li>
<li><p>AOF 持久化方式记录每次对服务器写的操作，当服务器重启的时候会重新执行这些命令来恢复原始的数据，AOF命令以Redis 协议追加保存每次写的操作到文件末尾，Redis还能对AOF文件进行后台重写，使得AOF文件的体积不至于过大</p>
</li>
<li><p>只做缓存，如果你只希望你的数据在服务器运行的时候存在，你也可以不使用任何持久化</p>
</li>
<li><p>同时开启两种持久化方式</p>
<ul>
<li><p>在这种情况下，当redis重启的时候会优先载入AOF文件来恢复原始的数据，因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整</p>
</li>
<li><p>RDB 的数据不实时，同时使用两者时服务器重启也只会找AOF文件，那要不要只使用AOF呢？作者</p>
<p>建议不要，因为RDB更适合用于备份数据库（AOF在不断变化不好备份），快速重启，而且不会有</p>
<p>AOF可能潜在的Bug，留着作为一个万一的手段</p>
</li>
</ul>
</li>
<li><p>性能建议</p>
<ul>
<li><p>因为RDB文件只用作后备用途，建议只在Slave上持久化RDB文件，而且只要15分钟备份一次就够了，只保留 save 900 1 这条规则</p>
</li>
<li><p>如果Enable AOF ，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只load自己的AOF文件就可以了，</p>
<p>代价一是带来了持续的IO，</p>
<p>二是AOF rewrite 的最后将 rewrite 过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。</p>
<p>只要硬盘许可，应该尽量减少AOF rewrite的频率，AOF重写的基础大小默认值64M太小了，可以设到5G以上，默认超过原大小100%大小重写可以改到适当的数值</p>
</li>
<li><p>如果不Enable AOF ，仅靠 Master-Slave Repllcation 实现高可用性也可以，能省掉一大笔IO，也减少了rewrite时带来的系统波动。代价是如果Master&#x2F;Slave 同时倒掉，会丢失十几分钟的数据，启动脚本也要比较两个 Master&#x2F;Slave 中的 RDB文件，载入较新的那个，微博就是这种架构</p>
</li>
</ul>
</li>
</ol>
<h1 id="十、redis发布订阅"><a href="#十、redis发布订阅" class="headerlink" title="十、redis发布订阅"></a>十、redis发布订阅</h1><p>Redis 发布订阅(pub&#x2F;sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。</p>
<p>Redis 客户端可以订阅任意数量的频道。</p>
<p>订阅&#x2F;发布消息图：</p>
<p>第一个：消息发送者， 第二个：频道 第三个：消息订阅者！十、redis发布订阅</p>
<p><img src="C:/Users/ASUS/AppData/Roaming/Typora/typora-user-images/image-20240921150900397.png" alt="image-20240921150900397"></p>
<p>下图展示了频道 channel1 ， 以及订阅这个频道的三个客户端 —— client2 、 client5 和 client1 之间的关系：</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-21/f74234fe4dcb0c60799446592142efcd--8ba8--image-20240921150942348.png" alt="image-20240921150942348"></p>
<p>当有新消息通过 PUBLISH 命令发送给频道 channel1 时， 这个消息就会被发送给订阅它的三个客户端： </p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-21/3aa664ca7d1444ad30c91597cfe42655--de96--image-20240921150954137.png" alt="image-20240921150954137"></p>
<blockquote>
<p>命令</p>
</blockquote>
<p>这些命令被广泛用于构建即时通信应用，比如网络聊天室(chatroom)和实时广播、实时提醒等</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-21/d258d7893e58711b6100ebd7fb948241--b706--image-20240921151004132.png" alt="image-20240921151004132"></p>
<blockquote>
<p>测试</p>
</blockquote>
<ol>
<li><p>订阅频道</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>(subscribed mode)&gt; subscribe zyy</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;subscribe&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;zyy&quot;</span></span><br><span class="line"><span class="number">3</span>) (integer) <span class="number">1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>发布消息到频道（新开一个服务验证）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; PUBLISH zyy <span class="title function_">hellp</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>查看订阅者的变化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>(subscribed mode)&gt; subscribe zyy</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;subscribe&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;zyy&quot;</span></span><br><span class="line"><span class="number">3</span>) (integer) <span class="number">1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;message&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;zyy&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;hellp&quot;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>原理</p>
</blockquote>
<p>Redis是使用C实现的，通过分析 Redis 源码里的 pubsub.c 文件，了解发布和订阅机制的底层实现，籍此加深对 Redis 的理解。</p>
<p>Redis 通过 PUBLISH 、SUBSCRIBE 和 PSUBSCRIBE 等命令实现发布和订阅功能。</p>
<p>通过 SUBSCRIBE 命令订阅某频道后，redis-server 里维护了一个字典，字典的键就是一个个 频道！，而字典的值则是一个链表，链表中保存了所有订阅这个 channel 的客户端。SUBSCRIBE 命令的关键，就是将客户端添加到给定 channel 的订阅链表中。</p>
<p>通过 PUBLISH 命令向订阅者发送消息，redis-server 会使用给定的频道作为键，在它所维护的 channel字典中查找记录了订阅这个频道的所有客户端的链表，遍历这个链表，将消息发布给所有订阅者。</p>
<p>Pub&#x2F;Sub 从字面上理解就是发布（Publish）与订阅（Subscribe），在Redis中，你可以设定对某一个key值进行消息发布及消息订阅，当一个key值上进行了消息发布后，所有订阅它的客户端都会收到相应的消息。这一功能最明显的用法就是用作实时消息系统，比如普通的即时聊天，群聊等功能。</p>
<blockquote>
<p>使用场景</p>
</blockquote>
<ol>
<li>实时消息系统</li>
<li>实时聊天！（频道当做聊天室，将信息回显给所有人即可！）</li>
<li>订阅，关注系统都是可以的！</li>
</ol>
<p>稍微复杂的场景我们就会使用 消息中间件 MQ </p>
<h1 id="十一、redis主从复制"><a href="#十一、redis主从复制" class="headerlink" title="十一、redis主从复制"></a>十一、redis主从复制</h1><h2 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h2><p>主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master&#x2F;leader)，后者称为从节点(slave&#x2F;follower)；<strong>数据的复制是单向的，只能由主节点到从节点。</strong>Master以写为主，Slave 以读为主。</p>
<p><strong>默认情况下，每台redis服务器都是主节点；</strong>且一个主节点可以有多个从节点（或者没有从节点），但一个从节点只能有一个主节点。</p>
<p><strong>主从复制的作用主要包括：</strong></p>
<ol>
<li>数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式</li>
<li>故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余</li>
<li>负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量</li>
<li>高可用（集群）基石：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础</li>
</ol>
<p>一般来说，要将redis运用于工程项目中，只使用一台redis是万万不能的（宕机），原因如下：</p>
<ol>
<li>从结构上，单个Redis服务器会发生单点故障，并且一台服务器需要处理所有的请求负载，压力较大</li>
<li>从容量上，单个Redis服务器内存容量有限，就算一台Redis服务器内存容量为256G，也不能将所有内存用作Redis存储内存，一般来说，<strong>单台Redis最大使用内存不应该超过20G</strong></li>
</ol>
<p>电商网站上的商品，一般都是一次上传，无数次浏览的，说专业点也就是”多读少写”。</p>
<p>对于这种场景，我们可以使如下这种架构</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-21/84251e5da3e19e489866f69944d5e388--57f7--image-20240921160224020.png" alt="image-20240921160224020"></p>
<p>主从复制，读写分离！ 80% 的情况下都是在进行读操作！减缓服务器的压力！架构中经常使用！ 一主二从！</p>
<p>只要在公司中，主从复制就是必须要使用的，因为在真实的项目中不可能单机使用Redis！ </p>
<h2 id="2、环境模拟配置"><a href="#2、环境模拟配置" class="headerlink" title="2、环境模拟配置"></a>2、环境模拟配置</h2><p>复制三个配置文件，修改对应的信息</p>
<ol>
<li><p>文件名</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-6380.conf</span><br><span class="line">redis-6381.conf</span><br><span class="line">redis-6382.conf</span><br></pre></td></tr></table></figure>
</li>
<li><p>端口</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">port 6380</span><br><span class="line">port 6381</span><br><span class="line">port 6382</span><br></pre></td></tr></table></figure>
</li>
<li><p>pid名字</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pidfile /var/run/redis_6380.pid</span><br><span class="line">pidfile /var/run/redis_6381.pid</span><br><span class="line">pidfile /var/run/redis_6382.pid</span><br></pre></td></tr></table></figure>
</li>
<li><p>log文件名字</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">logfile <span class="string">&quot;6380.log&quot;</span></span><br><span class="line">logfile <span class="string">&quot;6381.log&quot;</span></span><br><span class="line">logfile <span class="string">&quot;6382.log&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>dump.rdb名字</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dbfilename dump80.rdb </span><br><span class="line">dbfilename dump81.rdb </span><br><span class="line">dbfilename dump82.rdb</span><br></pre></td></tr></table></figure></li>
</ol>
<p>启动上面三台服务</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-21/88e39336389ca79fb6b3e81850eb95cb--dedf--image-20240921161940317.png" alt="image-20240921161940317"></p>
<p>查看6380的库的信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6380</span>&gt; info replication</span><br><span class="line"># Replication</span><br><span class="line">role:master</span><br><span class="line">connected_slaves:<span class="number">0</span></span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:2f1e61ead6a91614ced7226237145ac0dbc7a617</span><br><span class="line">master_replid2:<span class="number">0000000000000000000000000000000000000000</span></span><br><span class="line">master_repl_offset:<span class="number">0</span></span><br><span class="line">second_repl_offset:-<span class="number">1</span></span><br><span class="line">repl_backlog_active:<span class="number">0</span></span><br><span class="line">repl_backlog_size:<span class="number">1048576</span></span><br><span class="line">repl_backlog_first_byte_offset:<span class="number">0</span></span><br><span class="line">repl_backlog_histlen:<span class="number">0</span></span><br></pre></td></tr></table></figure>

<h2 id="3、一主二从"><a href="#3、一主二从" class="headerlink" title="3、一主二从"></a>3、一主二从</h2><p>默认情况下，每台Redis服务器都是主节点； 我们一般情况下只用配置从机就好了！</p>
<p>认老大！ 一主 （6380）二从（6381，6382）</p>
<p>配置6380作为6381的主机</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6381</span>&gt; SLAVEOF <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">6380</span></span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6381</span>&gt; info replication</span><br><span class="line"># Replication</span><br><span class="line">role:slave</span><br><span class="line">master_host:<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">master_port:<span class="number">6380</span></span><br><span class="line">master_link_status:up</span><br><span class="line">master_last_io_seconds_ago:<span class="number">6</span></span><br><span class="line">master_sync_in_progress:<span class="number">0</span></span><br><span class="line">slave_read_repl_offset:<span class="number">14</span></span><br><span class="line">slave_repl_offset:<span class="number">14</span></span><br><span class="line">slave_priority:<span class="number">100</span></span><br><span class="line">slave_read_only:<span class="number">1</span></span><br><span class="line">replica_announced:<span class="number">1</span></span><br><span class="line">connected_slaves:<span class="number">0</span></span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:8196217be6f411e9a1b76aa7820448ad9a8b6068</span><br><span class="line">master_replid2:<span class="number">0000000000000000000000000000000000000000</span></span><br><span class="line">master_repl_offset:<span class="number">14</span></span><br><span class="line">second_repl_offset:-<span class="number">1</span></span><br><span class="line">repl_backlog_active:<span class="number">1</span></span><br><span class="line">repl_backlog_size:<span class="number">1048576</span></span><br><span class="line">repl_backlog_first_byte_offset:<span class="number">15</span></span><br><span class="line">repl_backlog_histlen:<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>重新查看6380的配置</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6380&gt; info replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master</span><br><span class="line">connected_slaves:1</span><br><span class="line">slave0:ip=127.0.0.1,port=6381,state=online,offset=126,lag=0</span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:8196217be6f411e9a1b76aa7820448ad9a8b6068</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:126</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line">repl_backlog_histlen:126</span><br></pre></td></tr></table></figure>

<p>同样的配置配置6382即可</p>
<p><strong>真实的从主配置应该在配置文件中配置，这样的话是永久的，我们这里使用的是命令，暂时的！</strong></p>
<blockquote>
<p>细节</p>
</blockquote>
<p>主机可以读，可以写，从机只能读，不能写！主机中的所有信息和数据，都会被从机保存</p>
<p>主机：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6380</span>&gt; set k1 v1</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6380</span>&gt; get k1</span><br><span class="line"><span class="string">&quot;v1&quot;</span></span><br></pre></td></tr></table></figure>

<p>从机：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6381</span>&gt; set k2 <span class="title function_">v2</span></span><br><span class="line"><span class="params">(error)</span> READONLY You can<span class="string">&#x27;t write against a read only replica.</span></span><br><span class="line"><span class="string">127.0.0.1:6381&gt; get k1</span></span><br><span class="line"><span class="string">&quot;v1&quot;</span></span><br></pre></td></tr></table></figure>

<p>测试：主机断开连接，从机依旧连接到主机的，但是没有写操作，这个时候，主机如果回来了，从机依旧可以直接获取到主机写的信息！</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 主机宕机了</span></span><br><span class="line">127.0.0.1:6380&gt; shutdown</span><br><span class="line">not connected&gt; <span class="built_in">exit</span></span><br><span class="line"><span class="comment"># 从机依旧可读</span></span><br><span class="line">127.0.0.1:6381&gt; get k1</span><br><span class="line"><span class="string">&quot;v1&quot;</span></span><br><span class="line"><span class="comment"># 主机回来了 并且做了写操作</span></span><br><span class="line">root@VM-16-10-ubuntu:/usr/local/bin<span class="comment"># redis-server myconfig/redis-6380.conf</span></span><br><span class="line">root@VM-16-10-ubuntu:/usr/local/bin<span class="comment"># redis-cli -p 6380</span></span><br><span class="line">127.0.0.1:6380&gt; <span class="built_in">set</span> k2 v2</span><br><span class="line">OK</span><br><span class="line"><span class="comment"># 从机还是可读</span></span><br><span class="line">127.0.0.1:6381&gt; get k2</span><br><span class="line"><span class="string">&quot;v2&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果是使用命令行，来配置的主从，这个时候如果重启了，就会变回主机！只要变为从机，立马就会从主机中获取值！</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6380&gt; shutdown <span class="comment"># 从机宕机了</span></span><br><span class="line">not connected&gt; <span class="built_in">exit</span></span><br><span class="line">[root@iZwz9efdd2ukk4oauustczZ bin]<span class="comment"># redis-server myconfig/redis80.conf  # 重新启动服务</span></span><br><span class="line">[root@iZwz9efdd2ukk4oauustczZ bin]<span class="comment"># redis-cli -p 6380</span></span><br><span class="line">127.0.0.1:6380&gt; keys *</span><br><span class="line">1) <span class="string">&quot;k2&quot;</span></span><br><span class="line">2) <span class="string">&quot;k1&quot;</span></span><br><span class="line">127.0.0.1:6380&gt; info replication <span class="comment"># 发现变回主机了</span></span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master</span><br><span class="line">connected_slaves:0</span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:99c0d5a904392e0a4509b01cc77e1c9cc5e85495</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:0</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:0</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:0</span><br><span class="line">repl_backlog_histlen:0</span><br><span class="line">127.0.0.1:6380&gt; </span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个时候原先主机做写操作</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k3 v3</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; </span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里也是拿不到的 因为大家都是主机，没有同步</span></span><br><span class="line">127.0.0.1:6380&gt; get k3</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6380&gt; </span><br><span class="line"></span><br><span class="line"><span class="comment"># 6380再次变成6379的从机，就可以获取了</span></span><br><span class="line">127.0.0.1:6380&gt; slaveof 127.0.0.1 6379</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6380&gt; keys *</span><br><span class="line">1) <span class="string">&quot;k3&quot;</span></span><br><span class="line">2) <span class="string">&quot;k1&quot;</span></span><br><span class="line">3) <span class="string">&quot;k2&quot;</span></span><br><span class="line">127.0.0.1:6380&gt; get k3</span><br><span class="line"><span class="string">&quot;v3&quot;</span></span><br><span class="line">127.0.0.1:6380&gt; </span><br></pre></td></tr></table></figure>

<blockquote>
<p>复制原理</p>
</blockquote>
<p>Slave 启动成功连接到 master 后会发送一个sync同步命令</p>
<p>Master 接到命令，启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕之后，master将传送整个数据文件到slave，并完成一次完全同步。</p>
<p><strong>全量复制：</strong>slave服务在接收到数据库文件数据后，将其存盘并加载到内存中</p>
<p><strong>增量复制：</strong>Master 继续将新的所有收集到的修改命令依次传给slave，完成同步</p>
<p>但是只要是重新连接master，一次完全同步（全量复制）将被自动执行！ 我们的数据一定可以在从机中看到！</p>
<blockquote>
<p>层层链路</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-21/723bdbef4c75f6c57ea2e99d09f6095e--4ee3--image-20240921163224209.png" alt="image-20240921163224209"></p>
<p>此时6380还是从节点</p>
<blockquote>
<p>如果没有老大了，这个时候能不能选择一个老大出来呢？ 手动！</p>
</blockquote>
<p>谋朝篡位</p>
<p>如果主机断开了连接，我们可以使用 <code>slaveof no one</code> 让自己变成主机！其他的节点就可以手动连接到最新的这个主节点（手动）！如果这个时候老大修复了，那就重新连接！</p>
<h2 id="4、哨兵模式"><a href="#4、哨兵模式" class="headerlink" title="4、哨兵模式"></a>4、哨兵模式</h2><p>（自动选举老大的模式）</p>
<blockquote>
<p>概述</p>
</blockquote>
<p>主从切换技术的方法是：当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工干预，费事费力，还会造成一段时间内服务不可用。这不是一种推荐的方式，更多时候，我们优先考虑哨兵模式。Redis从2.8开始正式提供了Sentinel（哨兵） 架构来解决这个问题</p>
<p>谋朝篡位的自动版，能够后台监控主机是否故障，如果故障了根据投票数<strong>自动将从库转换为主库</strong>。</p>
<p>哨兵模式是一种特殊的模式，首先Redis提供了哨兵的命令，哨兵是一个独立的进程，作为进程，它会独立运行。其原理是<strong>哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个Redis实例</strong>。</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-21/2cf1c5d6a2a3efa128749c33e76a09b6--1c7e--image-20240921164130454.png" alt="image-20240921164130454"></p>
<p>这里的哨兵有两个作用</p>
<ul>
<li>通过发送命令，让Redis服务器返回监控其运行状态，包括主服务器和从服务器。</li>
<li>当哨兵监测到master宕机，会自动将slave切换成master，然后通过<strong>发布订阅模式</strong>通知其他的从服务器，修改配置文件，让它们切换主机。</li>
</ul>
<p>然而一个哨兵进程对Redis服务器进行监控，可能会出现问题，为此，我们可以使用多个哨兵进行监控。各个哨兵之间还会进行监控，这样就形成了多哨兵模式。</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-21/c32fb55d8058e4eed951465390d3f5e2--ca5c--image-20240921164314334.png" alt="image-20240921164314334"></p>
<p>假设主服务器宕机，哨兵1先检测到这个结果，系统并不会马上进行failover[故障转移]过程，仅仅是哨兵1主观的认为主服务器不可用，这个现象成为<strong>主观下线</strong>。当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行failover操作。切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为<strong>客观下线</strong>。</p>
<blockquote>
<p>测试</p>
</blockquote>
<p>我们目前的状态是 一主 （6379）二从（6380，6381）</p>
<p>我们目前的状态是 一主 （6379）二从（6380，6381）</p>
<ol>
<li><p>新建哨兵的配置文件sentinel.conf</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sentinel monitor myredis 127.0.0.1 6380 1</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动哨兵</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">root@VM-16-10-ubuntu:/usr/local/bin<span class="comment"># redis-sentinel myconfig/sentinel.conf</span></span><br><span class="line">2239978:X 21 Sep 2024 16:56:34.971 <span class="comment"># WARNING Memory overcommit must be enabled! Without it, a background save or replication may fail under low memory condition. Being disabled, it can also cause failures without low memory condition, see https://github.com/jemalloc/jemalloc/issues/1328. To fix this issue add &#x27;vm.overcommit_memory = 1&#x27; to /etc/sysctl.conf and then reboot or run the command &#x27;sysctl vm.overcommit_memory=1&#x27; for this to take effect.</span></span><br><span class="line">2239978:X 21 Sep 2024 16:56:34.971 * oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo</span><br><span class="line">2239978:X 21 Sep 2024 16:56:34.971 * Redis version=7.4.0, bits=64, commit=00000000, modified=1, pid=2239978, just started</span><br><span class="line">2239978:X 21 Sep 2024 16:56:34.971 * Configuration loaded</span><br><span class="line">2239978:X 21 Sep 2024 16:56:34.972 * Increased maximum number of open files to 10032 (it was originally <span class="built_in">set</span> to 1024).</span><br><span class="line">2239978:X 21 Sep 2024 16:56:34.972 * monotonic clock: POSIX clock_gettime</span><br><span class="line">                _._                                                  </span><br><span class="line">           _.-``__ <span class="string">&#x27;&#x27;</span>-._                                             </span><br><span class="line">      _.-``    `.  `_.  <span class="string">&#x27;&#x27;</span>-._           Redis Community Edition      </span><br><span class="line">  .-`` .-```.  ```\/    _.,_ <span class="string">&#x27;&#x27;</span>-._     7.4.0 (00000000/1) 64 bit</span><br><span class="line"> (    <span class="string">&#x27;      ,       .-`  | `,    )     Running in sentinel mode</span></span><br><span class="line"><span class="string"> |`-._`-...-` __...-.``-._|&#x27;</span>` _.-<span class="string">&#x27;|     Port: 26379</span></span><br><span class="line"><span class="string"> |    `-._   `._    /     _.-&#x27;</span>    |     PID: 2239978</span><br><span class="line">  `-._    `-._  `-./  _.-<span class="string">&#x27;    _.-&#x27;</span>                                   </span><br><span class="line"> |`-._`-._    `-.__.-<span class="string">&#x27;    _.-&#x27;</span>_.-<span class="string">&#x27;|                                  </span></span><br><span class="line"><span class="string"> |    `-._`-._        _.-&#x27;</span>_.-<span class="string">&#x27;    |           https://redis.io       </span></span><br><span class="line"><span class="string">  `-._    `-._`-.__.-&#x27;</span>_.-<span class="string">&#x27;    _.-&#x27;</span>                                   </span><br><span class="line"> |`-._`-._    `-.__.-<span class="string">&#x27;    _.-&#x27;</span>_.-<span class="string">&#x27;|                                  </span></span><br><span class="line"><span class="string"> |    `-._`-._        _.-&#x27;</span>_.-<span class="string">&#x27;    |                                  </span></span><br><span class="line"><span class="string">  `-._    `-._`-.__.-&#x27;</span>_.-<span class="string">&#x27;    _.-&#x27;</span>                                   </span><br><span class="line">      `-._    `-.__.-<span class="string">&#x27;    _.-&#x27;</span>                                       </span><br><span class="line">          `-._        _.-<span class="string">&#x27;                                           </span></span><br><span class="line"><span class="string">              `-.__.-&#x27;</span>                                               </span><br><span class="line"></span><br><span class="line">2239978:X 21 Sep 2024 16:56:34.980 * Sentinel new configuration saved on disk</span><br><span class="line">2239978:X 21 Sep 2024 16:56:34.981 * Sentinel ID is dad236bacdf1f7ef1af264a564be5fc82681fa06</span><br><span class="line">2239978:X 21 Sep 2024 16:56:34.981 <span class="comment"># +monitor master myredis 127.0.0.1 6381 quorum 1</span></span><br><span class="line">2239978:X 21 Sep 2024 16:57:25.052 <span class="comment"># +sdown master myredis 127.0.0.1 6381</span></span><br><span class="line">2239978:X 21 Sep 2024 16:57:25.052 <span class="comment"># +odown master myredis 127.0.0.1 6381 #quorum 1/1</span></span><br><span class="line">2239978:X 21 Sep 2024 16:57:25.052 <span class="comment"># +new-epoch 1</span></span><br><span class="line">2239978:X 21 Sep 2024 16:57:25.052 <span class="comment"># +try-failover master myredis 127.0.0.1 6381</span></span><br><span class="line">2239978:X 21 Sep 2024 16:57:25.061 * Sentinel new configuration saved on disk</span><br><span class="line">2239978:X 21 Sep 2024 16:57:25.061 <span class="comment"># +vote-for-leader dad236bacdf1f7ef1af264a564be5fc82681fa06 1</span></span><br><span class="line">2239978:X 21 Sep 2024 16:57:25.061 <span class="comment"># +elected-leader master myredis 127.0.0.1 6381</span></span><br><span class="line">2239978:X 21 Sep 2024 16:57:25.061 <span class="comment"># +failover-state-select-slave master myredis 127.0.0.1 6381</span></span><br><span class="line">2239978:X 21 Sep 2024 16:57:25.133 <span class="comment"># -failover-abort-no-good-slave master myredis 127.0.0.1 6381</span></span><br><span class="line">2239978:X 21 Sep 2024 16:57:25.223 * Next failover delay: I will not start a failover before Sat Sep 21 17:03:26 2024</span><br></pre></td></tr></table></figure>
</li>
<li><p>这个时候master宕机了话，这个时候就会从从机中随机选择一个服务器！ （这里面有一个投票算法！）</p>
<p>也就是之前配置文件中的所写将会变成master</p>
<p>并且如果主机此时回来了，只能归并到新的主机下，当做从机，这就是哨兵模式的规则</p>
</li>
</ol>
<blockquote>
<p>哨兵模式</p>
</blockquote>
<p>优点：</p>
<ol>
<li>哨兵集群，基于主从复制模式，所有的主从配置优点，它全有</li>
<li>主从可以切换，故障可以转移，系统的可用性就会更好</li>
<li>哨兵模式就是主从模式的升级，手动到自动，更加健壮！</li>
</ol>
<p>缺点：</p>
<ol>
<li>Redis 不好在线扩容的，集群容量一旦到达上限，在线扩容就十分麻烦</li>
<li>实现哨兵模式的配置其实是很麻烦的，里面有很多选择</li>
</ol>
<p>哨兵模式的全部配置</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Example sentinel.conf</span></span><br><span class="line"><span class="comment"># 哨兵sentinel实例运行的端口 默认26379</span></span><br><span class="line">port 26379</span><br><span class="line"><span class="comment"># 哨兵sentinel的工作目录</span></span><br><span class="line"><span class="built_in">dir</span> /tmp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 哨兵sentinel监控的redis主节点的 ip port</span></span><br><span class="line"><span class="comment"># master-name 可以自己命名的主节点名字 只能由字母A-z、数字0-9 、这三个字符&quot;.-_&quot;组成</span></span><br><span class="line"><span class="comment"># quorum 配置多少个sentinel哨兵统一认为master主节点失联 那么这时客观上认为主节点失联了</span></span><br><span class="line"><span class="comment"># sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;</span></span><br><span class="line">sentinel monitor mymaster 127.0.0.1 6379 2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当在Redis实例中开启了requirepass foobared 授权密码 这样所有连接Redis实例的客户端都要提供密码</span></span><br><span class="line"><span class="comment"># 设置哨兵sentinel 连接主从的密码 注意必须为主从设置一样的验证密码</span></span><br><span class="line"><span class="comment"># sentinel auth-pass &lt;master-name&gt; &lt;password&gt;</span></span><br><span class="line">sentinel auth-pass mymaster MySUPER--secret-0123passw0rd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定多少毫秒之后 主节点没有应答哨兵sentinel 此时 哨兵主观上认为主节点下线 默认30秒</span></span><br><span class="line"><span class="comment"># sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt;</span></span><br><span class="line">sentinel down-after-milliseconds mymaster 30000</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个配置项指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行 同步</span></span><br><span class="line"><span class="comment"># 这个数字越小，完成failover所需的时间就越长，</span></span><br><span class="line"><span class="comment"># 但是如果这个数字越大，就意味着越 多的slave因为replication而不可用。</span></span><br><span class="line"><span class="comment"># 可以通过将这个值设为 1 来保证每次只有一个slave 处于不能处理命令请求的状态。</span></span><br><span class="line"><span class="comment"># sentinel parallel-syncs &lt;master-name&gt; &lt;numslaves&gt;</span></span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 故障转移的超时时间 failover-timeout 可以用在以下这些方面：</span></span><br><span class="line"><span class="comment">#1. 同一个sentinel对同一个master两次failover之间的间隔时间。</span></span><br><span class="line"><span class="comment">#2. 当一个slave从一个错误的master那里同步数据开始计算时间。直到slave被纠正为向正确的master那 里同步数据时。</span></span><br><span class="line"><span class="comment">#3.当想要取消一个正在进行的failover所需要的时间。</span></span><br><span class="line"><span class="comment">#4.当进行failover时，配置所有slaves指向新的master所需的最大时间。不过，即使过了这个超时， slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则来了</span></span><br><span class="line"><span class="comment"># 默认三分钟</span></span><br><span class="line"><span class="comment"># sentinel failover-timeout &lt;master-name&gt; &lt;milliseconds&gt;</span></span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br><span class="line"></span><br><span class="line"><span class="comment"># SCRIPTS EXECUTION</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#配置当某一事件发生时所需要执行的脚本，可以通过脚本来通知管理员，例如当系统运行不正常时发邮件通知 相关人员。</span></span><br><span class="line"><span class="comment">#对于脚本的运行结果有以下规则：</span></span><br><span class="line"><span class="comment">#若脚本执行后返回1，那么该脚本稍后将会被再次执行，重复次数目前默认为10</span></span><br><span class="line"><span class="comment">#若脚本执行后返回2，或者比2更高的一个返回值，脚本将不会重复执行。</span></span><br><span class="line"><span class="comment">#如果脚本在执行过程中由于收到系统中断信号被终止了，则同返回值为1时的行为相同。</span></span><br><span class="line"><span class="comment">#一个脚本的最大执行时间为60s，如果超过这个时间，脚本将会被一个SIGKILL信号终止，之后重新执行。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#通知型脚本:当sentinel有任何警告级别的事件发生时（比如说redis实例的主观失效和客观失效等等）， 将会去调用这个脚本，这时这个脚本应该通过邮件，SMS等方式去通知系统管理员关于系统不正常运行的信 息。调用该脚本时，将传给脚本两个参数，一个是事件的类型，一个是事件的描述。如果sentinel.conf配 置文件中配置了这个脚本路径，那么必须保证这个脚本存在于这个路径，并且是可执行的，否则sentinel无 法正常启动成功。</span></span><br><span class="line"><span class="comment">#通知脚本</span></span><br><span class="line"><span class="comment"># shell编程</span></span><br><span class="line"><span class="comment"># sentinel notification-script &lt;master-name&gt; &lt;script-path&gt;</span></span><br><span class="line">sentinel notification-script mymaster /var/redis/notify.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 客户端重新配置主节点参数脚本</span></span><br><span class="line"><span class="comment"># 当一个master由于failover而发生改变时，这个脚本将会被调用，通知相关的客户端关于master地址已 经发生改变的信息。</span></span><br><span class="line"><span class="comment"># 以下参数将会在调用脚本时传给脚本:</span></span><br><span class="line"><span class="comment"># &lt;master-name&gt; &lt;role&gt; &lt;state&gt; &lt;from-ip&gt; &lt;from-port&gt; &lt;to-ip&gt; &lt;to-port&gt;</span></span><br><span class="line"><span class="comment"># 目前&lt;state&gt;总是“failover”,</span></span><br><span class="line"><span class="comment"># &lt;role&gt;是“leader”或者“observer”中的一个</span></span><br><span class="line"><span class="comment"># 参数 from-ip, from-port, to-ip, to-port是用来和旧的master和新的master(即旧的slave)通 信的</span></span><br><span class="line"><span class="comment"># 这个脚本应该是通用的，能被多次调用，不是针对性的。</span></span><br><span class="line"><span class="comment"># sentinel client-reconfig-script &lt;master-name&gt; &lt;script-path&gt;</span></span><br><span class="line">sentinel client-reconfig-script mymaster /var/redis/reconfig.sh <span class="comment"># 一般都是由运维来配置！</span></span><br></pre></td></tr></table></figure>

<h1 id="十二、redis穿透和雪崩"><a href="#十二、redis穿透和雪崩" class="headerlink" title="十二、redis穿透和雪崩"></a>十二、redis穿透和雪崩</h1><p>在这里我们不会详细的区分析解决方案的底层！</p>
<p>Redis缓存的使用，极大的提升了应用程序的性能和效率，特别是数据查询方面。但同时，它也带来了一些问题。其中，最要害的问题，就是数据的一致性问题，从严格意义上讲，这个问题无解。如果对数据的一致性要求很高，那么就不能使用缓存。</p>
<p>另外的一些典型问题就是，缓存穿透、缓存雪崩和缓存击穿。目前，业界也都有比较流行的解决方案。</p>
<h2 id="1、缓存穿透（查不到）"><a href="#1、缓存穿透（查不到）" class="headerlink" title="1、缓存穿透（查不到）"></a>1、缓存穿透（查不到）</h2><blockquote>
<p>概念</p>
</blockquote>
<p>缓存穿透的概念很简单，用户想要查询一个数据，发现redis内存数据库没有，也就是缓存没有命中，于是向持久层数据库查询。发现也没有，于是本次查询失败。当用户很多的时候，缓存都没有命中（秒杀！），于是都去请求了持久层数据库。这会给持久层数据库造成很大的压力，这时候就相当于出现了缓存穿透。</p>
<blockquote>
<p>解决方案</p>
</blockquote>
<p><strong>1.布隆过滤器</strong></p>
<p>布隆过滤器是一种数据结构，对所有可能查询的参数以hash形式存储，在控制层先进行校验，不符合则丢弃，从而避免了对底层存储系统的查询压力；</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-21/c2dbc2632d43d48162bbc838fa569704--36d1--image-20240921190220109.png" alt="image-20240921190220109"></p>
<p><strong>2.缓存空对象</strong></p>
<p>当存储层不命中后，即使返回的空对象也将其缓存起来，同时会设置一个过期时间，之后再访问这个数据将会从缓存中获取，保护了后端数据源；</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-21/8033f6c667202d1b6b3e47451742523d--795d--image-20240921190233789.png" alt="image-20240921190233789"></p>
<p>但是这种方法会存在两个问题：</p>
<ol>
<li>如果空值能够被缓存起来，这就意味着缓存需要更多的空间存储更多的键，因为这当中可能会有很多的空值的键</li>
<li>即使对空值设置了过期时间，还是会存在缓存层和存储层的数据会有一段时间窗口的不一致，这对于需要保持一致性的业务会有影响</li>
</ol>
<h2 id="2、缓存击穿"><a href="#2、缓存击穿" class="headerlink" title="2、缓存击穿"></a>2、缓存击穿</h2><blockquote>
<p>概述（热点key过期）</p>
</blockquote>
<p>这里需要注意和缓存击穿的区别，缓存击穿，是指一个key非常热点，在不停的扛着大并发，大并发集中、对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。</p>
<p>当某个key在过期的瞬间，有大量的请求并发访问，这类数据一般是热点数据，由于缓存过期，会同时访问数据库来查询最新数据，并且回写缓存，会导使数据库瞬间压力过大</p>
<blockquote>
<p> 解决方案</p>
</blockquote>
<p><strong>1.设置热点数据永不过期</strong></p>
<p>从缓存层面来看，没有设置过期时间，所以不会出现热点 key 过期后产生的问题</p>
<p><strong>2.加互斥锁</strong></p>
<p>分布式锁：使用分布式锁，保证对于每个key同时只有一个线程去查询后端服务，其他线程没有获得分布式锁的权限，因此只需要等待即可。这种方式将高并发的压力转移到了分布式锁，因此对分布式锁的考验很大。</p>
<h2 id="3、缓存雪崩（缓存集中过期，宕机）"><a href="#3、缓存雪崩（缓存集中过期，宕机）" class="headerlink" title="3、缓存雪崩（缓存集中过期，宕机）"></a>3、缓存雪崩（缓存集中过期，宕机）</h2><blockquote>
<p>概念</p>
</blockquote>
<p>缓存雪崩，是指在某一个时间段，缓存集中过期失效。</p>
<p>产生雪崩的原因之一，比如在写本文的时候，马上就要到双十二零点，很快就会迎来一波抢购，这波商品时间比较集中的放入了缓存，假设缓存一个小时。那么到了凌晨一点钟的时候，这批商品的缓存就都过期了。而对这批商品的访问查询，都落到了数据库上，对于数据库而言，就会产生周期性的压力波峰。于是所有的请求都会达到存储层，存储层的调用量会暴增，造成存储层也会挂掉的情况。</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-21/9396e3dceebaf224c16ab2e58f97730c--4b8c--image-20240921190254343.png" alt="image-20240921190254343"></p>
<p>其实集中过期，倒不是非常致命，比较致命的缓存雪崩，是缓存服务器某个节点宕机或断网。因为自然形成的缓存雪崩，一定是在某个时间段集中创建缓存，这个时候，数据库也是可以顶住压力的。无非就是对数据库产生周期性的压力而已。而缓存服务节点的宕机，对数据库服务器造成的压力是不可预知的，很有可能瞬间就把数据库压垮。</p>
<blockquote>
<p>解决方案</p>
</blockquote>
<p><strong>1.redis高可用</strong></p>
<p>这个思想的含义是，既然redis有可能挂掉，那我多增设几台redis，这样一台挂掉之后其他的还可以继续工作，其实就是搭建的集群。（异地多活！）</p>
<p><strong>2.限流降级</strong></p>
<p>这个解决方案的思想是，在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。</p>
<p><strong>3.数据预热</strong></p>
<p>数据加热的含义就是在正式部署之前，我先把可能的数据先预先访问一遍，这样部分可能大量访问的数据就会加载到缓存中。在即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://6pc1.github.io/2024/06/03/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="6pc1">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="6pc1's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 6pc1's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/06/03/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/" class="post-title-link" itemprop="url">应急响应</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-06-03 20:36:21" itemprop="dateCreated datePublished" datetime="2024-06-03T20:36:21+08:00">2024-06-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-07-11 16:20:00" itemprop="dateModified" datetime="2024-07-11T16:20:00+08:00">2024-07-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Web/" itemprop="url" rel="index"><span itemprop="name">Web</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2024/06/03/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2024/06/03/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>26k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>24 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>最近有一个应急响应的靶场，玄机应急响应，所以也就去研究研究应急响应相关的知识。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/06/03/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://6pc1.github.io/2024/06/03/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="6pc1">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="6pc1's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 6pc1's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/06/03/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">内网渗透知识点总结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2024-06-03 16:05:42 / 修改时间：20:28:39" itemprop="dateCreated datePublished" datetime="2024-06-03T16:05:42+08:00">2024-06-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Web/" itemprop="url" rel="index"><span itemprop="name">Web</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2024/06/03/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2024/06/03/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>7.2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>7 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>最近打了不少春秋云镜的内网渗透的徽章，所以打算对内网的知识点进行一个总结学习。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2024/06/03/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://6pc1.github.io/2023/11/28/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="6pc1">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="6pc1's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 6pc1's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/11/28/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/" class="post-title-link" itemprop="url">渗透测试学习之路</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-11-28 19:35:52" itemprop="dateCreated datePublished" datetime="2023-11-28T19:35:52+08:00">2023-11-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-05-11 09:28:51" itemprop="dateModified" datetime="2024-05-11T09:28:51+08:00">2024-05-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Web/" itemprop="url" rel="index"><span itemprop="name">Web</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2023/11/28/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2023/11/28/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>61k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>55 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>已经决定了准备暑假看看去找个实习，对于web手来说，渗透肯定是必不可少的，所以从现在开始，也要抓紧时间去好好学下渗透的相关知识了。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2023/11/28/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://6pc1.github.io/2023/11/09/java%E5%AE%89%E5%85%A8%E6%BC%AB%E8%B0%88%E7%9A%84%E4%B8%80%E4%BA%9B%E8%87%AA%E6%88%91%E7%90%86%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="6pc1">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="6pc1's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 6pc1's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/11/09/java%E5%AE%89%E5%85%A8%E6%BC%AB%E8%B0%88%E7%9A%84%E4%B8%80%E4%BA%9B%E8%87%AA%E6%88%91%E7%90%86%E8%A7%A3/" class="post-title-link" itemprop="url">java反序列化以及一些前置知识</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-11-09 11:47:55" itemprop="dateCreated datePublished" datetime="2023-11-09T11:47:55+08:00">2023-11-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-03-11 15:18:54" itemprop="dateModified" datetime="2024-03-11T15:18:54+08:00">2024-03-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2023/11/09/java%E5%AE%89%E5%85%A8%E6%BC%AB%E8%B0%88%E7%9A%84%E4%B8%80%E4%BA%9B%E8%87%AA%E6%88%91%E7%90%86%E8%A7%A3/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2023/11/09/java%E5%AE%89%E5%85%A8%E6%BC%AB%E8%B0%88%E7%9A%84%E4%B8%80%E4%BA%9B%E8%87%AA%E6%88%91%E7%90%86%E8%A7%A3/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>6.4k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>6 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>最近学习了java反序列化以及反射 的相关知识，就在这稍微做一些总结。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2023/11/09/java%E5%AE%89%E5%85%A8%E6%BC%AB%E8%B0%88%E7%9A%84%E4%B8%80%E4%BA%9B%E8%87%AA%E6%88%91%E7%90%86%E8%A7%A3/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://6pc1.github.io/2023/11/11/python%E5%AD%A6%E4%B9%A0%E5%8E%86%E7%A8%8B-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="6pc1">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="6pc1's blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 6pc1's blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/11/11/python%E5%AD%A6%E4%B9%A0%E5%8E%86%E7%A8%8B-1/" class="post-title-link" itemprop="url">python学习历程(1)</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-11-11 20:46:12" itemprop="dateCreated datePublished" datetime="2023-11-11T20:46:12+08:00">2023-11-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-03-11 11:55:35" itemprop="dateModified" datetime="2024-03-11T11:55:35+08:00">2024-03-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/python/" itemprop="url" rel="index"><span itemprop="name">python</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline：</span>
  
    <a title="waline" href="/2023/11/11/python%E5%AD%A6%E4%B9%A0%E5%8E%86%E7%A8%8B-1/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/2023/11/11/python%E5%AD%A6%E4%B9%A0%E5%8E%86%E7%A8%8B-1/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>最近也是大二了，好不容易终于接到了大创了，不过大创需要我们去深入学习python，加上打算去参加一个python的项目制作，再去想想我那python水平，简直一言难尽，只能抓紧时间赶快补了😱</p>
<p>这里就简单记录一下一些我没有什么印象的或者感觉比较重要的知识点。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2023/11/11/python%E5%AD%A6%E4%B9%A0%E5%8E%86%E7%A8%8B-1/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2023 – 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">6pc1</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">391k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">5:55</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




<script class="next-config" data-name="waline" type="application/json">{"lang":"zh-cn","enable":true,"serverURL":"waline-server-pi-one.vercel.app","cssUrl":"https://unpkg.com/@waline/client@v2/dist/waline.css","commentCount":true,"pageview":false,"placeholder":"请文明评论呀","avatar":"mm","meta":["nick","mail","link"],"pageSize":10,"visitor":false,"comment_count":true,"requiredFields":[],"libUrl":"//unpkg.com/@waline/client@v2/dist/waline.js","el":"#waline","comment":true,"path":"/"}</script>
<link rel="stylesheet" href="https://unpkg.com/@waline/client@v2/dist/waline.css">
<script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script>


  <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas> 
  <script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script> 
  <script type="text/javascript" src="/js/fireworks.js"></script>
</body>
</html>
