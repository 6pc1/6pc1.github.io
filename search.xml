<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2023/11/06/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<span id="more"></span>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>java反序列化以及一些前置知识</title>
    <url>/2023/11/09/java%E5%AE%89%E5%85%A8%E6%BC%AB%E8%B0%88%E7%9A%84%E4%B8%80%E4%BA%9B%E8%87%AA%E6%88%91%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<p>最近学习了java反序列化的相关知识，就在这稍微做一些总结。</p>
<span id="more"></span>

<h1 id="一、java反射"><a href="#一、java反射" class="headerlink" title="一、java反射"></a>一、java反射</h1><p>首先就是介绍总结一下java反射中用到的一些相关方法，当然也不是直接对着方法名记忆，那样太枯燥了，主要就是在使用的过程中去学习。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.Runtime&quot;</span>);</span><br><span class="line"><span class="comment">//这个的意思就是获取到java.lang.Runtime这个类，是一种获取类最常见的方法，然后获取到的类就被“等同”于clazz（！！！这里要想起来类和对象之间的区别，这两个不是同一种东西！！！）</span></span><br><span class="line">clazz.getMethod(<span class="string">&quot;exec&quot;</span>, String.class).invoke(clazz.newInstance(), <span class="string">&quot;id&quot;</span>);</span><br><span class="line"><span class="comment">//这里我们就逐步分析，首先就是getMethod就是获取一个类的方法</span></span><br><span class="line"><span class="comment">//格式： 类.getMethod（“方法名”, 这个方法需要传递的参数类型）</span></span><br><span class="line"><span class="comment">//然后就是invoke，这是一个调用上面获得的方法。</span></span><br><span class="line"><span class="comment">//格式： 方法名.(类的一个对象,需要传递给方法的参数)</span></span><br><span class="line"><span class="comment">//newInstance就是调用该类的构造方法去实例化一个对象</span></span><br></pre></td></tr></table></figure>

<p>当然这样直接去运行时会产生报错的！！！这又是为什么呢？</p>
<p>这里主要就是因为我们无法通过newInstance去获得类的对象，而这里是因为Runtime的构造方法是私有的，是一种”单例”的设计模式</p>
<blockquote>
<p>单例的设计模式：主要是考虑到某些类一般只需要类的初始化时使用一次构造方法，而不是每次都需要去再重新使用构造方法，但这样的话我们又应该怎么样去调用构造方法呢？所以设计者就设计了一个静态方法，像这里的就是getRuntime这个方法，使用这个方法就会返回一个对象</p>
</blockquote>
<p>所以修改之后的代码就是</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">clazz</span> = class.forName(<span class="string">&quot;java.lang.Runtime&quot;</span>);</span><br><span class="line"><span class="type">Method</span> <span class="variable">execMethod</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;exec&quot;</span>,String.class);</span><br><span class="line"><span class="type">Method</span> <span class="variable">getRuntimeMethod</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;getRuntime&quot;</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">runtime</span> <span class="operator">=</span> getRuntimeMethed.invoke(clazz);</span><br><span class="line">execMethod.invoke(runtime,<span class="string">&quot;calc&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这样就可以去调用到我们需要的方法了。</p>
<p>当然这样也是还有点缺点的，就比如如果没有这个getRuntime的方法呢？这又应该怎么办？</p>
<p>这个时候就可以使用getConstructor这个方法去获取到我们想要的类。</p>
<blockquote>
<p>格式： 类.getConstructor(构造方法的参数类型)</p>
</blockquote>
<p>eg.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">clazz</span> = Class.forName(<span class="string">&quot;java.lang.ProcessBuilder&quot;</span>);</span><br><span class="line">clazz.getMethod(<span class="string">&quot;start&quot;</span>).invoke(clazz.getConstructor(List.class).newInstance(Arrays.asList(<span class="string">&quot;calc.exe&quot;</span>)));</span><br></pre></td></tr></table></figure>

<p>然后就是如果构造方法是私有方法，我们应该去使用getDeclaredMethod这个方法。</p>
<blockquote>
<p>getMethod 系列方法获取的是当前类中所有公共方法，包括从父类继承的方法 </p>
<p>getDeclaredMethod 系列方法获取的是当前类中“声明”的方法，是实在写在这个类里的，包括私 有的方法，但从父类里继承来的就不包含了</p>
<p>还有就是getConstructor和getDeclaredConstructor基本上相似的，这里就不过多解释了</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">clazz</span> = Class.forName(<span class="string">&quot;java.lang.Runtime&quot;</span>);</span><br><span class="line"><span class="type">Constructor</span> <span class="variable">m</span> <span class="operator">=</span> clazz.getDeclaredConstructor();</span><br><span class="line">m.setAccessible(<span class="literal">true</span>);</span><br><span class="line">clazz.getMethod(<span class="string">&quot;exec&quot;</span>, String.class).invoke(m.newInstance(), <span class="string">&quot;calc.exe&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>setAccessible必须要设置为true，不然无法去使用。</p>
<h1 id="二、RMI"><a href="#二、RMI" class="headerlink" title="二、RMI"></a>二、RMI</h1><p>RMI全称是Remote Method Invocation，远程⽅法调⽤。听这名字应该也就知道，就是去从调用一个远程主机上的java方法，在这里就挑一些重点的代码片段进行讲解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line">Naming.bind(<span class="string">&quot;rmi://127.0.0.1:1099/Hello&quot;</span>, <span class="keyword">new</span> <span class="title class_">RemoteHelloWorld</span>());(这里是服务器上启动的)</span><br></pre></td></tr></table></figure>

<p>首先第一行这里就是创建并且执行Registry服务，这个服务就是相当于一个中继器，我将类和一个名字绑定丢到这里面去，别的人就可以通过名字去拿到这个对应的类，这就是Registry所起到的一个作用。然后就是第二行，就是将本机的一个类给绑定到了一个Registry服务上，这样等之后就可以去直接拿到这个类了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RMIServer.<span class="type">IRemoteHelloWorld</span> <span class="variable">hello</span> <span class="operator">=</span> (RMIServer.IRemoteHelloWorld)Naming.lookup(<span class="string">&quot;rmi://vps_ip:1099/Hello&quot;</span>);(本机运行)</span><br></pre></td></tr></table></figure>

<p>这里就通过Naming的lookup方法去寻找这个rmi类，我们就可以在Registry中拿到我们想要的类。</p>
<p>codebase的利用方法</p>
<p>在以前的有段时间，java是可以运行在浏览器上的，就有一个codebase属性，这是一个地址，去告诉哪个地方寻找类，这个时候我们就可以使用rmi的相关操作，去使其加载我们自己部署的服务器上的一些恶意类。</p>
<p>就比如在log4j这个CVE中，也是可以去使用rmi去实现的，去完成反弹shell从而获得权限。</p>
<h1 id="三、serialize🌟"><a href="#三、serialize🌟" class="headerlink" title="三、serialize🌟"></a>三、serialize🌟</h1><p>这是学习的重难点，我现在也还知识初步了解一些，还没完全弄完😭</p>
<p>一般web手初识反序列化都是从php开始，首先就java的反序列化和php的还是有很大区别的，php是直接利用serialize和unserialize这两个函数进行序列化和反序列化的过程，我们无法去控制这个过程中的任何东西，而java就不一样了。</p>
<blockquote>
<ul>
<li>writeObject：序列化</li>
<li>readObject：反序列化</li>
</ul>
</blockquote>
<p>这两个主要是java中序列化反序列化所需要使用到的，一般需要搭配一些其他的东西去使用。</p>
<p>eg</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">serialize</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">FileOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;result.txt&quot;</span>);  <span class="comment">//用于保存序列化数据</span></span><br><span class="line">     ObjectOutputStream obj_out=<span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(out);   <span class="comment">//实例化一个对象输出流</span></span><br><span class="line">     <span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">     u.setName(<span class="string">&quot;6pc1&quot;</span>);</span><br><span class="line">     obj_out.writeObject(u);   <span class="comment">//利用writeObject方法将序列化对象存储在本地</span></span><br><span class="line">     obj_out.close();</span><br><span class="line">     System.out.println(<span class="string">&quot;User对象序列化成功！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unserialize</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">FileInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;result.txt&quot;</span>);  <span class="comment">//读取之前保存的序列化数据</span></span><br><span class="line">     <span class="type">ObjectInputStream</span> <span class="variable">ins</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(in);  <span class="comment">//实例化一个对象输入流</span></span><br><span class="line">     <span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> (User)ins.readObject();      <span class="comment">//利用readObject方法将序列化对象转为对象</span></span><br><span class="line">     system.out.println(<span class="string">&quot;User对象反序列化成功！&quot;</span>);</span><br><span class="line">     System.out.println(u.getName());</span><br><span class="line">     ins.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就是java反序列话的主要过程，是可以自己去操作序列化反序列化的一些过程的，就比如在序列化后的文件中添加一些数据一类的</p>
<p>这也不是唯一一种，我们也可以用byte流的方法代替文件流</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">ObjectOutputStream obj_out=<span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(baos); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">ByteArrayInputStream</span> <span class="variable">bais</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(baos.toByteArray());</span><br><span class="line"><span class="type">ObjectInputStream</span> <span class="variable">ins</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(bais);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>serialize</tag>
      </tags>
  </entry>
  <entry>
    <title>关于博客搭建的一些自我心得</title>
    <url>/2023/11/09/%E5%85%B3%E4%BA%8E%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%9A%84%E4%B8%80%E4%BA%9B%E8%87%AA%E6%88%91%E5%BF%83%E5%BE%97/</url>
    <content><![CDATA[<p>首先，这篇博客并不会详细讲解搭博客的过程什么的，只是稍微分享一下我自己搭博客时遇到的一些问题和学到的一些东西。</p>
<!--  more -->

<h1 id="一、博客搭建主体的选择"><a href="#一、博客搭建主体的选择" class="headerlink" title="一、博客搭建主体的选择"></a>一、博客搭建主体的选择</h1><p>我感觉现在大部分主流的使用的博客主体就是两种，(当然主要也是我接触到的博客看好像都是这两种),分别就是hexo和WordPress，不过由于我现在还是囊中羞涩，所以就去使用了免费的github+hexo去搭建，而对于WordPress而言，搭建则需要有一个服务器才能去完成。</p>
<h1 id="二、搭建博客时遇到的一些问题"><a href="#二、搭建博客时遇到的一些问题" class="headerlink" title="二、搭建博客时遇到的一些问题"></a>二、搭建博客时遇到的一些问题</h1><p>博客的普通搭建还是非常简单的，基本就是按照网上的教程来就不会有什么问题的，主要就是主题的配置，这才是最难的。本来我是想着，主题这肯定就是要选个特别好看的啊，这样才炫，所以就选择了ParticleX这个主题，配置完了发现的确很炫啊，然后过了一段时间，我打算吧分类、标签什么的去弄好的时候，就发现也不知道为什么识别不出来创建页面的类型，试了好多方法都不行，就重新搭了，然后就更惨了，发现链代码块都识别错误了，完全没发用，又试了好几次，发现都不行，只能换成最通用的next主题了，😭，不过next主题其实也还不错，稳定而且功能什么的开发的都很全，网上教程很全，又费了一段时间也算成功搭好了。</p>
<h1 id="三、一些小建议"><a href="#三、一些小建议" class="headerlink" title="三、一些小建议"></a>三、一些小建议</h1><p>建议要是很有时间的话就是挑自己喜欢的博客吧，慢慢改改这最后肯定还是很炫的，不是那么在意外观的感觉next就很够用了，至少各种功能方便去配置。还有就是hexo我感觉相对WordPress是没有WordPress方便操作的，毕竟那个还有操作的界面什么的，当然，这也还是主要看个人选择。最重要的不在博客的外观，而在于内容，内容好才是真正好的博客！</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
</search>
