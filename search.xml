<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2023/11/06/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<span id="more"></span>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>java反序列化以及一些前置知识</title>
    <url>/2023/11/09/java%E5%AE%89%E5%85%A8%E6%BC%AB%E8%B0%88%E7%9A%84%E4%B8%80%E4%BA%9B%E8%87%AA%E6%88%91%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<p>最近学习了java反序列化的相关知识，就在这稍微做一些总结。</p>
<span id="more"></span>

<h1 id="一、java反射"><a href="#一、java反射" class="headerlink" title="一、java反射"></a>一、java反射</h1><p>首先就是介绍总结一下java反射中用到的一些相关方法，当然也不是直接对着方法名记忆，那样太枯燥了，主要就是在使用的过程中去学习。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.Runtime&quot;</span>);</span><br><span class="line"><span class="comment">//这个的意思就是获取到java.lang.Runtime这个类，是一种获取类最常见的方法，然后获取到的类就被“等同”于clazz（！！！这里要想起来类和对象之间的区别，这两个不是同一种东西！！！）</span></span><br><span class="line">clazz.getMethod(<span class="string">&quot;exec&quot;</span>, String.class).invoke(clazz.newInstance(), <span class="string">&quot;id&quot;</span>);</span><br><span class="line"><span class="comment">//这里我们就逐步分析，首先就是getMethod就是获取一个类的方法</span></span><br><span class="line"><span class="comment">//格式： 类.getMethod（“方法名”, 这个方法需要传递的参数类型）</span></span><br><span class="line"><span class="comment">//然后就是invoke，这是一个调用上面获得的方法。</span></span><br><span class="line"><span class="comment">//格式： 方法名.(类的一个对象,需要传递给方法的参数)</span></span><br><span class="line"><span class="comment">//newInstance就是调用该类的构造方法去实例化一个对象</span></span><br></pre></td></tr></table></figure>

<p>当然这样直接去运行时会产生报错的！！！这又是为什么呢？</p>
<p>这里主要就是因为我们无法通过newInstance去获得类的对象，而这里是因为Runtime的构造方法是私有的，是一种”单例”的设计模式</p>
<blockquote>
<p>单例的设计模式：主要是考虑到某些类一般只需要类的初始化时使用一次构造方法，而不是每次都需要去再重新使用构造方法，但这样的话我们又应该怎么样去调用构造方法呢？所以设计者就设计了一个静态方法，像这里的就是getRuntime这个方法，使用这个方法就会返回一个对象</p>
</blockquote>
<p>所以修改之后的代码就是</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">clazz</span> = class.forName(<span class="string">&quot;java.lang.Runtime&quot;</span>);</span><br><span class="line"><span class="type">Method</span> <span class="variable">execMethod</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;exec&quot;</span>,String.class);</span><br><span class="line"><span class="type">Method</span> <span class="variable">getRuntimeMethod</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;getRuntime&quot;</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">runtime</span> <span class="operator">=</span> getRuntimeMethed.invoke(clazz);</span><br><span class="line">execMethod.invoke(runtime,<span class="string">&quot;calc&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这样就可以去调用到我们需要的方法了。</p>
<p>当然这样也是还有点缺点的，就比如如果没有这个getRuntime的方法呢？这又应该怎么办？</p>
<p>这个时候就可以使用getConstructor这个方法去获取到我们想要的类。</p>
<blockquote>
<p>格式： 类.getConstructor(构造方法的参数类型)</p>
</blockquote>
<p>eg.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">clazz</span> = Class.forName(<span class="string">&quot;java.lang.ProcessBuilder&quot;</span>);</span><br><span class="line">clazz.getMethod(<span class="string">&quot;start&quot;</span>).invoke(clazz.getConstructor(List.class).newInstance(Arrays.asList(<span class="string">&quot;calc.exe&quot;</span>)));</span><br></pre></td></tr></table></figure>

<p>然后就是如果构造方法是私有方法，我们应该去使用getDeclaredMethod这个方法。</p>
<blockquote>
<p>getMethod 系列方法获取的是当前类中所有公共方法，包括从父类继承的方法 </p>
<p>getDeclaredMethod 系列方法获取的是当前类中“声明”的方法，是实在写在这个类里的，包括私 有的方法，但从父类里继承来的就不包含了</p>
<p>还有就是getConstructor和getDeclaredConstructor基本上相似的，这里就不过多解释了</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">clazz</span> = Class.forName(<span class="string">&quot;java.lang.Runtime&quot;</span>);</span><br><span class="line"><span class="type">Constructor</span> <span class="variable">m</span> <span class="operator">=</span> clazz.getDeclaredConstructor();</span><br><span class="line">m.setAccessible(<span class="literal">true</span>);</span><br><span class="line">clazz.getMethod(<span class="string">&quot;exec&quot;</span>, String.class).invoke(m.newInstance(), <span class="string">&quot;calc.exe&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>setAccessible必须要设置为true，不然无法去使用。</p>
<h1 id="二、RMI"><a href="#二、RMI" class="headerlink" title="二、RMI"></a>二、RMI</h1><p>RMI全称是Remote Method Invocation，远程⽅法调⽤。听这名字应该也就知道，就是去从调用一个远程主机上的java方法，在这里就挑一些重点的代码片段进行讲解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line">Naming.bind(<span class="string">&quot;rmi://127.0.0.1:1099/Hello&quot;</span>, <span class="keyword">new</span> <span class="title class_">RemoteHelloWorld</span>());(这里是服务器上启动的)</span><br></pre></td></tr></table></figure>

<p>首先第一行这里就是创建并且执行Registry服务，这个服务就是相当于一个中继器，我将类和一个名字绑定丢到这里面去，别的人就可以通过名字去拿到这个对应的类，这就是Registry所起到的一个作用。然后就是第二行，就是将本机的一个类给绑定到了一个Registry服务上，这样等之后就可以去直接拿到这个类了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RMIServer.<span class="type">IRemoteHelloWorld</span> <span class="variable">hello</span> <span class="operator">=</span> (RMIServer.IRemoteHelloWorld)Naming.lookup(<span class="string">&quot;rmi://vps_ip:1099/Hello&quot;</span>);(本机运行)</span><br></pre></td></tr></table></figure>

<p>这里就通过Naming的lookup方法去寻找这个rmi类，我们就可以在Registry中拿到我们想要的类。</p>
<p>codebase的利用方法</p>
<p>在以前的有段时间，java是可以运行在浏览器上的，就有一个codebase属性，这是一个地址，去告诉哪个地方寻找类，这个时候我们就可以使用rmi的相关操作，去使其加载我们自己部署的服务器上的一些恶意类。</p>
<p>就比如在log4j这个CVE中，也是可以去使用rmi去实现的，去完成反弹shell从而获得权限。</p>
<h1 id="三、serialize🌟"><a href="#三、serialize🌟" class="headerlink" title="三、serialize🌟"></a>三、serialize🌟</h1><p>这是学习的重难点，我现在也还知识初步了解一些，还没完全弄完😭</p>
<p>一般web手初识反序列化都是从php开始，首先就java的反序列化和php的还是有很大区别的，php是直接利用serialize和unserialize这两个函数进行序列化和反序列化的过程，我们无法去控制这个过程中的任何东西，而java就不一样了。</p>
<blockquote>
<ul>
<li>writeObject：序列化</li>
<li>readObject：反序列化</li>
</ul>
</blockquote>
<p>这两个主要是java中序列化反序列化所需要使用到的，一般需要搭配一些其他的东西去使用。</p>
<p>eg</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">serialize</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">FileOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;result.txt&quot;</span>);  <span class="comment">//用于保存序列化数据</span></span><br><span class="line">     ObjectOutputStream obj_out=<span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(out);   <span class="comment">//实例化一个对象输出流</span></span><br><span class="line">     <span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">     u.setName(<span class="string">&quot;6pc1&quot;</span>);</span><br><span class="line">     obj_out.writeObject(u);   <span class="comment">//利用writeObject方法将序列化对象存储在本地</span></span><br><span class="line">     obj_out.close();</span><br><span class="line">     System.out.println(<span class="string">&quot;User对象序列化成功！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unserialize</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">FileInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;result.txt&quot;</span>);  <span class="comment">//读取之前保存的序列化数据</span></span><br><span class="line">     <span class="type">ObjectInputStream</span> <span class="variable">ins</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(in);  <span class="comment">//实例化一个对象输入流</span></span><br><span class="line">     <span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> (User)ins.readObject();      <span class="comment">//利用readObject方法将序列化对象转为对象</span></span><br><span class="line">     system.out.println(<span class="string">&quot;User对象反序列化成功！&quot;</span>);</span><br><span class="line">     System.out.println(u.getName());</span><br><span class="line">     ins.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就是java反序列话的主要过程，是可以自己去操作序列化反序列化的一些过程的，就比如在序列化后的文件中添加一些数据一类的</p>
<p>这也不是唯一一种，我们也可以用byte流的方法代替文件流</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">ObjectOutputStream obj_out=<span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(baos); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">ByteArrayInputStream</span> <span class="variable">bais</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(baos.toByteArray());</span><br><span class="line"><span class="type">ObjectInputStream</span> <span class="variable">ins</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(bais);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>serialize</tag>
      </tags>
  </entry>
  <entry>
    <title>关于博客搭建的一些自我心得</title>
    <url>/2023/11/09/%E5%85%B3%E4%BA%8E%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%9A%84%E4%B8%80%E4%BA%9B%E8%87%AA%E6%88%91%E5%BF%83%E5%BE%97/</url>
    <content><![CDATA[<p>首先，这篇博客并不会详细讲解搭博客的过程什么的，只是稍微分享一下我自己搭博客时遇到的一些问题和学到的一些东西。</p>
<span id="more"></span>

<h1 id="一、博客搭建主体的选择"><a href="#一、博客搭建主体的选择" class="headerlink" title="一、博客搭建主体的选择"></a>一、博客搭建主体的选择</h1><p>我感觉现在大部分主流的使用的博客主体就是两种，(当然主要也是我接触到的博客看好像都是这两种),分别就是hexo和WordPress，不过由于我现在还是囊中羞涩，所以就去使用了免费的github+hexo去搭建，而对于WordPress而言，搭建则需要有一个服务器才能去完成。</p>
<h1 id="二、搭建博客时遇到的一些问题"><a href="#二、搭建博客时遇到的一些问题" class="headerlink" title="二、搭建博客时遇到的一些问题"></a>二、搭建博客时遇到的一些问题</h1><p>博客的普通搭建还是非常简单的，基本就是按照网上的教程来就不会有什么问题的，主要就是主题的配置，这才是最难的。本来我是想着，主题这肯定就是要选个特别好看的啊，这样才炫，所以就选择了ParticleX这个主题，配置完了发现的确很炫啊，然后过了一段时间，我打算吧分类、标签什么的去弄好的时候，就发现也不知道为什么识别不出来创建页面的类型，试了好多方法都不行，就重新搭了，然后就更惨了，发现链代码块都识别错误了，完全没发用，又试了好几次，发现都不行，只能换成最通用的next主题了，😭，不过next主题其实也还不错，稳定而且功能什么的开发的都很全，网上教程很全，又费了一段时间也算成功搭好了。</p>
<h1 id="三、一些小建议"><a href="#三、一些小建议" class="headerlink" title="三、一些小建议"></a>三、一些小建议</h1><p>建议要是很有时间的话就是挑自己喜欢的博客吧，慢慢改改这最后肯定还是很炫的，不是那么在意外观的感觉next就很够用了，至少各种功能方便去配置。还有就是hexo我感觉相对WordPress是没有WordPress方便操作的，毕竟那个还有操作的界面什么的，当然，这也还是主要看个人选择。最重要的不在博客的外观，而在于内容，内容好才是真正好的博客！</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>python学习历程(1)</title>
    <url>/2023/11/11/python%E5%AD%A6%E4%B9%A0%E5%8E%86%E7%A8%8B-1/</url>
    <content><![CDATA[<p>最近也是大二了，好不容易终于接到了大创了，不过大创需要我们去深入学习python，加上打算去参加一个python的项目制作，再去想想我那python水平，简直一言难尽，只能抓紧时间赶快补了😱</p>
<p>这里就简单记录一下一些我没有什么印象的或者感觉比较重要的知识点。</p>
<span id="more"></span>

<h1 id="一、python参数中的一些特殊参数"><a href="#一、python参数中的一些特殊参数" class="headerlink" title="一、python参数中的一些特殊参数"></a>一、python参数中的一些特殊参数</h1><p>首先就需要先去了解一下什么是位置参数和关键字参数分别是什么。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">standard_arg</span>(<span class="params">arg</span>):</span><br><span class="line">    <span class="built_in">print</span>(arg)</span><br><span class="line">    </span><br><span class="line">standard_arg(<span class="number">123</span>)   //位置参数，多个参数需要注意排序位置</span><br><span class="line">standard_arg(arg=<span class="number">21</span>)   //关键字参数</span><br></pre></td></tr></table></figure>

<p>函数定义中未使用 <code>/</code> 和 <code>*</code> 时，参数可以按位置或关键字传递给函数。</p>
<h2 id="1、仅位置参数"><a href="#1、仅位置参数" class="headerlink" title="1、仅位置参数"></a>1、仅位置参数</h2><p>仅限位置时，形参的顺序很重要，并且这些参数在传参时必须使用位置参数传参</p>
<p>仅限位置形参应放在 <code>/</code> （正斜杠）前。<code>/</code> 用于在逻辑上分割仅限位置形参与其它形参。如果函数定义中没有 <code>/</code>，则表示没有仅限位置形参</p>
<h2 id="2、仅关键词参数"><a href="#2、仅关键词参数" class="headerlink" title="2、仅关键词参数"></a>2、仅关键词参数</h2><p>把形参标记为 <em>仅限关键字</em>，表明必须以关键字参数形式传递该形参，应在参数列表中第一个 <em>仅限关键字</em> 形参前添加 <code>*</code>。</p>
<h2 id="3、实例"><a href="#3、实例" class="headerlink" title="3、实例"></a>3、实例</h2><p>请看下面的函数定义示例，注意 <code>/</code> 和 <code>*</code> 标记：</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">standard_arg</span>(<span class="params">arg</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(arg)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">pos_only_arg</span>(<span class="params">arg, /</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(arg)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">kwd_only_arg</span>(<span class="params">*, arg</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(arg)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">combined_example</span>(<span class="params">pos_only, /, standard, *, kwd_only</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(pos_only, standard, kwd_only)</span><br></pre></td></tr></table></figure>

<p>第一个函数定义 <code>standard_arg</code> 是最常见的形式，对调用方式没有任何限制，可以按位置也可以按关键字传递参数：</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>standard_arg(<span class="number">2</span>)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>standard_arg(arg=<span class="number">2</span>)</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>第二个函数 <code>pos_only_arg</code> 的函数定义中有 <code>/</code>，仅限使用位置形参：</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>pos_only_arg(<span class="number">1</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pos_only_arg(arg=<span class="number">1</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: pos_only_arg() got some positional-only arguments passed <span class="keyword">as</span> keyword arguments: <span class="string">&#x27;arg&#x27;</span></span><br></pre></td></tr></table></figure>

<p>第三个函数 <code>kwd_only_args</code> 的函数定义通过 <code>*</code> 表明仅限关键字参数：</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>kwd_only_arg(<span class="number">3</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: kwd_only_arg() takes <span class="number">0</span> positional arguments but <span class="number">1</span> was given</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>kwd_only_arg(arg=<span class="number">3</span>)</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>最后一个函数在同一个函数定义中，使用了全部三种调用惯例：</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>combined_example(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: combined_example() takes <span class="number">2</span> positional arguments but <span class="number">3</span> were given</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>combined_example(<span class="number">1</span>, <span class="number">2</span>, kwd_only=<span class="number">3</span>)</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>combined_example(<span class="number">1</span>, standard=<span class="number">2</span>, kwd_only=<span class="number">3</span>)</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>combined_example(pos_only=<span class="number">1</span>, standard=<span class="number">2</span>, kwd_only=<span class="number">3</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: combined_example() got some positional-only arguments passed <span class="keyword">as</span> keyword arguments: <span class="string">&#x27;pos_only&#x27;</span></span><br></pre></td></tr></table></figure>

<p>下面的函数定义中，<code>kwds</code> 把 <code>name</code> 当作键，因此，可能与位置参数 <code>name</code> 产生潜在冲突：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">name, **kwds</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;name&#x27;</span> <span class="keyword">in</span> kwds</span><br></pre></td></tr></table></figure>

<p>调用该函数不可能返回 <code>True</code>，因为关键字 <code>&#39;name&#39;</code> 总与第一个形参绑定。例如：</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo(<span class="number">1</span>, **&#123;<span class="string">&#x27;name&#x27;</span>: <span class="number">2</span>&#125;)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: foo() got multiple values <span class="keyword">for</span> argument <span class="string">&#x27;name&#x27;</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>加上 <code>/</code> （仅限位置参数）后，就可以了。此时，函数定义把 <code>name</code> 当作位置参数，<code>&#39;name&#39;</code> 也可以作为关键字参数的键：</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">name, /, **kwds</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> <span class="string">&#x27;name&#x27;</span> <span class="keyword">in</span> kwds</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo(<span class="number">1</span>, **&#123;<span class="string">&#x27;name&#x27;</span>: <span class="number">2</span>&#125;)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>换句话说，仅限位置形参的名称可以在 <code>**kwds</code> 中使用，而不产生歧义。</p>
<p><strong>取自python官方文档</strong></p>
<h1 id="二、装饰器"><a href="#二、装饰器" class="headerlink" title="二、装饰器"></a>二、装饰器</h1><p>可以通过修饰去简化代码并且达到相应的目的。</p>
<h2 id="1、装饰器雏形"><a href="#1、装饰器雏形" class="headerlink" title="1、装饰器雏形"></a>1、装饰器雏形</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">guanjia</span>(<span class="params">game</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;打开外挂&quot;</span>)</span><br><span class="line">        game()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;关闭外挂&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">play_dnf</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;你好啊！我叫赛利亚，今天又是美好的一天！&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@guanjia</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">play_lol</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;欢迎来到英雄联盟&quot;</span>)</span><br><span class="line"></span><br><span class="line">play_lol()</span><br></pre></td></tr></table></figure>

<p>这就是一个简单的装饰器，通过这种方法就能使我们更方便的对函数进行相关的加装以及优化，</p>
<h2 id="2、装饰器的简单应用"><a href="#2、装饰器的简单应用" class="headerlink" title="2、装饰器的简单应用"></a>2、装饰器的简单应用</h2><p>在一些程序应用当中，我们会需要利用到登入的操作，这个时候我们就会想要实现，去实现什么功能之前需要先登入，这个时候装饰器就有用武之地了。不多说，直接看个小案例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">login_flag = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">login_verify</span>(<span class="params">fn</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        <span class="keyword">global</span> login_flag</span><br><span class="line">        <span class="keyword">if</span> login_flag:</span><br><span class="line">            <span class="keyword">return</span> fn(*args, **kwargs)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;请先登录&#x27;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;还未完成用户登录操作&#x27;</span>)</span><br><span class="line">            <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">                username = <span class="built_in">input</span>(<span class="string">&#x27;请输入用户名：&#x27;</span>)</span><br><span class="line">                password = <span class="built_in">input</span>(<span class="string">&#x27;请输入密码：&#x27;</span>)</span><br><span class="line">                <span class="keyword">if</span> username == <span class="string">&#x27;admin&#x27;</span> <span class="keyword">and</span> password == <span class="string">&#x27;123456&#x27;</span>:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&#x27;登录成功&#x27;</span>)</span><br><span class="line">                    login_flag = <span class="literal">True</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&#x27;用户名或密码错误，请重新输入&#x27;</span>)</span><br><span class="line">            ret = fn(*args, **kwargs)</span><br><span class="line">            <span class="keyword">return</span> ret</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="meta">@login_verify</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;欢迎来到首页&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@login_verify</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">order</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;欢迎来到我的订单&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@login_verify</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">profile</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;欢迎来到我的资料&#x27;</span>)</span><br><span class="line"></span><br><span class="line">index()</span><br><span class="line">order()</span><br><span class="line">profile()</span><br></pre></td></tr></table></figure>

<p>之后的相应是</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">PS C:\VScodeproject&gt; &amp; C:/Users/ASUS/AppData/Local/Programs/Python/Python310/python.exe c:/VScodeproject/python/python-study/装饰器应用.py</span><br><span class="line">请先登录</span><br><span class="line">还未完成用户登录操作</span><br><span class="line">请输入用户名：admin</span><br><span class="line">请输入密码：<span class="number">123456</span></span><br><span class="line">登录成功</span><br><span class="line">欢迎来到首页</span><br><span class="line">欢迎来到我的订单</span><br><span class="line">欢迎来到我的资料</span><br></pre></td></tr></table></figure>

<h1 id="三、Pickle和Json模块的总结"><a href="#三、Pickle和Json模块的总结" class="headerlink" title="三、Pickle和Json模块的总结"></a>三、Pickle和Json模块的总结</h1><p>Pickle是将对象（数据）转化为字节，json是将对象（数据）转化为json格式</p>
<blockquote>
<p>1、dumps    把对象（数据）转化为字节</p>
<p>2、loads       把字节转化回对象（数据）</p>
<p>3、dump      把对象序列化成字节之后写入到文件</p>
<p>3、load         把文件中的字节反序列化成对象 </p>
</blockquote>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
</search>
